     1                                  
     2                                  	%include	"rta_x86n.def"
     3                              <1> 
     4                              <1> __SMP		equ	8
     5                              <1> 
     6                              <1> TIME_UPDATE	equ     1
     7                              <1> LOCKSTEP	equ	2
     8                              <1> BREAKPOINT	equ	4
     9                              <1> CHILLDOWN	equ	8
    10                              <1> 
    11                              <1> EXTERNAL_INTERRUPT 	equ	00FF00h
    12                              <1> ATTENTION		equ	128
    13                              <1> INCREMENTER_CARRY	equ	64
    14                              <1> 
    15                              <1> 		%if	DRANG & 2
    16                              <1> INDICATIONS	equ	CHILLDOWN|TIME_UPDATE|LOCKSTEP
    17                              <1> 		%else
    18                              <1> INDICATIONS	equ	CHILLDOWN|TIME_UPDATE|LOCKSTEP|BREAKPOINT
    19                              <1> 		%endif
    20                              <1> 
    21                              <1> EXTERNAL_INDICATIONS equ EXTERNAL_INTERRUPT|ATTENTION|INCREMENTER_CARRY
    22                              <1> 
    23                              <1> IO_PORTS	equ	192
    24                              <1> 
    25                              <1> 	%if	RTA_MBANKS
    26                              <1> global	_metric
    27                              <1> global	_indication
    28                              <1> global	_iselect
    29                              <1> global	_iselectu
    30                              <1> global	_readout
    31                              <1> global	_readoutx
    32                              <1> global	_readoutp
    33                              <1> global	_psr
    34                              <1> global	_apc
    35                              <1> global	_apcz
    36                              <1> global	_breakpoint
    37                              <1> global	_b0_name
    38                              <1> global	_b0p
    39                              <1> global	_devices
    40                              <1> global	_base
    41                              <1> global	_register_set
    42                              <1> global	__register
    43                              <1> global	_memory
    44                              <1> 
    45                              <1> 	%if	RTA_MBANKS<1
    46                              <1> RTA_MPAGES	equ	32
    47                              <1> 	%else
    48                              <1> RTA_MPAGES	equ	RTA_MBANKS*64
    49                              <1> 	%endif
    50                              <1> 
    51                              <1> 	%else
    52                              <1> extern	_metric
    53                              <1> extern	_indication
    54                              <1> extern	_iselect
    55                              <1> extern	_iselectu
    56                              <1> extern	_psr
    57                              <1> extern	_apc
    58                              <1> extern	_apcu
    59                              <1> extern	_apcz
    60                              <1> extern	_breakpoint
    61                              <1> extern	_b0_name
    62                              <1> extern	_b0p
    63                              <1> extern	_devices
    64                              <1> extern	_base
    65                              <1> extern	_register_set
    66                              <1> extern	__register
    67                              <1> extern	_memory
    68                              <1> 
    69                              <1> _output equ     272
    70                              <1> _inputr equ     264
    71                              <1> _input2 equ     256
    72                              <1> 
    73                              <1> _OUTPUT	equ	__register+_output*4
    74                              <1> _INPUTR	equ	__register+_inputr*4
    75                              <1> _INPUT2 equ	__register+_input2*4
    76                              <1> _BIAS	equ	_OUTPUT
    77                              <1> 
    78                              <1> 	%endif
    79                              <1> 
    80                              <1> 	extern	_flag
    81                              <1> 	extern	_uflag
    82                              <1> 
    83                              <1> HALF_W	equ	128
    84                              <1> FP_R	equ	8
    85                              <1> B_STREAMZR  equ 64
    86                              <1> B_STREAM16R equ 32
    87                              <1> B_STREAM16W equ 16
    88                              <1> 
    89                              <1> r	equ	0
    90                              <1> k	equ	1
    91                              <1> x	equ	2
    92                              <1> y	equ	3
    93                              <1> a	equ	4
    94                              <1> b	equ	5
    95                              <1> mantissa2 equ	6
    96                              <1> mantissa3 equ	7
    97                              <1> residue	equ	8
    98                              <1> p	equ	12
    99                              <1> q	equ	13
   100                              <1> fp	equ	14
   101                              <1> s_p	equ	15
   102                              <1> 
   103                              <1> rdatac	equ	20
   104                              <1> rdata	equ	21
   105                              <1> wdatac	equ	22
   106                              <1> wdata	equ	23
   107                              <1> 
   108                              <1> 
   109                              <1> fp_guard equ	128+19
   110                              <1> 
   111                              <1> rt_clock equ	128+20
   112                              <1> priority equ	128+21
   113                              <1> dayclock_u equ	128+22
   114                              <1> dayclock equ	128+23
   115                              <1> 
   116                              <1> R	equ	r*4
   117                              <1> K	equ	k*4
   118                              <1> X	equ	x*4
   119                              <1> Y	equ	y*4
   120                              <1> A	equ	a*4
   121                              <1> B	equ	b*4
   122                              <1> MANTISSA2 equ	mantissa2*4
   123                              <1> MANTISSA3 equ	mantissa3*4
   124                              <1> RESIDUE	equ	residue*4
   125                              <1> 
   126                              <1> P	equ	p*4
   127                              <1> Q	equ	q*4
   128                              <1> FP	equ	fp*4
   129                              <1> S_P	equ	s_p*4
   130                              <1> 
   131                              <1> RDATAC	equ	rdatac*4
   132                              <1> RDATA	equ	rdata*4
   133                              <1> WDATAC	equ	wdatac*4
   134                              <1> WDATA	equ	wdata*4
   135                              <1> 
   136                              <1> FP_GUARD equ	fp_guard*4
   137                              <1> 
   138                              <1> RT_CLOCK equ	rt_clock*4
   139                              <1> PRIORITY equ	priority*4
   140                              <1> DAYCLOCK_U equ	dayclock_u*4
   141                              <1> DAYCLOCK equ	dayclock*4
   142                              <1> 
   143                              <1> I	equ	4
   144                              <1> XI	equ	5
   145                              <1> 
   146                              <1> DEVICE  equ	32768
   147                              <1> SYSMEM  equ	16384
   148                              <1> DATA16  equ	1
   149                              <1> FSYS24  equ	2
   150                              <1> 
   151                              <1> II_GUARD equ	64+31
   152                              <1> II_EXIT	equ	64+6
   153                              <1> II_YIELD equ	64+1
   154                              <1> II_SPAWN equ	64+2
   155                              <1> II_BANK equ	64+3
   156                              <1> II_ARRAY equ	64+4
   157                              <1> II_BANK_FREE equ 64+5
   158                              <1> II_TWAIT equ	64+27
   159                              <1> II_EVENT_WAIT equ 64+28
   160                              <1> II_FPXPO equ	0+3
   161                              <1> 
   162                              <1> II_XINT		equ	0+2
   163                              <1> II_MSECOND	equ	0+4
   164                              <1> II_ATTENTION	equ	0+5
   165                              <1> 
   166                              <1> LP_AUTHORITY	equ	1		; latent parameters GUARD$
   167                              <1> LP_ADDRESS	equ	14
   168                              <1> 
   169                              <1> LP_TIMESLICE	equ	10		; latent parameter timeslice -> yield
   170                              <1> LP_RANGE	equ	12		; latent parameter FP$XPO
   171                              <1> LP_AUTOEXIT	equ	11		; latent parameter return -> EXIT$
   172                                  
   173                                  ;	this is not PIC code
   174                                  ;	but does relative jumps for compactness
   175                                  
   176                                  %define ptr
   177                                  %define include
   178                                  %define .model
   179                                  %define .code
   180                                  
   181                                  SYSMEM_FLAG	equ	00800000h
   182                                  DATA16_FLAG	equ	00400000h
   183                                  FSYS24_FLAG	equ	00C00000h
   184                                  
   185                                  					; instruction code starts here
   186                                  	section		.text
   187                                  	global		_leloup
   188                                  	global		_execute
   189                                  	global		_device_readp
   190                                  	global		_bus_readp
   191                                  	global		_memory_read
   192                                  	global		_bus_read
   193                                  	global		_device_read
   194                                  
   195                                  	%include	"leloup.msm"
   196                              <1> _leloup:
   197 00000000 55                  <1> 	push	ebp
   198 00000001 56                  <1> 	push	esi
   199 00000002 57                  <1> 	push	edi
   200                              <1> 
   201 00000003 50                  <1> 	push	eax
   202 00000004 53                  <1> 	push	ebx
   203 00000005 51                  <1> 	push	ecx
   204 00000006 52                  <1> 	push	edx
   205                              <1> 
   206 00000007 8B15[00000000]      <1> 	mov	edx, dword ptr [_apc]
   207 0000000D 8B2D[00000000]      <1> 	mov	ebp, dword ptr [_register_set]
   208                              <1> 
   209 00000013 3B15[00000000]      <1> loup:	cmp	edx, dword ptr [_apcz]
   210 00000019 7743                <1> 	ja	off_limits
   211                              <1> 
   212 0000001B 8B02                <1> 	mov	eax, dword ptr [edx]
   213 0000001D 0FC8                <1> 	bswap	eax
   214 0000001F 81C204000000        <1> 	add	edx, 4
   215 00000025 E801010000          <1> 	call	_execute
   216                              <1> 
   217                              <1> 	%if	RATIO
   218                              <1> 	%else
   219                              <1> 	%if	METRIC
   220                              <1> 	inc	dword ptr [_metric]
   221                              <1> 	%endif
   222                              <1> 	%endif
   223                              <1> 
   224                              <1> 	%if	TSLICE
   225 0000002A F705[00000000]0000- <1> 	test	dword ptr [_psr], 00870000h	; not while ISR or interrupt mask
   226 00000032 8700                <1>
   227 00000034 7532                <1> 	jnz	louping
   228 00000036 F705[50020000]FFFF- <1> 	test	dword ptr [__register+RT_CLOCK], 00FFFFFFh
   229 0000003E FF00                <1>
   230 00000040 7426                <1> 	jz	louping
   231                              <1> 
   232 00000042 FF0D[50020000]      <1> 	dec	dword ptr [__register+RT_CLOCK]
   233 00000048 751E                <1> 	jnz	louping
   234                              <1> 
   235 0000004A B841000000          <1> 	mov	eax, II_YIELD
   236 0000004F BE0A000000          <1> 	mov	esi, LP_TIMESLICE
   237 00000054 E80F0E0000          <1> 	call	_ii
   238                              <1> 	%endif
   239                              <1> 
   240 00000059 E90A000000          <1> 	jmp	louping
   241                              <1> 
   242                              <1> off_limits:
   243 0000005E B85F000000          <1> 	mov	eax, II_GUARD
   244 00000063 E8000E0000          <1> 	call	_ii
   245                              <1> 
   246                              <1> louping:
   247                              <1> 	%if	DRANG & 1
   248                              <1> 	dec	dword ptr [__register+282*4]
   249                              <1> 	jnz	loup_adrang
   250                              <1> 	or	word ptr [_indication], LOCKSTEP
   251                              <1> loup_adrang
   252                              <1> 	%endif
   253                              <1> 
   254                              <1> 	%if	DRANG & 2
   255 00000068 A1[00000000]        <1> 	mov	eax, dword ptr [_breakpoint]
   256 0000006D 31D0                <1> 	xor	eax, edx
   257 0000006F 744B                <1> 	jz	indicated
   258                              <1> 	%endif
   259                              <1> 
   260                              <1> 	%if	RATIO
   261 00000071 FF0D[6C040000]      <1> 	dec	dword ptr [__register+283*4]
   262 00000077 7509                <1> 	jnz	loup_away
   263 00000079 66810D[00000000]01- <1> 	or	word ptr [_indication], TIME_UPDATE
   264 00000081 00                  <1>
   265                              <1> loup_away:
   266                              <1> 	%endif
   267                              <1> 
   268 00000082 66A1[00000000]      <1> 	mov	ax, word ptr [_indication]
   269 00000088 8A0D[02000000]      <1> 	mov	cl, byte ptr [_psr+2]
   270 0000008E 80E107              <1> 	and	cl, 7				; highest interrupt mask?
   271 00000091 80F107              <1> 	xor	cl, 7
   272 00000094 7417                <1> 	jz	internal_indications?		; maskable interrupts are masked
   273                              <1> 
   274 00000096 66A9CBFF            <1>         test	ax, INDICATIONS|EXTERNAL_INDICATIONS
   275 0000009A 0F8473FFFFFF        <1> 	jz	loup
   276 000000A0 66A9C0FF            <1> 	test	ax, EXTERNAL_INDICATIONS
   277 000000A4 7416                <1> 	jz	indicated
   278 000000A6 E8300D0000          <1> 	call	_xi
   279 000000AB EBBB                <1> 	jmp	louping				; keep going intil pending flags are off
   280                              <1> 
   281                              <1> internal_indications?
   282 000000AD 66F705[00000000]0B- <1> 	test	word ptr [_indication], INDICATIONS
   283 000000B5 00                  <1>
   284 000000B6 0F8457FFFFFF        <1> 	jz	loup
   285                              <1> 
   286                              <1> indicated
   287 000000BC 892D[00000000]      <1> 	mov	dword ptr [_register_set], ebp
   288 000000C2 8915[00000000]      <1> 	mov	dword ptr [_apc], edx
   289                              <1> 
   290 000000C8 5A                  <1> 	pop	edx
   291 000000C9 59                  <1> 	pop	ecx
   292 000000CA 5B                  <1> 	pop	ebx
   293 000000CB 58                  <1> 	pop	eax
   294                              <1> 
   295 000000CC 5F                  <1> 	pop	edi
   296 000000CD 5E                  <1> 	pop	esi
   297 000000CE 5D                  <1> 	pop	ebp
   298 000000CF C3                  <1> 	ret
   299                              <1> 
   300                                  	%include	"execute.msm"
   301                              <1> ;	include	rta_x86.h
   302                              <1> .model	small
   303                              <1> .code
   304                              <1> ;	_execute:
   305                              <1> ;        mov     dword ptr [__register+287*4], esp
   306                              <1> 
   307 000000D0 89C1                <1> __ea:	mov	ecx, eax
   308 000000D2 C1E108              <1> 	shl	ecx, 8
   309 000000D5 C1E913              <1> 	shr	ecx, 24-5		; instruction index in ch
   310 000000D8 C0E905              <1> 	shr	cl, 5			; operand designator in cl
   311                              <1> 
   312 000000DB C1E010              <1> 	shl	eax, 16
   313 000000DE 80F905              <1> 	cmp	cl, XI			; sign extended immediate?
   314 000000E1 750B                <1> 	jnz	derive_ea
   315                              <1> 
   316 000000E3 C1F808              <1> 	sar	eax, 8			; different from other EAs
   317 000000E6 C1E808              <1> 	shr	eax, 8
   318 000000E9 E93C000000          <1> 	jmp	ea_derived
   319                              <1> 
   320                              <1> derive_ea:
   321 000000EE C1E810              <1> 	shr	eax, 16			; no sign of it
   322 000000F1 6621C0              <1> 	and	ax, ax			; indexing / indirection ?
   323 000000F4 7934                <1> 	jns	ea_derived		; no
   324                              <1> 
   325 000000F6 89C3                <1> 	mov	ebx, eax
   326 000000F8 80E47F              <1> 	and	ah, 127			; ie: and ax 32767
   327 000000FB 66C1EB0C            <1> 	shr	bx, 12			; position index tag
   328 000000FF F6C306              <1> 	test	bl, 6			; indirect or indexed ?
   329 00000102 7418                <1> 	jz	indirect
   330                              <1> 					; pe = PF set
   331                              <1> 					; can only be tested on b7..0
   332 00000104 7A03                <1> 	jpe	indexed_4bit		; indexed fp / sp
   333                              <1> 					; indexed x / y / a / b
   334 00000106 80E307              <1> 	and	bl, 7			; zero bit 3
   335                              <1> 
   336                              <1> indexed_4bit:
   337 00000109 6625FF0F            <1> 	and	ax, 4095		; isolate address offset
   338 0000010D 03449D00            <1> 	add	eax, dword ptr [ebp+ebx*4]
   339                              <1> 
   340 00000111 C1E008              <1> 	shl	eax, 8			; truncate any overflow
   341 00000114 C1E808              <1> 	shr	eax, 8
   342                              <1> 
   343 00000117 E90E000000          <1> 	jmp	ea_derived
   344                              <1> 
   345                              <1> indirect:				; indirect via page B0 / B1
   346 0000011C 6689CB              <1> 	mov	bx, cx
   347 0000011F 6631C9              <1> 	xor	cx, cx			; cl <- zero to read 1-word indirection pointer
   348 00000122 E822020000          <1> 	call	_operand_read
   349 00000127 6689D9              <1> 	mov	cx, bx			; retrieve instruction:class into cx
   350                              <1> 
   351                              <1> ea_derived:
   352 0000012A C3                  <1> 	ret
   353                              <1> 
   354                              <1> _execute:
   355 0000012B 8925[7C040000]      <1> 	mov	dword ptr [__register+287*4], esp
   356 00000131 E89AFFFFFF          <1> 	call	__ea
   357                              <1> 
   358 00000136 0FB6DD              <1> 	movzx	ebx, ch			; instruction index
   359 00000139 80F906              <1> 	cmp	cl, 6
   360 0000013C 740B                <1> 	jz	joshi
   361 0000013E 80F907              <1> 	cmp	cl, 7			; 2 quick questions about instruction class
   362 00000141 750B                <1> 	jnz	integer_operations
   363 00000143 E918010000          <1> 	jmp	large_operations
   364                              <1> 
   365 00000148 C3                  <1> escape:	ret
   366                              <1> 
   367 00000149 E989000000          <1> joshi:	jmp	shifts_jumps
   368                              <1> 
   369                              <1> integer_operations:
   370 0000014E 8B1C9D[57010000]    <1> 	mov	ebx, dword ptr [operations1+ebx*4]
   371 00000155 FFE3                <1> 	jmp	ebx
   372                              <1> 
   373                              <1> operations1:
   374 00000157 [FB110000]          <1>         dd	_sr
   375 0000015B [15120000]          <1>         dd	_sk
   376 0000015F [2F120000]          <1>         dd	_sx
   377 00000163 [49120000]          <1>         dd	_sy
   378 00000167 [63120000]          <1>         dd	_sa
   379 0000016B [7D120000]          <1>         dd	_sb
   380 0000016F [97120000]          <1>         dd	_z
   381 00000173 [B0120000]          <1>         dd	_pop
   382                              <1> 
   383 00000177 [D6120000]          <1>         dd	_lr
   384 0000017B [DF120000]          <1>         dd	_lk
   385 0000017F [E8120000]          <1>         dd	_lx
   386 00000183 [F1120000]          <1>         dd	_ly
   387 00000187 [FA120000]          <1>         dd	_la
   388 0000018B [03130000]          <1>         dd	_lb
   389 0000018F [0C130000]          <1>         dd	_tz
   390 00000193 [36130000]          <1>         dd	_tp
   391                              <1> 
   392 00000197 [7C160000]          <1>         dd	_ax
   393 0000019B [8D160000]          <1>         dd	_ay
   394 0000019F [9E160000]          <1>         dd	_or
   395 000001A3 [A7160000]          <1>         dd	_orB
   396 000001A7 [B0160000]          <1>         dd	_and
   397 000001AB [B9160000]          <1>         dd	_andB
   398 000001AF [C2160000]          <1>         dd	_xor
   399 000001B3 [CB160000]          <1>         dd	_xorB
   400                              <1> 
   401 000001B7 [D4160000]          <1>         dd	_aa
   402 000001BB [F9160000]          <1>         dd	_ab
   403 000001BF [DE160000]          <1>         dd	_ana
   404 000001C3 [03170000]          <1>         dd	_anb
   405 000001C7 [1E170000]          <1>         dd	_m
   406 000001CB [4E170000]          <1>         dd	_mf
   407 000001CF [AE170000]          <1>         dd	_d
   408 000001D3 [57130000]          <1>         dd	_push
   409                              <1> 
   410                              <1> shifts_jumps:
   411 000001D7 8B1C9D[E0010000]    <1> 	mov	ebx, dword ptr [operations6+ebx*4]
   412 000001DE FFE3                <1> 	jmp	ebx
   413                              <1> 
   414                              <1> operations6:
   415 000001E0 [59180000]          <1>         dd	_sar
   416 000001E4 [70180000]          <1>         dd	_sbr
   417 000001E8 [87180000]          <1>         dd	_dsr
   418 000001EC [79130000]          <1>         dd	_jdr
   419 000001F0 [9B180000]          <1>         dd	_sal
   420 000001F4 [B2180000]          <1>         dd	_sbl
   421 000001F8 [C9180000]          <1>         dd	_dsl
   422 000001FC [93130000]          <1>         dd	_lcal
   423                              <1> 
   424 00000200 [DD180000]          <1>         dd	_rar
   425 00000204 [E9180000]          <1>         dd	_rbr
   426 00000208 [F5180000]          <1>         dd	_drr
   427 0000020C [B1130000]          <1>         dd	_jnc
   428 00000210 [941A0000]          <1>         dd	_ral
   429 00000214 [A01A0000]          <1>         dd	_rbl
   430 00000218 [AC1A0000]          <1>         dd	_drl
   431 0000021C [BE130000]          <1>         dd	_jc
   432                              <1> 
   433 00000220 [C01A0000]          <1>         dd	_saa
   434 00000224 [D11A0000]          <1>         dd	_sba
   435 00000228 [E21A0000]          <1>         dd	_dsa
   436 0000022C [CB130000]          <1>         dd	_jao
   437 00000230 [D5130000]          <1>         dd	_jpa
   438 00000234 [DF130000]          <1>         dd	_jpb
   439 00000238 [E9130000]          <1>         dd	_j
   440 0000023C [0B140000]          <1>         dd	_jpo
   441                              <1> 
   442 00000240 [13140000]          <1>         dd	_jza
   443 00000244 [1D140000]          <1>         dd	_jzb
   444 00000248 [27140000]          <1>         dd	_jnza
   445 0000024C [31140000]          <1>         dd	_jnzb
   446 00000250 [3B140000]          <1>         dd	_jna
   447 00000254 [45140000]          <1>         dd	_jnb
   448 00000258 [4F140000]          <1>         dd	_jxge
   449 0000025C [5E140000]          <1>         dd	_jyge
   450                              <1> 
   451                              <1> 
   452                              <1> large_operations:
   453 00000260 8B1C9D[6B020000]    <1> 	mov	ebx, dword ptr [operations7+ebx*4]
   454 00000267 B100                <1> 	mov	cl, 0		; default size large operand
   455 00000269 FFE3                <1> 	jmp	ebx		; 1 word
   456                              <1> 
   457                              <1> operations7:
   458 0000026B [4F150000]          <1>         dd	_ts
   459 0000026F [F61A0000]          <1>         dd	_n
   460 00000273 [051B0000]          <1>         dd	_inc
   461 00000277 [101B0000]          <1>         dd	_dec
   462 0000027B [68150000]          <1>         dd	_sim
   463 0000027F [571B0000]          <1>         dd	_popA
   464 00000283 [1B1B0000]          <1>         dd	_src
   465 00000287 [391B0000]          <1>         dd	_slc
   466                              <1> 
   467 0000028B [71140000]          <1>         dd	_qs
   468 0000028F [7B140000]          <1>         dd	_ql
   469 00000293 [EE140000]          <1>         dd	_dte
   470 00000297 [AC140000]          <1>         dd	_dpop
   471 0000029B [F1230000]          <1>         dd	_fa
   472 0000029F [0C240000]          <1>         dd	_fan
   473 000002A3 [27240000]          <1>         dd	_fm
   474 000002A7 [42240000]          <1>         dd	_fd
   475                              <1> 
   476 000002AB [85140000]          <1>         dd	_qpop
   477 000002AF [98140000]          <1>         dd	_qpush
   478 000002B3 [45150000]          <1>         dd	_ex
   479 000002B7 [BF140000]          <1>         dd	_dpush
   480 000002BB [3A1C0000]          <1>         dd	_lsc
   481 000002BF [DA140000]          <1>         dd	_mta
   482 000002C3 [04150000]          <1>         dd	_sc
   483 000002C7 [15150000]          <1>         dd	_mlb
   484                              <1> 
   485 000002CB [2E150000]          <1>         dd	_ds
   486 000002CF [38150000]          <1>         dd	_dl
   487 000002D3 [871B0000]          <1>         dd	_da
   488 000002D7 [911B0000]          <1>         dd	_dan
   489 000002DB [4B1C0000]          <1>         dd	_dlsc
   490 000002DF [44150000]          <1>         dd	_spare
   491 000002E3 [AD150000]          <1>         dd	_go
   492 000002E7 [89150000]          <1>         dd	_call
   493                              <1> 
   494                                  	%include	"rw.msm"
   495                              <1> 
   496                              <1> 
   497                              <1> ;	include	rta_x86.h
   498                              <1> ;	.model	large
   499                              <1> ;	.code
   500                              <1> 
   501                              <1> ;	this is the operand reader / writer
   502                              <1> ;	for emulated RTA1 on x86
   503                              <1> 
   504                              <1> ;	layout is
   505                              <1> 
   506                              <1> ;	RTA1 24-bit registers are modeled in an array of
   507                              <1> ;	platform-endian integers. In x86 these are 32-bit
   508                              <1> ;	little-endian integers
   509                              <1> 
   510                              <1> ;	platform-endian doesn't affect registers
   511                              <1> ;	because endianness is not at the CPU
   512                              <1> ;	side of the bus, but at the memory side
   513                              <1> 
   514                              <1> ;	when Intel circuitry in the x86 CPU staticises the value
   515                              <1> ;	of an emulated register, that value is big endian
   516                              <1> 
   517                              <1> ;	the stored integers where emulated registers are modeled
   518                              <1> ;	are platform-endian, with identical effect on big and
   519                              <1> ;	little endian emulator platforms
   520                              <1> 
   521                              <1> ;	RTA1 24-bit executable space storage words are modeled in
   522                              <1> ;	another array of platform-endian 32-bit integers. Emulation
   523                              <1> ;	on x86 swaps the byte order of storage words on read and
   524                              <1> ;	before write to conform with RTA1 canonical storage order
   525                              <1> 
   526                              <1> ;       RTA1 architecture has registers in the first 256 locations
   527                              <1> ;       of address space and access differentiates registers from
   528                              <1> ;       from memory according to effective address
   529                              <1> 
   530                              <1> ;	location of registers and storage are handed to read / write
   531                              <1> ;	routines as RTA1 word linear effective addresses
   532                              <1> 
   533                              <1> ;	These routines maintain the RTA1 linear addresses passed
   534                              <1> ;	in x86 registers and apply them with shifted scale plus
   535                              <1> ;	displacement, for example
   536                              <1> 
   537                              <1> ;		mov	eax, dword ptr [edi+esi*4+_memory]
   538                              <1> ;		bswap	eax
   539                              <1> ;		mov	dword_ptr [ebp+ebx*4], eax
   540                              <1> 
   541                              <1> ;	RTA1 register addresses are already absolute in terms of
   542                              <1> ;	the emulated RTA1 machine
   543                              <1> 
   544                              <1> ;	ebp points at the context register frame. There are two
   545                              <1> ;	register frames, application and interrupt. Registers
   546                              <1> ;	addressed as storage operand are in a single list
   547                              <1> 
   548                              <1> ;		mov	eax, dword ptr [esi*4+__register]
   549                              <1> 
   550                              <1> ;	RTA1 storage addresses are translated by RTA1 relocation
   551                              <1> ;	architecture before application. The updated linear addresses
   552                              <1> ;	of the emulated machine are in esi
   553                              <1> 
   554                              <1> ;	The operand routines in this file point edi to the x86 platform
   555                              <1> ;	storage array start of the storage device, most often emulated
   556                              <1> ;	RTA1 executable space
   557                              <1> 
   558                              <1> ;	instructions call these operand routines with RTA1 effective 
   559                              <1> ;	address in eax
   560                              <1> 
   561                              <1> ;	instructions receive load operand values in eax and ebx, or in
   562                              <1> ;	a list of RTA1 emulated register locations pointed by ebp+ebx
   563                              <1> 
   564                              <1> ;	store instructions submit a value in ebx, or values in list of
   565                              <1> ;	RTA1 emulated register locations pointed by ebp+ebx
   566                              <1> 
   567                              <1> ;	to preserve linear address consistency, application instruction
   568                              <1> ;	work areas, where needed in addition to x86 registers, are
   569                              <1> ;	implemented as sub-architectural extra RTA1 registers at the end
   570                              <1> ;	of the 256-longword register stack. x86 register ebp+ebx*4 identify
   571                              <1> ;	these locations by linear RTA1 word quantum as "registers"
   572                              <1> 
   573                              <1> ;	RTA1 registers and storage alike are in 24-bit word address quantum space
   574                              <1> 
   575                              <1> ;	emulated instructions loading or storing multiple hidden extra work
   576                              <1> ;	registers should unconditionally set ebp to the start or application
   577                              <1> ;	frame of the emulated register array, so that [ebp+ebx*4] accesses the
   578                              <1> ;	correct locations at register occurence 256+
   579                              <1> 
   580                              <1> ;               _floating_operand2 equ  256+12
   581                              <1> 
   582                              <1> ;		push	ebp
   583                              <1> ;		mov	ebp, __register	; point to application register frame[0]
   584                              <1> ;		mov	ebx, 256+_floating_operand2
   585                              <1> ;		call	_burst_read4
   586                              <1> 
   587                              <1> ;		pop	ebp		; return to previous register frame[0] application
   588                              <1> 					;                          or frame[1] interrupt
   589                              <1> 
   590                              <1> ;	Both internal stack pointers are also absolute, so for stack operations
   591                              <1> ;	ebp should be momentarily forced to the lower-addressed (application) stack
   592                              <1> ;	frame after being used to point the stack location of reference
   593                              <1> 
   594                              <1> ;		mov	ebx, dword ptr [ebp+S_P]	; read one of the two stack pointers
   595                              <1> ;		cmp	ebx, ebp+STACK_LOWER_LIMIT	; 24*4 within context of either stack
   596                              <1> ;		jl	II_GUARD
   597                              <1> ;		add	ebx, -1				; new stack top
   598                              <1> ;		mov	dword ptr [ebp+S_P], ebx
   599                              <1> ;		push	ebp				; which ever stack pointer it is, it points
   600                              <1> ;		mov	ebp,__register			; relative to all the register stack
   601                              <1> ;		call	_operand_read			; for I am the single-word push instruction
   602                              <1> ;		pop	ebp				;
   603                              <1> 
   604                              <1> ;	register identities supplied from emulated instructions to these routines
   605                              <1> ;	are their lowercase names equated to RTA1 word addresses
   606                              <1> 
   607                              <1> ;	There exist also uppercase spellings which instruction routines may
   608                              <1> ;	access internally. The uppercase names are four times in value the
   609                              <1> ;	equivalent lowercase ordinal names to give x86 platform offset values
   610                              <1> 
   611                              <1> ;       Assembly language equate is like parentheses! What's in a label
   612                              <1> ;       is not an expression but its value. Nothing like C preprocessor.
   613                              <1> ;       Just in case you're developing enhancements in assembly using
   614                              <1> ;       preprocessor and #define
   615                              <1> 
   616                              <1> ;		_floating_operand2 equ	256+12
   617                              <1> ;		FLOATING_OPERAND2 equ	_floating_operand2*4
   618                              <1> 
   619                              <1> 
   620                              <1> ;		a	equ	4
   621                              <1> ;		b	equ	5
   622                              <1> ;		mantissa2 equ	6
   623                              <1> 
   624                              <1> ;		A	equ	a*4
   625                              <1> ;		B	equ	b*4
   626                              <1> ;		MANTISSA2 equ	mantissa2*4
   627                              <1> 
   628                              <1> ;		mov	ebx, dword ptr [bp+MANTISSA2]	; the very same!
   629                              <1> ;		mov	ebx, dword ptr [bp+mantissa2*4]	; the very same
   630                              <1> 
   631                              <1> ;	but to identify an instruction-implied register to these operand routines
   632                              <1> 
   633                              <1> ;		mov	ebx, mantissa2		; bp already says which register set
   634                              <1> 
   635                              <1> ;	instruction evaluation supplies right-hand side operand EA in eax
   636                              <1> ;	Instruction implementation needs not examine EA. Call _operand_read
   637                              <1> ;	or _operand_write. eax must be as supplied to the instruction routine
   638                              <1> ;	on on operand retrieve and store
   639                              <1> 
   640                              <1> ;	simple instructions receive operand mode in cl from instruction
   641                              <1> ;	evaluation
   642                              <1> 
   643                              <1> ;	shifts and jumps use the ea which is already indexed or indirected
   644                              <1> ;	if necessary and make no operand call
   645                              <1> 
   646                              <1> ;	instructions call _burst_read2 or _burst_write2 for two-word operand cycles
   647                              <1> ;	instructions call _burst_read4 or _burst_write4 for four-word operand cycles
   648                              <1> 
   649                              <1> ;	operand reads of 1 or 2 words return values in eax:ebx
   650                              <1> 
   651                              <1> ;		call	_burst_read2
   652                              <1> ;		mov	dword ptr [ebp+A], eax
   653                              <1> ;		mov	dword ptr [ebp+B], ebx
   654                              <1> 
   655                              <1> ;	to store one operand word place it in ebx
   656                              <1> 
   657                              <1> ;	_sc	mov	ebx, dword ptr[_psr]	; I am the store carry instruction sc
   658                              <1> ;		and	ebx, 1			; CARRY
   659                              <1> ;		call	_operand_write
   660                              <1> 
   661                              <1> ;	to store two or four words or to load four words, point bx to register
   662                              <1> 
   663                              <1> ;	_qpop	mov	ebx, dword ptr [ebp+S_P] ; internal stack pointer
   664                              <1> ;						; either application sp or interrupt sp
   665                              <1> ;
   666                              <1> ;		add	dword ptr [ebp+S_P], 4	; internal stack+= 4
   667                              <1> ;		push	ebp			;
   668                              <1> ;		mov	ebp, __register		; in case context is interrupt registers
   669                              <1> ;		call	_burst_write4		; both internal stack pointers are absolute
   670                              <1> ;		pop	ebp			; point epb back to application registers
   671                              <1> ;						;                or interrupt registers
   672                              <1> 
   673                              <1> ;	more complex instructions do something to the registers after
   674                              <1> ;	acquiring operands
   675                              <1> 
   676                              <1> ;		call	_operand_read
   677                              <1> ;		add	eax, dword ptr [ebp+A]
   678                              <1> ;		rol	eax
   679                              <1> ;		and	al, CARRY		; 1
   680                              <1> ;		or	byte ptr [_psr], al	; low-order byte of longword _psr
   681                              <1> ;		shr	eax, 8
   682                              <1> ;		mov	dword ptr [ebp+A], eax
   683                              <1> 
   684                              <1> ;	emulated RTA1 instructions which both read and write (modify)
   685                              <1> ;	storage use the address in [edi+esi*4] to rewrite. edi is
   686                              <1> ;	NULL if it's not a suitable memory for a modify operation
   687                              <1> 
   688                              <1> ;	modify instructions which may have a register operand (not TS)
   689                              <1> ;	call _operand_write to rewrite a register. This guards aganst
   690                              <1> ;	applications writing interrupt registers.
   691                              <1>  
   692                              <1> ;	the effect of storage buses characteristically different
   693                              <1> ;	from RTA1 executable space is emulated in the routines
   694                              <1> ;	device_read and device_write
   695                              <1> 
   696                              <1> ;	Peripheral bus types implemented are
   697                              <1> 
   698                              <1> ;		filestore containing extents of up to 768K octets
   699                              <1> ;		accessible to RTA1 as up to 256K words in each extent.
   700                              <1> ;		The 3-octet words are in canonical order and packed
   701                              <1> 
   702                              <1> ;		network interface buffer store shared with the emulator
   703                              <1> ;		platform and reading out to RTA1 at 16 data bits per word
   704                              <1> ;		with eight high-order zero bits. RTA writes 16 data bits
   705                              <1> ;		to these locations from register low-order bit positions.
   706                              <1> ;		Storage byte order is canonical. These buffers are normal
   707                              <1> ;		and contiguous byte arrays of the emulator platform.
   708                              <1> ;		To RTA1 they are an attached device array of 16-bit words
   709                              <1> 
   710                              <1> ;	Device array types are
   711                              <1> 
   712                              <1> ;		executable space
   713                              <1> ;		24-bit filestore array
   714                              <1> ;		16-bit network interface array
   715                              <1> 
   716                              <1> ;	devices are identified in RTA1 memory relocation pointers and
   717                              <1> ;	tagged with device type. Executable space is device zero
   718                              <1> 
   719                              <1> _burst_read2:
   720 000002EB 66B90600            <1> 	mov	cx, 6
   721 000002EF A900FFFF00          <1> 	test	eax, 00FFFF00h
   722 000002F4 7405                <1> 	jz	read2_registers
   723 000002F6 E96A000000          <1> 	jmp	_bus_read
   724                              <1> 
   725                              <1> read2_registers:				; load registers from registers
   726 000002FB 8B1C85[04000000]    <1> 	mov	ebx, dword ptr [eax*4+__register+4]
   727 00000302 8B0485[00000000]    <1> 	mov	eax, dword ptr [eax*4+__register]
   728 00000309 C3                  <1> 	ret
   729                              <1> 	
   730                              <1> _burst_read4:				; buffered read
   731 0000030A 66B90700            <1> 	mov	cx, 7			; that will help the caller
   732 0000030E A900FFFF00          <1> 	test	eax, 00FFFF00h		; ebp+ebx contains a register number
   733 00000313 7405                <1> 	jz	read4_registers		; may also identify extra
   734 00000315 E94B000000          <1> 	jmp	_bus_read
   735                              <1> 					; workspace registers
   736                              <1> read4_registers:			; at register stack tail
   737 0000031A 89C6                <1> 	mov	esi, eax
   738 0000031C 8B04B5[0C000000]    <1> 	mov	eax, dword ptr [esi*4+__register+12]
   739 00000323 89449D0C            <1> 	mov	dword ptr [ebp+ebx*4+12], eax
   740 00000327 8B04B5[08000000]    <1> 	mov	eax, dword ptr [esi*4+__register+8]
   741 0000032E 89449D08            <1> 	mov	dword ptr [ebp+ebx*4+8], eax
   742 00000332 8B04B5[04000000]    <1> 	mov	eax, dword ptr [esi*4+__register+4]
   743 00000339 89449D04            <1> 	mov	dword ptr [ebp+ebx*4+4], eax
   744 0000033D 8B04B5[00000000]    <1> 	mov	eax, dword ptr [esi*4+__register]
   745 00000344 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   746 00000348 C3                  <1> 	ret
   747                              <1> 
   748                              <1> _operand_read:			; call here with designator coded in cx
   749 00000349 80E107              <1> 	and	cl, 7		; and ea in eax
   750 0000034C 80F904              <1> 	cmp	cl, 4
   751 0000034F 7413                <1> 	je	immediate	; EA is operand
   752 00000351 80F905              <1> 	cmp	cl, 5
   753 00000354 740E                <1> 	je	immediate_xi	; EA is operand
   754                              <1> 
   755 00000356 A900FFFF00          <1> 	test	eax, 00FFFF00h
   756 0000035B 7508                <1> 	jnz	_bus_read	; ea does not point to registers
   757 0000035D 8B0485[00000000]    <1> 	mov	eax, dword ptr [eax*4+__register]
   758                              <1> 
   759                              <1> immediate:
   760                              <1> immediate_xi:
   761 00000364 C3                  <1> 	ret 
   762                              <1> 
   763                              <1> _bus_read:			; readout any memory
   764                              <1> 
   765                              <1> 
   766 00000365 E8E1030000          <1> 	call	base_read_pointer
   767                              <1> 
   768 0000036A A900004000          <1> 	test	eax, 00400000h		; big block?
   769 0000036F 741B                <1> 	je	memory_read_4k_block
   770                              <1> 
   771 00000371 80F906              <1> 	cmp	cl, 6			; multiword operation?
   772 00000374 720D                <1> 	jb	_bus_read_256k_block
   773                              <1> 
   774 00000376 81FEFCFF0300        <1> 	cmp	esi, 03FFFCh		; near the edge?
   775 0000037C 7605                <1> 	jna	_bus_read_256k_block	; no
   776                              <1> 
   777 0000037E E887210000          <1> 	call	read_straddle_18b?
   778                              <1> 
   779                              <1> _bus_read_256k_block:
   780 00000383 A83F                <1> 	test	al, 63
   781 00000385 7429                <1> 	jz	memory_read_page
   782                              <1> 
   783 00000387 E95F040000          <1> 	jmp	device_read
   784                              <1> 
   785                              <1> memory_read_4k_block:
   786 0000038C F7C600F00300        <1> 	test	esi, 0003F000h		; inside 4k block?
   787 00000392 740A                <1> 	jz	memory_read_thru
   788                              <1> 
   789 00000394 BE0E000000          <1> 	mov	esi, LP_ADDRESS
   790 00000399 E9BF0A0000          <1> 	jmp	guard_ii_escape	; no
   791                              <1> 
   792                              <1> memory_read_thru:
   793 0000039E 80F906              <1> 	cmp	cl, 6
   794 000003A1 720D                <1> 	jb	memory_read_page
   795                              <1> 
   796 000003A3 81FEFC0F0000        <1> 	cmp	esi, 0FFCh		; near the edge?
   797 000003A9 7605                <1> 	jna	memory_read_page	; no
   798                              <1> 
   799 000003AB E832210000          <1> 	call	read_straddle_12b?
   800                              <1> 
   801                              <1> memory_read_page:
   802 000003B0 C1E00C              <1> 	shl	eax, 12		; multiply by page and lose bit 00400000
   803 000003B3 01C6                <1> 	add	esi, eax
   804                              <1> 
   805 000003B5 BF[00000000]        <1> 	mov	edi, _memory	; byte address
   806                              <1> 
   807                              <1> 
   808                              <1> memory_read_on:
   809                              <1> 
   810 000003BA 0FB6C1              <1> 	movzx	eax, cl
   811 000003BD 8B0485[C6030000]    <1> 	mov	eax, dword ptr [read_action+eax*4]
   812 000003C4 FFE0                <1> 	jmp	eax
   813                              <1> read_action:
   814 000003C6 [E6030000]          <1> 	dd	memory_read_w0
   815 000003CA [2E040000]          <1> 	dd	memory_t1
   816 000003CE [39040000]          <1> 	dd	memory_t2	; or h1
   817 000003D2 [4D040000]          <1> 	dd	memory_t3	; or h2
   818 000003D6 [64030000]          <1> 	dd	immediate	; don't get here
   819 000003DA [64030000]          <1> 	dd	immediate_xi	; don't get here
   820 000003DE [EE030000]          <1> 	dd	memory_read2
   821 000003E2 [FE030000]          <1> 	dd	memory_read4
   822                              <1> 
   823                              <1> memory_read_w0:			; readout system memory 1 word
   824                              <1> ;	mov	dword ptr [__register+154*4], edi
   825                              <1> ;	mov	dword ptr [__register+155*4], esi
   826 000003E6 8B04B7              <1> 	mov	eax, dword ptr [edi+esi*4]
   827 000003E9 B000                <1> 	mov	al, 0
   828 000003EB 0FC8                <1> 	bswap	eax
   829                              <1> ; immediate:
   830                              <1> ; immediate_xi:
   831 000003ED C3                  <1>  	ret
   832                              <1> 
   833                              <1> memory_read2:			; readout system memory 2 words
   834 000003EE 8B5CB704            <1> 	mov	ebx, dword ptr [edi+esi*4+4]
   835 000003F2 8B04B7              <1> 	mov	eax, dword ptr [edi+esi*4]
   836                              <1> 
   837 000003F5 B000                <1> 	mov	al, 0
   838 000003F7 B300                <1> 	mov	bl, 0
   839 000003F9 0FC8                <1> 	bswap	eax
   840 000003FB 0FCB                <1> 	bswap	ebx
   841 000003FD C3                  <1> 	ret
   842                              <1> 				; readout system memory 4 words
   843                              <1> memory_read4:			; store by pointer
   844                              <1> 				; this will be useful to the caller
   845                              <1> 
   846 000003FE 8B04B7              <1> 	mov	eax, dword ptr [edi+esi*4]
   847 00000401 B000                <1> 	mov	al, 0
   848 00000403 0FC8                <1> 	bswap	eax
   849 00000405 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   850 00000409 8B44B704            <1> 	mov	eax, dword ptr [edi+esi*4+4]
   851 0000040D B000                <1> 	mov	al, 0
   852 0000040F 0FC8                <1> 	bswap	eax
   853 00000411 89449D04            <1> 	mov	dword ptr [ebp+ebx*4+4], eax
   854 00000415 8B44B708            <1> 	mov	eax, dword ptr [edi+esi*4+8]
   855 00000419 B000                <1> 	mov	al, 0
   856 0000041B 0FC8                <1> 	bswap	eax
   857 0000041D 89449D08            <1> 	mov	dword ptr [ebp+ebx*4+8], eax
   858 00000421 8B44B70C            <1> 	mov	eax, dword ptr [edi+esi*4+12]
   859 00000425 B000                <1> 	mov	al, 0
   860 00000427 0FC8                <1> 	bswap	eax
   861 00000429 89449D0C            <1> 	mov	dword ptr [ebp+ebx*4+12], eax
   862 0000042D C3                  <1> 	ret
   863                              <1> 
   864                              <1> memory_t1:
   865 0000042E 8B04B7              <1> 	mov	eax, dword ptr [edi+esi*4]
   866 00000431 C1E010              <1> 	shl	eax, 16		; t1 = 3.2.THIS.zero
   867 00000434 E920000000          <1> 	jmp	memory_tw
   868                              <1> 
   869                              <1> memory_t2:
   870 00000439 8B04B7              <1> 	mov	eax, dword ptr [edi+esi*4]
   871 0000043C F605[00000000]80    <1> 	test	byte ptr[_psr], HALF_W
   872 00000443 751B                <1> 	jnz	memory_h1
   873 00000445 C1E008              <1> 	shl	eax, 8		; t2 = 3.THIS.1.zero
   874 00000448 E90C000000          <1> 	jmp	memory_tw
   875                              <1> 
   876                              <1> memory_t3:
   877 0000044D 8B04B7              <1> 	mov	eax, dword ptr [edi+esi*4]
   878 00000450 F605[00000000]80    <1> 	test	byte ptr[_psr], HALF_W
   879 00000457 7511                <1> 	jnz	memory_h2
   880                              <1> memory_tw:
   881 00000459 C1F810              <1> 	sar	eax, 16		; t3 = THIS.2.1.zero
   882 0000045C C1E808              <1> 	shr	eax, 8
   883 0000045F C3                  <1> 	ret
   884                              <1> 
   885                              <1> memory_h1:
   886 00000460 0FC8                <1> 	bswap	eax		; already loaded but not swapped
   887 00000462 C1E008              <1> 	shl	eax, 8		; h1 = zero.HERE.2.3
   888 00000465 E905000000          <1> 	jmp	memory_hw
   889                              <1> 
   890                              <1> memory_h2:
   891 0000046A 0FC8                <1> 	bswap	eax		; already loaded but not swapped
   892 0000046C C1E014              <1> 	shl	eax, 8+12
   893                              <1> memory_hw:
   894 0000046F C1F80C              <1> 	sar	eax, 12
   895 00000472 C1E808              <1> 	shr	eax, 8
   896 00000475 C3                  <1> 	ret
   897                              <1> 
   898                              <1> 				; store system memory
   899                              <1> _burst_write4:
   900 00000476 66B90700            <1> 	mov	cx, 7
   901 0000047A A900FFFF00          <1> 	test	eax, 00FFFF00h
   902 0000047F 0F85AA000000        <1> 	jnz	NEAR bus_write
   903                              <1> 
   904                              <1> 	; store emulated registers to emulated registers
   905                              <1> 
   906 00000485 F705[00000000]0000- <1> 	test	dword ptr [_psr], 0800000h	; ISR ?
   907 0000048D 8000                <1>
   908 0000048F 750C                <1> 	jnz	write4_registers	; ISRs may write some spare registers
   909 00000491 3D7C000000          <1> 	cmp	eax, 124
   910 00000496 7605                <1> 	jna	write4_registers
   911 00000498 E9BB090000          <1> 	jmp	guard_ii_authority	; but applications may not write
   912                              <1> 					; any interrupt registers
   913                              <1> 
   914                              <1> write4_registers:
   915 0000049D 89C7                <1> 	mov	edi, eax		; eax can be freed
   916                              <1> 
   917 0000049F 8B449D00            <1> 	mov	eax, dword ptr [ebp+ebx*4]	; data for store
   918                              <1> 					; ebp+ebx is a register number
   919                              <1> 					; which can be extra register locations
   920                              <1> 					; serving as workspace at the tail of
   921                              <1> 					; the register stack
   922                              <1> 
   923 000004A3 8904BD[00000000]    <1> 	mov	dword ptr [edi*4+__register], eax
   924 000004AA 8B449D04            <1> 	mov	eax, dword ptr [ebp+ebx*4+4]
   925 000004AE 8904BD[04000000]    <1> 	mov	dword ptr [edi*4+__register+4], eax
   926                              <1> 
   927 000004B5 8B449D08            <1> 	mov	eax, dword ptr [ebp+ebx*4+8]
   928 000004B9 8904BD[08000000]    <1> 	mov	dword ptr [edi*4+__register+8], eax
   929 000004C0 8B449D0C            <1> 	mov	eax, dword ptr [ebp+ebx*4+12]
   930 000004C4 8904BD[0C000000]    <1> 	mov	dword ptr [edi*4+__register+12], eax
   931 000004CB C3                  <1> 	ret
   932                              <1> 
   933                              <1> _burst_write2:
   934 000004CC 66B90600            <1> 	mov	cx, 6
   935 000004D0 A900FFFF00          <1> 	test	eax, 00FFFF00h
   936 000004D5 7558                <1> 	jnz	bus_write
   937                              <1> 
   938                              <1> 	; store to emulated registers
   939                              <1> 
   940 000004D7 F705[00000000]0000- <1> 	test	dword ptr [_psr], 0800000h	; ISR ?
   941 000004DF 8000                <1>
   942 000004E1 750C                <1> 	jnz	write2_registers	; there are spare registers at the end
   943 000004E3 3D7E000000          <1> 	cmp	eax, 126		; but applications may not write
   944 000004E8 7605                <1> 	jna	write2_registers	; any interrupt registers
   945 000004EA E969090000          <1> 	jmp	guard_ii_authority
   946                              <1> 
   947                              <1> write2_registers:
   948 000004EF 89C7                <1> 	mov	edi, eax			; time to free eax
   949 000004F1 8B449D00            <1> 	mov	eax, dword ptr [ebp+ebx*4]
   950 000004F5 8B5C9D04            <1> 	mov	ebx, dword ptr [ebp+ebx*4+4]
   951 000004F9 8904BD[00000000]    <1> 	mov	dword ptr [edi*4+__register], eax
   952 00000500 891CBD[04000000]    <1> 	mov	dword ptr [edi*4+__register+4], ebx
   953 00000507 C3                  <1> 	ret
   954                              <1> 
   955                              <1> _operand_write:
   956 00000508 A900FFFF00          <1> 	test	eax, 00FFFF00h
   957 0000050D 7520                <1> 	jnz	bus_write
   958                              <1> 
   959                              <1> _operand_write_register:
   960 0000050F A980000000          <1> 	test	eax, 80h		; in the interrupt registers?
   961 00000514 7411                <1> 	jz	write1_register
   962 00000516 F705[00000000]0000- <1> 	test	dword ptr [_psr], 0800000h
   963 0000051E 8000                <1>
   964 00000520 7505                <1> 	jnz	write1_register
   965 00000522 E931090000          <1> 	jmp	guard_ii_authority
   966                              <1> 
   967                              <1> write1_register:
   968 00000527 891C85[00000000]    <1> 	mov	dword ptr [eax*4+__register], ebx
   969 0000052E C3                  <1> 	ret
   970                              <1> 
   971                              <1> bus_write:				; write any memory
   972                              <1> 
   973 0000052F E85D020000          <1> 	call	base_write_pointer
   974                              <1> 
   975 00000534 A900004000          <1> 	test	eax, 00400000h		; big block?
   976 00000539 741E                <1> 	jz	memory_write_4k_block	; no
   977 0000053B 80F906              <1> 	cmp	cl, 6			; multiword operation?
   978 0000053E 720D                <1> 	jb	bus_write_256k_block	; no
   979                              <1> 
   980 00000540 81FEFCFF0300        <1> 	cmp	esi, 03FFFCh		; near the edge?
   981 00000546 7605                <1> 	jna	bus_write_256k_block	; no
   982                              <1> 
   983 00000548 E82B200000          <1> 	call	write_straddle_18b?
   984                              <1> 
   985                              <1> bus_write_256k_block:
   986 0000054D A93F000000          <1> 	test	eax, 63			; a device array?
   987 00000552 7429                <1> 	jz	memory_write_page	; no. scaling shift will scrub bit 400000
   988 00000554 E99C030000          <1> 	jmp	_device_write		; yes a device array
   989                              <1> 
   990                              <1> memory_write_4k_block:
   991 00000559 F7C600F00300        <1> 	test	esi, 0003F000h		; inside a 4k page?
   992 0000055F 740A                <1> 	jz	memory_write_thru
   993 00000561 BE0E000000          <1> 	mov	esi, LP_ADDRESS
   994 00000566 E9F2080000          <1> 	jmp	guard_ii_escape		; no
   995                              <1> 
   996                              <1> memory_write_thru:
   997 0000056B 80F906              <1> 	cmp	cl, 6			; multiword operation?
   998 0000056E 720D                <1> 	jb	memory_write_page	; no
   999                              <1> 
  1000 00000570 81FEFC0F0000        <1> 	cmp	esi, 0FFCh		; near the edge?
  1001 00000576 7605                <1> 	jna	memory_write_page	; no
  1002                              <1> 
  1003 00000578 E8CE1F0000          <1> 	call	write_straddle_12b?
  1004                              <1> 
  1005                              <1> memory_write_page:
  1006 0000057D 3B05[F0010000]      <1> 	cmp	eax, dword ptr [_base+124*4]
  1007 00000583 0F82CF080000        <1> 	jb	near guard_ii_authority	; guard the NVRAM whether real or emulated
  1008                              <1> 
  1009 00000589 C1E00C              <1> 	shl	eax, 12			; multiply by page and lose bit 00400000
  1010 0000058C 01C6                <1> 	add	esi, eax		; add offset
  1011                              <1> 
  1012 0000058E BF[00000000]        <1> 	mov	edi, _memory
  1013                              <1> 
  1014                              <1> memory_write_on:
  1015 00000593 0FB6C1              <1> 	movzx	eax, cl
  1016 00000596 8B0485[9F050000]    <1> 	mov	eax, dword ptr [write_action+eax*4]
  1017 0000059D FFE0                <1> 	jmp	eax
  1018                              <1> 
  1019                              <1> write_action:
  1020 0000059F [BF050000]          <1> 	dd	memory_write
  1021 000005A3 [C5050000]          <1> 	dd	write_t1
  1022 000005A7 [CA050000]          <1> 	dd	write_t2	; or h1
  1023 000005AB [DB050000]          <1> 	dd	write_t3	; or h2
  1024 000005AF [C4050000]          <1> 	dd	just_dont
  1025 000005B3 [C4050000]          <1> 	dd	just_dont
  1026 000005B7 [1F060000]          <1> 	dd	memory_write2
  1027 000005BB [33060000]          <1> 	dd	memory_write4
  1028                              <1> 
  1029                              <1> memory_write:					; store system memory 1 word
  1030 000005BF 0FCB                <1> 	bswap	ebx
  1031 000005C1 891CB7              <1> 	mov	dword ptr [edi+esi*4], ebx
  1032                              <1> just_dont:
  1033 000005C4 C3                  <1> 	ret
  1034                              <1> 
  1035                              <1> write_t1:
  1036 000005C5 885CB701            <1> 	mov	byte ptr [edi+esi*4+1], bl
  1037 000005C9 C3                  <1> 	ret
  1038                              <1> 
  1039                              <1> write_t2:
  1040 000005CA F705[00000000]8000- <1> 	test	dword ptr [_psr], HALF_W
  1041 000005D2 0000                <1>
  1042 000005D4 7516                <1> 	jnz	write_h1
  1043 000005D6 885CB702            <1> 	mov	byte ptr [edi+esi*4+2], bl
  1044 000005DA C3                  <1> 	ret
  1045                              <1> 
  1046                              <1> write_t3:
  1047 000005DB F705[00000000]8000- <1> 	test	dword ptr [_psr], HALF_W
  1048 000005E3 0000                <1>
  1049 000005E5 751F                <1> 	jnz	write_h2
  1050 000005E7 885CB703            <1> 	mov	byte ptr [edi+esi*4+3], bl
  1051 000005EB C3                  <1> 	ret
  1052                              <1> 
  1053                              <1> write_h1:
  1054 000005EC 8B04B7              <1> 	mov	eax, dword ptr [edi+esi*4]
  1055 000005EF 0FC8                <1> 	bswap	eax
  1056 000005F1 81E3FF0F0000        <1> 	and	ebx, 4095
  1057 000005F7 C1E30C              <1> 	shl	ebx, 12
  1058 000005FA 25FF0F0000          <1> 	and	eax, 4095
  1059 000005FF 09D8                <1> 	or	eax, ebx
  1060 00000601 E913000000          <1> 	jmp	write_hw
  1061                              <1> 
  1062                              <1> write_h2:
  1063 00000606 8B04B7              <1> 	mov	eax, dword ptr [edi+esi*4]
  1064 00000609 0FC8                <1> 	bswap	eax
  1065 0000060B C1E80C              <1> 	shr	eax, 12
  1066 0000060E C1E00C              <1> 	shl	eax, 12
  1067 00000611 81E3FF0F0000        <1> 	and	ebx, 4095
  1068 00000617 09D8                <1> 	or	eax, ebx
  1069                              <1> 
  1070                              <1> write_hw:
  1071 00000619 0FC8                <1> 	bswap	eax
  1072 0000061B 8904B7              <1> 	mov	dword ptr [edi+esi*4], eax
  1073 0000061E C3                  <1> 	ret
  1074                              <1> 					; store system memory 2 words
  1075                              <1> memory_write2:				; eax is already free
  1076 0000061F 8B449D00            <1> 	mov	eax, dword ptr [ebp+ebx*4]
  1077 00000623 0FC8                <1> 	bswap	eax
  1078 00000625 8904B7              <1> 	mov	dword ptr [edi+esi*4], eax
  1079                              <1> 
  1080 00000628 8B449D04            <1> 	mov	eax, dword ptr [ebp+ebx*4+4]
  1081 0000062C 0FC8                <1> 	bswap	eax
  1082 0000062E 8944B704            <1> 	mov	dword ptr [edi+esi*4+4], eax
  1083 00000632 C3                  <1> 	ret
  1084                              <1> 
  1085                              <1> memory_write4:					; store system memory 4 words
  1086 00000633 8B449D00            <1> 	mov	eax, dword ptr [ebp+ebx*4]	; bx is a register number and may
  1087                              <1> 						; identify extra workspace registers
  1088                              <1> 						; at register stack tail
  1089 00000637 0FC8                <1> 	bswap	eax
  1090 00000639 8904B7              <1> 	mov	dword ptr [edi+esi*4], eax
  1091 0000063C 8B449D04            <1> 	mov	eax, dword ptr [ebp+ebx*4+4]
  1092 00000640 0FC8                <1> 	bswap	eax
  1093 00000642 8944B704            <1> 	mov	dword ptr [edi+esi*4+4], eax
  1094 00000646 8B449D08            <1> 	mov	eax, dword ptr [ebp+ebx*4+8]
  1095 0000064A 0FC8                <1> 	bswap	eax
  1096 0000064C 8944B708            <1> 	mov	dword ptr [edi+esi*4+8], eax
  1097 00000650 8B449D0C            <1> 	mov	eax, dword ptr [ebp+ebx*4+12]
  1098 00000654 0FC8                <1> 	bswap	eax
  1099 00000656 8944B70C            <1> 	mov	dword ptr [edi+esi*4+12], eax
  1100 0000065A C3                  <1> 	ret
  1101                              <1> 
  1102                              <1> ;	modify instructions n inc dec src slc sim popA
  1103                              <1> ;	rewrite here
  1104                              <1> 
  1105                              <1> memoreg_writeback:
  1106 0000065B F7C300FFFFFF        <1> 	test	ebx, -256			; save EA is ?
  1107 00000661 750C                <1> 	jnz	memory_direct			; a memory device
  1108 00000663 93                  <1> 	xchg	eax, ebx			; a register
  1109 00000664 81E3FFFFFF00        <1> 	and	ebx, 00FFFFFFh
  1110 0000066A E9A0FEFFFF          <1> 	jmp	_operand_write_register
  1111                              <1> 
  1112                              <1> ;	if not a register rewrite
  1113                              <1> ;	n inc dec src slc sim popA
  1114                              <1> ;	write RTA memory at its saved platform address
  1115                              <1> 
  1116                              <1> memory_direct:
  1117 0000066F 0FC8                <1> 	bswap	eax
  1118 00000671 30C0                <1> 	xor	al, al
  1119 00000673 8904B7              <1> 	mov	[edi+esi*4], eax
  1120 00000676 C3                  <1> 	ret
  1121                              <1> 
  1122                              <1> ;	execute calls memory read
  1123                              <1> ;	ea < 256 is not for execute a register
  1124                              <1> ;	operand is at a readable address in system memory or array
  1125                              <1> 
  1126                              <1> memory_read:					; for execute and modify instructions:
  1127 00000677 E854000000          <1> 	call	memory_point			; read only executable space
  1128 0000067C 8B04B7              <1> 	mov	eax, dword ptr [edi+esi*4]	; and similar memory types
  1129 0000067F 0FC8                <1> 	bswap	eax
  1130 00000681 C3                  <1> 	ret
  1131                              <1> 
  1132                              <1> ;	modify instructions n inc dec src slc sim popA call here
  1133                              <1> ;	ea < 256 is a register
  1134                              <1> 
  1135                              <1> memoreg:					; read-modify-write registers
  1136 00000682 89C3                <1> 	mov	ebx, eax			; or system-type memory
  1137 00000684 A900FFFFFF          <1> 	test	eax, -256			; but nothing marked as a peripheral bus
  1138 00000689 7508                <1> 	jnz	memory_read_lock
  1139 0000068B 8B0485[00000000]    <1> 	mov	eax, dword ptr [eax*4+__register]
  1140 00000692 C3                  <1> 	ret
  1141                              <1> 
  1142                              <1> ;	RAM boundary in port 124 defines the upper page limit
  1143                              <1> ;	of a real or emulated NVRAM containing the fixed system image
  1144                              <1> 
  1145                              <1> ;	fixed system image may be kernel + loader in a dozen pages
  1146                              <1> ;	or it may be the entire application
  1147                              <1> 
  1148                              <1> ;	emulated machine applies the update limit
  1149                              <1> ;	whether NVRAM is emulated or real
  1150                              <1> 
  1151                              <1> ;	if not a register
  1152                              <1> ;	n inc dec src slc sim popA read a memory word which is legal to write
  1153                              <1> ;	and keep the platform address to write the modified value
  1154                              <1> ;	modify instructions do not lock memory between read and rewrite
  1155                              <1> 
  1156                              <1> memory_read_lock:
  1157 00000693 E806000000          <1> 	call	memory_lock
  1158 00000698 8B04B7              <1> 	mov	eax, dword ptr [edi+esi*4]
  1159 0000069B 0FC8                <1> 	bswap	eax
  1160 0000069D C3                  <1> 	ret
  1161                              <1> 
  1162                              <1> ;	memory_read_lock calls here for modify instructions if ea > registers
  1163                              <1> ;	ts calls here with ea whatever range always -> memory
  1164                              <1> 
  1165                              <1> ;	ea must be a legally writable memory word
  1166                              <1> ;	memory_lock does not lock but identifies a platform write address  
  1167                              <1> ;	ts reads / unconditionally replaces word.t1
  1168                              <1> ;	under platform locking protocol, xchg platform instruction
  1169                              <1> 
  1170                              <1> memory_lock:					; point for update
  1171                              <1> 						; barred below RAM boundary as write is
  1172                              <1> 
  1173 0000069E E8EE000000          <1> 	call	base_write_pointer		; resolve device:block:offset from EA
  1174 000006A3 A900004000          <1> 	test	eax, 00400000h			; update block name is a big bank ?
  1175 000006A8 7419                <1> 	jz	memory_lock_page		; no
  1176 000006AA A93F000000          <1> 	test	eax, 63				; a device outside executable space ?
  1177 000006AF 7553                <1> 	jnz	_yspace_read			; yes
  1178 000006B1 25FFFF3F00          <1> 	and	eax, 003FFFFFh			; bit 0400000 is gets stripped later anyway
  1179 000006B6 3B05[F0010000]      <1> 	cmp	eax, dword ptr [_base+124*4]	; below RAM boundary?
  1180 000006BC 733C                <1> 	jnb	_xspace_read			; no, go ahead
  1181 000006BE E995070000          <1> 	jmp	guard_ii_authority
  1182                              <1> 
  1183                              <1> memory_lock_page:
  1184 000006C3 3B05[F0010000]      <1> 	cmp	eax, dword ptr [_base+124*4]	; below RAM boundary?
  1185 000006C9 731D                <1> 	jnb	_xspace_read4K			; no, go head if offset < 1000 hex
  1186 000006CB E988070000          <1> 	jmp	guard_ii_authority
  1187                              <1> 
  1188                              <1> 
  1189                              <1> ;	memory_read calls here for execute
  1190                              <1> ;	identify a platform read address of an RTA memory word
  1191                              <1> 
  1192                              <1> memory_point:
  1193 000006D0 E876000000          <1> 	call	base_read_pointer
  1194                              <1> 
  1195 000006D5 A900004000          <1> 	test	eax, 00400000h
  1196 000006DA 740C                <1> 	jz	_xspace_read4K
  1197                              <1> 
  1198 000006DC A93F000000          <1> 	test	eax, 63
  1199 000006E1 7417                <1> 	jz	_xspace_read
  1200 000006E3 E91C000000          <1> 	jmp	_yspace_read			; ie a device either appropriate or not
  1201                              <1> 
  1202                              <1> _xspace_read4K:
  1203 000006E8 F7C600F00300        <1> 	test	esi, 003F000h
  1204 000006EE 740A                <1> 	jz	_xspace_read
  1205 000006F0 BE0E000000          <1> 	mov	esi, LP_ADDRESS
  1206 000006F5 E963070000          <1> 	jmp	guard_ii_escape
  1207                              <1> 
  1208                              <1> _xspace_read:
  1209 000006FA BF[00000000]        <1> 	mov	edi, _memory
  1210 000006FF E937000000          <1> 	jmp	_memory_deliver			; device array zero
  1211                              <1> 
  1212                              <1> _yspace_read:
  1213 00000704 A900008000          <1> 	test	eax, 00800000h			; a tripsy non-space?
  1214 00000709 7536                <1> 	jnz	_zspace_read			; not allowed
  1215                              <1> 
  1216 0000070B 89C7                <1> 	mov	edi, eax
  1217 0000070D 81E73F000000        <1> 	and	edi, 63
  1218 00000713 8B3CBD[00020000]    <1> 	mov	edi, dword ptr [_base+128*4+edi*4]
  1219 0000071A F7C700008000        <1> 	test	edi, SYSMEM_FLAG
  1220 00000720 741F                <1> 	jz	_zspace_read
  1221 00000722 F7C700004000        <1> 	test	edi, DATA16_FLAG
  1222 00000728 7517                <1> 	jnz	_zspace_read
  1223                              <1> 
  1224 0000072A C1E002              <1> 	shl	eax, 2				; al = 4 * device index
  1225 0000072D 0FB6F8              <1> 	movzx	edi, al
  1226                              <1> 
  1227 00000730 8BBF[00000000]      <1> 	mov	edi, dword ptr [_devices+edi]
  1228 00000736 30C0                <1> 	xor	al, al				; necessary to lose the device bits now
  1229 00000738 C1E802              <1> 	shr	eax, 2
  1230                              <1> 
  1231                              <1> _memory_deliver
  1232 0000073B C1E00C              <1> 	shl	eax, 12		; multiply by page and lose bit 00400000
  1233 0000073E 01C6                <1> 	add	esi, eax
  1234                              <1> 
  1235                              <1> 	%if	__SMP
  1236                              <1> 	%else
  1237                              <1> 	mov	eax, dword ptr [edi+esi*4]
  1238                              <1> 	bswap	eax
  1239                              <1> 	%endif
  1240 00000740 C3                  <1> 	ret
  1241                              <1> 
  1242                              <1> _zspace_read
  1243 00000741 BE01000000          <1> 	mov	esi, LP_AUTHORITY
  1244 00000746 E912070000          <1> 	jmp	guard_ii_escape
  1245                              <1> 
  1246                              <1> 
  1247                              <1> base_read_pointer:
  1248 0000074B 89C7                <1> 	mov	edi, eax	; set aside EA for split operations
  1249                              <1> 
  1250 0000074D C1C910              <1> 	ror	ecx, 16		; save designator
  1251 00000750 C1C812              <1> 	ror	eax, 18
  1252 00000753 A83F                <1> 	test	al, 63
  1253 00000755 740A                <1> 	jz	page_read_pointer
  1254 00000757 88C1                <1> 	mov	cl, al
  1255 00000759 C1E80E              <1> 	shr	eax, 14
  1256 0000075C E908000000          <1> 	jmp	read_pointer
  1257                              <1> 
  1258                              <1> page_read_pointer:
  1259 00000761 C1C006              <1> 	rol	eax, 6
  1260 00000764 88C1                <1> 	mov	cl, al
  1261 00000766 C1E814              <1> 	shr	eax, 20
  1262                              <1> 
  1263                              <1> read_pointer:
  1264 00000769 89C6                <1>         mov	esi, eax
  1265 0000076B 80E13F              <1> 	and	cl, 63
  1266 0000076E 7413                <1> 	jz	direct_pointer	; there is no alternate to B0
  1267                              <1> 				; ROM constant reads clear from here
  1268 00000770 F6C138              <1> 	test	cl, 56
  1269 00000773 750E                <1> 	jnz	direct_pointer	; shift radix 8-1 might get slipped
  1270                              <1> 				; high memory writes clear from here
  1271 00000775 A1[00000000]        <1> 	mov	eax, dword ptr [_psr]		; now read out _psr
  1272                              <1> 
  1273                              <1> alternate_pointer?:		; only base_write_pointer may jump to here
  1274 0000077A D2E4                <1> 	shl	ah, cl		; so long as radix 31 applies to 8-bit shifts
  1275 0000077C D0EC                <1> 	shr	ah, 1		; any base-tag > 7 delivers zero
  1276 0000077E 80E440              <1> 	and	ah, 64
  1277 00000781 08E1                <1> 	or	cl, ah
  1278                              <1> 
  1279                              <1> direct_pointer:
  1280 00000783 0FB6C1              <1> 	movzx	eax, cl
  1281 00000786 8B0485[00000000]    <1> 	mov	eax, dword ptr [eax*4+_base]
  1282 0000078D C1C910              <1> 	ror	ecx, 16		; restore designator
  1283                              <1> 
  1284 00000790 C3                  <1> 	ret
  1285                              <1> 
  1286                              <1> base_write_pointer:
  1287 00000791 89C7                <1> 	mov	edi, eax	; set aside EA for split write operations
  1288 00000793 C1C910              <1> 	ror	ecx, 16		; save designator
  1289 00000796 C1C812              <1> 	ror	eax, 18
  1290 00000799 A83F                <1> 	test	al, 63
  1291 0000079B 740A                <1> 	jz	page_write_pointer
  1292 0000079D 88C1                <1> 	mov	cl, al
  1293 0000079F C1E80E              <1> 	shr	eax, 14
  1294 000007A2 E908000000          <1> 	jmp	write_pointer
  1295                              <1> 
  1296                              <1> page_write_pointer:
  1297 000007A7 C1C006              <1> 	rol	eax, 6
  1298 000007AA 88C1                <1> 	mov	cl, al
  1299 000007AC C1E814              <1> 	shr	eax, 20
  1300                              <1> 
  1301                              <1> write_pointer:
  1302 000007AF 89C6                <1> 	mov	esi, eax
  1303                              <1> 
  1304 000007B1 80E13F              <1> 	and	cl, 63		; even if an ISR has reason to write its iframe
  1305                              <1> 				; it can base it in a data window
  1306 000007B4 0F849E060000        <1> 	jz	NEAR guard_ii_authority	; so on attempted write in B0
  1307                              <1> 				; application: thread gets withdrawn
  1308                              <1> 				; ISR: forced to auto-restart the system
  1309 000007BA F6C138              <1> 	test	cl, 56
  1310 000007BD 751E                <1> 	jnz	write_allowed	; shift radix 32-1 might get slipped
  1311                              <1> 				; high memory operand writes clear from here
  1312                              <1> 				; 386 shift radix on a byte is 7 anyway
  1313 000007BF A1[00000000]        <1> 	mov	eax, dword ptr [_psr]	; last of all red out the psr
  1314 000007C4 A900008000          <1> 	test	eax, 00800000h		; interrupt code?
  1315 000007C9 75AF                <1> 	jnz	alternate_pointer?	; ISRs write anything
  1316                              <1> 					; unless it isn't there
  1317                              <1> 
  1318 000007CB 88E0                <1> 	mov	al, ah		; gate windows [ 0 2 TCB kernel ]
  1319 000007CD 0CA0                <1> 	or	al, 128+32	; applications may not write them
  1320 000007CF D2E0                <1> 	shl	al, cl
  1321                              <1> 
  1322 000007D1 790A                <1> 	jns	write_allowed
  1323                              <1> 
  1324 000007D3 BE01000000          <1> 	mov	esi, LP_AUTHORITY
  1325 000007D8 E980060000          <1> 	jmp	guard_ii_escape	; not allowed
  1326                              <1> 
  1327                              <1> write_allowed:
  1328 000007DD 0FB6C1              <1> 	movzx	eax, cl		; allowed
  1329 000007E0 8B0485[00000000]    <1> 	mov	eax, dword ptr [eax*4+_base]
  1330                              <1> 
  1331 000007E7 C1C910              <1> 	ror	ecx, 16		; restore designator
  1332 000007EA C3                  <1> 	ret
  1333                              <1> 
  1334                              <1> ;	sub-architectural measure on sabr and reload instructions
  1335                              <1> 
  1336                              <1> ;	check the target memory block is in range and the bus characteristic
  1337                              <1> ;	of the memory device when selecting blocks of memory, not when
  1338                              <1> ;	accessing them. Use 8 spare bits in the word containing _base[]
  1339                              <1> ;	for a quick recall of the emulated bus attribute on reference
  1340                              <1> 
  1341                              <1> ;	because this software emulation needs to act differently for
  1342                              <1> 
  1343                              <1> ;		executable space	rta1 24-bit words canonical memory
  1344                              <1> ;					modeled in platform 32-bit words
  1345                              <1> 
  1346                              <1> ;		shared network buffers	16-bit words canonical in memory
  1347                              <1> ;					and zero extend on readout to RTA1
  1348                              <1> 
  1349                              <1> ;		24-bit filestore array	3-octet words stored big-endian
  1350                              <1> ;					in packed array
  1351                              <1> 
  1352                              <1> ;	concept RTA1 device arrays with bus behaviour differences are completely
  1353                              <1> ;	emulated on PC emulations because device arrays are modeled in PC RAM.
  1354                              <1> 
  1355                              <1> ;	Various bus behaviours are emulated transparently to RTA1 target software
  1356                              <1> ;	in anticipation	that different memories for different uses may be attached
  1357                              <1> ;	on product boards, making core-emulated RTA1s much more efficient for not
  1358                              <1> ;	needing this part of emulation
  1359                              <1> 
  1360                              <1> ;	devices
  1361                              <1> 
  1362                              <1> ;	device 0 is always executable space, but there may be more devices
  1363                              <1> ;	with bus characteristics like device 0. The device descriptors are
  1364                              <1> 
  1365                              <1> ;		_________________________________________________________________
  1366                              <1> ;		| 16 bits flags	| 16 bits banks	|       32 bits pointer		|
  1367                              <1> ;		|_______________|____high index_|_______________________________|
  1368                              <1> 
  1369                              <1> 
  1370                              <1> ;	[out]	sabr	[go]	[call]	reload instructions call here
  1371                              <1> ;	go and call can probably check quicker themself
  1372                              <1> ;	out can be trusted because applications don't out memory _base[] ports
  1373                              <1> 
  1374                              <1> ;	a big block in an RTA1 address window is 262144 words.
  1375                              <1> ;	this checking concerns address windows tagged 2..63
  1376                              <1> ;	a device is an array up to 65536 big blocks or banks
  1377                              <1> 
  1378                              <1> ;	you get here with the relocation handle in ebx
  1379                              <1> ;	and the target window tag in eax, because that is the EA of a sabr instruction
  1380                              <1> 
  1381                              <1> device_read:				; readout device arrays
  1382 000007EB A900008000          <1>         test    eax, 0800000h           ; the vilainous bank index?
  1383 000007F0 752D                <1>         jnz     device_read_escape
  1384                              <1> 
  1385 000007F2 C1E002              <1> 	shl	eax, 2			;  al = device pointer * 4
  1386 000007F5 0FB6F8              <1> 	movzx	edi, al			; edi = device pointer * 4
  1387 000007F8 30C0                <1> 	xor	al, al			; eax = memory block * 256
  1388 000007FA C1E00A              <1> 	shl	eax, 10			; eax = memory block * 262144
  1389 000007FD 01C6                <1> 	add	esi, eax		; offset += base
  1390 000007FF 89F8                <1> 	mov	eax, edi
  1391 00000801 8BB8[00000000]      <1> 	mov	edi, dword ptr [_devices+eax] ; physical array storage
  1392                              <1> _device_read_xpanded:
  1393 00000807 8B80[00020000]      <1> 	mov	eax, dword ptr [_base+128*4+eax]
  1394                              <1> 
  1395 0000080D C1E816              <1> 	shr	eax, 22			; following conditions use parity
  1396                              <1> 					; parity only generated from LS octet
  1397                              <1> 					; how dumb can you get?
  1398                              <1> 
  1399 00000810 2403                <1> 	and	al, 3			; what sort of device array?
  1400                              <1> 
  1401 00000812 740B                <1> 	jz	device_read_escape	; that's double-checked option 00
  1402 00000814 7A67                <1> 	jpe	device_read_array24	; and option 11 shorten
  1403 00000816 A802                <1> 	test	al, SYSMEM_FLAG>>22
  1404 00000818 7414                <1> 	jz	device_read_data16	; and option 01
  1405 0000081A E90A000000          <1> 	jmp	device_read_sysmem	; and option 10
  1406                              <1> 	
  1407                              <1> device_read_escape
  1408 0000081F BE0E000000          <1> 	mov	esi, LP_ADDRESS
  1409 00000824 E934060000          <1> 	jmp	guard_ii_escape
  1410                              <1> 
  1411                              <1> 
  1412                              <1> device_read_sysmem:			; readout system memory array
  1413 00000829 E98CFBFFFF          <1> 	jmp	memory_read_on		; allow all variations partial word / multiword
  1414                              <1> ;	ret
  1415                              <1> 
  1416                              <1> device_read_data16:			; readout 16-bit array
  1417 0000082E 80F907              <1> 	cmp	cl, 7
  1418 00000831 7422                <1> 	jz	device_read_data16_4
  1419 00000833 80F906              <1> 	cmp	cl, 6
  1420 00000836 7411                <1> 	jz	device_read_data16_2
  1421 00000838 E900000000          <1> 	jmp	device_read_data16_1
  1422                              <1> 
  1423                              <1> device_read_data16_1:			; readout 1 word of 16-bit array
  1424 0000083D 0FB70477            <1> 	movzx	eax, word ptr [edi+esi*2]
  1425 00000841 86E0                <1> 	xchg	ah, al
  1426 00000843 A3[90020000]        <1> 	mov	dword ptr [__register+164*4], eax
  1427 00000848 C3                  <1> 	ret
  1428                              <1> 
  1429                              <1> device_read_data16_2:			; readout 2 words of 16-bit array
  1430 00000849 8B0477              <1> 	mov	eax, dword ptr [edi+esi*2]	; 4.3.2.1
  1431                              <1> 
  1432 0000084C 0FC8                <1> 	bswap	eax				; 1.2.3.4
  1433 0000084E 0FB7D8              <1> 	movzx	ebx, ax				; 0.0.3.4
  1434 00000851 C1E810              <1> 	shr	eax, 16				; 0.0.1.2
  1435 00000854 C3                  <1> 	ret
  1436                              <1> 
  1437                              <1> device_read_data16_4:			; readout 4 words of 16-bit array
  1438 00000855 8B0477              <1> 	mov	eax, dword ptr [edi+esi*2]
  1439 00000858 0FC8                <1> 	bswap	eax				; 1.2.3.4
  1440 0000085A 0FB7C8              <1> 	movzx	ecx, ax
  1441 0000085D C1E810              <1> 	shr	eax, 16
  1442 00000860 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
  1443 00000864 894C9D04            <1> 	mov	dword ptr [ebp+ebx*4+4], ecx
  1444                              <1> 
  1445 00000868 8B447704            <1> 	mov     eax, dword ptr [edi+esi*2+4]
  1446 0000086C 0FC8                <1> 	bswap	eax				; 5.6.7.8
  1447 0000086E 0FB7C8              <1> 	movzx	ecx, ax
  1448 00000871 C1E810              <1> 	shr	eax, 16
  1449 00000874 89449D08            <1> 	mov	dword ptr [ebp+ebx*4+8], eax
  1450 00000878 894C9D0C            <1> 	mov	dword ptr [ebp+ebx*4+12], ecx
  1451 0000087C C3                  <1> 	ret
  1452                              <1> 
  1453                              <1> device_read_array24:			; readout from packed 24-bit array
  1454 0000087D E847010000          <1> 	call	device_array24_setpointer
  1455                              <1> 
  1456 00000882 80F907              <1> 	cmp	cl, 7
  1457 00000885 7449                <1> 	jz	device_read_array24_4
  1458 00000887 80F906              <1> 	cmp	cl, 6
  1459 0000088A 7439                <1> 	jz	device_read_array24_2
  1460 0000088C E900000000          <1> 	jmp	device_read_array24_1
  1461                              <1> 
  1462                              <1> device_read_array24_1:			; readout a word of packed 24-bit array
  1463 00000891 660FB60437          <1> 	movzx	ax, byte ptr [edi+esi]
  1464 00000896 C1E008              <1> 	shl	eax, 8
  1465 00000899 8A443701            <1> 	mov	al, byte ptr [edi+esi+1]
  1466 0000089D C1E008              <1> 	shl	eax, 8
  1467 000008A0 8A443702            <1> 	mov	al, byte ptr [edi+esi+2]
  1468 000008A4 81C603000000        <1> 	add	esi, 3
  1469 000008AA C3                  <1> 	ret
  1470                              <1> 
  1471                              <1> device_read_array24_1R
  1472 000008AB 660FB61C37          <1> 	movzx	bx, byte ptr [edi+esi]
  1473 000008B0 C1E308              <1> 	shl	ebx, 8
  1474 000008B3 8A5C3701            <1> 	mov	bl, byte ptr [edi+esi+1]
  1475 000008B7 C1E308              <1> 	shl	ebx, 8
  1476 000008BA 8A5C3702            <1> 	mov	bl, byte ptr [edi+esi+2]
  1477 000008BE 81C603000000        <1> 	add	esi, 3
  1478 000008C4 C3                  <1> 	ret
  1479                              <1> 
  1480                              <1> device_read_array24_2:			; readout 2 words of packed 24-bit array
  1481 000008C5 E8C7FFFFFF          <1> 	call	device_read_array24_1
  1482 000008CA E8DCFFFFFF          <1> 	call	device_read_array24_1R
  1483 000008CF C3                  <1> 	ret
  1484                              <1> 
  1485                              <1> device_read_array24_4:			; readout 4 words of packed 24-bit array
  1486 000008D0 E8BCFFFFFF          <1> 	call	device_read_array24_1
  1487 000008D5 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
  1488 000008D9 E8B3FFFFFF          <1> 	call	device_read_array24_1
  1489 000008DE 89449D04            <1> 	mov	dword ptr [ebp+ebx*4+4], eax
  1490 000008E2 E8AAFFFFFF          <1> 	call	device_read_array24_1
  1491 000008E7 89449D08            <1> 	mov	dword ptr [ebp+ebx*4+8], eax
  1492 000008EB E8A1FFFFFF          <1> 	call	device_read_array24_1
  1493 000008F0 89449D0C            <1> 	mov	dword ptr [ebp+ebx*4+12], eax
  1494 000008F4 C3                  <1> 	ret
  1495                              <1> 
  1496                              <1> _device_write:				; store device arrays
  1497 000008F5 A900008000          <1> 	test	eax, 0800000h		; the vilainous bank index?
  1498                              <1> 
  1499 000008FA 752D                <1> 	jnz	device_write_escape
  1500                              <1> 
  1501 000008FC C1E002              <1> 	shl	eax, 2			;  al = device ID * 4
  1502 000008FF 0FB6F8              <1> 	movzx	edi, al			; edi = device ID * 4
  1503 00000902 30C0                <1> 	xor	al, al			; eax = 256 * block pointer
  1504 00000904 C1E00A              <1> 	shl	eax, 10			; block pointer *= 262144
  1505 00000907 01C6                <1> 	add	esi, eax
  1506 00000909 89F8                <1> 	mov	eax, edi
  1507 0000090B 8BB8[00000000]      <1> 	mov	edi, dword ptr [eax+_devices]	; physical buffer device array
  1508 00000911 8B80[00020000]      <1> 	mov	eax, dword ptr [eax+_base+128*4] ; descriptor port of device
  1509                              <1> 
  1510 00000917 C1E816              <1> 	shr	eax, 22			; following conditions use parity
  1511                              <1> 					; which is only generated from LS octet
  1512                              <1> 
  1513 0000091A 2403                <1> 	and	al, 3			; isolate the device type
  1514 0000091C 740B                <1> 	jz	device_write_escape
  1515 0000091E 7A54                <1> 	jpe	device_write_array24
  1516 00000920 A802                <1> 	test	al, SYSMEM_FLAG>>22
  1517 00000922 7414                <1> 	jz	device_write_data16
  1518 00000924 E90A000000          <1> 	jmp	device_write_sysmem
  1519                              <1> 
  1520                              <1> device_write_escape
  1521 00000929 BE0E000000          <1> 	mov	esi, LP_ADDRESS
  1522 0000092E E92A050000          <1> 	jmp	guard_ii_escape
  1523                              <1> 
  1524                              <1> 
  1525                              <1> device_write_sysmem:
  1526 00000933 E95BFCFFFF          <1> 	jmp	memory_write_on		; allow all variations partial word / multiword
  1527                              <1> 
  1528                              <1> device_write_data16:
  1529                              <1> 
  1530 00000938 80F907              <1> 	cmp	cl, 7
  1531 0000093B 7411                <1> 	jz	device_write_data16_4
  1532 0000093D 80F906              <1> 	cmp	cl, 6
  1533 00000940 741F                <1> 	jz	device_write_data16_2
  1534 00000942 E900000000          <1> 	jmp	device_write_data16_1
  1535                              <1> 
  1536                              <1> device_write_data16_1:			; store 16-bit array
  1537 00000947 86FB                <1> 	xchg	bh, bl
  1538 00000949 66891C77            <1> 	mov	word ptr [edi+esi*2], bx
  1539 0000094D C3                  <1> 	ret
  1540                              <1> 
  1541                              <1> 
  1542                              <1> device_write_data16_4:			; store 4 words in 16-bit array
  1543                              <1> 					; low-order half is swapped on bus read
  1544                              <1> 					; and canonical in eax
  1545 0000094E 668B449D08          <1> 	mov	ax, word ptr [ebp+ebx*4+8]	; get low-order half 3rd register
  1546 00000953 C1E010              <1> 	shl	eax, 16				; 5.6.0.0
  1547 00000956 668B449D0C          <1> 	mov	ax, word ptr [ebp+ebx*4+12]	; 5.6.7.8
  1548 0000095B 0FC8                <1> 	bswap	eax				; it's correct so swap for bus write
  1549 0000095D 89447704            <1> 	mov	dword ptr [edi+esi*2+4], eax
  1550                              <1> 
  1551                              <1> 
  1552                              <1> device_write_data16_2:			; store 2 words in 16-bit array
  1553                              <1> 					; registers are modeled in storage
  1554                              <1> 					; so each bus read corrects an octet pair
  1555                              <1> 
  1556 00000961 668B449D00          <1> 	mov	ax, word ptr [ebp+ebx*4]	; get low-order half 1st register
  1557 00000966 C1E010              <1> 	shl	eax, 16				; 1.2.0.0
  1558 00000969 668B449D04          <1> 	mov	ax, word ptr [ebp+ebx*4+4]	; 1.2.3.4
  1559 0000096E 0FC8                <1> 	bswap	eax				; it's correct, so swap for bus write
  1560 00000970 890477              <1> 	mov	dword ptr [edi+esi*2], eax
  1561 00000973 C3                  <1> 	ret
  1562                              <1> 
  1563                              <1> device_write_array24:			; store 24-bit packed array
  1564 00000974 E850000000          <1> 	call	device_array24_setpointer
  1565                              <1> 
  1566 00000979 80F907              <1> 	cmp	cl, 7
  1567 0000097C 743A                <1> 	jz	device_write_array24_4
  1568 0000097E 80F906              <1> 	cmp	cl, 6
  1569 00000981 7422                <1> 	jz	device_write_array24_2
  1570 00000983 E900000000          <1> 	jmp	device_write_array24_1
  1571                              <1> 
  1572                              <1> device_write_array24_1:			; store 1 word in packed 24-bit array
  1573 00000988 89D8                <1> 	mov	eax, ebx
  1574                              <1> device_write_array24_x:
  1575 0000098A C1C010              <1> 	rol	eax, 16
  1576 0000098D 880437              <1> 	mov	byte ptr [edi+esi], al
  1577 00000990 C1C008              <1> 	rol	eax, 8
  1578 00000993 88443701            <1> 	mov	byte ptr [edi+esi+1], al
  1579 00000997 C1C008              <1> 	rol	eax, 8
  1580 0000099A 88443702            <1> 	mov	byte ptr [edi+esi+2], al
  1581 0000099E 81C603000000        <1> 	add	esi, 3
  1582 000009A4 C3                  <1> 	ret
  1583                              <1> 
  1584                              <1> device_write_array24_2:			; store 2 words in packed 24-bit array
  1585 000009A5 8B449D00            <1> 	mov	eax, [ebp+ebx*4]
  1586 000009A9 E8DCFFFFFF          <1> 	call	device_write_array24_x
  1587 000009AE 8B449D04            <1> 	mov	eax, [ebp+ebx*4+4]
  1588 000009B2 E8D3FFFFFF          <1> 	call	device_write_array24_x
  1589                              <1> ;	add	ebx, 2
  1590 000009B7 C3                  <1> 	ret
  1591                              <1> 
  1592                              <1> device_write_array24_4:			; store 4 words in packed 24-bit array
  1593 000009B8 E8E8FFFFFF          <1> 	call	device_write_array24_2
  1594 000009BD 81C302000000        <1> 	add	ebx, 2
  1595 000009C3 E8DDFFFFFF          <1> 	call	device_write_array24_2
  1596 000009C8 C3                  <1> 	ret
  1597                              <1> 
  1598                              <1> device_array24_setpointer:
  1599 000009C9 89F0                <1> 	mov	eax, esi			; think of a number
  1600 000009CB D1E0                <1> 	shl	eax, 1				; double it
  1601 000009CD 01C6                <1> 	add	esi, eax			; add it to the number you first thought of...
  1602 000009CF C3                  <1> 	ret
  1603                              <1> 
  1604                                  	%include	"sr.msm"
  1605                              <1> 
  1606                              <1> ;	read staging register
  1607                              <1> ;	read bits from a stream of bits
  1608                              <1> 
  1609 000009D0 8B0D[50000000]      <1> _rsr:	mov	ecx, dword ptr [__register+RDATAC]
  1610 000009D6 88CD                <1> 	mov	ch, cl
  1611 000009D8 88C1                <1> 	mov	cl, al
  1612                              <1> 
  1613 000009DA 31C0                <1> 	xor	eax, eax
  1614 000009DC F705[00000000]4000- <1> 	test	dword ptr [_psr], B_STREAMZR
  1615 000009E4 0000                <1>
  1616 000009E6 7505                <1> 	jnz	_rsr_zadd
  1617 000009E8 A1[10000000]        <1> 	mov	eax, dword ptr [__register+A]
  1618                              <1> _rsr_zadd:
  1619 000009ED 20C9                <1> 	and	cl, cl
  1620 000009EF 745C                <1> 	jz	_rsr_x
  1621 000009F1 8B1D[54000000]      <1> 	mov	ebx, dword ptr [__register+RDATA]
  1622                              <1> 
  1623 000009F7 20ED                <1> 	and	ch, ch			; any data loaded yet?
  1624 000009F9 740F                <1> 	jz	_rsr_read		; if not read first no question 
  1625 000009FB 38CD                <1> 	cmp	ch, cl			; otherwise, already enough for request?
  1626 000009FD 7333                <1> 	jnb	_rsr_draw		; if so deliver data
  1627 000009FF 28E9                <1> 	sub	cl, ch			; if not trim the oustanding count
  1628 00000A01 86CD                <1> 	xchg	cl, ch			
  1629 00000A03 E8360F0000          <1> 	call	dsl			; and deliver available data
  1630 00000A08 86E9                <1> 	xchg	ch, cl			; before reading some more
  1631                              <1> _rsr_read:
  1632 00000A0A E8AF000000          <1> 	call	stream_read
  1633 00000A0F C705[50000000]1800- <1> 	mov	dword ptr [__register+RDATAC], 24
  1634 00000A17 0000                <1>
  1635 00000A19 F705[00000000]2000- <1> 	test	dword ptr [_psr], B_STREAM16R
  1636 00000A21 0000                <1>
  1637 00000A23 740D                <1> 	jz	_rsr_draw
  1638 00000A25 C705[50000000]1000- <1> 	mov	dword ptr [__register+RDATAC], 16
  1639 00000A2D 0000                <1>
  1640 00000A2F C1E308              <1> 	shl	ebx, 8
  1641                              <1> _rsr_draw:
  1642 00000A32 6651                <1> 	push	cx
  1643 00000A34 E8050F0000          <1> 	call	dsl
  1644 00000A39 6659                <1> 	pop	cx
  1645 00000A3B 81E1FF000000        <1> 	and	ecx, 255
  1646 00000A41 290D[50000000]      <1> 	sub	dword ptr [__register+RDATAC], ecx
  1647 00000A47 891D[54000000]      <1> 	mov	dword ptr [__register+RDATA], ebx
  1648                              <1> _rsr_x:
  1649 00000A4D A3[10000000]        <1> 	mov	dword ptr [__register+A], eax
  1650 00000A52 C3                  <1> 	ret
  1651                              <1> 
  1652                              <1> 
  1653                              <1> ;	write staging register
  1654                              <1> ;	write bits to a stream of bits
  1655                              <1> 
  1656 00000A53 8B0D[58000000]      <1> _wsr:	mov	ecx, dword ptr [__register+WDATAC]
  1657 00000A59 88CD                <1> 	mov	ch, cl					; accumulated count
  1658 00000A5B 88C1                <1> 	mov	cl, al					; new request
  1659                              <1> 
  1660 00000A5D A1[5C000000]        <1> 	mov	eax, dword ptr [__register+WDATA]	; accumulated data
  1661 00000A62 8B1D[10000000]      <1> 	mov	ebx, dword ptr [__register+A]		; source new data
  1662                              <1> 
  1663 00000A68 80C5E8              <1> 	add	ch, -24				; space for new data expressed negative
  1664 00000A6B F705[00000000]1000- <1> 	test	dword ptr [_psr], B_STREAM16W	; 16 bits / word flag
  1665 00000A73 0000                <1>
  1666 00000A75 7403                <1> 	jz	_wsr24
  1667 00000A77 80C508              <1> 	add	ch, 8
  1668                              <1> 
  1669 00000A7A 00CD                <1> _wsr24:	add	ch, cl			; increment towards zero
  1670 00000A7C 7404                <1> 	jz	_wsr_write		; accumulated word exactly full
  1671 00000A7E 731D                <1> 	jnc	_wsr_add		; not yet full
  1672                              <1> 
  1673 00000A80 28E9                <1> 	sub	cl, ch			; full + some more
  1674                              <1> 
  1675                              <1> _wsr_write:
  1676 00000A82 E8B70E0000          <1> 	call	dsl			; fill output word
  1677 00000A87 88E9                <1> 	mov	cl, ch			; position outstanding count
  1678 00000A89 E84D000000          <1> 	call	stream_write
  1679 00000A8E B800000000          <1> 	mov	eax, 0
  1680 00000A93 C705[58000000]0000- <1> 	mov	dword ptr [__register+WDATAC], 0
  1681 00000A9B 0000                <1>
  1682                              <1> 
  1683                              <1> _wsr_add:
  1684 00000A9D 6651                <1> 	push	cx
  1685 00000A9F E89A0E0000          <1> 	call	dsl			; add to output word
  1686 00000AA4 6659                <1> 	pop	cx
  1687 00000AA6 81E1FF000000        <1> 	and	ecx, 255		; format ecx for add to accumulated count 
  1688 00000AAC 010D[58000000]      <1> 	add	dword ptr [__register+WDATAC], ecx
  1689 00000AB2 A3[5C000000]        <1> 	mov	dword ptr [__register+WDATA], eax
  1690 00000AB7 891D[10000000]      <1> 	mov	dword ptr [__register+A], ebx
  1691 00000ABD C3                  <1> 	ret
  1692                              <1> 
  1693                              <1> stream_read:
  1694 00000ABE 51                  <1> 	push	ecx
  1695 00000ABF 50                  <1> 	push	eax
  1696 00000AC0 A1[34000000]        <1> 	mov	eax, dword ptr [__register+Q]
  1697 00000AC5 8105[34000000]0100- <1> 	add	dword ptr [__register+Q], 1
  1698 00000ACD 0000                <1>
  1699 00000ACF 30C9                <1> 	xor	cl, cl
  1700 00000AD1 E873F8FFFF          <1> 	call	_operand_read
  1701 00000AD6 89C3                <1> 	mov	ebx, eax
  1702 00000AD8 58                  <1> 	pop	eax
  1703 00000AD9 59                  <1> 	pop	ecx
  1704 00000ADA C3                  <1> 	ret
  1705                              <1> 
  1706                              <1> stream_write:
  1707 00000ADB 51                  <1> 	push	ecx
  1708 00000ADC 53                  <1> 	push	ebx
  1709 00000ADD 89C3                <1> 	mov	ebx, eax
  1710 00000ADF A1[30000000]        <1> 	mov	eax, dword ptr [__register+P]
  1711 00000AE4 8105[30000000]0100- <1> 	add	dword ptr [__register+P], 1
  1712 00000AEC 0000                <1>
  1713 00000AEE 30C9                <1> 	xor	cl, cl
  1714 00000AF0 E813FAFFFF          <1> 	call	_operand_write
  1715 00000AF5 5B                  <1> 	pop	ebx
  1716 00000AF6 59                  <1> 	pop	ecx
  1717 00000AF7 C3                  <1> 	ret
  1718                              <1> 
  1719                                  	%include	"io.msm"
  1720 00000AF8 8B1C85[00000000]    <1> _inA:	mov	ebx, dword ptr [eax*4+_base]
  1721 00000AFF 895D10              <1> 	mov	dword ptr [ebp+A], ebx
  1722 00000B02 C3                  <1> _inA_:	ret
  1723                              <1> 
  1724 00000B03 8B1C85[00000000]    <1> _inB:	mov	ebx, dword ptr [eax*4+_base]
  1725 00000B0A 895D14              <1> 	mov	dword ptr [ebp+B], ebx
  1726 00000B0D C3                  <1> _inB_:	ret
  1727                              <1> 
  1728 00000B0E 8B5D10              <1> _outA:	mov	ebx, dword ptr [ebp+A]
  1729 00000B11 E9A5010000          <1> 	jmp	oport
  1730                              <1> 
  1731 00000B16 8B5D14              <1> _outB:	mov	ebx, dword ptr [ebp+B]
  1732 00000B19 E99D010000          <1> 	jmp	oport
  1733                              <1> 
  1734                              <1> 
  1735                              <1> ISR_ONLY equ	8
  1736                              <1> MEMTYPE	equ	1
  1737                              <1> MEMZERONLY equ	2
  1738                              <1> EXTERNAL_IO equ	4
  1739                              <1> BROADCAST equ	16
  1740                              <1> 
  1741                              <1> B_1	equ	MEMTYPE
  1742                              <1> B_TCB	equ	MEMTYPE+ISR_ONLY
  1743                              <1> B_KERN	equ	MEMTYPE+ISR_ONLY
  1744                              <1> A_THREP	equ	MEMZERONLY+ISR_ONLY
  1745                              <1> I_PORT	equ	EXTERNAL_IO
  1746                              <1> O_PORT	equ	EXTERNAL_IO
  1747                              <1> O_INDICA equ	EXTERNAL_IO
  1748                              <1> O_CHILL	equ	EXTERNAL_IO
  1749                              <1> I_TZONE	equ	EXTERNAL_IO
  1750                              <1> RAM_THRESH equ	ISR_ONLY+MEMZERONLY
  1751                              <1> XI_ACK	equ	ISR_ONLY+EXTERNAL_IO
  1752                              <1> O_LEDS	equ	EXTERNAL_IO
  1753                              <1> O_INC	equ	ISR_ONLY+EXTERNAL_IO
  1754                              <1> O_MCAST	equ	ISR_ONLY+BROADCAST
  1755                              <1> 
  1756                              <1> 
  1757                              <1> mask_port_outAB
  1758 00000B1E 000100000000000000- <1> 	db	0, B_1, 0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
  1759 00000B27 00000000000000      <1>
  1760 00000B2E 000000000000000000- <1> 	db	    0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
  1761 00000B37 00000000000000      <1>
  1762                              <1> 
  1763 00000B3E 000000000000000000- <1> 	db	    0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
  1764 00000B47 00000000000000      <1>
  1765 00000B4E 000000000000000000- <1> 	db	    0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
  1766 00000B57 00000000000000      <1>
  1767                              <1> 
  1768 00000B5E 0009090909090909    <1> 	db	0,  B_TCB,B_KERN,B_KERN,B_KERN,B_KERN,B_KERN,B_KERN
  1769 00000B66 0A00000C0C000018    <1> 	db	A_THREP, 0, 0, XI_ACK,  O_INC, 0,0, O_MCAST
  1770                              <1> 
  1771 00000B6E 0404040404040404    <1> 	db	I_PORT,I_PORT,I_PORT,I_PORT,I_PORT,I_PORT,I_PORT,I_PORT
  1772 00000B76 0404040404040404    <1> 	db	O_PORT,O_PORT,O_PORT,O_PORT,O_PORT,O_PORT,O_PORT,O_PORT
  1773                              <1> 
  1774 00000B7E 0000000000040404    <1> 	db	0,0,0,0, 0, I_TZONE, O_INDICA, O_CHILL
  1775 00000B86 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  RAM_THRESH, 0,0, O_LEDS
  1776 00000B8F 0000000A000004      <1>
  1777                              <1> 
  1778 00000B96 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
  1779 00000B9F 00000000000000      <1>
  1780 00000BA6 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
  1781 00000BAF 00000000000000      <1>
  1782 00000BB6 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
  1783 00000BBF 00000000000000      <1>
  1784 00000BC6 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
  1785 00000BCF 00000000000000      <1>
  1786                              <1> 
  1787                              <1> 					; outA|B rules flags per I/O port
  1788                              <1> 
  1789                              <1> 	%if	0
  1790                              <1> 
  1791                              <1> oport:	cmp	eax, 192
  1792                              <1> 	jnb	ocheck
  1793                              <1> 	mov	cl, byte ptr [mask_port_outAB+eax]
  1794                              <1> 	and	cl, cl
  1795                              <1> 	jz	ocheck
  1796                              <1> 	test	cl, ISR_ONLY
  1797                              <1> 	jz	check_ahead
  1798                              <1> 	test	byte ptr [_psr+2], 128
  1799                              <1> 	jz	ocheck
  1800                              <1> 
  1801                              <1> check_ahead:
  1802                              <1> 	test	cl, EXTERNAL_IO
  1803                              <1> 	jz	check_mpointer		; no restriction if the port is flagged
  1804                              <1> 
  1805                              <1> 	mov	dword ptr [_base+eax*4], ebx
  1806                              <1> 					; effects of some outA|B cases
  1807                              <1> 	cmp	eax, 102
  1808                              <1> 	jnz	io_ack_pins?
  1809                              <1> 	or	dword ptr [_indication], ebx
  1810                              <1> 	jmp	outxio_complete
  1811                              <1> 
  1812                              <1> io_ack_pins?:
  1813                              <1> 	cmp	eax, 75			; turn off an ISR pending pin
  1814                              <1> 	jnz	alert_multicast?	; corresponding to the ACK pin in bl
  1815                              <1> 	not	bl
  1816                              <1> 	and	byte ptr [_base+74*4], bl
  1817                              <1> 	jmp	outxio_complete
  1818                              <1> 
  1819                              <1> alert_multicast?:			; raise core2core broadcast signal
  1820                              <1> 	cmp	eax, 79
  1821                              <1> 	jnz	outxio_complete
  1822                              <1> 	test	bl, 1			; only 1 core is emulated
  1823                              <1> 	jz	outxio_complete		; = bit 0 of broadcast mask
  1824                              <1> 	or	byte ptr [_indication], ATTENTION
  1825                              <1> 
  1826                              <1> outxio_complete:
  1827                              <1> 	ret				; for requester type [ ISR | anyone ]
  1828                              <1> 					; and is not a memory pointer [ 1..63 65..72 124 ]
  1829                              <1> ocheck:
  1830                              <1> 	mov	esi, LP_AUTHORITY
  1831                              <1> 	jmp	guard_ii_escape
  1832                              <1> 					; rules for ports
  1833                              <1> 					; wnich are pointers to memory
  1834                              <1> 					; outA|B isn't allowed 
  1835                              <1> check_mpointer:				; on ports [ 2..63 ]
  1836                              <1> 	test	cl, MEMTYPE		; they are in scope of sabr insrtuction
  1837                              <1> 	jnz	check_mdevice
  1838                              <1> 
  1839                              <1> 	test	ebx, 0400000h		; only the plain page pointer accepted
  1840                              <1> 	jnz	ocheck
  1841                              <1> 
  1842                              <1> check_mpointer_zero
  1843                              <1> 	mov	ecx, dword ptr [_base+128*4]
  1844                              <1> 	and	ecx, 003fffffh		; can't be higher than device zero pages
  1845                              <1> 	cmp	ecx, ebx
  1846                              <1> 	jb	ocheck
  1847                              <1> 	mov	dword ptr [_base+eax*4], ebx
  1848                              <1> 	ret
  1849                              <1> 
  1850                              <1> check_mdevice:
  1851                              <1> 	test	ebx, 00400000h		; page pointer is good & quick
  1852                              <1> 	jz	check_mpointer_zero
  1853                              <1> 	test	ebx, 63			; device zero = system memory
  1854                              <1> 	jz	check_device_zero	; is good & quick
  1855                              <1> 
  1856                              <1> 	mov	cl, bl			; otherwise measure the device
  1857                              <1> 	and	ecx, 63
  1858                              <1> 	mov	ecx, dword ptr [_base+128*4+ecx*4]
  1859                              <1> 	rol	ecx, 10			; the device must have
  1860                              <1> 	and	cl, 3			; the same type as system memory
  1861                              <1> 	cmp	cl, 2
  1862                              <1> 	jne	ocheck
  1863                              <1> 
  1864                              <1> 	shr	ecx, 10			; a page #, last 6 bits always 63 (03F)
  1865                              <1> 
  1866                              <1> 	mov	esi, ebx		; a page #, last 6 bits zero for comparison
  1867                              <1> 	and	esi, 00BFFFC0h
  1868                              <1> 	cmp	ecx, esi
  1869                              <1> 	jb	ocheck
  1870                              <1> 	mov	dword ptr [_base+eax*4], ebx
  1871                              <1> 	ret
  1872                              <1> 
  1873                              <1> check_device_zero:
  1874                              <1> 	mov	ecx, dword ptr [_base+128*4]
  1875                              <1> 	and	ecx, 003FFFFFh
  1876                              <1> 	or	ecx, 00400000h
  1877                              <1> 	cmp	ecx, ebx
  1878                              <1> 	jb	ocheck
  1879                              <1> 	mov	dword ptr [_base+eax*4], ebx
  1880                              <1> 	ret
  1881                              <1> 
  1882                              <1> 	%endif
  1883                              <1> 
  1884                              <1> _reload:
  1885 00000BD6 50                  <1> 	push	eax
  1886 00000BD7 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
  1887 00000BDA 81451002000000      <1> 	add	dword ptr [ebp+A], 2
  1888 00000BE1 E805F7FFFF          <1> 	call	_burst_read2
  1889 00000BE6 5F                  <1> 	pop	edi
  1890 00000BE7 8904BD[00000000]    <1> 	mov	dword ptr [edi*4+_base], eax
  1891 00000BEE 891CBD[04000000]    <1> 	mov	dword ptr [edi*4+_base+4], ebx
  1892 00000BF5 C3                  <1> 	ret
  1893                              <1> 
  1894 00000BF6 C3                  <1> _emulator_cool: ret
  1895                              <1> 
  1896                              <1> ;	sabr checks what it places in operand space windows
  1897                              <1> ;	there are no subsequent range checks on reference
  1898                              <1> 
  1899 00000BF7 A93E000000          <1> _sabr:	test	eax, 0000003Eh		; target window must be 2..63
  1900 00000BFC 0F8456020000        <1> 	jz	near guard_ii_authority
  1901 00000C02 A9C0FFFF00          <1> 	test	eax, 00FFFFC0h
  1902 00000C07 0F854B020000        <1> 	jnz	near guard_ii_authority
  1903 00000C0D 89C6                <1> 	mov	esi, eax		; target window
  1904 00000C0F 8B4510              <1> 	mov	eax, dword ptr [ebp+A]	; requested storage block index
  1905 00000C12 89C3                <1> 	mov	ebx, eax		; cache a copy
  1906                              <1> 
  1907 00000C14 8B0D[00020000]      <1> 	mov	ecx, dword ptr [_base+128*4]
  1908                              <1> 					; device zero = executable space
  1909                              <1> 					; load its size parameter
  1910 00000C1A A900004000          <1> 	test	eax, 00400000h		; big and maybe not system memory?
  1911 00000C1F 7432                <1> 	jz	_sabr_executable_space	; yes executable space
  1912                              <1> 
  1913 00000C21 F7C33F000000        <1> 	test	ebx, 63
  1914 00000C27 742A                <1> 	jz	_sabr_executable_space	; yes executable space
  1915                              <1> 					; no some other space
  1916                              <1> 
  1917 00000C29 81E33F000000        <1> 	and	ebx, 63
  1918 00000C2F 8B0C9D[00020000]    <1> 	mov	ecx, dword ptr [_base+128*4+ebx*4]
  1919 00000C36 F7C100004000        <1> 	test	ecx, DATA16_FLAG
  1920 00000C3C 7532                <1> 	jnz	 _sabr_device_array
  1921 00000C3E F7C100008000        <1> 	test	ecx, 00800000h
  1922 00000C44 744F                <1> 	jz	_sabr_guard		; range issue. The device is void
  1923                              <1> 
  1924 00000C46 89C3                <1> 	mov	ebx, eax
  1925 00000C48 81E3C0FFBF00        <1> 	and	ebx, 00BFFFC0h		; blocks of 64 pages if not device zero
  1926 00000C4E E90E000000          <1> 	jmp	_sabr_executable_type	; devices usable as system memory
  1927                              <1> 	
  1928                              <1> _sabr_executable_space:			; is the target page @+ application space?
  1929 00000C53 81E3FFFFBF00        <1> 	and	ebx, 00BFFFFFh		; just the page, not any flags
  1930 00000C59 3B1D[20010000]      <1> 	cmp	ebx, dword ptr [_base+72*4]
  1931 00000C5F 7834                <1> 	js	_sabr_guard		; neither ISrs nor applications may base ISR space
  1932                              <1> 
  1933                              <1> _sabr_executable_type:			; has the device this much memory?
  1934 00000C61 81E1FFFF3F00        <1> 	and	ecx, 003FFFFFh		; 4K-word page high index of device
  1935                              <1> 					; has the device this many pages?
  1936 00000C67 29D9                <1> 	sub	ecx, ebx
  1937                              <1> 
  1938 00000C69 792F                <1> 	jns	_sabr_thru		; yes
  1939 00000C6B E925000000          <1> 	jmp	_sabr_guard		; no
  1940                              <1> 
  1941                              <1> _sabr_device_array:
  1942 00000C70 F705[00000000]0000- <1> 	test	dword ptr [_psr], 00800000h
  1943 00000C78 8000                <1>
  1944 00000C7A 0F84D8010000        <1> 	jz	near guard_ii_authority	; only be here if you are an ISR
  1945 00000C80 89C3                <1> 	mov	ebx, eax		; refresh the requested block index
  1946 00000C82 81E3FFFF3F00        <1> 	and	ebx, 003FFFFFh
  1947 00000C88 C1EB06              <1> 	shr	ebx, 6			; align it with high index from device port
  1948 00000C8B 81E1FFFF3F00        <1> 	and	ecx, 003FFFFFh		; has the device array this many blocks?
  1949                              <1> 
  1950 00000C91 29D9                <1> 	sub	ecx, ebx
  1951 00000C93 7905                <1> 	jns	_sabr_thru		; yes
  1952                              <1> 					; no
  1953                              <1> _sabr_guard:
  1954 00000C95 B80100C000          <1> 	mov	eax, 00C00001h		; no-access value
  1955                              <1> 					; will trip on reference in target window
  1956                              <1> _sabr_thru:
  1957 00000C9A 8904B5[00000000]    <1> 	mov	dword ptr [_base+esi*4], eax
  1958                              <1> 					; esi = target window
  1959 00000CA1 8B1D[04010000]      <1> 	mov	ebx, dword ptr [_base+65*4]	; thread TCB
  1960 00000CA7 C1E30E              <1> 	shl	ebx, 12+2		; 4K page * 4 platform bytes
  1961 00000CAA BF[00000000]        <1> 	mov	edi, _memory		; so system memory of emulated machine
  1962 00000CAF 01DF                <1> 	add	edi, ebx		; + offset of TCB 
  1963 00000CB1 0FC8                <1> 	bswap	eax			; big endian store at TCB + ABT + esi * 4 
  1964 00000CB3 8984B700010000      <1> 	mov	dword ptr [edi+esi*4+64*4], eax
  1965                              <1> 					; -> TCB + ABT + window index
  1966 00000CBA C3                  <1> _sabrx:	ret
  1967                              <1> 
  1968                                  	%include	"oport.msm"
  1969                              <1> 							; static void oport(int ea, int value, smp *xcore)
  1970                              <1> 							; {
  1971                              <1> oport:		; write I / O port			;    int		 rule,
  1972                              <1> 		; RTA instructions outA outB		;			 device;
  1973                              <1> 							; 
  1974                              <1> 		; ports which are memory pointers	;    int		 mask,
  1975                              <1> 		; must have a block that exists		;			 from,
  1976                              <1> 		; ISRs can write trap value C00001 	;                 	 index;
  1977                              <1> 		; = device 400001 | illegal 800000	; 
  1978                              <1> 		; port # = effective address = eax	;    int		 device_index = 0;
  1979                              <1> 		; write value in ebx			; 
  1980                              <1> 		; multicast bits in RTA register k	;    smp		*ascor;
  1981                              <1> 		 					;    unsigned	*register_set = xcore->register_set;
  1982 00000CBB 3DC0000000          <1> 	cmp	eax, IO_PORTS				; 
  1983 00000CC0 7365                <1> 	jnb	no_port					;    if (ea < IO_PORTS)
  1984                              <1> 							;    {
  1985 00000CC2 8A88[1E0B0000]      <1> 	mov	cl, byte ptr [eax+mask_port_outAB]	;       rule = mask_port_outAB[ea];
  1986 00000CC8 20C9                <1> 	and	cl, cl					; 
  1987 00000CCA 745B                <1> 	jz	no_rule					;       if (rule)
  1988 00000CCC F6C108              <1> 	test	cl, ISR_ONLY				;       {
  1989 00000CCF 7409                <1> 	jz	application_plus_isr_rule		;          if (((rule & ISR_ONLY) == 0) || (psr & 0x00800000))
  1990 00000CD1 F605[02000000]80    <1> 	test	byte ptr [_psr+2], 128			;          {
  1991 00000CD8 744D                <1> 	jz	no_authority				;
  1992                              <1> 							;
  1993                              <1> application_plus_isr_rule:				;
  1994 00000CDA F6C104              <1> 	test	cl, EXTERNAL_IO				;             if (rule & EXTERNAL_IO)
  1995 00000CDD 7427                <1> 	jz	broadcast_rule?				;             {
  1996 00000CDF 891C85[00000000]    <1> 	mov	dword ptr [eax*4+_base], ebx		;                base[ea] = value;
  1997 00000CE6 3D66000000          <1> 	cmp	eax, 102	; INDICATION$		;                if (ea == 102) indication |= value;
  1998 00000CEB 7506                <1> 	jne	xi_ack?		 			;
  1999 00000CED 091D[00000000]      <1> 	or	dword ptr [_indication], ebx		;
  2000                              <1>  							;
  2001                              <1> xi_ack?							;
  2002 00000CF3 3D4B000000          <1> 	cmp	eax, 75					;                if (ea == 75)
  2003 00000CF8 750B                <1> 	jne	xi_no_ack				;                {
  2004 00000CFA F6D3                <1> 	not	bl					;                    base[74] &= (value & 255) ^ 255;
  2005 00000CFC 0FB6DB              <1> 	movzx	ebx, bl					;                    // indication |= (value & 255) << 8;
  2006                              <1> 							;                }
  2007 00000CFF 211D[28010000]      <1> 	and	dword ptr [_base+74*4], ebx		; 
  2008                              <1> xi_no_ack:						; //               if ((ea == 79) && (value & 1)) indication |= ATTENTION;
  2009 00000D05 C3                  <1> 	ret						;                return;
  2010                              <1> 							;             }
  2011                              <1> 							; 
  2012                              <1> broadcast_rule?:					;             if (rule & BROADCAST)
  2013 00000D06 F6C110              <1> 	test	cl, BROADCAST				;             {
  2014 00000D09 7426                <1> 	jz	memory_rule?				;                mask = k;
  2015 00000D0B F6450501            <1> 	test	byte ptr [ebp+K+1], 1			;                from = base[77];
  2016                              <1> 	; there is only core 0				; 
  2017 00000D0F 740E                <1> 	jz	storecast				;                for (index = 0; index < RTA_SMP; index++)
  2018                              <1> ;	 write the port still means write the port	;                {
  2019 00000D11 800D[39010000]01    <1> 	or	byte ptr [_base+78*4+1], 1		;                   if (mask & 1)
  2020 00000D18 800D[00000000]80    <1> 	or	byte ptr [_indication], ATTENTION	;                   {
  2021                              <1> 							;                      ascor = core + index;
  2022                              <1> storecast:						;                      ascor->BASE[78] |= 1 << from;
  2023 00000D1F 891C85[00000000]    <1> 	mov	dword ptr [eax*4+_base], ebx		;                      ascor->INDICATION |= ATTENTION;
  2024 00000D26 C3                  <1> 	ret						;                   }
  2025                              <1> 							; 
  2026                              <1> 							;                   mask >>= 1;
  2027                              <1> 							;                }
  2028                              <1> no_port:						; 
  2029                              <1> no_rule:						;                /**************************************************
  2030                              <1> no_authority:						; 			keep these on the sending side
  2031 00000D27 BE01000000          <1> 	mov	esi, LP_AUTHORITY			; 			until constructing interrupt frame
  2032 00000D2C E92C010000          <1> 	jmp	guard_ii_escape				; 			between instructions at target core
  2033                              <1> 							;                         to avoid overwrites from other cores
  2034                              <1> 							;                **************************************************/
  2035                              <1> 							; 
  2036                              <1> 							;                base[ea] = value;	/* latent parameter	*/
  2037                              <1> 							;                return;
  2038                              <1> 							;             }
  2039                              <1> 							; 
  2040                              <1> memory_rule?:	; system memory type only		;             else if (rule & MEMTYPE)
  2041 00000D31 F6C101              <1> 	test	cl, MEMTYPE				;             {
  2042 00000D34 745C                <1> 	jz	page_pointer?				;                if (value & 0x00400000) device_index = value & 63;
  2043 00000D36 F7C300004000        <1> 	test	ebx, 0400000h	; bank sized?		; 
  2044 00000D3C 7461                <1> 	jz	memory_page_pointer			;                if (device_index)
  2045 00000D3E 89DE                <1> 	mov	esi, ebx				;                {
  2046 00000D40 81E63F000000        <1> 	and	esi, 63					;                   if (value & 0x00800000)
  2047 00000D46 7419                <1> 	jz	device_is_pointed			;                   {
  2048 00000D48 F7C300008000        <1> 	test	ebx, 0800000h	; the trap device?	;                      if (psr & 0x00800000)
  2049 00000D4E 7411                <1> 	jz	device_is_pointed			;                      {
  2050 00000D50 F605[02000000]80    <1> 	test	byte ptr [_psr+2], 128	; ISR?		;                         base[ea] = value;
  2051 00000D57 74CE                <1> 	jz	no_authority				;                         return;
  2052 00000D59 891C85[00000000]    <1> 	mov	[eax*4+_base], ebx			;                      }
  2053 00000D60 C3                  <1> 	ret						; 
  2054                              <1> 							;                      GUARD_AUTHORITY
  2055                              <1> device_is_pointed:					;                      return;
  2056 00000D61 8B0CB5[00020000]    <1> 	mov	ecx, dword ptr [esi*4+128*4+_base]	;                   }
  2057 00000D68 F7C100008000        <1> 	test	ecx, 00800000h				;                }
  2058 00000D6E 74B7                <1> 	jz	no_authority				; 
  2059 00000D70 F7C100004000        <1> 	test	ecx, 00400000h				;                device = base[128+device_index];
  2060 00000D76 75AF                <1> 	jnz	no_authority				;            
  2061 00000D78 81E1FFFF3F00        <1> 	and	ecx, 003FFFFFh				;                if ((device & 0x00C00000) == 0x00800000)
  2062 00000D7E 89DE                <1> 	mov	esi, ebx				;                {
  2063 00000D80 81E6FFFFBF00        <1> 	and	esi, 00BFFFFFh	; catch any 00800000	;                   if ((value & 0x003FFFC0) > (device & 0x003FFFFF))
  2064 00000D86 39F1                <1> 	cmp	ecx, esi				;                   {
  2065 00000D88 7233                <1> 	jb	outwith		; beyond memory		;                   }
  2066 00000D8A 891C85[00000000]    <1> 	mov	[eax*4+_base], ebx			;                   else
  2067 00000D91 C3                  <1> 	ret						;                   {
  2068                              <1> 							;                      base[ea] = value;
  2069                              <1> 							;                      return;
  2070                              <1> 							;                   }
  2071                              <1> 							;                }
  2072                              <1> 							;             }
  2073                              <1> 							;             else
  2074                              <1> 							;             {
  2075                              <1> 							;                /*******************************************
  2076                              <1> ;	only a device zero page index will do		; 			page pointer to system memory
  2077                              <1> 							;                *******************************************/
  2078                              <1> page_pointer?:						; 
  2079 00000D92 F6C102              <1> 	test	cl, MEMZERONLY				;                if ((value & 0x00400000) == 0)
  2080 00000D95 7490                <1> 	jz	no_rule					;                {
  2081 00000D97 F7C30000C000        <1> 	test	ebx, 00C00000h				;                   if (value > (base[128] & 0x003FFFFF))
  2082 00000D9D 7588                <1> 	jnz	no_authority				;                   {
  2083                              <1> 							;                   }
  2084                              <1> memory_page_pointer:					;                   else
  2085 00000D9F 8B0D[00020000]      <1> 	mov	ecx, dword ptr [_base+128*4]		;                   {
  2086 00000DA5 81E1FFFF3F00        <1> 	and	ecx, 003FFFFFh				;                      base[ea] = value;
  2087 00000DAB 81E3FFFFFF00        <1> 	and	ebx, 00FFFFFFh				;                      return;
  2088 00000DB1 39D9                <1> 	cmp	ecx, ebx				;                   }
  2089 00000DB3 7208                <1> 	jb	outwith					;                }
  2090 00000DB5 891C85[00000000]    <1> 	mov	[eax*4+_base], ebx			;             }
  2091 00000DBC C3                  <1> 	ret						;          }
  2092                              <1> 							;       }
  2093                              <1> 							;    }
  2094                              <1> outwith							; 
  2095 00000DBD BE0E000000          <1> 	mov	esi, LP_ADDRESS				;    GUARD_AUTHORITY;
  2096 00000DC2 E996000000          <1> 	jmp	guard_ii_escape				; }							; 
  2097                                  	%include	"ii.msm"
  2098 00000DC7 660905[00000000]    <1> _on:	or	word ptr [_psr], ax	; only touch low-order 16 bits
  2099 00000DCE C3                  <1> 	ret
  2100                              <1> 
  2101 00000DCF 6635FFFF            <1> _off:	xor	ax, 0000FFFFh
  2102 00000DD3 662105[00000000]    <1> 	and	word ptr [_psr], ax	; only touch low-order 16 bits
  2103 00000DDA C3                  <1> 	ret
  2104                              <1> 
  2105 00000DDB 20E4                <1> _xi:	and	ah, ah				; 8 external interrupts
  2106 00000DDD 741B                <1> 	jz	_xix
  2107                              <1> 
  2108 00000DDF 30C9                <1> 	xor	cl, cl
  2109                              <1> 
  2110                              <1> _xi_next:					; external interrupt pending signals[8]
  2111 00000DE1 8825[28010000]      <1> 	mov	byte ptr [_base+74*4], ah	; position for inA|B from port XI_PENDING$	LL.mm.hh.zz
  2112 00000DE7 C605[01000000]00    <1> 	mov	byte ptr [_indication+1], 0	; clear from platform indications fabric	ll.MM.hh.zz
  2113 00000DEE 31F6                <1> 	xor	esi, esi			; clear latent param
  2114 00000DF0 B802000000          <1> 	mov	eax, II_XINT			; select external interrupt
  2115                              <1> 
  2116 00000DF5 E985000000          <1> 	jmp	_ii_
  2117                              <1> 	
  2118 00000DFA A880                <1> _xix:	test	al, ATTENTION			; core2core interrupt
  2119                              <1> 
  2120 00000DFC 8035[00000000]80    <1> 	xor	byte ptr [_indication], ATTENTION
  2121                              <1> 
  2122 00000E03 F605[38010000]01    <1> 	test	byte ptr [_base+78*4], 1	; the 1 core
  2123 00000E0A 7417                <1> 	jz	_xiy				; has not selected itself
  2124                              <1> 
  2125 00000E0C B805000000          <1> 	mov	eax, II_ATTENTION
  2126 00000E11 8B35[3C010000]      <1> 	mov	esi, dword ptr [_base+79*4]	; latent parameter
  2127 00000E17 8025[38010000]FE    <1> 	and	byte ptr [_base+78*4], -2	; 
  2128                              <1> 
  2129 00000E1E E95C000000          <1> 	jmp	_ii_
  2130                              <1> 
  2131 00000E23 A840                <1> _xiy:	test	al, INCREMENTER_CARRY		; nanosecond or other counter 
  2132 00000E25 7413                <1> 	jz	_xiz				; from minus to carrry on zero
  2133                              <1> 						; to feed millisecond dayclock
  2134 00000E27 8035[00000000]40    <1> 	xor	byte ptr [_indication], INCREMENTER_CARRY
  2135 00000E2E B804000000          <1> 	mov	eax, II_MSECOND
  2136 00000E33 31F6                <1> 	xor	esi, esi
  2137 00000E35 E945000000          <1> 	jmp	_ii_
  2138                              <1> 
  2139 00000E3A C3                  <1> _xiz:	ret
  2140                              <1> 
  2141                              <1> _ii_instruction
  2142 00000E3B 89C3                <1> 	mov	ebx, eax
  2143 00000E3D C1EB06              <1> 	shr	ebx, 6
  2144 00000E40 2B1D[20010000]      <1> 	sub	ebx, dword ptr [_base+72*4]	; application threshold
  2145 00000E46 7910                <1> 	jns	guard_ii_authority	; must have executed a character string
  2146                              <1> 					; like 757575
  2147 00000E48 A9C0FFFFFF          <1> 	test	eax, -64
  2148 00000E4D 7519                <1> 	jnz	_ii			; not in restart page OK
  2149 00000E4F F605[02000000]80    <1> 	test	byte ptr [_psr+2], 128	; psr + 1 in BE-speak LE:L_M_H_Z
  2150 00000E56 7510                <1> 	jnz	_ii			; ISR may interrupt to restart page
  2151                              <1> 
  2152                              <1> 		; service call application to restart page not allowed
  2153                              <1> 		; most likely to be an accident
  2154                              <1> 		; drop thru and be quelled
  2155                              <1> 
  2156                              <1> guard_ii_authority
  2157 00000E58 BE01000000          <1> 	mov	esi, LP_AUTHORITY
  2158                              <1> guard_ii_escape
  2159 00000E5D B85F000000          <1> 	mov	eax, II_GUARD
  2160                              <1> _ii_escape:
  2161 00000E62 8B25[7C040000]      <1> 	mov	esp, dword ptr [__register+287*4]
  2162                              <1> 
  2163 00000E68 3D5F000000          <1> _ii:	cmp	eax, II_GUARD
  2164 00000E6D 7510                <1> 	jnz	_ii_
  2165 00000E6F F605[19000000]01    <1> 	test	byte ptr [_uflag+'Z'-'A'], 1	; break to debug console?
  2166 00000E76 7407                <1> 	jz	_ii_				; not if not opted
  2167 00000E78 800D[00000000]02    <1> 	or	byte ptr [_indication], LOCKSTEP
  2168                              <1> 	
  2169 00000E7F BD[00020000]        <1> _ii_:	mov	ebp, __register+128*4
  2170 00000E84 892D[00000000]      <1> 	mov	dword ptr [_register_set], ebp
  2171 00000E8A C705[00000000]8000- <1> 	mov	dword ptr [_iselect], 128
  2172 00000E92 0000                <1>
  2173                              <1> 
  2174                              <1> 	%if	1
  2175 00000E94 8B5D3C              <1> 	mov	ebx, dword ptr [ebp+S_P]
  2176 00000E97 81FB00010000        <1> 	cmp	ebx, 256
  2177 00000E9D 0F87FD010000        <1> 	ja	near guard_stack
  2178 00000EA3 81C3FCFFFFFF        <1> 	add	ebx, -4
  2179 00000EA9 895D3C              <1> 	mov	dword ptr [ebp+S_P], ebx
  2180 00000EAC 81FB98000000        <1> 	cmp	ebx, 128+24
  2181 00000EB2 0F82E8010000        <1> 	jb	near guard_stack
  2182                              <1> 
  2183                              <1> 	%else
  2184                              <1> 	add	dword ptr [ebp+S_P], -4
  2185                              <1> 	jns	_ii_ahead
  2186                              <1> 	mov	dword ptr [ebp+S_P], 256
  2187                              <1> 
  2188                              <1> _ii_ahead:
  2189                              <1> 	mov	ebx, dword ptr [ebp+S_P]
  2190                              <1> 	%endif
  2191                              <1> 
  2192 00000EB8 2B15[00000000]      <1> 	sub	edx, dword ptr [_b0p]
  2193 00000EBE C1EA02              <1> 	shr	edx, 2
  2194 00000EC1 89149D[0C000000]    <1> 	mov	dword ptr [ebx*4+__register+12], edx	; save PC offset
  2195 00000EC8 8B15[00000000]      <1> 	mov	edx, dword ptr [_b0_name]
  2196 00000ECE 89149D[08000000]    <1> 	mov	dword ptr [ebx*4+__register+8], edx	; save bank ID
  2197 00000ED5 8B15[00000000]      <1> 	mov	edx, dword ptr [_psr]
  2198 00000EDB 89149D[04000000]    <1> 	mov	dword ptr [ebx*4+__register+4], edx	; saved PSR
  2199 00000EE2 89349D[00000000]    <1> 	mov	dword ptr [ebx*4+__register], esi	; latent parameter
  2200 00000EE9 F7C200008000        <1> 	test	edx, 00800000h				; nested interrupt ?
  2201 00000EEF 7503                <1> 	jnz	_ii_ii
  2202 00000EF1 895D38              <1> 	mov	dword ptr [ebp+FP], ebx			; if not, mark interrupted
  2203                              <1> 							; application stack frame
  2204                              <1> _ii_ii:
  2205 00000EF4 81CA00008000        <1> 	or	edx, 00800000h				; ISR active
  2206 00000EFA 8915[00000000]      <1> 	mov	dword ptr [_psr], edx
  2207                              <1> 
  2208 00000F00 89C2                <1> 	mov	edx, eax				; get to the operand
  2209 00000F02 81E23F000000        <1> 	and	edx, 63					; address from interrupt vector
  2210 00000F08 C1E806              <1> 	shr	eax, 6
  2211 00000F0B 25FF030000          <1> 	and	eax, 000003FFh				; eax -> page containing ISR ; edx  -> vector
  2212 00000F10 31DB                <1> 	xor	ebx, ebx				; single page ISR
  2213 00000F12 E9E2060000          <1> 	jmp	_go2_frame
  2214                              <1> 
  2215                              <1> ;	_ir	sign extended ea is in eax
  2216                              <1> 
  2217 00000F17 F605[02000000]80    <1> _ir:	test	byte ptr [_psr+2], 128		; eax = EA = variation on return offset
  2218 00000F1E 0F8434FFFFFF        <1> 	jz	guard_ii_authority		; not good to do Interrupt Return from application space
  2219 00000F24 89D7                <1> 	mov	edi, edx			; save in case the operation interrupts itself
  2220 00000F26 89C2                <1> 	mov	edx, eax			; +- displacement operand, offset in stack added later
  2221                              <1> 
  2222 00000F28 E8AA010000          <1> 	call	stack_read4			; [ebp+ebx*4] -> interrupt stack frame
  2223                              <1> 						; interrupt stack pointer is already updated ebx+4
  2224                              <1> 
  2225 00000F2D 8B449D08            <1> 	mov	eax, dword ptr [ebp+ebx*4+2*4]		; interrupted b0_name
  2226                              <1> 
  2227 00000F31 8B4C9D04            <1> 	mov	ecx, dword ptr [ebp+ebx*4+1*4]		; interrupted psr
  2228                              <1> 
  2229 00000F35 03549D0C            <1> 	add	edx, dword ptr [ebp+ebx*4+3*4]		; add interrupted iframe offset to EA
  2230                              <1> 
  2231 00000F39 31DB                <1> 	xor	ebx, ebx				; 
  2232 00000F3B A900008000          <1> 	test	eax, 00800000h
  2233 00000F40 7410                <1> 	jz	ir_4k_iframe				; 1-page iframe return target
  2234                              <1> 
  2235 00000F42 89C3                <1> 	mov	ebx, eax				; larger
  2236 00000F44 C1E30C              <1> 	shl	ebx, 12					; read page high index
  2237 00000F47 0FB61C9D[01010000]  <1> 	movzx	ebx, byte ptr [_memory+ebx*4+64*4+1]	; from high order 6 bits
  2238 00000F4F C1EB02              <1> 	shr	ebx, 2					; of sample gate at iframe+64 
  2239                              <1> 
  2240                              <1> ir_4k_iframe:
  2241 00000F52 890D[00000000]      <1> 	mov	dword ptr [_psr], ecx
  2242 00000F58 F7C100008000        <1> 	test	ecx, 00800000h				; returning ISR -> ISR ?
  2243 00000F5E 741A                <1> 	jz	ir_application				; no
  2244 00000F60 BD[00020000]        <1> 	 mov	ebp, __register+128*4			; for nested interrupts
  2245 00000F65 892D[00000000]      <1> 	 mov	dword ptr [_register_set], ebp		; positively maintain
  2246 00000F6B C705[00000000]8000- <1> 	 mov	dword ptr [_iselect], 128		; interrupt register set
  2247 00000F73 0000                <1>
  2248 00000F75 E97F060000          <1> 	jmp	_go2_frame				; yes
  2249                              <1> 
  2250                              <1> ir_application:
  2251 00000F7A BD[00000000]        <1> 	mov	ebp, __register
  2252 00000F7F 892D[00000000]      <1> 	mov	dword ptr [_register_set], ebp
  2253 00000F85 C705[00000000]0000- <1> 	mov	dword ptr [_iselect], 0
  2254 00000F8D 0000                <1>
  2255 00000F8F E965060000          <1> 	jmp	_go2_frame
  2256                              <1> 
  2257                                  	%include	"stack.msm"
  2258                              <1> ;	stack operations call these to add or subract stack
  2259                              <1> ;	limits are checked here
  2260                              <1> ;	these routines always leave epb -> all registers 0..255
  2261                              <1> ;	because both  interrupt internal stack pointer register 128 + 15
  2262                              <1> ;		and application internal stack pointer register 15
  2263                              <1> 
  2264                              <1> ;	are absolute pointers to the entire register stack
  2265                              <1> 
  2266                              <1> ;	therefore instructions calling here must afterwards
  2267                              <1> 
  2268                              <1> ;		mov	ebp, dword ptr [_register_set]
  2269                              <1> 
  2270                              <1> ;	to get ebp back to application registers 0..127
  2271                              <1> ;			or interrupt registers 128..255
  2272                              <1> 
  2273                              <1> ;	ebp governs which r k x y a b mantissa2 mantissa3 fp sp is implied in the instruction opcode
  2274                              <1> ;	registers addressed as operand are always absolute in the range 0..255
  2275                              <1> 
  2276                              <1> ;	these don't move any data but leave [ebp+ebx*4] pointing to the required stack frame
  2277                              <1> ;	and update the stack pointer
  2278                              <1> 
  2279                              <1> ;	although applications can and must read interrupt registers with load instructions
  2280                              <1> ;	they can't read interrupt registers with runaway pop instructions
  2281                              <1> ;	because the problem is easier to find with an interrupt as soon as 128+ gets popped
  2282                              <1> 
  2283                              <1> 
  2284 00000F94 8B5D3C              <1> stack1:	mov	ebx, dword ptr [ebp+S_P]
  2285 00000F97 F605[02000000]80    <1> 	test	byte ptr [_psr+2], 128
  2286 00000F9E 7430                <1> 	jz	stack1_a
  2287 00000FA0 81FB00010000        <1> 	cmp	ebx, 256
  2288 00000FA6 0F87F4000000        <1> 	ja	near guard_stack
  2289 00000FAC 4B                  <1> 	dec	ebx
  2290 00000FAD 0F88ED000000        <1> 	js	near guard_stack
  2291 00000FB3 81FB98000000        <1> 	cmp	ebx, 128+24
  2292 00000FB9 730C                <1> 	jnb	stack1_j			; in range
  2293 00000FBB 81FB7F000000        <1> 	cmp	ebx, 128-1			; new sp value
  2294 00000FC1 0F87D9000000        <1> 	ja	near guard_stack		; in working registers page
  2295                              <1> stack1_j:
  2296 00000FC7 895D3C              <1> 	mov	dword ptr [ebp+S_P], ebx
  2297 00000FCA BD[00000000]        <1> 	mov	ebp, __register
  2298 00000FCF C3                  <1> 	ret
  2299                              <1> 
  2300                              <1> stack1_a:
  2301 00000FD0 81FB80000000        <1> 	cmp	ebx, 128			; application push high limit 128,  ISR 256
  2302 00000FD6 0F87C4000000        <1> 	ja	near guard_stack
  2303 00000FDC 4B                  <1> 	dec	ebx
  2304 00000FDD 81FB18000000        <1> 	cmp	ebx, 24
  2305 00000FE3 0F82B7000000        <1> 	jb	near guard_stack		; stack top limit zero ISR and application
  2306 00000FE9 895D3C              <1> 	mov	dword ptr [ebp+S_P], ebx
  2307 00000FEC BD[00000000]        <1> 	mov	ebp, __register
  2308 00000FF1 C3                  <1> 	ret
  2309                              <1> 
  2310 00000FF2 8B5D3C              <1> stack2:	mov	ebx, dword ptr [ebp+S_P]
  2311 00000FF5 F605[02000000]80    <1> 	test	byte ptr [_psr+2], 128
  2312 00000FFC 7435                <1> 	jz	stack2_a
  2313 00000FFE 81FB00010000        <1> 	cmp	ebx, 256
  2314 00001004 0F8796000000        <1> 	ja	near guard_stack
  2315 0000100A 81C3FEFFFFFF        <1> 	add	ebx, -2
  2316 00001010 0F888A000000        <1> 	js	near guard_stack
  2317 00001016 81FB98000000        <1> 	cmp	ebx, 128+24
  2318 0000101C 730C                <1> 	jnb	stack2_j
  2319 0000101E 81FB7E000000        <1> 	cmp	ebx, 128-2
  2320 00001024 0F8776000000        <1> 	ja	near guard_stack
  2321                              <1> 
  2322                              <1> stack2_j:
  2323 0000102A 895D3C              <1> 	mov	dword ptr [ebp+S_P], ebx
  2324 0000102D BD[00000000]        <1> 	mov	ebp, __register
  2325 00001032 C3                  <1> 	ret
  2326                              <1> 
  2327                              <1> stack2_a:
  2328 00001033 81FB80000000        <1> 	cmp	ebx, 128			; application push high limit 128,  ISR 256
  2329 00001039 7765                <1> 	ja	guard_stack
  2330 0000103B 81C3FEFFFFFF        <1> 	add	ebx, -2
  2331 00001041 81FB18000000        <1> 	cmp	ebx, 24
  2332 00001047 7257                <1> 	jb	guard_stack			; stack top limit zero ISR and application
  2333 00001049 895D3C              <1> 	mov	dword ptr [ebp+S_P], ebx
  2334 0000104C BD[00000000]        <1> 	mov	ebp, __register
  2335 00001051 C3                  <1> 	ret
  2336                              <1> 
  2337 00001052 8B5D3C              <1> stack4:	mov	ebx, dword ptr [ebp+S_P]
  2338 00001055 F605[02000000]80    <1> 	test	byte ptr [_psr+2], 128		; read psr interrupt bit
  2339 0000105C 7426                <1> 	jz	stack4_a			; stack is registers 24..127
  2340 0000105E 81FB00010000        <1> 	cmp	ebx, 256			; stack is registers  0..255
  2341 00001064 773A                <1> 	ja	guard_stack
  2342 00001066 81C3FCFFFFFF        <1> 	add	ebx, -4				; proposed frame
  2343 0000106C 7832                <1> 	js	guard_stack			; not lower than register zero
  2344 0000106E 81FB98000000        <1> 	cmp	ebx, 128+24
  2345 00001074 7308                <1> 	jnb	stack4_j
  2346 00001076 81FB7C000000        <1> 	cmp	ebx, 128-4			; in working registers page
  2347 0000107C 7722                <1> 	ja	guard_stack
  2348                              <1> 
  2349                              <1> stack4_j:
  2350 0000107E BD[00000000]        <1> 	mov	ebp, __register			; registers means all of them
  2351 00001083 C3                  <1> 	ret					; both sp are absolute pointers
  2352                              <1> 
  2353                              <1> stack4_a:
  2354 00001084 81FB80000000        <1> 	cmp	ebx, 128			; don't push into a higher register than 127
  2355 0000108A 7714                <1> 	ja	guard_stack
  2356 0000108C 81C3FCFFFFFF        <1> 	add	ebx, -4
  2357 00001092 81FB18000000        <1> 	cmp	ebx, 24				; dont push lower than 24
  2358 00001098 7206                <1> 	jb	guard_stack
  2359                              <1> 
  2360 0000109A BD[00000000]        <1> 	mov	ebp, __register			; registers means all of them
  2361 0000109F C3                  <1> 	ret					; both sp are absolute pointers
  2362                              <1> 
  2363                              <1> guard_stack:
  2364                              <1> stack_underflow:
  2365 000010A0 8B2D[00000000]      <1> 	mov	ebp, dword ptr [_register_set]	; application or interrupt register set
  2366 000010A6 F705[00000000]0000- <1> 	test	dword ptr [_psr], 00800000h
  2367 000010AE 8000                <1>
  2368 000010B0 0F84A2FDFFFF        <1> 	jz	guard_ii_authority		; sideline the application
  2369 000010B6 C7453C00010000      <1> 	mov	dword ptr [ebp+S_P], 256	; restart the interrupt stack
  2370 000010BD B801000000          <1> 	mov	eax, 1				; so the interrupt can be interrupted
  2371 000010C2 F605[19000000]01    <1> 	test	byte ptr [_uflag+'Z'-'A'], 1
  2372 000010C9 7407                <1> 	jz	gsago
  2373 000010CB 800D[00000000]02    <1> 	or	byte ptr [_indication], LOCKSTEP
  2374 000010D2 E98BFDFFFF          <1> gsago:	jmp	_ii_escape
  2375                              <1> 
  2376                              <1> stack_read4:
  2377 000010D7 BB04000000          <1> 	mov	ebx, 4
  2378 000010DC 035D3C              <1> 	add	ebx, dword ptr [ebp+S_P]
  2379 000010DF 81FB80000000        <1> 	cmp	ebx, 128			; you can have stack locations up to here
  2380 000010E5 7611                <1> 	jna	stack_r4			; whoever you are
  2381 000010E7 F605[02000000]80    <1> 	test	byte ptr [_psr+2], 128		; any higher you have to be an ISR
  2382 000010EE 74B0                <1> 	jz	stack_underflow
  2383 000010F0 81FB00010000        <1> 	cmp	ebx, 256			; and then not any higher than this
  2384 000010F6 77A8                <1> 	ja	stack_underflow
  2385                              <1> 
  2386                              <1> stack_r4:
  2387 000010F8 875D3C              <1> 	xchg	ebx, dword ptr [ebp+S_P]
  2388 000010FB BD[00000000]        <1> 	mov	ebp, __register
  2389 00001100 C3                  <1> 	ret
  2390                              <1> 
  2391                              <1> stack_read2:
  2392 00001101 BB02000000          <1> 	mov	ebx, 2
  2393 00001106 035D3C              <1> 	add	ebx, dword ptr [ebp+S_P]
  2394 00001109 81FB80000000        <1> 	cmp	ebx, 128			; you can have stack locations up to here
  2395 0000110F 7615                <1> 	jna	stack_r2			; whoever you are
  2396 00001111 F605[02000000]80    <1> 	test	byte ptr [_psr+2], 128		; any higher you have to be an ISR
  2397 00001118 7486                <1> 	jz	stack_underflow
  2398 0000111A 81FB00010000        <1> 	cmp	ebx, 256			; and then not any higher than this
  2399 00001120 0F877AFFFFFF        <1> 	ja	stack_underflow
  2400                              <1> 
  2401                              <1> stack_r2:
  2402 00001126 875D3C              <1> 	xchg	ebx, dword ptr [ebp+S_P]
  2403 00001129 BD[00000000]        <1> 	mov	ebp, __register
  2404 0000112E C3                  <1> 	ret
  2405                              <1> 
  2406                              <1> stack_read1:
  2407 0000112F BB01000000          <1> 	mov	ebx, 1
  2408 00001134 035D3C              <1> 	add	ebx, dword ptr [ebp+S_P]
  2409 00001137 81FB80000000        <1> 	cmp	ebx, 128			; you can have stack locations up to here
  2410 0000113D 7619                <1> 	jna	stack_r1			; whoever you are
  2411 0000113F F605[02000000]80    <1> 	test	byte ptr [_psr+2], 128		; any higher you have to be an ISR
  2412 00001146 0F8454FFFFFF        <1> 	jz	stack_underflow
  2413 0000114C 81FB00010000        <1> 	cmp	ebx, 256			; and then not any higher than this
  2414 00001152 0F8748FFFFFF        <1> 	ja	stack_underflow
  2415                              <1> 
  2416                              <1> stack_r1:
  2417 00001158 875D3C              <1> 	xchg	ebx, dword ptr [ebp+S_P]	; already updated
  2418 0000115B BD[00000000]        <1> 	mov	ebp, __register
  2419 00001160 C3                  <1> 	ret
  2420                              <1> 
  2421                                  	%include	"return.msm"
  2422                              <1> _autoexit:
  2423 00001161 B846000000          <1> 	mov	eax, II_EXIT
  2424 00001166 BE0B000000          <1> 	mov	esi, LP_AUTOEXIT
  2425 0000116B E9F2FCFFFF          <1> 	jmp	_ii_escape
  2426                              <1> 
  2427 00001170 F705[00000000]0000- <1> _lret:	test	dword ptr [_psr], 00800000h
  2428 00001178 8000                <1>
  2429 0000117A 7509                <1> 	jnz	_lret_
  2430                              <1> 
  2431 0000117C 817D3C80000000      <1> 	cmp	dword ptr [ebp+S_P], 128
  2432 00001183 74DC                <1> 	jz	_autoexit
  2433                              <1> 
  2434 00001185 E8A5FFFFFF          <1> _lret_:	call	stack_read1
  2435 0000118A 03449D00            <1> 	add	eax, dword ptr [ebp+ebx*4]
  2436 0000118E 8B2D[00000000]      <1> 	mov	ebp, dword ptr [_register_set]
  2437 00001194 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
  2438 00001199 E94B020000          <1> 	jmp	_j
  2439                              <1> 
  2440 0000119E F705[00000000]0000- <1> _fret:	test	dword ptr [_psr], 00800000h
  2441 000011A6 8000                <1>
  2442 000011A8 7509                <1> 	jnz	_fret_
  2443                              <1> 
  2444 000011AA 817D3C80000000      <1> 	cmp	dword ptr [ebp+S_P], 128
  2445 000011B1 74AE                <1> 	jz	_autoexit
  2446                              <1> 
  2447 000011B3 E849FFFFFF          <1> _fret_:	call	stack_read2
  2448 000011B8 8915[00000000]      <1> 	mov	dword ptr [_apc], edx
  2449 000011BE 89C2                <1> 	mov	edx, eax
  2450 000011C0 03549D04            <1> 	add	edx, dword ptr [ebp+ebx*4+1*4]	; add EA as displacement to offset on stack
  2451 000011C4 8B449D00            <1> 	mov	eax, dword ptr [ebp+ebx*4]
  2452 000011C8 8B2D[00000000]      <1> 	mov	ebp, dword ptr [_register_set]
  2453 000011CE 31DB                <1> 	xor	ebx, ebx			; 1-page frame?
  2454 000011D0 A900008000          <1> 	test	eax, 00800000h			; multipages frame?
  2455 000011D5 7410                <1> 	jz	_fret_1page
  2456 000011D7 89C3                <1> 	mov	ebx, eax
  2457 000011D9 C1E30C              <1> 	shl	ebx, 12
  2458 000011DC 0FB61C9D[01010000]  <1> 	movzx	ebx, byte ptr [_memory+ebx*4+64*4+1]
  2459 000011E4 C1EB02              <1> 	shr	ebx, 2
  2460                              <1> 
  2461                              <1> _fret_1page:
  2462 000011E7 E90D040000          <1> 	jmp	_go2_frame
  2463                              <1> 
  2464 000011EC B803000000          <1> _fpxpo:	mov	eax, II_FPXPO
  2465 000011F1 BE0C000000          <1> 	mov	esi, LP_RANGE
  2466 000011F6 E967FCFFFF          <1> 	jmp	_ii_escape
  2467                              <1> 
  2468                                  	%include	"rta.msm"
  2469                              <1> 
  2470 000011FB 80F904              <1> _sr:	cmp	cl, I
  2471 000011FE 0F84F4F8FFFF        <1> 	jz	_inA
  2472 00001204 80F905              <1> 	cmp	cl, XI
  2473 00001207 0F84BAFBFFFF        <1> 	jz	_on
  2474                              <1> 
  2475 0000120D 8B5D00              <1> 	mov	ebx, dword ptr [ebp+R]
  2476 00001210 E9F3F2FFFF          <1> 	jmp	_operand_write
  2477                              <1> 
  2478 00001215 80F904              <1> _sk:	cmp	cl, I
  2479 00001218 0F84E5F8FFFF        <1> 	jz	_inB
  2480 0000121E 80F905              <1> 	cmp	cl, XI
  2481 00001221 0F84A8FBFFFF        <1> 	jz	_off
  2482                              <1> 
  2483 00001227 8B5D04              <1> 	mov	ebx, dword ptr [ebp+K]
  2484 0000122A E9D9F2FFFF          <1> 	jmp	_operand_write
  2485                              <1> 
  2486 0000122F 80F904              <1> _sx:	cmp	cl, I
  2487 00001232 0F84D6F8FFFF        <1> 	jz	_outA
  2488 00001238 80F905              <1> 	cmp	cl, XI
  2489 0000123B 0F848FF7FFFF        <1> 	jz	_rsr
  2490                              <1> 
  2491 00001241 8B5D08              <1> 	mov	ebx, dword ptr [ebp+X]
  2492 00001244 E9BFF2FFFF          <1> 	jmp	_operand_write
  2493                              <1> 
  2494 00001249 80F904              <1> _sy:	cmp	cl, I
  2495 0000124C 0F84C4F8FFFF        <1> 	jz	_outB
  2496 00001252 80F905              <1> 	cmp	cl, XI
  2497 00001255 0F84F8F7FFFF        <1> 	jz	_wsr
  2498                              <1> 
  2499 0000125B 8B5D0C              <1> 	mov	ebx, dword ptr [ebp+Y]
  2500 0000125E E9A5F2FFFF          <1> 	jmp	_operand_write;
  2501                              <1> 
  2502 00001263 80F904              <1> _sa:	cmp	cl, I
  2503 00001266 0F846AF9FFFF        <1> 	jz	_reload
  2504 0000126C 80F905              <1> 	cmp	cl, XI
  2505 0000126F 0F84D3EEFFFF        <1> 	jz	escape
  2506                              <1> 
  2507 00001275 8B5D10              <1> 	mov	ebx, dword ptr [ebp+A]
  2508 00001278 E98BF2FFFF          <1> 	jmp	_operand_write
  2509                              <1> 
  2510 0000127D 80F904              <1> _sb:	cmp	cl, I
  2511 00001280 0F8470F9FFFF        <1> 	jz	_emulator_cool
  2512 00001286 80F905              <1> 	cmp	cl, XI
  2513 00001289 0F84B9EEFFFF        <1> 	jz	escape
  2514                              <1> 
  2515 0000128F 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]
  2516 00001292 E971F2FFFF          <1> 	jmp	_operand_write
  2517                              <1> 
  2518 00001297 80F904              <1> _z:	cmp	cl, I
  2519 0000129A 0F8457F9FFFF        <1> 	jz	_sabr
  2520 000012A0 80F905              <1> 	cmp	cl, XI
  2521 000012A3 0F84C7FEFFFF        <1> 	jz	_lret
  2522 000012A9 31DB                <1> 	xor	ebx, ebx
  2523 000012AB E958F2FFFF          <1> 	jmp	_operand_write
  2524                              <1> 
  2525 000012B0 80F904              <1> _pop:	cmp	cl, I
  2526 000012B3 0F848FEEFFFF        <1> 	jz	escape
  2527 000012B9 80F905              <1> 	cmp	cl, XI
  2528 000012BC 0F84DCFEFFFF        <1> 	jz	_fret
  2529                              <1> 
  2530 000012C2 E868FEFFFF          <1> 	call	stack_read1
  2531 000012C7 8B5C9D00            <1> 	mov	ebx, dword ptr [ebp+ebx*4]
  2532 000012CB 8B2D[00000000]      <1> 	mov	ebp, dword ptr [_register_set]
  2533 000012D1 E932F2FFFF          <1> 	jmp	_operand_write
  2534                              <1> 
  2535 000012D6 E86EF0FFFF          <1> _lr:	call	_operand_read
  2536 000012DB 894500              <1> 	mov	dword ptr [ebp+R], eax
  2537 000012DE C3                  <1> 	ret
  2538                              <1> 
  2539 000012DF E865F0FFFF          <1> _lk:	call	_operand_read
  2540 000012E4 894504              <1> 	mov	dword ptr [ebp+K], eax
  2541 000012E7 C3                  <1> 	ret
  2542 000012E8 E85CF0FFFF          <1> _lx:	call	_operand_read
  2543 000012ED 894508              <1> 	mov	dword ptr [ebp+X], eax
  2544 000012F0 C3                  <1> 	ret
  2545                              <1> 
  2546 000012F1 E853F0FFFF          <1> _ly:	call	_operand_read
  2547 000012F6 89450C              <1> 	mov	dword ptr [ebp+Y], eax
  2548 000012F9 C3                  <1> 	ret
  2549                              <1> 
  2550 000012FA E84AF0FFFF          <1> _la:	call	_operand_read
  2551 000012FF 894510              <1> 	mov	dword ptr [ebp+A], eax
  2552 00001302 C3                  <1> 	ret
  2553                              <1> 
  2554 00001303 E841F0FFFF          <1> _lb:	call	_operand_read
  2555 00001308 894514              <1> 	mov	dword ptr [ebp+B], eax
  2556 0000130B C3                  <1> 	ret
  2557                              <1> 
  2558 0000130C 80F904              <1> _tz:	cmp	cl, I
  2559 0000130F 0F8419140000        <1> 	jz	near _rex
  2560 00001315 80F905              <1> 	cmp	cl, XI
  2561 00001318 BE00000000          <1> 	mov	esi, 0
  2562 0000131D 0F8418FBFFFF        <1> 	jz	_ii_instruction
  2563                              <1> 
  2564 00001323 E821F0FFFF          <1> 	call	_operand_read
  2565 00001328 A9FFFFFF00          <1> 	test	eax, 00FFFFFFh
  2566 0000132D 7506                <1> 	jnz	_tz_
  2567 0000132F 81C204000000        <1> 	add	edx, 4
  2568 00001335 C3                  <1> _tz_:	ret
  2569                              <1> 
  2570 00001336 80F904              <1> _tp:	cmp	cl, I
  2571 00001339 7431                <1> 	jz	_jdz
  2572 0000133B 80F905              <1> 	cmp	cl, XI
  2573 0000133E 0F84D3FBFFFF        <1> 	jz	_ir
  2574                              <1> 
  2575 00001344 E800F0FFFF          <1> 	call	_operand_read
  2576 00001349 A900008000          <1> 	test	eax, 00800000h
  2577 0000134E 7506                <1> 	jnz	_tp_
  2578 00001350 81C204000000        <1> 	add	edx, 4
  2579 00001356 C3                  <1> _tp_:	ret
  2580                              <1> 
  2581 00001357 E8EDEFFFFF          <1> _push:	call	_operand_read	; this 1st in case sp is pushed
  2582 0000135C E833FCFFFF          <1> 	call	stack1
  2583 00001361 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
  2584 00001365 8B2D[00000000]      <1> 	mov	ebp, dword ptr [_register_set]
  2585                              <1> 	
  2586                              <1> ;	add	dword ptr [ebp+S_P], -1
  2587                              <1> ;	mov	ebx, dword ptr [ebp+S_P]
  2588                              <1> ;	mov	dword ptr [ebx*4+__register], eax
  2589                              <1> 
  2590 0000136B C3                  <1> 	ret
  2591                              <1> 
  2592 0000136C 8B5D14              <1> _jdz:	mov	ebx, dword ptr [ebp+B]
  2593 0000136F 0B5D10              <1> 	or	ebx, dword ptr [ebp+A]
  2594 00001372 0F8471000000        <1> 	jz	near _j
  2595 00001378 C3                  <1> 	ret
  2596                              <1> 
  2597 00001379 8B5D00              <1> _jdr:	mov	ebx, dword ptr [ebp+R]	; dec r and jump if it passed from zero to -1
  2598 0000137C 81C3FFFFFF00        <1> 	add	ebx, 00FFFFFFh
  2599 00001382 C1C308              <1> 	rol	ebx, 8
  2600 00001385 88D9                <1> 	mov	cl, bl
  2601 00001387 C1EB08              <1> 	shr	ebx, 8			; write back to registers only 00000000 thru 00FFFFFF
  2602 0000138A 895D00              <1> 	mov	dword ptr [ebp+R], ebx
  2603 0000138D F6C101              <1> 	test	cl, 1
  2604 00001390 7557                <1> 	jnz	_j
  2605 00001392 C3                  <1> 	ret
  2606                              <1> 
  2607 00001393 E8FCFBFFFF          <1> _lcal:	call	stack1
  2608 00001398 2B15[00000000]      <1> 	sub	edx, dword ptr [_b0p]
  2609 0000139E C1EA02              <1> 	shr	edx, 2
  2610 000013A1 89549D00            <1> 	mov	dword ptr [ebp+ebx*4], edx
  2611 000013A5 8B2D[00000000]      <1> 	mov	ebp, dword ptr [_register_set]
  2612 000013AB E939000000          <1> 	jmp	_j			; EA is in eax
  2613 000013B0 C3                  <1> 	ret
  2614                              <1> 
  2615 000013B1 F705[00000000]0100- <1> _jnc:	test	dword ptr [_psr], 1
  2616 000013B9 0000                <1>
  2617 000013BB 742C                <1> 	jz	_j
  2618 000013BD C3                  <1> 	ret
  2619                              <1> 
  2620 000013BE F705[00000000]0100- <1> _jc:	test	dword ptr [_psr], 1
  2621 000013C6 0000                <1>
  2622 000013C8 751F                <1> 	jnz	_j
  2623 000013CA C3                  <1> 	ret
  2624                              <1> 
  2625 000013CB F7451001000000      <1> _jao:	test	dword ptr [ebp+A], 1
  2626 000013D2 7515                <1> 	jnz	_j
  2627 000013D4 C3                  <1> 	ret
  2628                              <1> 
  2629 000013D5 F7451000008000      <1> _jpa:	test	dword ptr [ebp+A], 00800000h
  2630 000013DC 740B                <1> 	jz	_j
  2631 000013DE C3                  <1> 	ret
  2632                              <1> 
  2633 000013DF F7451400008000      <1> _jpb:	test	dword ptr [ebp+B], 00800000h
  2634 000013E6 7401                <1> 	jz	_j
  2635 000013E8 C3                  <1> 	ret
  2636                              <1> 
  2637 000013E9 89D7                <1> _j:	mov	edi, edx			; save updated apc
  2638 000013EB 8B15[00000000]      <1> 	mov	edx, dword ptr [_b0p]
  2639 000013F1 C1E002              <1> 	shl	eax, 2
  2640 000013F4 01C2                <1> 	add	edx, eax
  2641 000013F6 3B15[00000000]      <1> 	cmp	edx, dword ptr [_apcz]
  2642 000013FC 7701                <1> 	ja	_j_check
  2643 000013FE C3                  <1> 	ret
  2644                              <1> 
  2645                              <1> _j_check:
  2646 000013FF 89FA                <1> 	mov	edx, edi			; restore updated apc
  2647 00001401 BE0E000000          <1> 	mov	esi, LP_ADDRESS
  2648 00001406 E952FAFFFF          <1> 	jmp	guard_ii_escape			; for interrupt come-from
  2649                              <1> 
  2650 0000140B E8C4100000          <1> _jpo:	call	NEAR _get_parity
  2651 00001410 7BD7                <1> 	jpo	_j
  2652 00001412 C3                  <1> 	ret
  2653                              <1> 
  2654 00001413 816510FFFFFF00      <1> _jza:	and	dword ptr [ebp+A], 00FFFFFFh
  2655 0000141A 74CD                <1> 	jz	_j
  2656 0000141C C3                  <1> 	ret
  2657                              <1> 
  2658 0000141D 816514FFFFFF00      <1> _jzb:	and	dword ptr [ebp+B], 00FFFFFFh
  2659 00001424 74C3                <1> 	jz	_j
  2660 00001426 C3                  <1> 	ret
  2661                              <1> 
  2662 00001427 816510FFFFFF00      <1> _jnza:	and	dword ptr [ebp+A], 00FFFFFFh
  2663 0000142E 75B9                <1> 	jnz	_j
  2664 00001430 C3                  <1> 	ret
  2665                              <1> 
  2666 00001431 816514FFFFFF00      <1> _jnzb:	and	dword ptr [ebp+B], 00FFFFFFh
  2667 00001438 75AF                <1> 	jnz	_j
  2668 0000143A C3                  <1> 	ret
  2669                              <1> 
  2670 0000143B F7451000008000      <1> _jna:	test	dword ptr [ebp+A], 00800000h
  2671 00001442 75A5                <1> 	jnz	_j
  2672 00001444 C3                  <1> 	ret
  2673                              <1> 
  2674 00001445 F7451400008000      <1> _jnb:	test	dword ptr [ebp+B], 00800000h
  2675 0000144C 759B                <1> 	jnz	_j
  2676 0000144E C3                  <1> 	ret
  2677                              <1> 
  2678 0000144F 8B5D08              <1> _jxge:	mov	ebx, dword ptr [ebp+X]
  2679 00001452 2B5D00              <1> 	sub	ebx, dword ptr [ebp+R]
  2680 00001455 F7C300000001        <1> 	test	ebx, 01000000h		; microcarry?
  2681 0000145B 748C                <1> 	jz	_j			; no:  x <  r,    jump
  2682 0000145D C3                  <1> 	ret				; yes: x >= r, no jump
  2683                              <1> 
  2684 0000145E 8B5D0C              <1> _jyge:	mov	ebx, dword ptr [ebp+Y]
  2685 00001461 2B5D00              <1> 	sub	ebx, dword ptr [ebp+R]
  2686 00001464 F7C300000001        <1> 	test	ebx, 01000000h		; microcarry?
  2687 0000146A 0F8479FFFFFF        <1> 	jz	_j			; no:  y <  r,    jump
  2688 00001470 C3                  <1> 	ret				; yes: y >= r, no jump
  2689                              <1> 
  2690 00001471 BB04000000          <1> _qs:	mov	ebx, a
  2691 00001476 E9FBEFFFFF          <1> 	jmp	_burst_write4
  2692                              <1> 
  2693 0000147B BB04000000          <1> _ql:	mov	ebx, a
  2694 00001480 E985EEFFFF          <1> 	jmp	_burst_read4
  2695                              <1> 
  2696 00001485 50                  <1> _qpop:	push	eax				; EA
  2697 00001486 E84CFCFFFF          <1> 	call	stack_read4			; places 4 stack registers in the scope of burst write
  2698 0000148B 58                  <1> 	pop	eax				; EA
  2699 0000148C E8E5EFFFFF          <1> 	call	_burst_write4
  2700 00001491 8B2D[00000000]      <1> 	mov	ebp, dword ptr [_register_set]	; stack ops have ebp->total register set
  2701                              <1> 
  2702 00001497 C3                  <1> 	ret					; stack pointers are absolute
  2703                              <1> 
  2704 00001498 E8B5FBFFFF          <1> _qpush: call	stack4
  2705 0000149D E868EEFFFF          <1> 	call	_burst_read4
  2706 000014A2 8B2D[00000000]      <1> 	mov	ebp, dword ptr [_register_set]
  2707 000014A8 895D3C              <1> 	mov	dword ptr [ebp+S_P], ebx	; updated sp written after burst read
  2708 000014AB C3                  <1> 	ret
  2709                              <1> 
  2710 000014AC 50                  <1> _dpop:	push	eax
  2711 000014AD E84FFCFFFF          <1> 	call	stack_read2
  2712 000014B2 58                  <1> 	pop	eax
  2713 000014B3 E814F0FFFF          <1> 	call	_burst_write2
  2714 000014B8 8B2D[00000000]      <1> 	mov	ebp, dword ptr [_register_set]	; stack op had register set of all registers
  2715 000014BE C3                  <1> 	ret
  2716                              <1> 
  2717 000014BF E827EEFFFF          <1> _dpush:	call	_burst_read2
  2718 000014C4 53                  <1> 	push	ebx
  2719 000014C5 E828FBFFFF          <1> 	call	stack2
  2720 000014CA 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
  2721 000014CE 58                  <1> 	pop	eax
  2722 000014CF 89449D04            <1> 	mov	dword ptr [ebp+ebx*4+1*4], eax
  2723 000014D3 8B2D[00000000]      <1> 	mov	ebp, dword ptr [_register_set]
  2724 000014D9 C3                  <1> 	ret
  2725                              <1> 
  2726 000014DA E86AEEFFFF          <1> _mta:	call	_operand_read
  2727 000014DF 334510              <1> 	xor	eax, dword ptr [ebp+A]
  2728 000014E2 234504              <1> 	and	eax, dword ptr [ebp+K]
  2729 000014E5 7506                <1> 	jnz	_mta_
  2730 000014E7 81C204000000        <1> 	add	edx, 4		; k AND (a XOR operand) = 0, skip 1 instruction
  2731 000014ED C3                  <1> _mta_:	ret
  2732                              <1> 
  2733 000014EE E8F8EDFFFF          <1> _dte:	call	_burst_read2
  2734 000014F3 334510              <1> 	xor	eax, dword ptr [ebp+A]
  2735 000014F6 750B                <1> 	jnz	_dte_
  2736 000014F8 335D14              <1> 	xor	ebx, dword ptr [ebp+B]
  2737 000014FB 7506                <1> 	jnz	_dte_
  2738 000014FD 81C204000000        <1> 	add	edx, 4
  2739 00001503 C3                  <1> _dte_:	ret	
  2740                              <1> 
  2741 00001504 8B1D[00000000]      <1> _sc:	mov	ebx, dword ptr [_psr]
  2742 0000150A 81E301000000        <1> 	and	ebx, 1		; store carry 
  2743 00001510 E9F3EFFFFF          <1> 	jmp	_operand_write
  2744                              <1> 
  2745 00001515 E82FEEFFFF          <1> _mlb:	call	_operand_read
  2746 0000151A 8B5D04              <1> 	mov	ebx, dword ptr [ebp+K]
  2747 0000151D 21D8                <1> 	and	eax, ebx
  2748 0000151F 81F3FFFFFF00        <1> 	xor	ebx, 00FFFFFFh
  2749 00001525 235D14              <1> 	and	ebx, dword ptr [ebp+B]
  2750 00001528 09C3                <1> 	or	ebx, eax
  2751 0000152A 895D14              <1> 	mov	dword ptr [ebp+B], ebx	; b = (b AND (NOT k)) OR (operand AND k)
  2752 0000152D C3                  <1> 	ret
  2753                              <1> 
  2754 0000152E BB04000000          <1> _ds:	mov	ebx, a
  2755 00001533 E994EFFFFF          <1> 	jmp	_burst_write2
  2756                              <1> 
  2757 00001538 E8AEEDFFFF          <1> _dl:	call	_burst_read2
  2758 0000153D 895D14              <1> 	mov	dword ptr [ebp+B], ebx
  2759 00001540 894510              <1> 	mov	dword ptr [ebp+A], eax
  2760 00001543 C3                  <1> 	ret
  2761                              <1> 
  2762 00001544 C3                  <1> _spare:	ret
  2763                              <1> 
  2764 00001545 E82DF1FFFF          <1> _ex:	call	memory_read
  2765 0000154A E9DCEBFFFF          <1> 	jmp	_execute
  2766                              <1> 
  2767                              <1> 	%if	__SMP
  2768                              <1> 
  2769 0000154F E84AF1FFFF          <1> _ts:	call	memory_lock
  2770 00001554 66B80080            <1> 	mov	ax, 08000h
  2771 00001558 668704B7            <1> 	xchg	ax, word ptr [edi+esi*4]	; swap -> t1 for 080 under lock
  2772 0000155C 6621C0              <1> 	and	ax, ax
  2773 0000155F 7806                <1> 	js	_ts___				; no action if already locked
  2774                              <1> 
  2775 00001561 81C204000000        <1> 	add	edx, 4				; skip if ms bit was clear before
  2776                              <1> 
  2777 00001567 C3                  <1> _ts___:	ret
  2778                              <1> 
  2779                              <1> 	%else
  2780                              <1> 
  2781                              <1> _ts:	call	memory_read_lock
  2782                              <1> 	test	eax, 00800000h
  2783                              <1> 	jz	_ts___
  2784                              <1> 
  2785                              <1> 	ret					; not obtained
  2786                              <1> 
  2787                              <1> _ts___:	add	edx, 4				; successful, skip one instruction
  2788                              <1> 	or	eax, 00800000h			; claim
  2789                              <1> 	jmp	memory_direct
  2790                              <1> 
  2791                              <1> 	%endif
  2792                              <1> 
  2793 00001568 E815F1FFFF          <1> _sim:	call	memoreg	
  2794 0000156D 66C1E008            <1> 	shl	ax, 8				; mask 3 bits
  2795 00001571 A0[02000000]        <1> 	mov	al, byte ptr [_psr+2]		; read the psr mask part
  2796 00001576 C1C803              <1> 	ror	eax, 3
  2797 00001579 C0C003              <1> 	rol	al, 3
  2798 0000157C A2[02000000]        <1> 	mov	byte ptr [_psr+2], al
  2799 00001581 C1E81D              <1> 	shr	eax, 32-3
  2800 00001584 E9D2F0FFFF          <1> 	jmp	memoreg_writeback
  2801                              <1> 
  2802 00001589 52                  <1> _call:	push	edx
  2803 0000158A E863FAFFFF          <1> 	call	stack2
  2804 0000158F 2B15[00000000]      <1> 	sub	edx, dword ptr [_b0p]
  2805 00001595 C1EA02              <1> 	shr	edx, 2
  2806 00001598 89549D04            <1> 	mov	dword ptr [ebp+ebx*4+1*4], edx
  2807 0000159C 8B15[00000000]      <1> 	mov	edx, dword ptr [_b0_name]
  2808 000015A2 89549D00            <1> 	mov	dword ptr [ebp+ebx*4], edx
  2809 000015A6 5A                  <1> 	pop	edx		; in case the jump goes wrong
  2810                              <1> 				; and an interrupt frame needs constructed
  2811 000015A7 8B2D[00000000]      <1> 	mov	ebp, dword ptr [_register_set]
  2812                              <1> 
  2813 000015AD 8915[00000000]      <1> _go:	mov	dword ptr [_apc], edx
  2814 000015B3 E891EDFFFF          <1> 	call	_operand_read	; may be memory or register
  2815                              <1> 
  2816 000015B8 89C2                <1> 	mov	edx, eax	; lookaside to calculate the vector
  2817 000015BA A900008000          <1> 	test	eax, 00800000h	; gate?
  2818 000015BF 7428                <1> 	jz	_go2_4k_frame
  2819                              <1> 
  2820 000015C1 25FFFF7F00          <1> 	and	eax, 007FFFFFh	; read the gate constant
  2821 000015C6 E820EDFFFF          <1> 	call	_burst_read2	;
  2822 000015CB 89C2                <1> 	mov	edx, eax	; page high index ++ word offset
  2823 000015CD 89D8                <1> 	mov	eax, ebx	; storage block base page index
  2824 000015CF C1C20E              <1> 	rol	edx, 6+8
  2825 000015D2 89D3                <1> 	mov	ebx, edx	; instruction frame page high index
  2826 000015D4 81E33F000000        <1> 	and	ebx, 63
  2827 000015DA 7405                <1> 	jz	_go_gate	; one page iframe
  2828 000015DC 0D00008000          <1> 	or	eax, 00800000h	; two+ page iframe
  2829                              <1> 
  2830                              <1> _go_gate:
  2831 000015E1 C1EA0E              <1> 	shr	edx, 6+8	; net word offset
  2832                              <1> 
  2833 000015E4 E910000000          <1> 	jmp	_go2_frame
  2834                              <1> 	
  2835                              <1> _go2_4k_frame:
  2836 000015E9 81E23F000000        <1> 	and	edx, 63		; target is in 4k block, 64 vectors
  2837 000015EF C1E806              <1> 	shr	eax, 6		; new b0_name
  2838 000015F2 25FFFF0000          <1> 	and	eax, 0000FFFFh	; bit 22 of GO / CALL word reserved
  2839 000015F7 31DB                <1> 	xor	ebx, ebx	; frame high page index
  2840                              <1> 
  2841                              <1> _go2_frame:
  2842 000015F9 F605[02000000]80    <1> 	test	byte ptr [_psr+2], 128	; already in interrupt code?
  2843 00001600 7520                <1> 	jnz	_go2_base_frame	; 	; may branch into interrupt code
  2844                              <1> 					; because he is interrupt code
  2845 00001602 89C1                <1> 	mov	ecx, eax
  2846 00001604 81E1FFFF3F00        <1> 	and	ecx, 03FFFFFh
  2847 0000160A 2B0D[20010000]      <1> 	sub	ecx, dword ptr [_base+72*4]	; applications lower limit
  2848 00001610 7D10                <1> 	jnl	_go2_base_frame
  2849                              <1> 
  2850 00001612 8B15[00000000]      <1> 	mov	edx, dword ptr [_apc]
  2851 00001618 BE01000000          <1> 	mov	esi, LP_AUTHORITY
  2852 0000161D E93BF8FFFF          <1> 	jmp	guard_ii_escape
  2853                              <1> 
  2854                              <1> _go2_base_frame:
  2855                              <1> 
  2856 00001622 A3[00000000]        <1> 	mov	dword ptr [_b0_name], eax	; with flags
  2857 00001627 25FFFF3F00          <1> 	and	eax, 003FFFFFh			; base page index only
  2858 0000162C 01C3                <1> 	add	ebx, eax
  2859 0000162E 891D[00010000]      <1> 	mov	dword ptr [_base+64*4], ebx
  2860                              <1> 
  2861                              <1> 	%if	1
  2862 00001634 8B0D[00020000]      <1> 	mov	ecx, dword ptr [_base+128*4]	; memory page high index
  2863 0000163A 81E1FFFF3F00        <1> 	and	ecx, 003FFFFFh			; strip memory type bits
  2864 00001640 29D9                <1> 	sub	ecx, ebx			; iframe high page may be = not >
  2865 00001642 7910                <1> 	jns	_go2_frame_in_range
  2866                              <1> 
  2867 00001644 BE0E000000          <1> 	mov	esi, LP_ADDRESS
  2868 00001649 8B15[00000000]      <1> 	mov	edx, dword ptr [_apc]
  2869 0000164F E909F8FFFF          <1> 	jmp	guard_ii_escape
  2870                              <1> 
  2871                              <1> _go2_frame_in_range:
  2872                              <1> 
  2873                              <1> 	%else
  2874                              <1> 	mov	ecx, dword ptr [_base+128*4]	; have we the highest frame page?
  2875                              <1> 	and	ecx, 003FFFFFh			; read highest page index
  2876                              <1> 	mov	esi, LP_ADDRESS			; trim off flags
  2877                              <1> 	sub	ecx, ebx			; compare
  2878                              <1> 	xchg	edx, dword ptr [_apc]
  2879                              <1> 	js	guard_ii_escape			; if negative that should catch it
  2880                              <1> 	xchg	edx, dword ptr [_apc]
  2881                              <1> 	%endif
  2882                              <1> 
  2883 00001654 C1E30C              <1> 	shl	ebx, 12
  2884 00001657 8D1C9D[FC3F0000]    <1> 	lea	ebx, [_memory+ebx*4+4095*4]	; last instruction word in iframe
  2885                              <1> 						; higher = wrong
  2886 0000165E 891D[00000000]      <1> 	mov	dword ptr [_apcz], ebx	; set execution limit pointer
  2887                              <1> 
  2888 00001664 A3[00000000]        <1> 	mov	dword ptr [_base], eax
  2889 00001669 C1E00E              <1> 	shl	eax, 12+2	; 4kword block multiplied by 4 for word
  2890 0000166C 05[00000000]        <1> 	add	eax, _memory	; add the platform location of executable space
  2891 00001671 A3[00000000]        <1> 	mov	dword ptr [_b0p], eax
  2892 00001676 C1E202              <1> 	shl	edx, 2		; add the vector offset * 4 for word
  2893 00001679 01C2                <1> 	add	edx, eax
  2894 0000167B C3                  <1> _go_:	ret
  2895                              <1> 
  2896                                  	%include	"alu.msm"
  2897                              <1> 
  2898                              <1> 
  2899 0000167C E8C8ECFFFF          <1> _ax:	call	_operand_read
  2900 00001681 034508              <1> 	add	eax, dword ptr [ebp+X]
  2901 00001684 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
  2902 00001689 894508              <1> 	mov	dword ptr [ebp+X], eax
  2903 0000168C C3                  <1> 	ret
  2904                              <1> 
  2905 0000168D E8B7ECFFFF          <1> _ay:	call	_operand_read
  2906 00001692 03450C              <1> 	add	eax, dword ptr [ebp+Y]
  2907 00001695 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
  2908 0000169A 89450C              <1> 	mov	dword ptr [ebp+Y], eax
  2909 0000169D C3                  <1> 	ret
  2910                              <1> 
  2911 0000169E E8A6ECFFFF          <1> _or:	call	_operand_read
  2912 000016A3 094510              <1> 	or	dword ptr [ebp+A], eax
  2913 000016A6 C3                  <1> 	ret
  2914                              <1> 
  2915 000016A7 E89DECFFFF          <1> _orB:	call	_operand_read
  2916 000016AC 094514              <1> 	or	dword ptr [ebp+B], eax
  2917 000016AF C3                  <1> 	ret
  2918                              <1> 
  2919 000016B0 E894ECFFFF          <1> _and:	call	_operand_read
  2920 000016B5 214510              <1> 	and	dword ptr [ebp+A], eax
  2921 000016B8 C3                  <1> 	ret
  2922                              <1> 
  2923 000016B9 E88BECFFFF          <1> _andB:	call	_operand_read
  2924 000016BE 214514              <1> 	and	dword ptr [ebp+B], eax
  2925 000016C1 C3                  <1> 	ret
  2926                              <1> 
  2927 000016C2 E882ECFFFF          <1> _xor:	call	_operand_read
  2928 000016C7 314510              <1> 	xor	dword ptr [ebp+A], eax
  2929 000016CA C3                  <1> 	ret
  2930                              <1> 
  2931 000016CB E879ECFFFF          <1> _xorB:	call	_operand_read
  2932 000016D0 314514              <1> 	xor	dword ptr [ebp+B], eax
  2933 000016D3 C3                  <1> 	ret
  2934                              <1> 
  2935 000016D4 E870ECFFFF          <1> _aa:	call	_operand_read
  2936 000016D9 E90F000000          <1> 	jmp	_aa_
  2937 000016DE E866ECFFFF          <1> _ana:	call	_operand_read
  2938 000016E3 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
  2939 000016E8 0501000000          <1> 	add	eax, 1
  2940 000016ED 034510              <1> _aa_:	add	eax, dword ptr [ebp+A]
  2941 000016F0 E8CA040000          <1> 	call	_alu_carry
  2942                              <1> 
  2943                              <1> 	%if	0
  2944                              <1> 	rol	eax, 8
  2945                              <1> 	and	al, 1
  2946                              <1> 	and	byte ptr [_psr], 254
  2947                              <1> 	or	byte ptr [_psr], al
  2948                              <1> 	shr	eax, 8
  2949                              <1> 	%endif
  2950                              <1> 
  2951 000016F5 894510              <1> 	mov	dword ptr [ebp+A], eax
  2952 000016F8 C3                  <1> 	ret
  2953                              <1> 
  2954 000016F9 E84BECFFFF          <1> _ab:	call	_operand_read
  2955 000016FE E90F000000          <1> 	jmp	_ab_
  2956 00001703 E841ECFFFF          <1> _anb:	call	_operand_read
  2957 00001708 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
  2958 0000170D 0501000000          <1> 	add	eax, 1
  2959 00001712 034514              <1> _ab_:	add	eax, dword ptr [ebp+B]
  2960 00001715 E8A5040000          <1> 	call	_alu_carry
  2961                              <1> 
  2962                              <1> 	%if	0
  2963                              <1> 	rol	eax, 8
  2964                              <1> 	and	al, 1
  2965                              <1>         and     byte ptr [_psr], 254
  2966                              <1> 	or	byte ptr [_psr], al
  2967                              <1> 	shr	eax, 8
  2968                              <1> 	%endif
  2969                              <1> 
  2970 0000171A 894514              <1> 	mov	dword ptr [ebp+B], eax
  2971 0000171D C3                  <1> 	ret
  2972                              <1> 
  2973 0000171E 52                  <1> _m:	push	edx			; 80386 platform has it ready made, so
  2974 0000171F E825ECFFFF          <1> 	call	_operand_read
  2975 00001724 C1E008              <1> 	shl	eax, 8			; prepare multiplier to be multiplicand 
  2976 00001727 C1F808              <1> 	sar	eax, 8			; sign it in eax
  2977 0000172A 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]	; this is register side multiplicand but
  2978                              <1> 					; it makes no difference which is which
  2979 0000172D C1E308              <1> 	shl	ebx, 8			; so use it as multiplier if that is OK
  2980 00001730 C1FB08              <1> 	sar	ebx, 8			; sign it first
  2981                              <1> 
  2982 00001733 F7EB                <1> 	imul	ebx
  2983                              <1> 
  2984 00001735 C1C008              <1> 	rol	eax, 8			; move 8 bits up from eax to edx
  2985 00001738 C1E208              <1> 	shl	edx, 8
  2986 0000173B 88C2                <1> 	mov	dl, al
  2987 0000173D C1E808              <1> 	shr	eax, 8
  2988 00001740 894514              <1> 	mov	dword ptr [ebp+B], eax	; product bits 23..0
  2989 00001743 C1E208              <1> 	shl	edx, 8
  2990 00001746 C1EA08              <1> 	shr	edx, 8
  2991 00001749 895510              <1> 	mov	dword ptr [ebp+A], edx	; product high order bits
  2992 0000174C 5A                  <1> 	pop	edx
  2993 0000174D C3                  <1> 	ret
  2994                              <1> 
  2995 0000174E 52                  <1> _mf:	push	edx		; the multiplier is signed the multiplicand unsigned
  2996 0000174F E8F5EBFFFF          <1> 	call	_operand_read
  2997 00001754 89C1                <1> 	mov	ecx, eax	; just to remember the multiplier sign
  2998 00001756 A900008000          <1> 	test	eax, 00800000h
  2999 0000175B 740A                <1> 	jz	_mfplusplus
  3000 0000175D 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
  3001 00001762 0501000000          <1> 	add	eax, 1
  3002                              <1> _mfplusplus:
  3003 00001767 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]	; this is the multiplicand, unsigned
  3004 0000176A F7E3                <1> 	mul	ebx		; two 24-bit unsigned values should be OK here
  3005 0000176C C1C008              <1> 	rol	eax, 8
  3006 0000176F C1E208              <1> 	shl	edx, 8
  3007 00001772 88C2                <1> 	mov	dl, al
  3008 00001774 C1E808              <1> 	shr	eax, 8
  3009 00001777 C1E208              <1> 	shl	edx, 8
  3010 0000177A C1EA08              <1> 	shr	edx, 8
  3011 0000177D F7C100008000        <1> 	test	ecx, 00800000h	; was the multiplier signed?
  3012 00001783 7421                <1> 	jz	_mfstore
  3013 00001785 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
  3014 0000178A 81F2FFFFFF00        <1> 	xor	edx, 00FFFFFFh
  3015 00001790 0501000000          <1> 	add	eax, 1
  3016 00001795 C1C008              <1> 	rol	eax, 8
  3017 00001798 0FB6C8              <1> 	movzx	ecx, al
  3018 0000179B C1E808              <1> 	shr	eax, 8
  3019 0000179E 01CA                <1> 	add	edx, ecx
  3020 000017A0 81E2FFFFFF00        <1> 	and	edx, 00FFFFFFh
  3021                              <1> _mfstore:
  3022 000017A6 894514              <1> 	mov	dword ptr [ebp+B], eax
  3023 000017A9 895510              <1> 	mov	dword ptr [ebp+A], edx
  3024 000017AC 5A                  <1> 	pop	edx
  3025 000017AD C3                  <1> 	ret
  3026                              <1> 
  3027 000017AE BF04000000          <1> _d:	mov	edi, a
  3028 000017B3 E80A000000          <1> 	call	_divide
  3029 000017B8 895D10              <1> 	mov	dword ptr [ebp+A], ebx
  3030 000017BB 894518              <1> 	mov	dword ptr [ebp+MANTISSA2], eax
  3031 000017BE 894D14              <1> 	mov	dword ptr [ebp+B], ecx
  3032 000017C1 C3                  <1> 	ret
  3033                              <1> 
  3034                              <1> 	%if	1
  3035                              <1> 
  3036                              <1> ;	this divide made from 2 Intel divides should be a better method
  3037                              <1> ;	than the procession of 1-bit shifts and test subtracts
  3038                              <1> ;	which is the %else which it replaces. That also works
  3039                              <1> 
  3040                              <1> ;	this converts to and from positive magnitude
  3041                              <1> ;	because zoning the 2nd divide with a zero 1st remainder
  3042                              <1> ;	can't tell +0 from -0 in platform 2s complement
  3043                              <1> 
  3044                              <1> ;	polarity conversions before and after need no explanation
  3045                              <1> 
  3046                              <1> ;	1st dividend is 48 zero bits and high order 16 data bits
  3047                              <1> ;	of the the 48-bit RTA1 dividend
  3048                              <1> 
  3049                              <1> ;	2nd dividend is 1st remainder and the remaining 32 bits
  3050                              <1> ;	the the RTA1 dividend
  3051                              <1> 
  3052                              <1> ;	input is compressed from 24-bit words and output unpacked
  3053                              <1> ;	to 24-bit words
  3054                              <1> 
  3055                              <1> ;	64-bit dividend in 386 mode is high order bits in edx, low in eax
  3056                              <1> ;	platform faults if quotient carries from eax. Remainder in edx
  3057                              <1> 
  3058                              <1> ;	RTA1 quotient is 48 bits so it takes 2 divides in 32-bit mode
  3059                              <1> 
  3060                              <1> _divide:
  3061 000017C2 52                  <1> 	push	edx
  3062 000017C3 57                  <1> 	push	edi
  3063 000017C4 E880EBFFFF          <1> 	call	_operand_read	; read divisor
  3064 000017C9 5F                  <1> 	pop	edi
  3065 000017CA 31C9                <1> 	xor	ecx, ecx	; final sign
  3066 000017CC A900008000          <1> 	test	eax, 00800000h
  3067 000017D1 7408                <1> 	jz	_dsig?
  3068 000017D3 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
  3069 000017D8 F7D1                <1> 	not	ecx		; reverse final sign
  3070 000017DA 40                  <1> 	inc	eax
  3071 000017DB 25FFFFFF00          <1> _dsig?:	and	eax, 00FFFFFFh	; check zerodiv here mebbes
  3072 000017E0 89C3                <1> 	mov	ebx, eax	; eax will be used twice as divisor LS word
  3073 000017E2 7473                <1> 	jz	_d_ont		; zero results in eax ebx already
  3074                              <1> 
  3075 000017E4 8B44BD04            <1> 	mov	eax, dword ptr [ebp+edi*4+4]
  3076 000017E8 8B54BD00            <1> 	mov	edx, dword ptr [ebp+edi*4]
  3077 000017EC C1E008              <1> 	shl	eax, 8		; pack two 24-bit words to 64 bits 
  3078 000017EF 88D0                <1> 	mov	al, dl
  3079 000017F1 C1C808              <1> 	ror	eax, 8
  3080 000017F4 C1E208              <1> 	shl	edx, 8
  3081 000017F7 C1EA10              <1> 	shr	edx, 16
  3082 000017FA 6689D1              <1> 	mov	cx, dx		; save dividend sign
  3083 000017FD 6621D2              <1> 	and	dx, dx		; bit 47 on?
  3084 00001800 7915                <1> 	jns	_dive_in
  3085                              <1> 
  3086 00001802 81F10000FFFF        <1> 	xor	ecx, 0FFFF0000h	; reverse final sign
  3087 00001808 F7D0                <1> 	not	eax
  3088 0000180A 66F7D2              <1> 	not	dx
  3089 0000180D 0501000000          <1> 	add	eax, 1
  3090 00001812 6681D20000          <1> 	adc	dx, 0
  3091                              <1> 
  3092                              <1> _dive_in:
  3093 00001817 89C6                <1> 	mov	esi, eax	; reserve 2nd dividend
  3094 00001819 89D0                <1> 	mov	eax, edx	; position 1st dividend
  3095 0000181B 31D2                <1> 	xor	edx, edx	; with leading zero
  3096 0000181D F7F3                <1> 	div	ebx
  3097 0000181F 96                  <1> 	xchg	eax, esi	; save 1st quotient
  3098 00001820 F7F3                <1> 	div	ebx		; generate 2nd quotient
  3099                              <1> 
  3100 00001822 6621C9              <1> 	and	cx, cx		; dividend negative?
  3101 00001825 7903                <1> 	jns	_d_remainder_plus
  3102 00001827 F7D2                <1> 	not	edx
  3103 00001829 42                  <1> 	inc	edx
  3104                              <1> 
  3105                              <1> _d_remainder_plus:
  3106 0000182A 81E2FFFFFF00        <1> 	and	edx, 00FFFFFFh
  3107 00001830 87D1                <1> 	xchg	edx, ecx	; remainder -> ecx / final sign -> edx
  3108                              <1> 
  3109 00001832 89C3                <1> 	mov	ebx, eax	; low order quotient
  3110 00001834 89F0                <1> 	mov	eax, esi	; high order quotient
  3111                              <1> 
  3112 00001836 21D2                <1> 	and	edx, edx	; final sign?
  3113 00001838 790F                <1> 	jns	_d_quotient_plus
  3114                              <1> 
  3115 0000183A F7D3                <1> 	not	ebx		; invert + increment quotient
  3116 0000183C 66F7D0              <1> 	not	ax		; RTA1 integer is also 2s complement
  3117 0000183F 81C301000000        <1> 	add	ebx, 1
  3118 00001845 66150000            <1> 	adc	ax, 0
  3119                              <1> 
  3120                              <1> _d_quotient_plus:
  3121 00001849 0FB7C0              <1> 	movzx	eax, ax		; unpack from 32-bit words to 24-bit words
  3122 0000184C C1E008              <1> 	shl	eax, 8		; move 8 bits up
  3123 0000184F C1C308              <1> 	rol	ebx, 8
  3124 00001852 88D8                <1> 	mov	al, bl
  3125 00001854 C1EB08              <1> 	shr	ebx, 8		; quotient in eax:ebx
  3126                              <1> 
  3127 00001857 5A                  <1> _d_ont:	pop	edx		; give back the emulated program counter
  3128 00001858 C3                  <1> 	ret
  3129                              <1> 
  3130                              <1> 	%else
  3131                              <1> 
  3132                              <1> _divide:
  3133                              <1> 	xor	ebx, ebx
  3134                              <1> 	push	ebx		;
  3135                              <1> 	push	ebx		; quotient
  3136                              <1> 	push	ebx		; dividend[b]
  3137                              <1> 	push	ebx		; dividend[a]
  3138                              <1> 	push	ebx		; trailing divisor
  3139                              <1> 	push	ebx		; divisor
  3140                              <1> 	push	ebx		; signs2 
  3141                              <1> 	push	ebx		; signs1
  3142                              <1> 	mov	ebx, 24
  3143                              <1> 	push	ebx		; beats
  3144                              <1> 
  3145                              <1> 
  3146                              <1> _D_BEATS	equ	0
  3147                              <1> _D_SIGNS1	equ	1*4
  3148                              <1> _D_SIGNS2	equ	2*4
  3149                              <1> _D_DIVISORU	equ	3*4
  3150                              <1> _D_DIVISORL	equ	4*4
  3151                              <1> _D_DIVIDENDU	equ	5*4
  3152                              <1> _D_DIVIDENDL	equ	6*4
  3153                              <1> _D_QUOTIENTU	equ	7*4
  3154                              <1> _D_QUOTIENTL	equ	8*4
  3155                              <1> 
  3156                              <1> 	push	edi
  3157                              <1> 	call	_operand_read
  3158                              <1> 	pop	edi
  3159                              <1> 
  3160                              <1> 	test	eax, 00800000h
  3161                              <1> 	jnz	_d_nmagnitude1			; must be stored negative
  3162                              <1> 	xor	eax, 00FFFFFFh
  3163                              <1> 	jmp	_d_nmagnitude2
  3164                              <1> _d_nmagnitude1:
  3165                              <1> 	add	eax, -1				; if it's already negative
  3166                              <1> 	mov	dword ptr [esp+_D_SIGNS2], 0FFFFFFFFh
  3167                              <1> _d_nmagnitude2:
  3168                              <1> 	call	qscale
  3169                              <1> 	cmp	bl, 24
  3170                              <1> 	jz	_d_allsigns
  3171                              <1> 	add	dword ptr [esp+_D_BEATS], ebx
  3172                              <1> _d_allsigns:
  3173                              <1> 	mov	ebx, 00FFFFFF00h ; make the divisor 48 bits contiguous	
  3174                              <1> 	mov	bl, al
  3175                              <1> 	ror	ebx, 8
  3176                              <1> 	shl	eax, 8
  3177                              <1> 	mov	ax, 65535
  3178                              <1> 	ror	eax, 16
  3179                              <1> 
  3180                              <1> 	mov	dword ptr [esp+_D_DIVISORL], ebx
  3181                              <1> 	mov	dword ptr [esp+_D_DIVISORU], eax
  3182                              <1> 
  3183                              <1> 	mov	ecx, 1				; precarry
  3184                              <1> 
  3185                              <1> ;	mov	ebx, dword ptr [ebp+B]	; dividend
  3186                              <1> ;	mov	eax, dword ptr [ebp+A]
  3187                              <1> 
  3188                              <1> 	mov	ebx, dword ptr [ebp+edi*4+4]
  3189                              <1> 	mov	eax, dword ptr [ebp+edi*4] 
  3190                              <1> 
  3191                              <1> 	test	eax, 00800000h
  3192                              <1> 	jz	_d_pmagnitude			; must be stored positive
  3193                              <1> 	mov	dword ptr [esp+_D_SIGNS1], 00FFFFFFFFh
  3194                              <1> 	xor	ebx, 00FFFFFFh
  3195                              <1> 	xor	eax, 00FFFFFFh
  3196                              <1> 	add	ecx, ebx
  3197                              <1> 	mov	ebx, ecx
  3198                              <1> 	and	ebx, 00FFFFFFh
  3199                              <1> 	shr	ecx, 24
  3200                              <1> 	add	eax, ecx
  3201                              <1> 	and	eax, 00FFFFFFh
  3202                              <1> 
  3203                              <1> _d_pmagnitude:
  3204                              <1> 	shl	ebx, 8
  3205                              <1> 	mov	bl, al
  3206                              <1> 	ror	ebx, 8
  3207                              <1> 	shl	eax, 8
  3208                              <1> 	shr	eax, 16
  3209                              <1> 	mov	dword ptr [esp+_D_DIVIDENDL], ebx
  3210                              <1> 	mov	dword ptr [esp+_D_DIVIDENDU], eax
  3211                              <1> 
  3212                              <1> 	mov	ecx, dword ptr [esp+_D_BEATS]
  3213                              <1> 
  3214                              <1> 	add	ecx, -1
  3215                              <1> _d_beat:			; iterative part as quick as possible
  3216                              <1> 				; could study doing a pair of Intel divides here
  3217                              <1> 	stc
  3218                              <1> 	rcr	dword ptr [esp+_D_DIVISORU], 1
  3219                              <1> 	rcr	dword ptr [esp+_D_DIVISORL], 1
  3220                              <1> 
  3221                              <1> 	stc
  3222                              <1> 	adc	ebx, dword ptr [esp+_D_DIVISORL]
  3223                              <1> 	adc	eax, dword ptr [esp+_D_DIVISORU]
  3224                              <1> 
  3225                              <1> 	jc	_d_carried
  3226                              <1> 	mov	ebx, dword ptr [esp+_D_DIVIDENDL]
  3227                              <1> 	mov	eax, dword ptr [esp+_D_DIVIDENDU]
  3228                              <1> 	jmp	_d_carried_or_not
  3229                              <1> 
  3230                              <1> _d_carried:
  3231                              <1> 	mov	dword ptr [esp+_D_DIVIDENDL], ebx
  3232                              <1> 	mov	dword ptr [esp+_D_DIVIDENDU], eax
  3233                              <1> 
  3234                              <1> _d_carried_or_not:
  3235                              <1> 	rcl	dword ptr [esp+_D_QUOTIENTL], 1
  3236                              <1> 	rcl	dword ptr [esp+_D_QUOTIENTU], 1
  3237                              <1> 	
  3238                              <1> 	add	ecx, -1
  3239                              <1> 	jc	_d_beat
  3240                              <1> 
  3241                              <1> 	pop	ecx		; BEATS
  3242                              <1> 	pop	ecx		; SIGNS1
  3243                              <1> 	pop	eax		; SIGNS2
  3244                              <1> 	pop	ebx		; DIVISORU
  3245                              <1> 	pop	ebx		; DIVISORL
  3246                              <1> 	pop	ebx		; DIVIDENDU
  3247                              <1> 	pop	ebx		; DIVIDENDL
  3248                              <1> 
  3249                              <1> 	xor	ebx, ecx	; set remainder to sign of dividend
  3250                              <1> 	jns	_d_remplus
  3251                              <1> 	inc	ebx		; set -remainder 2s complement
  3252                              <1> 
  3253                              <1> _d_remplus:
  3254                              <1> 	and	ebx, 00FFFFFFh	; store remainder
  3255                              <1> ;	mov	dword ptr [ebp+B], ebx
  3256                              <1> 
  3257                              <1> 	xor	ecx, eax	; set sign of quotient to difference of signs
  3258                              <1> 	mov	ecx, ebx	; remainder for return
  3259                              <1> 	pop	eax		; QUOTIENTU
  3260                              <1> 	pop	ebx		; QUOTIENTL
  3261                              <1> 
  3262                              <1> 	jns	_d_quotient_plus		; cc set from xor of signy
  3263                              <1> 
  3264                              <1> 	not	eax
  3265                              <1> 	not	ebx
  3266                              <1> 	add	ebx, 1
  3267                              <1> 	adc	eax, 0
  3268                              <1> 
  3269                              <1> _d_quotient_plus:
  3270                              <1> 	shl	eax, 8
  3271                              <1> 	rol	ebx, 8
  3272                              <1> 	mov	al, bl
  3273                              <1> 	shr	ebx, 8
  3274                              <1> 	shl	eax, 8
  3275                              <1> 	shr	eax, 8
  3276                              <1> 
  3277                              <1> ;	mov	dword ptr [ebp+A], ebx
  3278                              <1> ;	mov	dword ptr [ebp+MANTISSA2], eax
  3279                              <1> 	ret
  3280                              <1> 
  3281                              <1> 	%endif
  3282                              <1> 
  3283                              <1> 
  3284 00001859 88C1                <1> _sar:	mov	cl, al			; eax shift radix is 31
  3285 0000185B 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
  3286 0000185E F6C1E0              <1> 	test	cl, -32
  3287 00001861 7402                <1> 	jz	_sardo
  3288 00001863 31C0                <1> 	xor	eax, eax		; shift 32+ clears same as 24+
  3289 00001865 D3E8                <1> _sardo:	shr	eax, cl
  3290 00001867 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
  3291 0000186C 894510              <1> 	mov	dword ptr [ebp+A], eax
  3292 0000186F C3                  <1> 	ret
  3293                              <1> 
  3294 00001870 88C1                <1> _sbr:	mov	cl, al
  3295 00001872 8B4514              <1> 	mov	eax, dword ptr [ebp+B]
  3296 00001875 F6C1E0              <1> 	test	cl, -32
  3297 00001878 7402                <1> 	jz	_sbrdo
  3298 0000187A 31C0                <1> 	xor	eax, eax		; shift 32+ clears same as 24+
  3299 0000187C D3E8                <1> _sbrdo:	shr	eax, cl
  3300 0000187E 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
  3301 00001883 894514              <1> 	mov	dword ptr [ebp+B], eax
  3302 00001886 C3                  <1> 	ret
  3303                              <1> 
  3304                              <1> 
  3305 00001887 88C1                <1> _dsr:	mov	cl, al
  3306 00001889 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]
  3307 0000188C 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
  3308 0000188F E875000000          <1> 	call	dsr
  3309 00001894 895D14              <1> 	mov	dword ptr [ebp+B], ebx
  3310 00001897 894510              <1> 	mov	dword ptr [ebp+A], eax
  3311 0000189A C3                  <1> 	ret
  3312                              <1> 
  3313 0000189B 88C1                <1> _sal:	mov	cl, al			; shift radix eax is 31
  3314 0000189D 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
  3315 000018A0 F6C1E0              <1> 	test	cl, -32
  3316 000018A3 7402                <1> 	jz	_saldo
  3317 000018A5 31C0                <1> 	xor	eax, eax		; shift 32+ clears same as 24+
  3318 000018A7 D3E0                <1> _saldo:	shl	eax, cl
  3319 000018A9 25FFFFFF00          <1> 	and	eax, 00FFFFFFh		; write back to registers only 00000000 thru 00FFFFFF
  3320 000018AE 894510              <1> 	mov	dword ptr [ebp+A], eax
  3321 000018B1 C3                  <1> 	ret
  3322                              <1> 
  3323 000018B2 88C1                <1> _sbl:	mov	cl, al
  3324 000018B4 8B4514              <1> 	mov	eax, dword ptr [ebp+B]
  3325 000018B7 F6C1E0              <1> 	test	cl,-32
  3326 000018BA 7402                <1> 	jz	_sbldo
  3327 000018BC 31C0                <1> 	xor	eax, eax		; shift 32+ clears same as 24+
  3328 000018BE D3E0                <1> _sbldo:	shl	eax, cl
  3329 000018C0 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
  3330 000018C5 894514              <1> 	mov	dword ptr [ebp+B], eax
  3331 000018C8 C3                  <1> 	ret
  3332                              <1> 
  3333 000018C9 88C1                <1> _dsl	mov	cl, al
  3334 000018CB 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]
  3335 000018CE 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
  3336 000018D1 E868000000          <1> 	call	dsl
  3337 000018D6 895D14              <1> 	mov	dword ptr [ebp+B], ebx
  3338 000018D9 894510              <1> 	mov	dword ptr [ebp+A], eax
  3339 000018DC C3                  <1> 	ret
  3340                              <1> 
  3341 000018DD 8B5D10              <1> _rar:	mov	ebx, dword ptr [ebp+A]
  3342 000018E0 E8C6000000          <1> 	call	rr
  3343 000018E5 895D10              <1> 	mov	dword ptr [ebp+A], ebx
  3344 000018E8 C3                  <1> 	ret
  3345                              <1> 
  3346 000018E9 8B5D14              <1> _rbr:	mov	ebx, dword ptr [ebp+B]
  3347 000018EC E8BA000000          <1> 	call	rr
  3348 000018F1 895D14              <1> 	mov	dword ptr [ebp+B], ebx
  3349 000018F4 C3                  <1> 	ret
  3350                              <1> 
  3351 000018F5 88C1                <1> _drr:	mov	cl, al
  3352 000018F7 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]
  3353 000018FA 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
  3354 000018FD E8F7000000          <1> 	call	drr
  3355 00001902 895D14              <1> 	mov	dword ptr [ebp+B], ebx
  3356 00001905 894510              <1> 	mov	dword ptr [ebp+A], eax
  3357 00001908 C3                  <1> 	ret
  3358                              <1> 
  3359                              <1> 
  3360 00001909 C1E008              <1> dsr:	shl	eax, 8
  3361 0000190C C1E308              <1> 	shl	ebx, 8
  3362 0000190F 80C1E8              <1> dsru:	add	cl, -24
  3363 00001912 7306                <1> 	jnc	dsrl
  3364 00001914 89C3                <1> 	mov	ebx, eax
  3365 00001916 31C0                <1> 	xor	eax, eax
  3366 00001918 EBF5                <1> 	jmp	dsru
  3367 0000191A 80C110              <1> dsrl:	add	cl, 16
  3368 0000191D 730D                <1> 	jnc	dsr7
  3369 0000191F C1E808              <1> dsr8:	shr	eax, 8
  3370 00001922 88C3                <1> 	mov	bl, al
  3371 00001924 C1CB08              <1> 	ror	ebx, 8
  3372 00001927 80C1F8              <1> 	add	cl,-8
  3373 0000192A 72F3                <1> 	jc	dsr8
  3374 0000192C 80E107              <1> dsr7:	and	cl, 7
  3375 0000192F D3E8                <1> 	shr	eax, cl
  3376 00001931 88C3                <1> 	mov	bl, al		; bits from al in high-order positions bl
  3377 00001933 D2C3                <1> 	rol	bl, cl		; roll them to low-order positions
  3378 00001935 D3CB                <1> 	ror	ebx, cl
  3379 00001937 C1EB08              <1> 	shr	ebx, 8
  3380 0000193A C1E808              <1> 	shr	eax, 8
  3381 0000193D C3                  <1> 	ret
  3382                              <1> 
  3383 0000193E C1E008              <1> dsl:	shl	eax, 8
  3384 00001941 C1E308              <1> 	shl	ebx, 8
  3385 00001944 80C1E8              <1> dslu:	add	cl, -24
  3386 00001947 7306                <1> 	jnc	dsll
  3387 00001949 89D8                <1> 	mov	eax, ebx
  3388 0000194B 31DB                <1> 	xor	ebx, ebx
  3389 0000194D EBF5                <1> 	jmp	dslu
  3390 0000194F 80C110              <1> dsll:	add	cl, 16
  3391 00001952 730F                <1> 	jnc	dsl7
  3392 00001954 C1C308              <1> dsl8:	rol	ebx, 8
  3393 00001957 88D8                <1> 	mov	al, bl
  3394 00001959 30DB                <1> 	xor	bl, bl
  3395 0000195B C1E008              <1> 	shl	eax, 8
  3396 0000195E 80C1F8              <1> 	add	cl, -8
  3397 00001961 72F1                <1> 	jc	dsl8
  3398 00001963 80E107              <1> dsl7:	and	cl, 7
  3399 00001966 D3C3                <1> 	rol	ebx, cl
  3400 00001968 88D8                <1> 	mov	al, bl		; bits from bl in low-order positions al
  3401 0000196A D2C8                <1> 	ror	al, cl		; roll them to high-order positions
  3402 0000196C D3E0                <1> 	shl	eax, cl
  3403 0000196E C1EB08              <1> 	shr	ebx, 8
  3404 00001971 C1E808              <1> 	shr	eax, 8
  3405 00001974 C3                  <1> 	ret
  3406                              <1> 
  3407 00001975 C1E008              <1> dsa:	shl	eax, 8
  3408 00001978 C1E308              <1> 	shl	ebx, 8
  3409 0000197B 80C1E8              <1> dsa24:	add	cl, -24
  3410 0000197E 7307                <1> 	jnc	dsa16
  3411 00001980 89C3                <1> 	mov	ebx, eax
  3412 00001982 C1F818              <1> 	sar	eax, 24
  3413 00001985 EBF4                <1> 	jmp	dsa24
  3414 00001987 80C110              <1> dsa16:	add	cl, 16
  3415 0000198A 730D                <1> 	jnc	dsa7
  3416 0000198C C1F808              <1> dsa8:	sar	eax, 8
  3417 0000198F 88C3                <1> 	mov	bl, al
  3418 00001991 C1CB08              <1> 	ror	ebx, 8
  3419 00001994 80C1F8              <1> 	add	cl, -8
  3420 00001997 72F3                <1> 	jc	dsa8
  3421 00001999 80E107              <1> dsa7:	and	cl, 7
  3422 0000199C D3F8                <1> 	sar	eax, cl
  3423 0000199E 88C3                <1> 	mov	bl, al		; bits from al in high-order positions bl
  3424 000019A0 D2C3                <1> 	rol	bl, cl		; roll them to low-order positions
  3425 000019A2 D3CB                <1> 	ror	ebx, cl
  3426 000019A4 C1E808              <1> 	shr	eax, 8
  3427 000019A7 C1EB08              <1> 	shr	ebx, 8
  3428 000019AA C3                  <1> 	ret	
  3429                              <1> 
  3430                              <1> 
  3431 000019AB 88C1                <1> rr:	mov	cl, al
  3432 000019AD C1E308              <1> 	shl	ebx, 8
  3433 000019B0 F6C118              <1> 	test	cl, 24		; bits 16:8 are self-cancelling
  3434 000019B3 7A11                <1> 	jpe	rr7
  3435 000019B5 F6C110              <1> 	test	cl, 16
  3436 000019B8 7407                <1> 	jz	rr8		; 16 is off so 8 is on
  3437 000019BA C1C308              <1> 	rol	ebx, 8		; 8 left in 24-bit ring = 16 right
  3438 000019BD 88DF                <1> 	mov	bh, bl		; compress 32-bit ring to 24-bit
  3439 000019BF EB05                <1> 	jmp	short rr7
  3440 000019C1 88FB                <1> rr8:	mov	bl, bh		; extend 24-bit ring to 32-bit
  3441 000019C3 C1CB08              <1> 	ror	ebx, 8
  3442 000019C6 80E107              <1> rr7:	and	cl, 7		; isolate remaining count bits
  3443 000019C9 88FB                <1> 	mov	bl, bh		; don't ask, just do it
  3444 000019CB D3CB                <1> 	ror	ebx, cl
  3445 000019CD C1EB08              <1> 	shr	ebx, 8
  3446 000019D0 C3                  <1> 	ret
  3447                              <1> 
  3448 000019D1 88C1                <1> rl:	mov	cl, al
  3449 000019D3 C1E308              <1> 	shl	ebx, 8
  3450 000019D6 F6C118              <1> 	test	cl, 24		; bits 16:8 are self-cancelling
  3451 000019D9 7A11                <1> 	jpe	rl7
  3452 000019DB F6C110              <1> 	test	cl, 16
  3453 000019DE 7407                <1> 	jz	rl8		; 16 is off so 8 is on
  3454 000019E0 88FB                <1> 	mov	bl, bh		; extend 24-bit ring to 32-bit
  3455 000019E2 C1CB08              <1> 	ror	ebx, 8		; 8 right in 24-bit ring = 16 left
  3456 000019E5 EB05                <1> 	jmp	short rl7
  3457 000019E7 C1C308              <1> rl8:	rol	ebx, 8
  3458 000019EA 88DF                <1> 	mov	bh, bl		; compress 32-bit ring to 24-bit	
  3459 000019EC 80E107              <1> rl7:	and	cl, 7
  3460 000019EF 30DB                <1> 	xor	bl, bl
  3461 000019F1 D3C3                <1> 	rol	ebx, cl
  3462 000019F3 08DF                <1> 	or	bh, bl
  3463 000019F5 C1EB08              <1> 	shr	ebx, 8
  3464 000019F8 C3                  <1> 	ret
  3465                              <1> 
  3466 000019F9 C1E008              <1> drr:	shl	eax, 8
  3467 000019FC C1E308              <1> 	shl	ebx, 8
  3468                              <1> 
  3469 000019FF F6C130              <1> 	test	cl, 48		; bits 32:16 are self-cancelling
  3470 00001A02 7B0A                <1> 	jpo	drr24		; rotate 48 = zero or 56 = 8 positions
  3471 00001A04 F6C108              <1> 	test	cl, 8		; parity = pe dans le pays d'Intel
  3472 00001A07 741F                <1> 	jz	drr7
  3473 00001A09 E915000000          <1> 	jmp	drr_cdrr8
  3474                              <1> 
  3475 00001A0E 93                  <1> drr24:	xchg	eax, ebx	; rotate 24 right or left as you wish
  3476 00001A0F F6C118              <1> 	test	cl, 24
  3477 00001A12 7A0D                <1> 	jpe	drr24_32	; pattern is 100xxx or 011xxx
  3478 00001A14 F6C108              <1> 	test	cl, 8		; pattern is 010xxx or 101xxx
  3479 00001A17 7401                <1> 	jz	drrl8		; pattern is 010
  3480 00001A19 93                  <1> 	xchg	eax, ebx	; swap back, pattern 101 = 40 right = 8 left 
  3481 00001A1A E828000000          <1> drrl8:	call	near drl8	; pattern is 010
  3482 00001A1F EB07                <1> 	jmp	short drr7 	; already rotated 24 right, now 8 left
  3483                              <1> 
  3484                              <1> drr24_32:
  3485 00001A21 7505                <1> 	jnz	drr7		; pattern is 011 = rotate 24. We did
  3486                              <1> drr_cdrr8:
  3487 00001A23 E814000000          <1> 	call	near drr8	; pattern is 100 = rotate 32
  3488 00001A28 80E107              <1> drr7:	and	cl, 7
  3489 00001A2B 7408                <1> 	jz	drrx
  3490 00001A2D 88E3                <1> 	mov	bl, ah		; rotate low bits ebx 31:8 to eax high positions
  3491 00001A2F 88F8                <1> 	mov	al, bh		; rotate low bits eax 31:8 to ebx high positions
  3492 00001A31 D3C8                <1> 	ror	eax, cl		; bits from bh in low order positions al
  3493 00001A33 D3CB                <1> 	ror	ebx, cl		; bits from ah in low order positions bl
  3494 00001A35 C1E808              <1> drrx:	shr	eax, 8
  3495 00001A38 C1EB08              <1> 	shr	ebx, 8
  3496 00001A3B C3                  <1> 	ret
  3497                              <1> 
  3498 00001A3C 88E3                <1> drr8:   mov     bl, ah          ; cross 8 bits from one 32-bit ring to another
  3499 00001A3E 88F8                <1>         mov     al, bh		
  3500 00001A40 C1C808              <1>         ror     eax, 8
  3501 00001A43 C1CB08              <1>         ror     ebx, 8
  3502 00001A46 C3                  <1>         ret
  3503                              <1> 
  3504 00001A47 C1C008              <1> drl8:   rol     eax, 8
  3505 00001A4A C1C308              <1>         rol     ebx, 8
  3506 00001A4D 88DC                <1>         mov     ah, bl          ; cross 8 bits from one 32-bit ring to another
  3507 00001A4F 88C7                <1>         mov     bh, al
  3508 00001A51 C3                  <1>         ret
  3509                              <1> 
  3510 00001A52 C1E008              <1> drl:	shl	eax, 8
  3511 00001A55 C1E308              <1> 	shl	ebx, 8
  3512 00001A58 F6C130              <1> 	test	cl, 48		; values 32:16 cancel each other
  3513 00001A5B 7B07                <1> 	jpo	drl24
  3514 00001A5D F6C108              <1> 	test	cl, 8
  3515 00001A60 741C                <1> 	jz	drl7
  3516 00001A62 EB15                <1> 	jmp	short drl_cdrl8
  3517                              <1> 
  3518 00001A64 93                  <1> drl24:	xchg	eax, ebx
  3519 00001A65 F6C118              <1> 	test	cl, 24
  3520 00001A68 7A0D                <1> 	jpe	drl24_32	; pattern is 011xxx or 100xxx
  3521 00001A6A F6C108              <1> 	test	cl, 8		; pattern is 010xxx or 101xxx
  3522 00001A6D 7401                <1> 	jz	drlr8		; pattern is 010 = 16 left = 8 right
  3523 00001A6F 93                  <1> 	xchg	eax, ebx	; swap back, pattern = 101 = 40 left = 8 right
  3524 00001A70 E8C7FFFFFF          <1> drlr8:	call	drr8
  3525 00001A75 EB07                <1> 	jmp	short drl7
  3526                              <1> 
  3527                              <1> drl24_32:
  3528 00001A77 7505                <1> 	jnz	drl7		; pattern is 011 = rotate24. We did
  3529                              <1> drl_cdrl8:			; pattern = 100xxx or 001xxx, rotate 8 more
  3530 00001A79 E8C9FFFFFF          <1> 	call	drl8
  3531 00001A7E 80E107              <1> drl7:	and	cl, 7		; rotate positions 0..7
  3532 00001A81 30C0                <1> 	xor	al, al
  3533 00001A83 30DB                <1> 	xor	bl, bl
  3534 00001A85 D3C0                <1> 	rol	eax, cl
  3535 00001A87 D3C3                <1> 	rol	ebx, cl
  3536 00001A89 08DC                <1> 	or	ah, bl
  3537 00001A8B 08C7                <1> 	or	bh, al
  3538 00001A8D C1E808              <1> 	shr	eax, 8
  3539 00001A90 C1EB08              <1> 	shr	ebx, 8
  3540 00001A93 C3                  <1> 	ret
  3541                              <1> 
  3542 00001A94 8B5D10              <1> _ral:	mov	ebx, dword ptr [ebp+A]
  3543 00001A97 E835FFFFFF          <1> 	call	rl
  3544 00001A9C 895D10              <1> 	mov	dword ptr [ebp+A], ebx
  3545 00001A9F C3                  <1> 	ret
  3546                              <1> 
  3547 00001AA0 8B5D14              <1> _rbl:	mov	ebx, dword ptr [ebp+B]
  3548 00001AA3 E829FFFFFF          <1> 	call	rl
  3549 00001AA8 895D14              <1> 	mov	dword ptr [ebp+B], ebx
  3550 00001AAB C3                  <1> 	ret	
  3551                              <1> 
  3552 00001AAC 88C1                <1> _drl:	mov	cl, al
  3553 00001AAE 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
  3554 00001AB1 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]
  3555 00001AB4 E899FFFFFF          <1> 	call	drl
  3556 00001AB9 895D14              <1> 	mov	dword ptr [ebp+B], ebx
  3557 00001ABC 894510              <1> 	mov	dword ptr [ebp+A], eax
  3558 00001ABF C3                  <1> 	ret
  3559                              <1> 
  3560 00001AC0 88C1                <1> _saa:	mov	cl, al
  3561 00001AC2 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
  3562 00001AC5 C1E008              <1> 	shl	eax, 8
  3563 00001AC8 D3F8                <1> 	sar	eax, cl
  3564 00001ACA C1E808              <1> 	shr	eax, 8
  3565 00001ACD 894510              <1> 	mov	dword ptr [ebp+A], eax
  3566 00001AD0 C3                  <1> 	ret
  3567                              <1> 
  3568 00001AD1 88C1                <1> _sba:	mov	cl, al
  3569 00001AD3 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]
  3570 00001AD6 C1E308              <1> 	shl	ebx, 8
  3571 00001AD9 D3FB                <1> 	sar	ebx, cl
  3572 00001ADB C1EB08              <1> 	shr	ebx, 8
  3573 00001ADE 895D14              <1> 	mov	dword ptr [ebp+B], ebx
  3574 00001AE1 C3                  <1> 	ret
  3575                              <1> 
  3576 00001AE2 88C1                <1> _dsa:	mov	cl, al
  3577 00001AE4 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]
  3578 00001AE7 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
  3579 00001AEA E886FEFFFF          <1> 	call	dsa
  3580 00001AEF 895D14              <1> 	mov	dword ptr [ebp+B], ebx
  3581 00001AF2 894510              <1> 	mov	dword ptr [ebp+A], eax
  3582 00001AF5 C3                  <1> 	ret
  3583                              <1> 
  3584 00001AF6 E887EBFFFF          <1> _n:	call	memoreg
  3585 00001AFB 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
  3586 00001B00 E956EBFFFF          <1> 	jmp	memoreg_writeback
  3587                              <1> 
  3588 00001B05 E878EBFFFF          <1> _inc:	call	memoreg
  3589 00001B0A 40                  <1> 	inc	eax
  3590 00001B0B E94BEBFFFF          <1> 	jmp	memoreg_writeback
  3591                              <1> 
  3592 00001B10 E86DEBFFFF          <1> _dec:	call	memoreg
  3593 00001B15 48                  <1> 	dec	eax
  3594 00001B16 E940EBFFFF          <1> 	jmp	memoreg_writeback
  3595                              <1> 
  3596 00001B1B E862EBFFFF          <1> _src:	call	memoreg
  3597 00001B20 C1E008              <1> 	shl	eax, 8
  3598 00001B23 A0[00000000]        <1> 	mov	al, byte ptr [_psr]
  3599 00001B28 D1C8                <1> 	ror	eax, 1
  3600 00001B2A D0C0                <1> 	rol	al, 1
  3601 00001B2C A2[00000000]        <1> 	mov	byte ptr [_psr], al
  3602 00001B31 C1E808              <1> 	shr	eax, 8
  3603 00001B34 E922EBFFFF          <1> 	jmp	memoreg_writeback
  3604                              <1> 
  3605 00001B39 E844EBFFFF          <1> _slc:	call	memoreg
  3606 00001B3E C1E008              <1> 	shl	eax, 8
  3607 00001B41 A0[00000000]        <1> 	mov	al, byte ptr [_psr]
  3608 00001B46 D0C8                <1> 	ror	al, 1
  3609 00001B48 D1C0                <1> 	rol	eax, 1
  3610 00001B4A A2[00000000]        <1> 	mov	byte ptr [_psr], al
  3611 00001B4F C1E808              <1> 	shr	eax, 8
  3612 00001B52 E904EBFFFF          <1> 	jmp	memoreg_writeback
  3613                              <1> 
  3614 00001B57 50                  <1> _popA:	push	eax			; EA
  3615 00001B58 E825EBFFFF          <1> 	call	memoreg			; register or system memory, no peripheral bus
  3616 00001B5D E8CDF5FFFF          <1> 	call	stack_read1
  3617 00001B62 03449D00            <1> 	add	eax, dword ptr [ebp+ebx*4]
  3618 00001B66 8B2D[00000000]      <1> 	mov	ebp, dword ptr [_register_set]
  3619 00001B6C C1E007              <1> 	shl	eax, 7
  3620 00001B6F D1C0                <1> 	rol	eax, 1
  3621 00001B71 8025[00000000]FE    <1> 	and	byte ptr [_psr], 254
  3622 00001B78 0805[00000000]      <1> 	or	byte ptr [_psr], al
  3623 00001B7E C1E808              <1> 	shr	eax, 8
  3624                              <1> ;	mov	ebx, eax
  3625 00001B81 5B                  <1> 	pop	ebx			; EA
  3626 00001B82 E9D4EAFFFF          <1> 	jmp	memoreg_writeback
  3627                              <1> 	
  3628 00001B87 E85FE7FFFF          <1> _da:	call	_burst_read2
  3629 00001B8C E911000000          <1> 	jmp	_da_
  3630                              <1> 
  3631 00001B91 E855E7FFFF          <1> _dan:	call	_burst_read2
  3632 00001B96 81F3FFFFFF00        <1> 	xor	ebx, 00FFFFFFh
  3633 00001B9C 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
  3634 00001BA1 43                  <1> 	inc	ebx			; carry from bit 23 
  3635                              <1> 					; remains in bit 24 for now
  3636                              <1> 	%if	0
  3637                              <1> 
  3638                              <1> _da_:	add	ebx, dword ptr [ebp+B]
  3639                              <1> 	mov	dword ptr [ebp+B], ebx
  3640                              <1> 	and	dword ptr [ebp+B], 00FFFFFFh
  3641                              <1> 	shr	ebx, 24			; zone carry value from bit 23
  3642                              <1> 	add	eax, ebx
  3643                              <1> 	add	eax, dword ptr [ebp+A]
  3644                              <1> 	mov	dword ptr [ebp+A], eax
  3645                              <1> 	and	dword ptr [ebp+A], 00FFFFFFh
  3646                              <1> 	shr	eax, 24
  3647                              <1> 	mov	ebx, dword ptr [_psr]
  3648                              <1> 	and	bl, 254
  3649                              <1> 	or	bl, al
  3650                              <1> 	mov	dword ptr [_psr], ebx
  3651                              <1> 	ret
  3652                              <1> 
  3653                              <1> 	%else
  3654                              <1> 
  3655 00001BA2 035D14              <1> _da_:	add	ebx, [ebp+B]
  3656 00001BA5 C1E308              <1> 	shl	ebx, 8
  3657 00001BA8 1500000000          <1> 	adc	eax, 0
  3658 00001BAD C1EB08              <1> 	shr	ebx, 8
  3659 00001BB0 895D14              <1> 	mov	[ebp+B], ebx
  3660 00001BB3 034510              <1> 	add	eax, [ebp+A]
  3661 00001BB6 E804000000          <1> 	call	_alu_carry
  3662 00001BBB 894510              <1> 	mov	[ebp+A], eax
  3663 00001BBE C3                  <1> 	ret
  3664                              <1> 
  3665                              <1> _alu_carry:
  3666 00001BBF C1C008              <1> 	rol	eax, 8
  3667 00001BC2 2401                <1> 	and	al, 1
  3668 00001BC4 8025[00000000]FE    <1> 	and	byte ptr [_psr], 254
  3669 00001BCB 0805[00000000]      <1> 	or	byte ptr [_psr], al
  3670 00001BD1 C1E808              <1> 	shr	eax, 8
  3671 00001BD4 C3                  <1> 	ret
  3672                              <1> 
  3673                              <1> 	%endif
  3674                              <1> 
  3675 00001BD5 040302020101010100- <1> scalex	db	4,3,2,2, 1,1,1,1, 0,0,0,0, 0,0,0,0
  3676 00001BDE 00000000000000      <1>
  3677                              <1> 
  3678                              <1> field_scale:			; examine 24-bit integer in 8-position steps
  3679 00001BE5 C1C008              <1> 	rol	eax, 8		; until high-order 8 bits are not all signs
  3680 00001BE8 88C4                <1> 	mov	ah, al
  3681 00001BEA 30E8                <1> 	xor	al, ch
  3682 00001BEC 7509                <1> 	jnz	not8signs
  3683 00001BEE 80C108              <1> 	add	cl, 8
  3684 00001BF1 80F918              <1> 	cmp	cl, 24
  3685 00001BF4 72EF                <1> 	jb	field_scale
  3686 00001BF6 C3                  <1> 	ret			; 24 signs = the RTA1 computer word
  3687                              <1> not8signs:			; al = 0 indicates it
  3688 00001BF7 A8F0                <1> 	test	al, 240		; move back some positions but keep counting up
  3689 00001BF9 7506                <1> 	jnz	scale_u
  3690 00001BFB 80C104              <1> 	add	cl, 4
  3691 00001BFE C0C004              <1> 	rol	al, 4
  3692                              <1> scale_u:
  3693 00001C01 C0E804              <1> 	shr	al, 4
  3694 00001C04 0FB6F0              <1> 	movzx	esi, al		; add to count-up 1..7
  3695 00001C07 2E028E[D51B0000]    <1> 	add	cl, [cs:esi+scalex]
  3696 00001C0E 6651                <1> 	push	cx		; roll back 7..1 positions
  3697 00001C10 80E107              <1> 	and	cl, 7
  3698 00001C13 80F107              <1> 	xor	cl, 7
  3699 00001C16 80C101              <1> 	add	cl, 1
  3700 00001C19 88E0                <1> 	mov	al, ah
  3701 00001C1B D3C8                <1> 	ror	eax, cl
  3702 00001C1D 6659                <1> 	pop	cx
  3703 00001C1F C3                  <1> 	ret
  3704                              <1> 
  3705 00001C20 C1E008              <1> qscale:	shl	eax, 8		; 1.2.3
  3706 00001C23 C1F808              <1> 	sar	eax, 8		; s.1.2.3
  3707 00001C26 C1C008              <1> 	rol	eax, 8		; 1.2.3.s
  3708 00001C29 6631C9              <1> 	xor	cx, cx
  3709 00001C2C 88C5                <1> 	mov	ch, al		; keep 8 sign bits
  3710 00001C2E E8B2FFFFFF          <1> 	call	field_scale
  3711                              <1> ;	call	scale8
  3712                              <1> ;	mov	al, ah		; reverse 8 rotate positions
  3713                              <1> ;	ror	eax, 8
  3714 00001C33 0FB6D9              <1> 	movzx	ebx, cl
  3715                              <1> ;	and	cl, 7		; last part rotate
  3716                              <1> ;	xor	al, al
  3717                              <1> ;	rol	eax, cl
  3718                              <1> ;	or	ah, al
  3719 00001C36 C1E808              <1> 	shr	eax, 8
  3720 00001C39 C3                  <1> 	ret
  3721                              <1> 
  3722 00001C3A E80AE7FFFF          <1> _lsc:	call	_operand_read
  3723 00001C3F E8DCFFFFFF          <1> 	call	qscale
  3724 00001C44 895D14              <1> 	mov	dword ptr [ebp+B], ebx	; store the scale
  3725 00001C47 894510              <1> 	mov	dword ptr [ebp+A], eax	; store the rotated value
  3726 00001C4A C3                  <1> 	ret
  3727                              <1> 
  3728 00001C4B E89BE6FFFF          <1> _dlsc:	call	_burst_read2
  3729 00001C50 894510              <1> 	mov	dword ptr [ebp+A], eax		; keep original 1st word
  3730 00001C53 C1E008              <1> 	shl	eax, 8
  3731 00001C56 C1F808              <1> 	sar	eax, 8
  3732 00001C59 C1C008              <1> 	rol	eax, 8
  3733 00001C5C 6631C9              <1> 	xor	cx, cx
  3734 00001C5F 88C5                <1> 	mov	ch, al				; keep 8 sign bits
  3735 00001C61 E87FFFFFFF          <1> 	call	field_scale
  3736 00001C66 20C0                <1> 	and	al, al
  3737 00001C68 7415                <1> 	jz	_dlsc24				; if the first word is all signs
  3738                              <1> ;	call	scale8
  3739 00001C6A 0FB6C1              <1> 	movzx	eax, cl
  3740 00001C6D 894518              <1> 	mov	dword ptr [ebp+MANTISSA2], eax	; store the scale
  3741 00001C70 8B4510              <1> 	mov	eax, dword ptr [ebp+A]		; retrieve the input high order word
  3742 00001C73 E8DAFDFFFF          <1> 	call	drl				; scale the two input words per cl
  3743 00001C78 895D14              <1> 	mov	dword ptr [ebp+B], ebx
  3744 00001C7B 894510              <1> 	mov	dword ptr [ebp+A], eax  	; store the rotated value
  3745 00001C7E C3                  <1> 	ret
  3746                              <1> 
  3747                              <1> _dlsc24:				; different when high order word is all signs
  3748 00001C7F C1E808              <1> 	shr	eax, 8			; one result word of signs
  3749 00001C82 894514              <1> 	mov	dword ptr [ebp+B], eax	; into the low-order result word
  3750 00001C85 89D8                <1> 	mov	eax, ebx		; scale the low-order input
  3751 00001C87 C1E008              <1> 	shl	eax, 8
  3752 00001C8A 30C9                <1> 	xor	cl, cl			; restart the scale count-up
  3753 00001C8C E854FFFFFF          <1> 	call	field_scale
  3754 00001C91 80C118              <1> 	add	cl, 24			; restore the early part of the count-up
  3755                              <1> ;	call	scale8
  3756 00001C94 0FB6D9              <1> 	movzx	ebx, cl
  3757 00001C97 895D18              <1> 	mov	dword ptr [ebp+MANTISSA2], ebx	; store the scale
  3758                              <1> ;	mov	al, ah
  3759                              <1> ;	ror	eax, 8			; reverse the last 8 rotation positions
  3760                              <1> ;	and	cl, 7			; do the last part of the rotate
  3761                              <1> ;	xor	al, al
  3762                              <1> ;	rol	eax, 7
  3763                              <1> ;	or	ah, al
  3764 00001C9A C1E808              <1> 	shr	eax, 8
  3765 00001C9D 894510              <1> 	mov	dword ptr [ebp+A], eax	; store the rotated value
  3766 00001CA0 C3                  <1> 	ret
  3767                              <1> 
  3768                              <1> 	%if	0
  3769                              <1> 
  3770                              <1> _fpx:	call	_burst_read2		; data read in eax ebx
  3771                              <1> 	push	ebx			; ebx is used in RTA1 stack frame
  3772                              <1> 	call	stack4			; construct RTA1 stack frame
  3773                              <1> 
  3774                              <1> 	shl	eax, 4			; move 12 mantissa bits out of eax
  3775                              <1> 	movsx	ecx, ax			; and extend the normalising bit
  3776                              <1> 
  3777                              <1> 	rol	eax, 4+1		; shelter sign in eax bit 0
  3778                              <1> 	shl	ax, 12			; better still in eax bit 12
  3779                              <1> 	sar	eax, 12			; propagate the value at midpoint position
  3780                              <1> 	ror	eax, 1			; have the sign back
  3781                              <1> 	shr	eax, 8			; clear eax 31..24
  3782                              <1> 	xor	eax, 003ffc00h		; reverse the 12 copies of midpoint bit
  3783                              <1> 					; yon's ra complicated bit done
  3784                              <1> 	mov	dword ptr [ebp+ebx*4], eax
  3785                              <1> 
  3786                              <1> 	xor	eax, ecx		; is the normalising bit opposite to signs ?
  3787                              <1> 	test	eax, 00800000h
  3788                              <1> 	jz	_fpx_allsigns		; no so unnormalised = zero
  3789                              <1> 
  3790                              <1> 	pop	eax			; the 2nd operand word, ya remember?
  3791                              <1> 	shl	eax, 4			; get them 2 halves over the centre
  3792                              <1> 
  3793                              <1> 	shr	cx, 4			; zero quartets at high order of 16 bits
  3794                              <1> 	shr	ax, 4
  3795                              <1> 
  3796                              <1> 	xchg	ax, cx			; low-order mantissa bits with unsigns in ecx
  3797                              <1> 					; high-order mantissa bits with middle part in eax
  3798                              <1> 
  3799                              <1> 	shl	eax, 4			; LLLz | HHHz
  3800                              <1> 	shr	ax, 4			; LLLz | zHHH
  3801                              <1> 	rol	eax, 12			; zzHH | HLLL
  3802                              <1> 
  3803                              <1> 	mov	dword ptr [ebp+ebx*4+1*4], eax
  3804                              <1> 	rol	ecx, 12
  3805                              <1> 	xor	ecx, 0FFFh		; 12 normalising bits = 12 inverted signs
  3806                              <1> 	mov	dword ptr [ebp+ebx*4+2*4], ecx
  3807                              <1> 	not	ecx			; convert high order quartet to signs
  3808                              <1> 	sar	ecx, 20			; 24 of them
  3809                              <1> 	shr	ecx, 8
  3810                              <1> 	mov	dword ptr [ebp+ebx*4+3*4], ecx
  3811                              <1> 	mov	ebp, dword ptr [_register_set]
  3812                              <1> 	mov	dword ptr [ebp+S_P], ebx	; update whichever sp that is
  3813                              <1> 	ret
  3814                              <1> 
  3815                              <1> _fpx_allsigns:
  3816                              <1> 	add	esp, 4			; take saved operand word back from stack
  3817                              <1> 	sar	ecx, 8			; 16 unnormalised normalising bits
  3818                              <1> 	shr	ecx, 8			; = 24 sign bits
  3819                              <1> 
  3820                              <1> 	mov	dword ptr [ebp+ebx*4], ecx
  3821                              <1> 	mov	dword ptr [ebp+ebx*4+1*4], ecx
  3822                              <1> 	mov	dword ptr [ebp+ebx*4+2*4], ecx
  3823                              <1> 	mov	dword ptr [ebp+ebx*4+3*4], ecx
  3824                              <1> 
  3825                              <1> 	mov	ebp, dword ptr [_register_set]
  3826                              <1> 	mov	dword ptr [ebp+S_P], ebx	; update whichever sp that is
  3827                              <1> 	ret
  3828                              <1> 
  3829                              <1> _fpp:	call	stack_read4
  3830                              <1> 	push	eax				; thats EA
  3831                              <1> 
  3832                              <1> 	mov	eax, dword ptr [ebp+ebx*4]	; s + 23 exponent bits
  3833                              <1> 	rol	eax, 8+2			; save sign and midpoint
  3834                              <1> 	shl	eax, 12				; squeeze out 12 exponent bits
  3835                              <1> 	shr	ax, 12				; bring sign + midpoint back
  3836                              <1> 	ror	eax, 2				; and roll them back in
  3837                              <1> 	shr	eax, 4				; position 12 bits low in 16 bits
  3838                              <1> 	mov	ecx, dword ptr [ebp+ebx*4+1*4]	; take 1st mantissa word from the stack
  3839                              <1> 	ror	ecx, 12				; rotate 12 bits down
  3840                              <1> 	shl	cx, 4				; position 12 bits high in 16 bits
  3841                              <1> 	mov	ax, cx				; merge
  3842                              <1> 	shr	eax, 4				; position 24 bits low in 32 bits
  3843                              <1> 	mov	dword ptr [ebp+ebx*4], eax	; place back in RTA1 stack frame
  3844                              <1> 						; next 12 mantissa bits in ecx 31..20
  3845                              <1> 
  3846                              <1> 	mov	eax, dword ptr [ebp+ebx*4+2*4]	; read 24 more
  3847                              <1> 	shr	eax, 12-4			; position 12 bits at ax 15..4
  3848                              <1> 	shr	ecx, 4				;				
  3849                              <1> 	mov	cx, ax				; juxtapose with mantissa 23..12
  3850                              <1> 	shr	ecx, 4				; wirraff
  3851                              <1> 
  3852                              <1> 	mov	dword ptr [ebp+ebx*4+1*4], ecx	; making 2nd and final output word
  3853                              <1> 
  3854                              <1> 	pop	eax				; recover EA
  3855                              <1> 	mov	ebp, dword ptr [_register_set]	; do this after all stack_readX
  3856                              <1> 	jmp	_burst_write2
  3857                              <1> 
  3858                              <1> 	%endif
  3859                                  	%include	"fpu.msm"
  3860                              <1> compress4to8:			; readout floating operand
  3861                              <1> 				; and pack to 32-bit words
  3862                              <1> 				; for 1 bit-distance shifting
  3863                              <1> 				; acquired operand is in 1st half of 
  3864                              <1> 				; 8-register block [esi]
  3865                              <1> 
  3866 00001CA1 8B06                <1> 	mov	eax, dword ptr [esi]	; 1s-complement scale field
  3867 00001CA3 C1E008              <1> 	shl	eax, 8			; 1st data bit reveals sign
  3868 00001CA6 C1F808              <1> 	sar	eax, 8			; propagate that sign some
  3869 00001CA9 89C3                <1> 	mov	ebx, eax
  3870 00001CAB C1F818              <1> 	sar	eax, 24			; propagate signs to 32 bits
  3871 00001CAE 31C3                <1> 	xor	ebx, eax		; change scale to unsigned magnitude
  3872 00001CB0 891E                <1> 	mov	dword ptr [esi], ebx	; position scale magnitude in 1st register
  3873 00001CB2 89461C              <1> 	mov	dword ptr [esi+7*4], eax	; 96 trailing signs
  3874 00001CB5 894618              <1> 	mov	dword ptr [esi+6*4], eax
  3875 00001CB8 894614              <1> 	mov	dword ptr [esi+5*4], eax
  3876 00001CBB 8B5E0C              <1> 	mov	ebx, dword ptr [esi+3*4]	; read low-order mantissa word
  3877 00001CBE 88D8                <1> 	mov	al, bl				; low-order octet
  3878 00001CC0 C1C808              <1> 	ror	eax, 8				; is followed by 24 signs
  3879 00001CC3 894610              <1> 	mov	dword ptr [esi+4*4], eax	; ebx also contains mantissa 23..8
  3880                              <1> 						; in positions 23..8
  3881                              <1> 
  3882 00001CC6 8B4608              <1> 	mov	eax, dword ptr [esi+2*4]	; eax now contains mantissa 47..24
  3883 00001CC9 C1E308              <1> 	shl	ebx, 8
  3884 00001CCC 6689C3              <1> 	mov	bx, ax				; mantissa 39..24 -> ebx
  3885 00001CCF C1C310              <1> 	rol	ebx, 16				; ebx now contains mantissa 40..8
  3886 00001CD2 895E0C              <1> 	mov	dword ptr [esi+3*4], ebx
  3887 00001CD5 8B5E04              <1> 	mov	ebx, dword ptr [esi+1*4]	; mantissa 71..48
  3888 00001CD8 C1E308              <1> 	shl	ebx, 8
  3889 00001CDB C1E810              <1> 	shr	eax, 16				; mantissa 47..40
  3890 00001CDE 88C3                <1> 	mov	bl, al
  3891 00001CE0 895E08              <1> 	mov	dword ptr [esi+2*4], ebx	; mantissa 71..40
  3892 00001CE3 8B4614              <1> 	mov	eax, dword ptr [esi+5*4]	; copy 32 signs
  3893 00001CE6 894604              <1> 	mov	dword ptr [esi+1*4], eax	; to 2nd word of register block
  3894 00001CE9 C3                  <1> 	ret
  3895                              <1> 
  3896                              <1> 
  3897                              <1> ;	___________________________________
  3898                              <1> ;	| magnitude scale|     32 signs   |
  3899                              <1> ;	|________________|________________|
  3900                              <1> ;	| platform word 7| platform word 6|
  3901                              <1> 
  3902                              <1> 
  3903                              <1> ;	<------------ 168-bit mantissa 167..72-------------|
  3904                              <1> ;	<------------  72-bit mantissa ------>
  3905                              <1> ;	_____________|___________|____________|____________________________
  3906                              <1> ;	|      24    | 8 |   16  |   16   | 8 |    24 signs|96 more signs for
  3907                              <1> ;	|____________|___|______ |________|___|____________|residue calculation
  3908                              <1> ;	| platform word 5| platform word 4|   +rounding <--- @  96-bit operation
  3909                              <1> 
  3910                              <1> ;	                 <---------------------------------[ platform words 2..0
  3911                              <1> ;	                 :
  3912                              <1> ;	                 [                                                  ]
  3913                              <1> 
  3914                              <1> ;	                 |--- 168-bit mantissa 71:0   -------->
  3915                              <1> ;	                      rounding @ 192-bit operation --->+
  3916                              <1> ;      	                 _________________________|____________|_____________
  3917                              <1> ;	                 |      24    | 8 |   16  |   16   | 8 |    24 signs|
  3918                              <1> ;	                 |____________|___|_______|________|___|____________|
  3919                              <1> ;	                 | platform word 2| platform word 1| platform word 0|
  3920                              <1> 
  3921                              <1> ;	                 |    residue rounding -->+
  3922                              <1> ;	                 |--- 144-bit mantissa -->	                                    
  3923                              <1> 
  3924                              <1> _deliver_edi:
  3925 00001CEA 89FE                <1> 	mov	esi, edi
  3926                              <1> _deliver_:
  3927 00001CEC F705[00000000]0800- <1> 	test	dword ptr [_psr], FP_R
  3928 00001CF4 0000                <1>
  3929 00001CF6 0F8480000000        <1> 	jz	near _deliver
  3930 00001CFC 53                  <1> 	push	ebx		; save result register index
  3931 00001CFD 8B1E                <1> 	mov	ebx, dword ptr [esi]		; read scale unsigned magnitude
  3932                              <1> 						; not yet signed
  3933                              <1> 
  3934                              <1> 				; all results except scale have been polarised
  3935                              <1> 				; ebx = positive magnitude of major exponent
  3936                              <1> 				; deliver floating residue
  3937 00001CFF 81C3B8FFFFFF        <1> 	add	ebx, -72	; calculate exponent of residue
  3938 00001D05 B148                <1> 	mov	cl, 72
  3939                              <1> 
  3940 00001D07 8B4610              <1> 	mov	eax, dword ptr [esi+4*4]	; mantissa */ 64 bits
  3941 00001D0A C1E008              <1> 	shl	eax, 8		; separate residual mantissa
  3942 00001D0D C1E808              <1> 	shr	eax, 8
  3943 00001D10 50                  <1> 	push	eax
  3944 00001D11 8B4614              <1> 	mov	eax, dword ptr [esi+5*4]	; mantissa */ 96 bits
  3945 00001D14 50                  <1> 	push	eax
  3946 00001D15 8B4618              <1> 	mov	eax, dword ptr [esi+6*4]	; mantissa */ 128 bits
  3947 00001D18 668B4604            <1> 	mov	ax, word ptr [esi+1*4]		; change low-order half trailing word to signs
  3948 00001D1C 50                  <1> 	push	eax				; before normalising
  3949                              <1> 
  3950                              <1> _normalise_residue:
  3951 00001D1D 8B442408            <1> 	mov	eax, dword ptr [esp+2*4]	; residual mantissa high-order word
  3952 00001D21 334604              <1> 	xor	eax, dword ptr [esi+1*4]	; signs
  3953 00001D24 2500008000          <1> 	and	eax, 00800000h			; normalising position
  3954 00001D29 751D                <1> 	jnz	_residue_normalised
  3955 00001D2B 8B4604              <1> 	mov	eax, dword ptr [esi+1*4]	; signs again
  3956 00001D2E D1D0                <1> 	rcl	eax, 1				; place a sign in carry				
  3957 00001D30 D11424              <1> 	rcl	dword ptr [esp], 1		; rotate 96 bits residual mantissa
  3958 00001D33 D1542404            <1> 	rcl	dword ptr [esp+1*4], 1
  3959 00001D37 D1542408            <1> 	rcl	dword ptr [esp+2*4], 1		; thirdly the high-order word
  3960 00001D3B 81C3FFFFFFFF        <1> 	add	ebx, -1
  3961 00001D41 80C1FF              <1> 	add	cl, -1
  3962 00001D44 72D7                <1> 	jc	_normalise_residue
  3963 00001D46 31DB                <1> 	xor	ebx, ebx			; residue all signs zero -> scale
  3964                              <1> _residue_normalised:
  3965 00001D48 F7C3000080FF        <1> 	test	ebx, 0FF800000h
  3966 00001D4E 7574                <1> 	jnz	_xpo4				; nonzero mantissa
  3967                              <1> 						; and exponent underflow / overflow
  3968                              <1> 						
  3969                              <1> ;			residual mantissa on the stack now is
  3970                              <1> ;			______________________________________________
  3971                              <1> ;	sp------------->| mantissa bits 15..0 | 16 sign bits discard |
  3972                              <1> ;			|_____________________|______________________|
  3973                              <1> ;			|            mantissa bits 47..16            |
  3974                              <1> ;			|____________________________________________| 
  3975                              <1> ;			| 0000 0000  mantissa bits 71..48            |
  3976                              <1> ;			|____________________________________________|
  3977                              <1> ;			|	     result register indication      |
  3978                              <1> ;			|____________________________________________|
  3979                              <1> 
  3980 00001D50 8B4604              <1> 	mov	eax, dword ptr [esi+1*4]	; signs
  3981 00001D53 31D8                <1> 	xor	eax, ebx			; sign residue exponent now
  3982 00001D55 C1E008              <1> 	shl	eax, 8				; trim characteristic to RTA1 24-bit word
  3983 00001D58 C1E808              <1> 	shr	eax, 8
  3984 00001D5B 894520              <1> 	mov	dword ptr [ebp+8*4], eax	; scale XOR signs -> residue characteristic
  3985                              <1> 
  3986 00001D5E 5B                  <1> 	pop	ebx				; low order mantissa part
  3987 00001D5F 58                  <1> 	pop	eax				; middle order mantissa part
  3988 00001D60 88C3                <1> 	mov	bl, al				; donate 8 bits
  3989 00001D62 C1CB08              <1> 	ror	ebx, 8				; distribute as RTA1 24-bit words
  3990 00001D65 C1EB08              <1> 	shr	ebx, 8				; mantissa 23..0
  3991 00001D68 C1E808              <1> 	shr	eax, 8				; mantissa 47..24
  3992 00001D6B 895D2C              <1> 	mov	dword ptr [ebp+11*4], ebx
  3993 00001D6E 894528              <1> 	mov	dword ptr [ebp+10*4], eax
  3994 00001D71 58                  <1> 	pop	eax				; high order residual mantissa part
  3995 00001D72 5B                  <1> 	pop	ebx				; saved result register index
  3996 00001D73 C1E008              <1> 	shl	eax, 8
  3997 00001D76 C1E808              <1> 	shr	eax, 8				; normalising position is bit 23
  3998 00001D79 894524              <1> 	mov	dword ptr [ebp+9*4], eax	; mantissa 71..48
  3999                              <1> 
  4000                              <1> _deliver:					; deliver floating result
  4001                              <1> 						; ebx = target register index
  4002                              <1> 						; result register index [ebp+]ebx*4
  4003 00001D7C 8B06                <1> 	mov	eax, dword ptr [esi]		; unsigned scale magnitude
  4004 00001D7E A9000080FF          <1> 	test	eax, 0FF800000h
  4005 00001D83 0F8563F4FFFF        <1> 	jnz	_fpxpo				; exponent underflow / overflow
  4006 00001D89 334604              <1> 	xor	eax, dword ptr [esi+1*4]	; sign it
  4007 00001D8C C1E008              <1> 	shl	eax, 8
  4008 00001D8F C1E808              <1> 	shr	eax, 8
  4009                              <1> 
  4010                              <1> _store_float
  4011 00001D92 89449D00            <1>         mov     dword ptr [ebp+ebx*4], eax      ; store characteristic = scale XOR signs
  4012 00001D96 8B4608              <1>         mov     eax, dword ptr [esi+2*4]	; read bits 71..40 major mantissa
  4013 00001D99 0FB6C8              <1>         movzx   ecx, al
  4014 00001D9C C1E808              <1>         shr     eax, 8
  4015 00001D9F 89449D04            <1>         mov     dword ptr [ebp+ebx*4+4], eax	; store mantissa bits 71..48
  4016 00001DA3 8B460C              <1>         mov     eax, dword ptr [esi+3*4]	; read mantissa bits 39..8
  4017 00001DA6 C1E110              <1>         shl     ecx, 16				; position mantissa bits 47..40
  4018 00001DA9 C1C810              <1>         ror     eax, 16
  4019 00001DAC 6689C1              <1>         mov     cx, ax				; position mantissa bits 39..24
  4020 00001DAF 894C9D08            <1>         mov     dword ptr [ebp+ebx*4+8], ecx	; store mantissa bits 47..24
  4021 00001DB3 8B4E10              <1>         mov     ecx, dword ptr [esi+4*4]	; read mantissa bits 7..0 plus 24 trailing bits
  4022 00001DB6 C1E910              <1>         shr     ecx, 16				; position after mantissa 23..8
  4023 00001DB9 6689C8              <1>         mov     ax, cx
  4024 00001DBC C1E808              <1>         shr     eax, 8				; store mantissa bits 23..0
  4025 00001DBF 89449D0C            <1>         mov     dword ptr [ebp+ebx*4+12], eax
  4026 00001DC3 C3                  <1> 	ret
  4027                              <1> 
  4028 00001DC4 5B                  <1> _xpo4:	pop	ebx				; exponent underflow / overflow
  4029 00001DC5 5B                  <1> 	pop	ebx				; with 128 bits on the stack
  4030 00001DC6 5B                  <1> 	pop	ebx
  4031 00001DC7 5B                  <1> 	pop	ebx
  4032 00001DC8 E91FF4FFFF          <1> 	jmp	_fpxpo
  4033                              <1> 
  4034                              <1> 
  4035                              <1> ;	_output equ	272
  4036                              <1> ;	_inputr equ	264
  4037                              <1> ;	_input2 equ	256
  4038                              <1> 
  4039                              <1> ;	_OUTPUT	equ	__register+_output*4
  4040                              <1> ;	_INPUTR equ	__register+_inputr*4
  4041                              <1> ;	_INPUT2 equ	__register+_input2*4
  4042                              <1> ;	_BIAS	equ	_OUTPUT
  4043                              <1> 
  4044                              <1> zoutput:
  4045 00001DCD 31C0                <1> 	xor	eax, eax
  4046 00001DCF 8906                <1> 	mov	dword ptr [esi], eax
  4047 00001DD1 894604              <1> 	mov	dword ptr [esi+1*4], eax
  4048 00001DD4 894608              <1> 	mov	dword ptr [esi+2*4], eax
  4049 00001DD7 89460C              <1> 	mov	dword ptr [esi+3*4], eax
  4050 00001DDA 894610              <1> 	mov	dword ptr [esi+4*4], eax
  4051 00001DDD 894614              <1> 	mov	dword ptr [esi+5*4], eax
  4052 00001DE0 894618              <1> 	mov	dword ptr [esi+6*4], eax
  4053 00001DE3 89461C              <1> 	mov	dword ptr [esi+7*4], eax
  4054 00001DE6 C3                  <1> 	ret
  4055                              <1> 
  4056                              <1> 
  4057                              <1> ;	round before add or divide
  4058                              <1> ;	XOR rounding pattern to guard field
  4059                              <1> 
  4060 00001DE7 0FB6DD              <1> round1:	movzx	ebx, ch
  4061 00001DEA A1[4C020000]        <1> 	mov	eax, dword ptr [__register+FP_GUARD]
  4062 00001DEF D3E8                <1> 	shr	eax, cl
  4063 00001DF1 C1E008              <1> 	shl	eax, 8
  4064 00001DF4 31449F08            <1> 	xor	dword ptr [edi+ebx*4+2*4], eax
  4065 00001DF8 C3                  <1> 	ret
  4066                              <1> 
  4067 00001DF9 0FB6DD              <1> round2:	movzx	ebx, ch
  4068 00001DFC A1[4C020000]        <1> 	mov	eax, dword ptr [__register+FP_GUARD]
  4069 00001E01 D3E8                <1> 	shr	eax, cl
  4070 00001E03 C1E008              <1> 	shl	eax, 8
  4071 00001E06 01449F08            <1> 	add	dword ptr [edi+ebx*4+2*4], eax
  4072                              <1> round2more:
  4073 00001E0A 81549F0400000000    <1> 	adc	dword ptr [edi+ebx*4+1*4], 0
  4074 00001E12 4B                  <1> 	dec	ebx
  4075 00001E13 75F5                <1> 	jnz	round2more
  4076 00001E15 C3                  <1> 	ret
  4077                              <1> 
  4078                              <1> end_around_down:
  4079 00001E16 B8FFFFFFFF          <1> 	mov	eax, -1
  4080 00001E1B D3E8                <1> 	shr	eax, cl
  4081 00001E1D F7D0                <1> 	not	eax
  4082 00001E1F E907000000          <1> 	jmp	eoc1
  4083                              <1> end_around_carry:
  4084 00001E24 B801000000          <1> 	mov	eax, 1				; don't call this if there is no carry
  4085 00001E29 D3C8                <1> 	ror	eax, cl
  4086                              <1> 
  4087 00001E2B 0FB6DD              <1> eoc1:	movzx	ebx, ch
  4088 00001E2E 01449F08            <1> 	add	dword ptr [edi+ebx*4+2*4], eax
  4089 00001E32 9C                  <1> 	pushf
  4090 00001E33 C1F81F              <1> 	sar	eax, 31
  4091 00001E36 9D                  <1> 	popf
  4092 00001E37 43                  <1> 	inc	ebx
  4093 00001E38 11049F              <1> eoc:	adc	dword ptr [edi+ebx*4], eax
  4094 00001E3B 4B                  <1> 	dec	ebx
  4095 00001E3C 75FA                <1> 	jnz	eoc
  4096 00001E3E C3                  <1> 	ret
  4097                              <1> 
  4098                              <1> restore_trailing_signs:
  4099 00001E3F 0FB6DD              <1> 	movzx	ebx, ch
  4100 00001E42 8B4704              <1> 	mov	eax, dword ptr [edi+1*4]
  4101                              <1> 
  4102 00001E45 89471C              <1> 	mov	dword ptr [edi+7*4], eax
  4103                              <1> 
  4104 00001E48 21C0                <1> 	and	eax, eax
  4105 00001E4A 780B                <1> 	js	restore_trailing_ones
  4106 00001E4C F7D0                <1> 	not	eax
  4107 00001E4E D3E8                <1> 	shr	eax, cl
  4108 00001E50 F7D0                <1> 	not	eax
  4109 00001E52 21449F08            <1> 	and	dword ptr [edi+ebx*4+2*4], eax
  4110 00001E56 C3                  <1> 	ret
  4111                              <1> restore_trailing_ones
  4112 00001E57 D3E8                <1> 	shr	eax, cl
  4113 00001E59 09449F08            <1> 	or	dword ptr [edi+ebx*4+2*4], eax
  4114 00001E5D C3                  <1> 	ret
  4115                              <1> 	
  4116                              <1> bias_addend:					; input mantissa [esi] is biased into location _BIAS
  4117 00001E5E 56                  <1> 	push	esi
  4118 00001E5F 57                  <1> 	push	edi
  4119                              <1> 
  4120 00001E60 BF[40040000]        <1> 	mov	edi, _BIAS
  4121 00001E65 E803000000          <1> 	call	biasfp
  4122                              <1> 
  4123 00001E6A 5F                  <1> 	pop	edi
  4124 00001E6B 5E                  <1> 	pop	esi
  4125 00001E6C C3                  <1> 	ret
  4126                              <1> 
  4127 00001E6D 52                  <1> biasfp:	push	edx
  4128 00001E6E 51                  <1> 	push	ecx
  4129                              <1> 
  4130 00001E6F BB01000000          <1> 	mov	ebx, 1				; output index
  4131 00001E74 66C1E003            <1> 	shl	ax, 3				; words sign fill
  4132 00001E78 C0E803              <1> 	shr	al, 3				; bits sign fill
  4133 00001E7B 6689C1              <1> 	mov	cx, ax
  4134 00001E7E 81C604000000        <1> 	add	esi, 4				; input pointer
  4135 00001E84 8B06                <1> 	mov	eax, dword ptr [esi]		; there shall be this word of signs at least
  4136                              <1> 
  4137 00001E86 89049F              <1> bias32:	mov	dword ptr [edi+ebx*4], eax	; write 1 word of signs
  4138 00001E89 43                  <1> 	inc	ebx				; consider the next output word
  4139 00001E8A FECD                <1> 	dec	ch				; any more words of signs?
  4140 00001E8C 79F8                <1> 	jns	bias32
  4141                              <1> 
  4142 00001E8E 20C9                <1> 	and	cl, cl
  4143 00001E90 742B                <1> 	jz	bias_fast			; there is no 32-bit shift
  4144                              <1> 
  4145 00001E92 B520                <1> 	mov	ch, 32				; demonstrate the missing advantage
  4146 00001E94 28CD                <1> 	sub	ch, cl				; of instruction architectures
  4147                              <1> 						; with 2-register shifts
  4148                              <1> biasup2:
  4149 00001E96 81FB08000000        <1> 	cmp	ebx, 8
  4150 00001E9C 743A                <1> 	jz	bias_addx
  4151 00001E9E 81C604000000        <1> 	add	esi, 4				; read new mantissa word
  4152 00001EA4 8B16                <1> 	mov	edx, dword ptr [esi]		; it becomes word # new in edx
  4153 00001EA6 86E9                <1> 	xchg	ch, cl
  4154 00001EA8 D3E0                <1> 	shl	eax, cl				; shift buffered word left 32 - bit offset
  4155 00001EAA 86E9                <1> 	xchg	ch, cl
  4156 00001EAC D3EA                <1> 	shr	edx, cl				; shift new mantissa word right bit offset
  4157 00001EAE 09D0                <1> 	or	eax, edx
  4158 00001EB0 89049F              <1> 	mov	dword ptr [edi+ebx*4], eax	; write 1 merged word
  4159 00001EB3 8B06                <1> 	mov	eax, dword ptr [esi]		; read the same mantissa word again
  4160 00001EB5 81C301000000        <1> 	add	ebx, 1				; it becomes word # previous in eax
  4161 00001EBB EBD9                <1> 	jmp	biasup2
  4162                              <1> 
  4163                              <1> bias_fast:
  4164 00001EBD 81FB08000000        <1> 	cmp	ebx, 8
  4165 00001EC3 7413                <1> 	jz	bias_addx
  4166 00001EC5 81C604000000        <1> 	add	esi, 4
  4167 00001ECB 8B06                <1> 	mov	eax, dword ptr [esi]
  4168 00001ECD 89049F              <1> 	mov	dword ptr [edi+ebx*4], eax
  4169 00001ED0 81C301000000        <1> 	add	ebx, 1
  4170 00001ED6 EBE5                <1> 	jmp	bias_fast
  4171                              <1> 
  4172                              <1> bias_addx:
  4173 00001ED8 59                  <1> 	pop	ecx
  4174 00001ED9 5A                  <1> 	pop	edx				; restore the program counter
  4175 00001EDA C3                  <1> 	ret
  4176                              <1> 
  4177                              <1> frame_mantissa:
  4178                              <1> ;	ror	ecx, 16				; words count is up, beats index down
  4179 00001EDB 80C501              <1> 	add	ch, 1				; up the beats index to beats count
  4180 00001EDE 66C1E905            <1> 	shr	cx, 5				; positions / 32 in ch
  4181 00001EE2 C0E903              <1> 	shr	cl, 3				; positions /// 32 in cl
  4182 00001EE5 0FB6DD              <1> 	movzx	ebx, ch				; derive platform words rounded down
  4183 00001EE8 C3                  <1> 	ret
  4184                              <1> 
  4185                              <1> renormalise:					; rule 1: restore sign fill in
  4186                              <1> 						; low-order containing platform word
  4187                              <1> ; done before end-around-carry, and saved
  4188                              <1> ;;	call	frame_mantissa			; it was mashed by rounding and adding
  4189 00001EE9 E851FFFFFF          <1> 	call	restore_trailing_signs
  4190 00001EEE C1C910              <1> 	ror	ecx, 16				; the governing parameter is now
  4191                              <1> 						; the containing words count in cx
  4192                              <1> renormalise32:
  4193 00001EF1 8B4708              <1> 	mov	eax, dword ptr [edi+2*4]	; sample 32 mantissa bits
  4194 00001EF4 3B4704              <1> 	cmp	eax, dword ptr [edi+1*4]	; compare it with 32 signs
  4195 00001EF7 750C                <1> 	jnz	renormalise8
  4196 00001EF9 E841000000          <1> 	call	rotate32left			; this also discovers if it's ALL signs = 0
  4197 00001EFE 21C0                <1> 	and	eax, eax			; and is the only place that needs examined
  4198 00001F00 75EF                <1> 	jnz	renormalise32
  4199                              <1> 
  4200 00001F02 8907                <1> 	mov	dword ptr [edi], eax		; mantissa is signed zero, +0 -> scale
  4201                              <1> renormalised:
  4202 00001F04 C3                  <1> 	ret
  4203                              <1> 
  4204                              <1> renormalise8:					; from this point on the value is nonzero
  4205 00001F05 C1C008              <1> 	rol	eax, 8				; are there 8 signs at head of mantissa?
  4206 00001F08 3A4707              <1> 	cmp	al, byte ptr [edi+1*4+3]	; this is Intel and the 4th byte is high-order
  4207 00001F0B 750A                <1> 	jnz	renormalise1			; you have found the 8 bits containing the
  4208                              <1> 						; normalising bit
  4209 00001F0D E84F000000          <1> 	call	rotate8left			; or else you haven't
  4210 00001F12 8B4708              <1> 	mov     eax, dword ptr [edi+2*4]	; sample the moved mantissa
  4211 00001F15 EBEE                <1> 	jmp	renormalise8
  4212                              <1> 
  4213                              <1> renormalise1:
  4214                              <1> ;	movzx	ebx, cx	
  4215 00001F17 8B4704              <1> 	mov	eax, dword ptr [edi+1*4]		
  4216                              <1> ;	mov	dword ptr [edi+ebx*4+1*4], eax	; in case polarity has changed
  4217 00001F1A 334708              <1> 	xor	eax, dword ptr [edi+2*4]	; normalising bit opposite polarity to sign?
  4218 00001F1D 78E5                <1> 	js	renormalised			; arrived
  4219 00001F1F E802000000          <1> 	call	bitwise_scale			; almost arrived
  4220 00001F24 EBF1                <1> 	jmp	renormalise1
  4221                              <1> 
  4222                              <1> 
  4223                              <1> bitwise_scale:
  4224 00001F26 D1571C              <1> 	rcl	dword ptr [edi+7*4], 1	; so it doesn't matter whether 0 or 1
  4225 00001F29 D15718              <1> 	rcl	dword ptr [edi+6*4], 1	; gets shifted into the 192nd bit
  4226 00001F2C D15714              <1> 	rcl	dword ptr [edi+5*4], 1
  4227 00001F2F D15710              <1> 	rcl	dword ptr [edi+4*4], 1	; it's quicker to shift 6 words
  4228 00001F32 D1570C              <1> 	rcl	dword ptr [edi+3*4], 1	; than a counted loop of 4 or 5 or 6 words
  4229 00001F35 D15708              <1> 	rcl	dword ptr [edi+2*4], 1
  4230                              <1> 
  4231 00001F38 8107FFFFFFFF        <1> 	add	dword ptr [edi], -1	; scale down
  4232 00001F3E C3                  <1> 	ret
  4233                              <1> 
  4234                              <1> rotate32left:				; rotate all containing platform words of mantissa
  4235 00001F3F 52                  <1> 	push	edx			; 32 bit positions left and report if all signs
  4236 00001F40 51                  <1> 	push	ecx
  4237 00001F41 0FB7D9              <1> 	movzx	ebx, cx
  4238 00001F44 31D2                <1> 	xor	edx, edx		; initialise equality = all signs
  4239                              <1> 
  4240                              <1> rotate32next:				; the word initially loaded in eax is all signs
  4241 00001F46 4B                  <1> 	dec	ebx
  4242 00001F47 87449F08            <1> 	xchg	eax, dword ptr [edi+ebx*4+2*4]
  4243 00001F4B 89C1                <1> 	mov	ecx, eax
  4244 00001F4D 334F04              <1> 	xor	ecx, dword ptr [edi+1*4] ; difference between this word and signs
  4245 00001F50 09CA                <1> 	or	edx, ecx		; sum of differences
  4246 00001F52 21DB                <1> 	and	ebx, ebx
  4247 00001F54 75F0                <1> 	jnz	rotate32next
  4248 00001F56 8107E0FFFFFF        <1> 	add	dword ptr [edi], -32	; scale down
  4249 00001F5C 89D0                <1> 	mov	eax, edx
  4250 00001F5E 59                  <1> 	pop	ecx
  4251 00001F5F 5A                  <1> 	pop	edx
  4252 00001F60 C3                  <1> 	ret
  4253                              <1> 
  4254                              <1> rotate8left:				; rotate all containing platform words of mantissa
  4255 00001F61 51                  <1> 	push	ecx			; 8 bit positions left. 1st word is rotated already
  4256 00001F62 0FB7D9              <1> 	movzx	ebx, cx			; and contains signs in 8 low-order bit positions
  4257                              <1> rotate8next:
  4258 00001F65 8B4C9F08            <1> 	mov	ecx, dword ptr [edi+ebx*4+2*4]
  4259 00001F69 C1C108              <1> 	rol	ecx, 8
  4260 00001F6C 86C1                <1> 	xchg	al, cl
  4261 00001F6E 894C9F08            <1> 	mov	dword ptr [edi+ebx*4+2*4], ecx
  4262 00001F72 81C3FFFFFFFF        <1> 	add	ebx, -1
  4263 00001F78 72EB                <1> 	jc	rotate8next
  4264 00001F7A 8107F8FFFFFF        <1> 	add	dword ptr [edi], -8	; scale down
  4265 00001F80 59                  <1> 	pop	ecx
  4266 00001F81 C3                  <1> 	ret
  4267                              <1> 
  4268 00001F82 F75608              <1> zover:	not	dword ptr [esi+2*4]
  4269 00001F85 F7560C              <1> 	not	dword ptr [esi+3*4]
  4270 00001F88 F75610              <1> 	not	dword ptr [esi+4*4]
  4271 00001F8B F75614              <1> 	not	dword ptr [esi+5*4]
  4272 00001F8E F75618              <1> 	not	dword ptr [esi+6*4]
  4273 00001F91 F7561C              <1> 	not	dword ptr [esi+7*4]
  4274 00001F94 C3                  <1> 	ret
  4275                              <1> 
  4276                              <1> _add_low:
  4277 00001F95 8B15[1C040000]      <1>         mov     edx, dword ptr [_INPUT2+7*4]
  4278 00001F9B 1315[3C040000]      <1>         adc     edx, dword ptr [_INPUTR+7*4]
  4279 00001FA1 8B1D[18040000]      <1>         mov     ebx, dword ptr [_INPUT2+6*4]
  4280 00001FA7 131D[38040000]      <1>         adc     ebx, dword ptr [_INPUTR+6*4]
  4281 00001FAD A1[14040000]        <1>         mov     eax, dword ptr [_INPUT2+5*4]
  4282 00001FB2 1305[34040000]      <1>         adc     eax, dword ptr [_INPUTR+5*4]
  4283 00001FB8 C3                  <1>         ret
  4284                              <1> 
  4285                              <1> _add_high:
  4286 00001FB9 8B15[10040000]      <1>         mov     edx, dword ptr [_INPUT2+4*4]
  4287 00001FBF 1315[30040000]      <1>         adc     edx, dword ptr [_INPUTR+4*4]
  4288 00001FC5 8B1D[0C040000]      <1>         mov     ebx, dword ptr [_INPUT2+3*4]
  4289 00001FCB 131D[2C040000]      <1>         adc     ebx, dword ptr [_INPUTR+3*4]
  4290 00001FD1 A1[08040000]        <1>         mov     eax, dword ptr [_INPUT2+2*4]
  4291 00001FD6 1305[28040000]      <1>         adc     eax, dword ptr [_INPUTR+2*4]
  4292 00001FDC C3                  <1>         ret
  4293                              <1> 
  4294 00001FDD BE[00040000]        <1> fan:	mov	esi, _INPUT2
  4295 00001FE2 E89BFFFFFF          <1> 	call	zover				; mantissa
  4296 00001FE7 F715[04040000]      <1> 	not	dword ptr [_INPUT2+1*4]		; 32 signs
  4297                              <1> 
  4298 00001FED BE[00040000]        <1> fa:	mov	esi, _INPUT2
  4299 00001FF2 BF[20040000]        <1> 	mov	edi, _INPUTR
  4300                              <1> 
  4301 00001FF7 8B4604              <1> 	mov	eax, dword ptr [esi+1*4]	; normalised?
  4302 00001FFA 334608              <1> 	xor	eax, dword ptr [esi+2*4]	; normalising bit must ^ signs
  4303 00001FFD 7801                <1> 	js	fa_addend_normalised		; yes
  4304 00001FFF C3                  <1> fa_nop:	ret					; accumulator block unchanged
  4305                              <1> 
  4306                              <1> fa_addend_normalised:
  4307 00002000 8B4704              <1> 	mov	eax, dword ptr [edi+1*4]	; register side operand normalised?
  4308 00002003 334708              <1> 	xor	eax, dword ptr [edi+2*4]	; normalising bit must ^ signs
  4309 00002006 7806                <1> 	js	fa_promote_magnitude		; normalised, get on with it
  4310 00002008 BF[00040000]        <1> 	mov	edi, _INPUT2			; accumulator block is not normalised
  4311 0000200D C3                  <1> 	ret					; storage addend zero-added
  4312                              <1> 
  4313                              <1> fa_promote_magnitude:
  4314                              <1> ;	mov	eax, dword ptr [esi]		; subtract addend2 scale magnitude
  4315                              <1> ;	neg	eax
  4316                              <1> ;	add	eax, dword ptr [edi]		; from target scale magnitude
  4317                              <1> 
  4318 0000200E 8B07                <1> 	mov	eax, dword ptr [edi]
  4319 00002010 2B06                <1> 	sub	eax, dword ptr [esi]
  4320                              <1> 
  4321 00002012 790C                <1> 	jns	fa_add				; register-side operand is not lower
  4322 00002014 BE[20040000]        <1> 	mov	esi, _INPUTR			; not so, importance is reversed
  4323 00002019 BF[00040000]        <1> 	mov	edi, _INPUT2
  4324 0000201E F7D8                <1> 	neg	eax
  4325                              <1> 
  4326                              <1> fa_add:	;	call	frame_mantissa
  4327 00002020 50                  <1> 	push	eax
  4328 00002021 E8C1FDFFFF          <1> 	call	round1
  4329                              <1> 
  4330 00002026 58                  <1> 	pop	eax
  4331                              <1> 
  4332 00002027 21C0                <1> 	and	eax, eax
  4333 00002029 7411                <1> 	jz	fa_addfast
  4334                              <1> 
  4335 0000202B 3DBF000000          <1> 	cmp	eax, 191			; do they touch?
  4336 00002030 77CD                <1> 	ja	fa_nop
  4337                              <1> 
  4338 00002032 E827FEFFFF          <1> 	call	bias_addend
  4339 00002037 BE[40040000]        <1> 	mov	esi, _BIAS			; shifted addend
  4340                              <1> 
  4341                              <1> fa_addfast:
  4342 0000203C 8B4704              <1> 	mov	eax, dword ptr [edi+1*4]
  4343 0000203F A3[40040000]        <1> 	mov	dword ptr [__register+272*4], eax	; destination signs
  4344                              <1> 
  4345 00002044 C1C910              <1> 	ror	ecx, 16				; get containing compute words
  4346 00002047 0FB7D9              <1> 	movzx	ebx, cx				; index / count
  4347 0000204A C1C910              <1> 	ror	ecx, 16
  4348                              <1> 
  4349 0000204D F8                  <1> 	clc
  4350                              <1> 
  4351                              <1> fa_action:
  4352 0000204E 8B049E              <1> 	mov	eax, dword ptr [esi+ebx*4]
  4353 00002051 11049F              <1> 	adc	dword ptr [edi+ebx*4], eax
  4354 00002054 4B                  <1> 	dec	ebx				; process word 1
  4355 00002055 75F7                <1> 	jnz	fa_action			; leave word 0 alone
  4356                              <1> 
  4357 00002057 A1[40040000]        <1> 	mov	eax, dword ptr [__register+272*4]
  4358 0000205C 334704              <1> 	xor	eax, dword ptr [edi+1*4]
  4359 0000205F 7933                <1> 	jns	fa_testcarry
  4360                              <1> 
  4361 00002061 F7571C              <1> 	not	dword ptr [edi+7*4]
  4362 00002064 F605[00000000]08    <1> 	test	byte ptr [_psr], 8
  4363 0000206B 7506                <1> 	jnz	switch_long
  4364                              <1> 
  4365 0000206D F75718              <1> 	not	dword ptr [edi+6*4]
  4366 00002070 F75714              <1> 	not	dword ptr [edi+5*4]
  4367                              <1> switch_long
  4368                              <1> 
  4369 00002073 F715[40040000]      <1> 	not	dword ptr [__register+272*4]	; thru zero
  4370 00002079 F705[40040000]FFFF- <1> 	test	dword ptr [__register+272*4], -1
  4371 00002081 FFFF                <1>
  4372 00002083 780A                <1> 	js	fa_change2negative
  4373                              <1> 
  4374 00002085 E89AFDFFFF          <1> 	call	end_around_carry
  4375                              <1> 
  4376 0000208A E905000000          <1> 	jmp	fa_testcarry
  4377                              <1> 
  4378                              <1> fa_change2negative:
  4379 0000208F E882FDFFFF          <1> 	call	end_around_down
  4380                              <1> 
  4381                              <1> fa_testcarry:
  4382                              <1> 
  4383 00002094 8B4704              <1> 	mov	eax, dword ptr [edi+1*4]
  4384 00002097 3305[40040000]      <1> 	xor	eax, dword ptr [__register+272*4]
  4385 0000209D A801                <1> 	test	al, 1
  4386 0000209F 7424                <1> 	jz	fa_normalise
  4387 000020A1 FF07                <1> 	inc	dword ptr [edi]			; exponent magnitude++
  4388                              <1> 
  4389 000020A3 D15F04              <1> 	rcr	dword ptr [edi+1*4], 1
  4390 000020A6 D15F08              <1> 	rcr	dword ptr [edi+2*4], 1
  4391 000020A9 D15F0C              <1> 	rcr	dword ptr [edi+3*4], 1
  4392 000020AC D15F10              <1> 	rcr	dword ptr [edi+4*4], 1
  4393 000020AF D15F14              <1> 	rcr	dword ptr [edi+5*4], 1
  4394 000020B2 D15F18              <1> 	rcr	dword ptr [edi+6*4], 1
  4395 000020B5 D15F1C              <1> 	rcr	dword ptr [edi+7*4], 1
  4396                              <1> 
  4397 000020B8 A1[40040000]        <1> 	mov	eax, dword ptr [__register+272*4]
  4398 000020BD 894704              <1> 	mov	dword ptr [edi+1*4], eax	; make sure that is one 
  4399                              <1> 						; complete word of signs again
  4400 000020C0 E905000000          <1> 	jmp	fa_normalised
  4401                              <1> 
  4402                              <1> fa_normalise:
  4403 000020C5 E81FFEFFFF          <1> 	call	renormalise			; in case the sum is plenty positions
  4404                              <1> fa_normalised					; below the fractional point
  4405 000020CA C3                  <1> 	ret
  4406                              <1> 	
  4407 000020CB BE[40040000]        <1> fm:	mov	esi, _OUTPUT			; initialise final accumulation
  4408 000020D0 E8F8FCFFFF          <1> 	call	zoutput
  4409                              <1> 
  4410 000020D5 8B1D[24040000]      <1> 	mov	ebx, dword ptr [_INPUTR+1*4]	; read register-side signs
  4411 000020DB A1[28040000]        <1> 	mov	eax, dword ptr [_INPUTR+2*4]	; and high-end mantissa
  4412 000020E0 31D8                <1> 	xor	eax, ebx	 		; cache if-normalised in eax
  4413 000020E2 331D[04040000]      <1> 	xor	ebx, dword ptr [_INPUT2+1*4]	; multiply signs
  4414 000020E8 891D[44040000]      <1> 	mov	dword ptr [_OUTPUT+1*4], ebx	; save the output sign
  4415 000020EE 21C0                <1> 	and	eax, eax			; test the cached if-normalised
  4416 000020F0 790D                <1> 	jns	fmdont
  4417                              <1> 
  4418 000020F2 A1[04040000]        <1> 	mov	eax, dword ptr [_INPUT2+1*4]	; is the multiplier normalised?
  4419 000020F7 3305[08040000]      <1> 	xor	eax, dword ptr [_INPUT2+2*4]	; sign XOR normalising bit?
  4420 000020FD 782F                <1> 	js	fmgo				; yes, proceed
  4421                              <1> 
  4422 000020FF 891D[48040000]      <1> fmdont:	mov	dword ptr [_OUTPUT+2*4], ebx
  4423 00002105 891D[4C040000]      <1> 	mov	dword ptr [_OUTPUT+3*4], ebx
  4424 0000210B 891D[50040000]      <1> 	mov	dword ptr [_OUTPUT+4*4], ebx
  4425 00002111 891D[54040000]      <1> 	mov	dword ptr [_OUTPUT+5*4], ebx
  4426 00002117 891D[58040000]      <1> 	mov	dword ptr [_OUTPUT+6*4], ebx
  4427 0000211D 891D[5C040000]      <1> 	mov	dword ptr [_OUTPUT+7*4], ebx
  4428 00002123 C705[40040000]0000- <1> 	mov	dword ptr [_OUTPUT], 0		; mantissa to go
  4429 0000212B 0000                <1>
  4430                              <1> 
  4431 0000212D C3                  <1> 	ret					; no, effective zero multiplier
  4432                              <1> 
  4433 0000212E 51                  <1> fmgo:	push	ecx
  4434 0000212F A1[24040000]        <1> 	mov	eax, dword ptr [_INPUTR+1*4]
  4435 00002134 B148                <1> 	mov	cl, 72				; beats count exactly 72
  4436 00002136 21C0                <1> 	and	eax, eax
  4437 00002138 790A                <1> 	jns	fmp1
  4438 0000213A BE[20040000]        <1> 	mov	esi, _INPUTR
  4439 0000213F E83EFEFFFF          <1> 	call	zover
  4440                              <1> 
  4441 00002144 A1[04040000]        <1> fmp1:	mov	eax, dword ptr [_INPUT2+1*4]
  4442 00002149 21C0                <1> 	and	eax, eax
  4443 0000214B 790A                <1> 	jns	fmadd
  4444 0000214D BE[00040000]        <1> 	mov	esi, _INPUT2
  4445 00002152 E82BFEFFFF          <1> 	call	zover
  4446                              <1> 
  4447 00002157 F8                  <1> fmadd:	clc
  4448                              <1> 
  4449 00002158 BE[20040000]        <1> 	mov	esi, _INPUTR
  4450 0000215D D15E08              <1> 	rcr	dword ptr [esi+2*4], 1		; addend shift right
  4451 00002160 D15E0C              <1> 	rcr	dword ptr [esi+3*4], 1
  4452 00002163 D15E10              <1> 	rcr	dword ptr [esi+4*4], 1
  4453 00002166 D15E14              <1> 	rcr	dword ptr [esi+5*4], 1
  4454 00002169 D15E18              <1> 	rcr	dword ptr [esi+6*4], 1
  4455 0000216C D15E1C              <1> 	rcr	dword ptr [esi+7*4], 1
  4456                              <1> 
  4457 0000216F BE[00040000]        <1> 	mov	esi, _INPUT2
  4458                              <1> ;	rcl	dword ptr [esi+7*4], 1		; multiplier shift left
  4459                              <1> ;	rcl	dword ptr [esi+6*4], 1
  4460                              <1> ;	rcl	dword ptr [esi+5*4], 1		; multiplier mantissa is only 72 bits
  4461 00002174 D15610              <1> 	rcl	dword ptr [esi+4*4], 1
  4462 00002177 D1560C              <1> 	rcl	dword ptr [esi+3*4], 1
  4463 0000217A D15608              <1> 	rcl	dword ptr [esi+2*4], 1
  4464                              <1> 
  4465 0000217D BE[40040000]        <1> 	mov	esi, _OUTPUT
  4466 00002182 7330                <1> 	jnc	fmadx
  4467                              <1> 						; 1 shifted from multiplier
  4468 00002184 A1[3C040000]        <1> fmadc:	mov	eax, dword ptr [_INPUTR+7*4]	
  4469 00002189 01461C              <1> 	add	dword ptr [esi+7*4], eax	; do not use carry
  4470 0000218C A1[38040000]        <1> 	mov	eax, dword ptr [_INPUTR+6*4]
  4471 00002191 114618              <1> 	adc	dword ptr [esi+6*4], eax	; start using carry
  4472 00002194 A1[34040000]        <1> 	mov	eax, dword ptr [_INPUTR+5*4]
  4473 00002199 114614              <1> 	adc	dword ptr [esi+5*4], eax
  4474 0000219C A1[30040000]        <1> 	mov	eax, dword ptr [_INPUTR+4*4]
  4475 000021A1 114610              <1> 	adc	dword ptr [esi+4*4], eax
  4476 000021A4 A1[2C040000]        <1> 	mov	eax, dword ptr [_INPUTR+3*4]
  4477 000021A9 11460C              <1> 	adc	dword ptr [esi+3*4], eax
  4478 000021AC A1[28040000]        <1> 	mov	eax, dword ptr [_INPUTR+2*4]
  4479 000021B1 114608              <1> 	adc	dword ptr [esi+2*4], eax
  4480                              <1> 
  4481 000021B4 FEC9                <1> fmadx:	dec	cl
  4482 000021B6 759F                <1> 	jnz	fmadd
  4483                              <1> 
  4484 000021B8 59                  <1> 	pop	ecx
  4485                              <1> 
  4486 000021B9 8B4608              <1> 	mov	eax, dword ptr [esi+2*4] 	; normalised?
  4487 000021BC D1D0                <1> 	rcl	eax, 1
  4488 000021BE 7221                <1> 	jc	fm_normalised
  4489                              <1> 
  4490 000021C0 8105[20040000]FFFF- <1> 	add	dword ptr [_INPUTR], -1		; take 1 from scale
  4491 000021C8 FFFF                <1>
  4492                              <1> 
  4493 000021CA D1561C              <1> 	rcl	dword ptr [esi+7*4], 1
  4494 000021CD D15618              <1> 	rcl	dword ptr [esi+6*4], 1
  4495 000021D0 D15614              <1> 	rcl	dword ptr [esi+5*4], 1
  4496 000021D3 D15610              <1> 	rcl	dword ptr [esi+4*4], 1
  4497 000021D6 D1560C              <1> 	rcl	dword ptr [esi+3*4], 1
  4498 000021D9 D15608              <1> 	rcl	dword ptr [esi+2*4], 1
  4499                              <1> 
  4500 000021DC E928000000          <1> 	jmp	fm_inrange
  4501                              <1> 
  4502                              <1> fm_normalised:
  4503 000021E1 BF[40040000]        <1> 	mov	edi, _OUTPUT
  4504                              <1> 
  4505 000021E6 E80EFCFFFF          <1> 	call	round2
  4506                              <1> 
  4507 000021EB 731C                <1> 	jnc	fm_inrange
  4508 000021ED D15E08              <1> 	rcr	dword ptr [esi+2*4], 1
  4509 000021F0 D15E0C              <1> 	rcr	dword ptr [esi+3*4], 1
  4510 000021F3 D15E10              <1> 	rcr	dword ptr [esi+4*4], 1
  4511 000021F6 D15E14              <1> 	rcr	dword ptr [esi+5*4], 1
  4512 000021F9 D15E18              <1> 	rcr	dword ptr [esi+6*4], 1
  4513 000021FC D15E1C              <1> 	rcr	dword ptr [esi+7*4], 1
  4514 000021FF 8105[20040000]0100- <1> 	add	dword ptr [_INPUTR], 1
  4515 00002207 0000                <1>
  4516                              <1> 
  4517                              <1> fm_inrange
  4518                              <1> 
  4519 00002209 A1[20040000]        <1> 	mov	eax, dword ptr [_INPUTR]
  4520 0000220E 0305[00040000]      <1> 	add	eax, dword ptr [_INPUT2]
  4521 00002214 050000C0FF          <1> 	add	eax, -00400000h
  4522 00002219 8906                <1> 	mov	dword ptr [esi], eax		; insert unsigned magnitude product scale
  4523 0000221B 8B4604              <1> 	mov	eax, dword ptr [esi+1*4]
  4524 0000221E 314608              <1> 	xor	dword ptr [esi+2*4], eax	; the mantissa gets polarised here
  4525 00002221 31460C              <1> 	xor	dword ptr [esi+3*4], eax
  4526 00002224 314610              <1> 	xor	dword ptr [esi+4*4], eax
  4527 00002227 314614              <1> 	xor	dword ptr [esi+5*4], eax
  4528 0000222A 314618              <1> 	xor	dword ptr [esi+6*4], eax
  4529 0000222D 31461C              <1> 	xor	dword ptr [esi+7*4], eax
  4530 00002230 C3                  <1> 	ret
  4531                              <1> 
  4532 00002231 BE[40040000]        <1> fd:	mov	esi, _OUTPUT
  4533 00002236 E892FBFFFF          <1> 	call	zoutput				; result which may stay zero
  4534 0000223B A1[04040000]        <1> 	mov	eax, dword ptr [_INPUT2+1*4]	; signs
  4535 00002240 89C3                <1> 	mov	ebx, eax
  4536 00002242 3305[08040000]      <1> 	xor	eax, dword ptr [_INPUT2+2*4]	; normalising bit 31
  4537 00002248 780C                <1> 	js	fdgo
  4538 0000224A F715[44040000]      <1> 	not	dword ptr [_OUTPUT+1*4]		; divisor 0 or otherwise unnormalised
  4539 00002250 E82DFDFFFF          <1> 	call	zover				; return -0.0
  4540 00002255 C3                  <1> fdnop:	ret					; not normalised = zero divisor
  4541                              <1> 
  4542 00002256 A1[24040000]        <1> fdgo:	mov     eax, dword ptr [_INPUTR+1*4]	; make sure the dividend is present
  4543 0000225B 3305[28040000]      <1> 	xor	eax, dword ptr [_INPUTR+2*4]	; normalising bit must be not sign
  4544 00002261 7833                <1> 	js	fdop				; go after all
  4545                              <1> 						; unnormalised = 0 = unnormalised
  4546 00002263 A1[24040000]        <1> 	mov	eax, dword ptr [_INPUTR+1*4]	; read the signs I tell you
  4547 00002268 C705[40040000]0000- <1> 	mov	dword ptr [_OUTPUT], 0		; exponent magnitude of nowhere
  4548 00002270 0000                <1>
  4549 00002272 A3[44040000]        <1> 	mov	dword ptr [_OUTPUT+1*4], eax	; signs
  4550 00002277 A3[48040000]        <1> 	mov	dword ptr [_OUTPUT+2*4], eax	; and as much mantissa as you like
  4551 0000227C A3[4C040000]        <1> 	mov	dword ptr [_OUTPUT+3*4], eax
  4552 00002281 A3[50040000]        <1> 	mov	dword ptr [_OUTPUT+4*4], eax
  4553 00002286 A3[54040000]        <1> 	mov	dword ptr [_OUTPUT+5*4], eax
  4554 0000228B A3[58040000]        <1> 	mov	dword ptr [_OUTPUT+6*4], eax
  4555 00002290 A3[5C040000]        <1> 	mov	dword ptr [_OUTPUT+7*4], eax
  4556 00002295 C3                  <1> 	ret
  4557                              <1> 
  4558 00002296 21DB                <1> fdop:	and	ebx, ebx			; divisor either is negative magnitude
  4559 00002298 780A                <1> 	js	fd_comp1	
  4560 0000229A BE[00040000]        <1> 	mov	esi, _INPUT2			; or shall be
  4561 0000229F E8DEFCFFFF          <1> 	call	zover
  4562                              <1> fd_comp1:
  4563 000022A4 F705[24040000]0000- <1> 	test	dword ptr [_INPUTR+1*4], 080000000h
  4564 000022AC 0080                <1>
  4565 000022AE 740A                <1> 	jz	fd_upright			; dividend must be positive magnitude
  4566 000022B0 BE[20040000]        <1> 	mov	esi, _INPUTR
  4567 000022B5 E8C8FCFFFF          <1> 	call	zover
  4568                              <1> fd_upright:
  4569 000022BA BF[20040000]        <1> 	mov	edi, _INPUTR
  4570 000022BF E823FBFFFF          <1> 	call	round1				; this also sets counters
  4571                              <1> 
  4572 000022C4 52                  <1> 	push	edx
  4573 000022C5 51                  <1> 	push	ecx
  4574                              <1> 
  4575                              <1> ;	add	cx, 01818h		; a divide needs 24 more beats
  4576                              <1> 					; than a multiply
  4577                              <1> 
  4578 000022C6 89C8                <1> 	mov	eax, ecx		; save words count in add range
  4579 000022C8 B15F                <1> 	mov	cl, 95
  4580                              <1> 
  4581 000022CA C1E810              <1> 	shr	eax, 16			; isolate words count in add range
  4582 000022CD 6605FAFF            <1> 	add	ax, -6			; is it big?
  4583 000022D1 0F8390000000        <1> 	jnc	near fd_72
  4584                              <1> 
  4585                              <1> ;	test	ch, 128
  4586                              <1> ;	jz	near fd_72
  4587                              <1> 
  4588 000022D7 89E7                <1> 	mov	edi, esp
  4589                              <1> 
  4590 000022D9 B1BF                <1> 	mov	cl, 191			; maybe
  4591                              <1> 
  4592 000022DB F9                  <1> fd_144:	stc				; add negative mantissa
  4593 000022DC E8B4FCFFFF          <1> 	call	_add_low		; to positive dividend
  4594 000022E1 52                  <1> 	push	edx			; save the low half in the stack
  4595 000022E2 53                  <1> 	push	ebx
  4596 000022E3 50                  <1> 	push	eax
  4597 000022E4 E8D0FCFFFF          <1> 	call	_add_high			; add the high half in eax edx ebx
  4598                              <1> 
  4599 000022E9 7323                <1> 	jnc	fd_144level			; no carry = drop the result
  4600                              <1> 
  4601 000022EB A3[28040000]        <1> 	mov	dword ptr [_INPUTR+2*4], eax	; carry = update the dividend
  4602 000022F0 891D[2C040000]      <1> 	mov	dword ptr [_INPUTR+3*4], ebx
  4603 000022F6 8915[30040000]      <1> 	mov	dword ptr [_INPUTR+4*4], edx
  4604                              <1> 
  4605 000022FC 58                  <1> 	pop	eax
  4606 000022FD A3[34040000]        <1> 	mov	dword ptr [_INPUTR+5*4], eax
  4607 00002302 58                  <1> 	pop	eax
  4608 00002303 A3[38040000]        <1> 	mov	dword ptr [_INPUTR+6*4], eax
  4609 00002308 58                  <1> 	pop	eax
  4610 00002309 A3[3C040000]        <1> 	mov	dword ptr [_INPUTR+7*4], eax
  4611                              <1> fd_144level:
  4612 0000230E 89FC                <1> 	mov	esp, edi			; clear stack whether popped or not
  4613 00002310 D115[5C040000]      <1> 	rcl	dword ptr [_OUTPUT+7*4], 1	; shift value of carry into quotient
  4614 00002316 D115[58040000]      <1> 	rcl	dword ptr [_OUTPUT+6*4], 1
  4615 0000231C D115[54040000]      <1> 	rcl	dword ptr [_OUTPUT+5*4], 1
  4616 00002322 D115[50040000]      <1> 	rcl	dword ptr [_OUTPUT+4*4], 1
  4617 00002328 D115[4C040000]      <1> 	rcl	dword ptr [_OUTPUT+3*4], 1
  4618 0000232E D115[48040000]      <1> 	rcl	dword ptr [_OUTPUT+2*4], 1
  4619                              <1> 
  4620 00002334 F9                  <1> 	stc
  4621 00002335 D11D[08040000]      <1> 	rcr	dword ptr [_INPUT2+2*4], 1	; shift negative addend
  4622 0000233B D11D[0C040000]      <1> 	rcr	dword ptr [_INPUT2+3*4], 1	; 1 position starboard
  4623 00002341 D11D[10040000]      <1> 	rcr	dword ptr [_INPUT2+4*4], 1
  4624 00002347 D11D[14040000]      <1> 	rcr	dword ptr [_INPUT2+5*4], 1
  4625 0000234D D11D[18040000]      <1> 	rcr	dword ptr [_INPUT2+6*4], 1
  4626 00002353 D11D[1C040000]      <1> 	rcr	dword ptr [_INPUT2+7*4], 1
  4627                              <1> 
  4628 00002359 80C1FF              <1> 	add	cl, -1
  4629 0000235C 0F8279FFFFFF        <1> 	jc	fd_144
  4630 00002362 E943000000          <1> 	jmp	fd_restore	
  4631                              <1> 
  4632 00002367 F9                  <1> fd_72:	stc					; add negative mantissa
  4633 00002368 E84CFCFFFF          <1> 	call	_add_high			; to positive dividend
  4634 0000236D 7311                <1> 	jnc	fd_72level			; no carry = drop the result
  4635                              <1> 
  4636 0000236F A3[28040000]        <1> 	mov	dword ptr [_INPUTR+2*4], eax	; carry = update the dividend
  4637 00002374 891D[2C040000]      <1> 	mov	dword ptr [_INPUTR+3*4], ebx
  4638 0000237A 8915[30040000]      <1> 	mov	dword ptr [_INPUTR+4*4], edx
  4639                              <1> fd_72level:
  4640 00002380 D115[50040000]      <1> 	rcl	dword ptr [_OUTPUT+4*4], 1	; shift value of carry into quotient
  4641 00002386 D115[4C040000]      <1> 	rcl	dword ptr [_OUTPUT+3*4], 1
  4642 0000238C D115[48040000]      <1> 	rcl	dword ptr [_OUTPUT+2*4], 1
  4643                              <1> 
  4644 00002392 F9                  <1> 	stc
  4645 00002393 D11D[08040000]      <1> 	rcr	dword ptr [_INPUT2+2*4], 1	; shift negative addend
  4646 00002399 D11D[0C040000]      <1> 	rcr	dword ptr [_INPUT2+3*4], 1	; 1 position starboard
  4647 0000239F D11D[10040000]      <1> 	rcr	dword ptr [_INPUT2+4*4], 1	;
  4648                              <1> 
  4649 000023A5 80C1FF              <1> 	add	cl, -1
  4650 000023A8 72BD                <1> 	jc	fd_72
  4651                              <1> 
  4652 000023AA 59                  <1> fd_restore:	pop	ecx
  4653 000023AB 5A                  <1> 		pop	edx				; hand the program counter back
  4654 000023AC A1[20040000]        <1> 		mov	eax, dword ptr [_INPUTR]	; + magnitude dividend exponent
  4655 000023B1 2B05[00040000]      <1> 		sub	eax, dword ptr [_INPUT2]	; + magnitude divisor exponent
  4656 000023B7 0501004000          <1> 		add	eax, 00400001h			; midpoint + 1
  4657 000023BC A3[40040000]        <1> 		mov	dword ptr [_OUTPUT], eax	; magnitude of quotient scale
  4658                              <1> 							; -> front of delivery string
  4659                              <1> 
  4660 000023C1 BF[40040000]        <1> 		mov	edi, _OUTPUT
  4661                              <1> 
  4662 000023C6 E81EFBFFFF          <1> 		call	renormalise
  4663                              <1> 
  4664 000023CB BE[40040000]        <1> 		mov	esi, _OUTPUT			; tell rewrite where it is
  4665 000023D0 A1[24040000]        <1> 		mov	eax, dword ptr [_INPUTR+1*4]	; determine sign of quotient
  4666 000023D5 3305[04040000]      <1> 		xor	eax, dword ptr [_INPUT2+1*4]
  4667 000023DB 894604              <1> 		mov	[esi+1*4], eax			; output 32 signs
  4668                              <1> 							; _deliver_ polarises the quotient scale
  4669 000023DE 314608              <1> 		xor	dword ptr [esi+2*4], eax	; switch quotient mantissa
  4670 000023E1 31460C              <1> 		xor	dword ptr [esi+3*4], eax
  4671 000023E4 314610              <1> 		xor	dword ptr [esi+4*4], eax
  4672 000023E7 314614              <1> 		xor	dword ptr [esi+5*4], eax	; switch the long mantissa
  4673 000023EA 314618              <1> 		xor	dword ptr [esi+6*4], eax
  4674 000023ED 31461C              <1> 		xor	dword ptr [esi+7*4], eax
  4675                              <1> 
  4676 000023F0 C3                  <1> 		ret
  4677                              <1> 
  4678                              <1> 	;	these instructions take the left-side + target as
  4679                              <1> 	;	[register_set]->a:b:mantissa2:mantissa3
  4680                              <1> 	;	and the right side as [ea]
  4681                              <1> 
  4682                              <1> 	;	after acquisition and before delivery they call modules
  4683                              <1> ;	fa fan fm fd
  4684                              <1> ;	which may be used in extended instruction sets
  4685                              <1> ;	using source and target registers in the internal stack
  4686                              <1> ;	with maximum mantissa size 168 bits
  4687                              <1> 
  4688                              <1> 
  4689 000023F1 BB04000000          <1> _fa:	mov	ebx, a
  4690 000023F6 53                  <1> _far:	push	ebx
  4691 000023F7 E861000000          <1> 	call	fp_operands
  4692 000023FC E889000000          <1> 	call	fp_registers_a
  4693 00002401 E8E7FBFFFF          <1> 	call	fa
  4694 00002406 5B                  <1> 	pop	ebx
  4695 00002407 E9DEF8FFFF          <1> 	jmp	_deliver_edi
  4696                              <1> 
  4697 0000240C BB04000000          <1> _fan:	mov	ebx, a
  4698 00002411 53                  <1> _fanr:	push	ebx
  4699 00002412 E846000000          <1> 	call	fp_operands
  4700 00002417 E86E000000          <1> 	call	fp_registers_a
  4701 0000241C E8BCFBFFFF          <1> 	call	fan
  4702 00002421 5B                  <1> 	pop	ebx
  4703 00002422 E9C3F8FFFF          <1> 	jmp	_deliver_edi
  4704                              <1> 
  4705 00002427 BB04000000          <1> _fm:	mov	ebx, a
  4706 0000242C 53                  <1> _fmr:	push	ebx
  4707 0000242D E82B000000          <1> 	call	fp_operands
  4708 00002432 E86A000000          <1> 	call	fp_registers_m
  4709 00002437 E88FFCFFFF          <1> 	call	fm
  4710 0000243C 5B                  <1> 	pop	ebx
  4711 0000243D E9AAF8FFFF          <1> 	jmp	 _deliver_
  4712                              <1> 
  4713 00002442 BB04000000          <1> _fd:	mov	ebx, a				; default target register
  4714 00002447 53                  <1> _fdr:	push	ebx
  4715 00002448 E810000000          <1> 	call	fp_operands
  4716 0000244D E84F000000          <1> 	call	fp_registers_m
  4717 00002452 E8DAFDFFFF          <1> 	call	fd
  4718 00002457 5B                  <1> 	pop	ebx
  4719 00002458 E98FF8FFFF          <1> 	jmp	_deliver_
  4720                              <1> 
  4721                              <1> fp_operands
  4722 0000245D 50                  <1> 	push	eax				; effective address often useful
  4723 0000245E BE[20040000]        <1> 	mov	esi, _INPUTR
  4724 00002463 E850000000          <1> 	call	_load_quad
  4725 00002468 E834F8FFFF          <1> 	call	compress4to8
  4726 0000246D 58                  <1> 	pop	eax				; effective address
  4727 0000246E 55                  <1> 	push	ebp
  4728 0000246F BD[00000000]        <1> 	mov	ebp, __register			; registers absolute array
  4729 00002474 BB00010000          <1> 	mov	ebx, _input2			; if source2 is a register
  4730 00002479 E88CDEFFFF          <1> 	call	_burst_read4
  4731 0000247E BE[00040000]        <1> 	mov	esi, _INPUT2
  4732 00002483 E819F8FFFF          <1> 	call	compress4to8
  4733 00002488 5D                  <1> 	pop	ebp				; App / Int register context
  4734 00002489 C3                  <1> 	ret
  4735                              <1> 
  4736                              <1> fp_registers_a
  4737 0000248A B908020400          <1> 	mov	ecx, 00040208h
  4738 0000248F F705[00000000]0800- <1> 	test	dword ptr [_psr], FP_R
  4739 00002497 0000                <1>
  4740 00002499 7405                <1> 	jz	fp_registers_x
  4741 0000249B B910040600          <1> 	mov	ecx, 00060410h
  4742                              <1> fp_registers_x
  4743 000024A0 C3                  <1> 	ret
  4744                              <1> 
  4745                              <1> fp_registers_m
  4746 000024A1 B908020400          <1> 	mov	ecx, 00040208h
  4747 000024A6 F705[00000000]0800- <1> 	test	dword ptr [_psr], FP_R
  4748 000024AE 0000                <1>
  4749 000024B0 7405                <1> 	jz	fp_registers_z
  4750 000024B2 B910040600          <1> 	mov	ecx, 00060410h
  4751                              <1> fp_registers_z
  4752 000024B7 C3                  <1> 	ret
  4753                              <1> 
  4754                              <1> _load_quad
  4755 000024B8 8B449D0C            <1> 	mov	eax, dword ptr[ebp+ebx*4+3*4]
  4756 000024BC 89460C              <1> 	mov	dword ptr [esi+3*4], eax
  4757 000024BF 8B449D08            <1> 	mov	eax, dword ptr  [ebp+ebx*4+2*4]
  4758 000024C3 894608              <1> 	mov	dword ptr [esi+2*4], eax
  4759 000024C6 8B449D04            <1> 	mov	eax, dword ptr [ebp+ebx*4+1*4]
  4760 000024CA 894604              <1> 	mov	dword ptr [esi+1*4], eax
  4761 000024CD 8B449D00            <1> 	mov	eax, dword ptr [ebp+ebx*4]
  4762 000024D1 8906                <1> 	mov	dword ptr [esi], eax
  4763 000024D3 C3                  <1> 	ret
  4764                              <1> 
  4765                                  	%include	"parity.msm"
  4766                              <1> _get_parity:
  4767 000024D4 8B5D10              <1>         mov     ebx, dword ptr [ebp+A]
  4768 000024D7 235D04              <1>         and     ebx, dword ptr [ebp+K]
  4769                              <1> _fold_parity:
  4770 000024DA 30DF                <1>         xor     bh, bl
  4771 000024DC C1EB08              <1>         shr     ebx, 8
  4772 000024DF 30FB                <1>         xor     bl, bh
  4773 000024E1 C3                  <1>         ret
  4774                              <1> 
  4775                                  	%include	"margin.msm"
  4776                              <1> read_straddle_12b?
  4777 000024E2 F6C101              <1> 	test	cl, 1				; 4 words? You are here because
  4778 000024E5 7531                <1> 	jnz	split_read4w			; offset is within last 3 of page
  4779                              <1> 						; 2 words then
  4780 000024E7 81FEFF0F0000        <1> 	cmp	esi, 0FFFh			; starting @ last word of page?
  4781 000024ED 7228                <1> 	jb	readout				; not so, go ahead with burst read
  4782                              <1> 
  4783                              <1> split_read2w:
  4784 000024EF 893C24              <1> 	mov	dword ptr [esp], edi		; delete 1st return address + save EA
  4785 000024F2 89F8                <1> 	mov	eax, edi			; recover EA
  4786 000024F4 30C9                <1> 	xor	cl, cl				; request 1 word
  4787 000024F6 E86ADEFFFF          <1> 	call	_bus_read			;
  4788 000024FB 870424              <1> 	xchg	eax, dword ptr [esp]		; save 1st word read + load updated EA
  4789 000024FE 40                  <1> 	inc	eax				; advance EA onto next page
  4790 000024FF 30C9                <1> 	xor	cl, cl				; request 1 word
  4791 00002501 E85FDEFFFF          <1> 	call	_bus_read			; read new page or block
  4792 00002506 89C3                <1> 	mov	ebx, eax
  4793 00002508 58                  <1> 	pop	eax				; recover 1st read word
  4794 00002509 C3                  <1> 	ret					; return to caller of operand_read
  4795                              <1> 
  4796                              <1> read_straddle_18b?
  4797 0000250A F6C101              <1> 	test	cl, 1				; 4 words? You are here because 
  4798 0000250D 7509                <1> 	jnz	split_read4w			; offset is within last 3 of of bank
  4799                              <1> 						; 2 words then
  4800 0000250F 81FEFFFF0300        <1> 	cmp	esi, 0003FFFFh			; starting @ last word of bank?
  4801 00002515 73D8                <1> 	jnb	split_read2w			; otherwise fall thru to burst read
  4802                              <1> 
  4803                              <1> readout:
  4804 00002517 C3                  <1> 	ret					; burst read in order
  4805                              <1> 
  4806                              <1> split_read4w:					; write EA over stack top return address
  4807 00002518 893C24              <1> 	mov	dword ptr [esp], edi		; one or other of these 2-word reads
  4808 0000251B 89F8                <1> 	mov	eax, edi			; splits down to 1-word reads
  4809 0000251D E807000000          <1> 	call	read2				; when offset is [3F]FFD
  4810 00002522 E802000000          <1> 	call	read2				;             or [3F]FFF
  4811 00002527 58                  <1> 	pop	eax				;   but not when [3F]FFE
  4812 00002528 C3                  <1> 	ret					; return to caller of caller
  4813                              <1> 	
  4814 00002529 50                  <1> read2:	push	eax				; EA
  4815 0000252A 53                  <1> 	push	ebx				; destination index on stack top
  4816 0000252B B106                <1> 	mov	cl, 6				; ask bus for 2 words
  4817 0000252D E833DEFFFF          <1> 	call	_bus_read			; replaces eax and ebx
  4818 00002532 871C24              <1> 	xchg	ebx, dword ptr [esp]		; get destination index up again
  4819 00002535 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax	; write 1st result word
  4820 00002539 58                  <1> 	pop	eax				; recover 2nd result word
  4821 0000253A 89449D04            <1> 	mov	dword ptr [ebp+ebx*4+1*4], eax	; write 2nd result word
  4822 0000253E 58                  <1> 	pop	eax				; EA
  4823 0000253F 0502000000          <1> 	add	eax, 2
  4824 00002544 81C302000000        <1> 	add	ebx, 2
  4825 0000254A C3                  <1> 	ret	
  4826                              <1> 
  4827                                  	%include	"margin_w.msm"
  4828                              <1> write_straddle_12b?				; multiword write request
  4829                              <1> write_straddle12b?				; in last 3 words of block
  4830 0000254B F6C101              <1> 	test	cl, 1				; 4-word write request?
  4831 0000254E 7536                <1> 	jnz	split_write4w			;
  4832 00002550 81FEFF0F0000        <1> 	cmp	esi, 0FFFH			; 2 words then. In last word?
  4833 00002556 722D                <1> 	jb	writeout			; no
  4834                              <1> 						; yes
  4835                              <1> split_write2w:
  4836 00002558 891C24              <1> 	mov	dword ptr [esp], ebx		; not returning to there
  4837 0000255B 57                  <1> 	push	edi				; esp -> saved eax [ea], saved ebx
  4838 0000255C 89F8                <1> 	mov	eax, edi			; place ea in eax
  4839 0000255E 30C9                <1> 	xor	cl, cl				; request 1-word write
  4840 00002560 8B5C9D00            <1> 	mov	ebx, dword ptr [ebp+ebx*4]	; data from register array
  4841 00002564 E8C6DFFFFF          <1> 	call	bus_write
  4842 00002569 58                  <1> 	pop	eax				; retrieve ea from stack
  4843 0000256A 5B                  <1> 	pop	ebx				; retrieve register index
  4844 0000256B 40                  <1> 	inc	eax				; advance ea to next block
  4845 0000256C 8B5C9D04            <1> 	mov	ebx, dword ptr [ebp+ebx*4+4]	; data from register array
  4846 00002570 30C9                <1> 	xor	cl, cl				; request 1-word write
  4847 00002572 E8B8DFFFFF          <1> 	call	bus_write
  4848 00002577 C3                  <1> 	ret					; return caller of caller
  4849                              <1> 
  4850                              <1> write_straddle_18b?				; multiword write request
  4851                              <1> write_straddle18b?				; in last 3 words of block
  4852 00002578 F6C101              <1> 	test	cl, 1				; 4 words?
  4853 0000257B 7509                <1> 	jnz	split_write4w
  4854 0000257D 81FEFFFF0300        <1> 	cmp	esi, 0003FFFFh			; 2 words then. In last word?
  4855 00002583 73D3                <1> 	jnb	split_write2w			; yes
  4856                              <1> 						; no
  4857                              <1> writeout:
  4858 00002585 C3                  <1> 	ret					; return to burst write
  4859                              <1> 
  4860                              <1> split_write4w:
  4861 00002586 893C24              <1> 	mov	dword ptr [esp], edi		; return address at stack top not used
  4862 00002589 89F8                <1> 	mov	eax, edi			; copy ea
  4863 0000258B E807000000          <1> 	call	write2				; request 2 writes word pairs
  4864 00002590 E802000000          <1> 	call	write2				; if 1 of them straddles it splits again
  4865 00002595 58                  <1> 	pop	eax				; this is ea
  4866 00002596 C3                  <1> 	ret					; return to caller of caller
  4867                              <1> 
  4868                              <1> 
  4869 00002597 B106                <1> write2:	mov	cl, 6				; request 2-word bus write
  4870 00002599 50                  <1> 	push	eax				; save ea
  4871 0000259A 53                  <1> 	push	ebx				; save register array index
  4872 0000259B E88FDFFFFF          <1> 	call	bus_write			; send write pair request
  4873 000025A0 5B                  <1> 	pop	ebx				; retrieve register index
  4874 000025A1 58                  <1> 	pop	eax				; and ea
  4875 000025A2 81C302000000        <1> 	add	ebx, 2				; update register index
  4876 000025A8 0502000000          <1> 	add	eax, 2				; and ea
  4877 000025AD C3                  <1> 	ret
  4878                                  	%include	"rex.msm"
  4879                              <1> 
  4880                              <1> _rextable_1
  4881 000025AE 000000000000000000- <1> 	dd	0, 0, 0, 0,		r_sa, r_sb, r_z, 0
  4882 000025B7 00000000000000-     <1>
  4883 000025BE [18290000]-         <1>
  4884 000025C2 [0D290000]-         <1>
  4885 000025C6 [31290000]00000000  <1>
  4886 000025CE 000000000000000000- <1> 	dd	0, 0, 0, 0,		r_la, r_lb, r_tz, r_tp
  4887 000025D7 00000000000000-     <1>
  4888 000025DE [4E290000]-         <1>
  4889 000025E2 [43290000]-         <1>
  4890 000025E6 [D6280000]-         <1>
  4891 000025EA [F1280000]          <1>
  4892 000025EE 0000000000000000-   <1> 	dd	0, 0, r_or, r_orB,	r_and, r_andB, r_xor, r_xorB
  4893 000025F6 [6E290000]-         <1>
  4894 000025FA [63290000]-         <1>
  4895 000025FE [92290000]-         <1>
  4896 00002602 [87290000]-         <1>
  4897 00002606 [B6290000]-         <1>
  4898 0000260A [AB290000]          <1>
  4899 0000260E [DA290000]-         <1> 	dd	r_aa, r_ab, r_ana, r_anb, r_m, r_mf, r_d, 0
  4900 00002612 [CF290000]-         <1>
  4901 00002616 [FA290000]-         <1>
  4902 0000261A [EF290000]-         <1>
  4903 0000261E [362A0000]-         <1>
  4904 00002622 [152A0000]-         <1>
  4905 00002626 [DB2A0000]00000000  <1>
  4906                              <1> 
  4907                              <1> _rextable_6
  4908 0000262E [1C2B0000]-         <1> 	dd	r_sar, r_sbr, r_dsr, 0, r_sal, r_sbl, r_dsl, 0
  4909 00002632 [112B0000]-         <1>
  4910 00002636 [372B0000]00000000- <1>
  4911 0000263E [652B0000]-         <1>
  4912 00002642 [5A2B0000]-         <1>
  4913 00002646 [802B0000]00000000  <1>
  4914 0000264E [AE2B0000]-         <1> 	dd	r_rar, r_rbr, r_drr, 0, r_ral, r_rbl, r_drl, 0
  4915 00002652 [A32B0000]-         <1>
  4916 00002656 [C72B0000]00000000- <1>
  4917 0000265E [F52B0000]-         <1>
  4918 00002662 [EA2B0000]-         <1>
  4919 00002666 [0E2C0000]00000000  <1>
  4920 0000266E [3C2C0000]-         <1> 	dd	r_saa, r_sba, r_dsa, 0, 0, 0, 0, 0
  4921 00002672 [312C0000]-         <1>
  4922 00002676 [582C0000]00000000- <1>
  4923 0000267E 000000000000000000- <1>
  4924 00002687 00000000000000      <1>
  4925 0000268E 000000000000000000- <1> 	dd	0, 0, 0, 0, 		0, 0, 0, 0
  4926 00002697 000000000000000000- <1>
  4927 000026A0 000000000000000000- <1>
  4928 000026A9 0000000000          <1>
  4929                              <1> 
  4930                              <1> _rextable_7
  4931 000026AE 000000000000000000- <1> 	dd	0, 0, 0, 0,		0, 0, 0, 0
  4932 000026B7 000000000000000000- <1>
  4933 000026C0 000000000000000000- <1>
  4934 000026C9 0000000000          <1>
  4935 000026CE [7B2C0000]-         <1> 	dd	r_qs, r_ql, r_dte, 0,	r_fa, r_fan, r_fm, r_fd
  4936 000026D2 [8A2C0000]-         <1>
  4937 000026D6 [992C0000]00000000- <1>
  4938 000026DE [A6280000]-         <1>
  4939 000026E2 [B2280000]-         <1>
  4940 000026E6 [BE280000]-         <1>
  4941 000026EA [CA280000]          <1>
  4942 000026EE 000000000000000000- <1> 	dd	0, 0, 0, 0, 		0, r_mta, 0, 0
  4943 000026F7 000000000000000000- <1>
  4944 00002700 0000[B22C0000]0000- <1>
  4945 00002708 000000000000        <1>
  4946 0000270E [D32C0000]-         <1> 	dd	r_ds, r_dl, r_da, r_dan, 0, 0, 0, 0
  4947 00002712 [E22C0000]-         <1>
  4948 00002716 [182D0000]-         <1>
  4949 0000271A [FB2C0000]00000000- <1>
  4950 00002722 000000000000000000- <1>
  4951 0000272B 000000              <1>
  4952                              <1> 
  4953                              <1> 
  4954 0000272E F605[02000000]80    <1> _rex:	test	byte ptr [_psr+2], 128
  4955 00002735 0F88EF000000        <1> 	js	near _rex_z				; ISRs can't do this
  4956                              <1> 
  4957 0000273B E837DFFFFF          <1> 	call	memory_read				; ea -> instruction for repeat	
  4958 00002740 A3[78040000]        <1> 	mov	dword ptr [__register+286*4], eax	; save instruction word
  4959 00002745 E886D9FFFF          <1> 	call	__ea					; get initial ea of repeated  instruction
  4960 0000274A 0FB6DD              <1> 	movzx	ebx, ch					; spin-off is opcode index in ch
  4961                              <1> 							; and operand type in cl
  4962 0000274D 80F906              <1> 	cmp	cl, 6
  4963 00002750 721A                <1> 	jb	_rex_itable1
  4964 00002752 770C                <1> 	ja	_rex_itable7
  4965                              <1> 							; instruction list 6
  4966 00002754 8B1C9D[2E260000]    <1> 	mov	ebx, dword ptr [_rextable_6+ebx*4]	; shifts and jumps
  4967 0000275B E913000000          <1> 	jmp	_rex_evaluate
  4968                              <1> 
  4969                              <1> _rex_itable7:						; instruction list 7
  4970 00002760 8B1C9D[AE260000]    <1> 	mov	ebx, dword ptr [_rextable_7+ebx*4]	; large arithmetic
  4971 00002767 E907000000          <1> 	jmp	_rex_evaluate
  4972                              <1> 
  4973                              <1> _rex_itable1:						; instruction list 1
  4974 0000276C 8B1C9D[AE250000]    <1> 	mov	ebx, dword ptr [_rextable_1+ebx*4]	; single integer arithmetic
  4975                              <1> 
  4976                              <1> _rex_evaluate:
  4977 00002773 21DB                <1> 	and	ebx, ebx				; instruction for repeat execute?
  4978 00002775 0F84AF000000        <1> 	jz	near _rex_z				; no
  4979 0000277B 891D[74040000]      <1> 	mov	dword ptr [__register+285*4], ebx	; yes: save execution logic pointer
  4980                              <1> 
  4981                              <1> 							; if repeat instruction is indexed:
  4982                              <1> 							; quick lookup tag for index increment
  4983 00002781 C705[70040000]0000- <1> 	mov	dword ptr [__register+284*4], 0		; default no index register referenced
  4984 00002789 0000                <1>
  4985 0000278B 8B1D[78040000]      <1> 	mov	ebx, dword ptr [__register+286*4]	; identify any index register tag
  4986 00002791 6621DB              <1> 	and	bx, bx					; in the instruction word
  4987 00002794 791D                <1> 	jns	_rex_ready				; by testing bit 15
  4988 00002796 66C1EB0C            <1> 	shr	bx, 12
  4989                              <1> 							; must be > indirection tags *B0+ *B1+
  4990 0000279A 80FB0A              <1> 	cmp	bl, 10					; pointers in storage not incremented
  4991 0000279D 7214                <1> 	jb	_rex_ready				; index registers may increment
  4992 0000279F 80FB0E              <1> 	cmp	bl, 14
  4993 000027A2 7303                <1> 	jnb	_rex_indexed				; [   fp sp ]  registers   [ 14 15 ]
  4994 000027A4 80E307              <1> 	and	bl, 7					; [ x y a b ]  registers [ 2 3 4 5 ]
  4995                              <1> 
  4996                              <1> _rex_indexed:
  4997 000027A7 81E30F000000        <1> 	and	ebx, 15					; make 32-bit index value
  4998 000027AD 891D[70040000]      <1> 	mov	dword ptr [__register+284*4], ebx	; write quick lookup
  4999                              <1> 
  5000                              <1> _rex_ready
  5001 000027B3 8B1D[34000000]      <1> 	mov	ebx, dword ptr [__register+Q]		; default target register [ q ] ->	
  5002 000027B9 FF15[74040000]      <1> 	call	dword ptr [__register+285*4]		; execute logic ->
  5003                              <1> 
  5004 000027BF A1[70040000]        <1> 	mov	eax, dword ptr [__register+284*4]	; index register tag?
  5005 000027C4 6621C0              <1> 	and	ax, ax
  5006 000027C7 7422                <1> 	jz	_rex_count				; no
  5007                              <1> 
  5008 000027C9 8B0D[5C000000]      <1> 	mov	ecx, dword ptr [__register+WDATA]
  5009 000027CF 81E1FFFFFF00        <1> 	and	ecx, 00FFFFFFh				; index register increment configured?
  5010 000027D5 7414                <1> 	jz	_rex_count				; no
  5011                              <1> 
  5012 000027D7 030C85[00000000]    <1> 	add	ecx, dword ptr [__register+eax*4]	; calculate index + increment
  5013 000027DE 81E1FFFFFF00        <1> 	and	ecx, 00FFFFFFh				; 
  5014 000027E4 890C85[00000000]    <1> 	mov	dword ptr [__register+eax*4], ecx	; write back to tagged index register
  5015                              <1> 
  5016                              <1> _rex_count:
  5017 000027EB A1[50000000]        <1> 	mov	eax, dword ptr [__register+RDATAC]
  5018 000027F0 48                  <1> 	dec	eax
  5019 000027F1 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
  5020                              <1> 
  5021 000027F6 A3[50000000]        <1> 	mov	dword ptr [__register+RDATAC], eax
  5022 000027FB A900008000          <1> 	test	eax, 00800000h
  5023 00002800 7528                <1> 	jnz	_rex_z					; reached -1 end
  5024                              <1> 
  5025 00002802 66F705[00000000]C0- <1> 	test	word ptr [_indication], EXTERNAL_INDICATIONS
  5026 0000280A FF                  <1>
  5027 0000280B 740B                <1> 	jz	_rex_along
  5028                              <1> 
  5029 0000280D 81C2FCFFFFFF        <1> 	add	edx, -4					; restart after
  5030 00002813 E912000000          <1> 	jmp	_rex_z					; yielding to interrupt
  5031                              <1> 
  5032                              <1> _rex_along:
  5033 00002818 A1[78040000]        <1> 	mov	eax, [__register+286*4]			; instruction encoding
  5034 0000281D E8AED8FFFF          <1> 	call	__ea
  5035 00002822 8B1D[74040000]      <1> 	mov	ebx, [__register+285*4]			; command pointer
  5036 00002828 EB89                <1> 	jmp	_rex_ready
  5037 0000282A C3                  <1> _rex_z:	ret
  5038                              <1> 
  5039                              <1> _rex_prime_final_count:
  5040 0000282B F7455000008000      <1> 	test	dword ptr [ebp+RDATAC], 00800000h
  5041 00002832 7422                <1> 	jz	_rex_primed
  5042 00002834 8B5D58              <1> 	mov	ebx, dword ptr [ebp+WDATAC]
  5043 00002837 895D50              <1> 	mov	dword ptr [ebp+RDATAC], ebx
  5044 0000283A C3                  <1> 	ret
  5045                              <1> 
  5046                              <1> _rex_prime:
  5047 0000283B F7455000008000      <1> 	test	dword ptr [ebp+RDATAC], 00800000h
  5048 00002842 7412                <1> 	jz	_rex_primed
  5049 00002844 8B5D58              <1> 	mov	ebx, dword ptr [ebp+WDATAC]
  5050 00002847 895D50              <1> 	mov	dword ptr [ebp+RDATAC], ebx
  5051 0000284A 8B5D3C              <1> 	mov	ebx, dword ptr [ebp+S_P]
  5052 0000284D 81E3FFFFFF00        <1> 	and	ebx, 00FFFFFFh
  5053 00002853 895D34              <1> 	mov	dword ptr [ebp+Q], ebx
  5054                              <1> _rex_primed:
  5055 00002856 C3                  <1> 	ret
  5056                              <1> 
  5057                              <1> _rex_accumulate:
  5058 00002857 8B5D54              <1> 	mov	ebx, dword ptr [ebp+RDATA]
  5059 0000285A 035D34              <1> 	add	ebx, dword ptr [ebp+Q]
  5060 0000285D 81E3FFFFFF00        <1> 	and	ebx, 00FFFFFFh
  5061 00002863 895D34              <1> 	mov	dword ptr [ebp+Q], ebx
  5062 00002866 C3                  <1> 	ret
  5063                              <1> 
  5064                              <1> _rex_chex_127:
  5065 00002867 E8CFFFFFFF          <1> 	call	_rex_prime
  5066 0000286C 81FB7F000000        <1> 	cmp	ebx, 127
  5067 00002872 7624                <1> 	jna	_rex_chex_low
  5068 00002874 E928000000          <1> 	jmp	_rex_chexit
  5069                              <1> 
  5070                              <1> _rex_chex_126:
  5071 00002879 E8BDFFFFFF          <1> 	call	_rex_prime
  5072 0000287E 81FB7E000000        <1> 	cmp	ebx, 126
  5073 00002884 7612                <1> 	jna	_rex_chex_low
  5074 00002886 E916000000          <1> 	jmp	_rex_chexit
  5075                              <1> 
  5076                              <1> _rex_chex_124:
  5077 0000288B E8ABFFFFFF          <1> 	call	_rex_prime
  5078 00002890 81FB7C000000        <1> 	cmp	ebx, 124
  5079 00002896 7709                <1> 	ja	_rex_chexit
  5080                              <1> _rex_chex_low:
  5081 00002898 81FB18000000        <1> 	cmp	ebx, 24
  5082 0000289E 7201                <1> 	jb	_rex_chexit
  5083 000028A0 C3                  <1> 	ret
  5084                              <1> 
  5085                              <1> _rex_chexit
  5086 000028A1 E9B2E5FFFF          <1> 	jmp	guard_ii_authority
  5087                              <1> 
  5088                              <1> ;	eax = EA
  5089                              <1> ;	q -> target register selected
  5090                              <1> 
  5091 000028A6 E8E0FFFFFF          <1> r_fa:	call	_rex_chex_124
  5092 000028AB E846FBFFFF          <1> 	call	_far
  5093 000028B0 EBA5                <1> 	jmp	_rex_accumulate
  5094                              <1> 
  5095 000028B2 E8D4FFFFFF          <1> r_fan:	call	_rex_chex_124
  5096 000028B7 E855FBFFFF          <1> 	call	_fanr
  5097 000028BC EB99                <1> 	jmp	_rex_accumulate
  5098                              <1> 
  5099 000028BE E8C8FFFFFF          <1> r_fm:	call	_rex_chex_124
  5100 000028C3 E864FBFFFF          <1> 	call	_fmr
  5101 000028C8 EB8D                <1> 	jmp	_rex_accumulate
  5102                              <1> 
  5103 000028CA E8BCFFFFFF          <1> r_fd:	call	_rex_chex_124
  5104 000028CF E873FBFFFF          <1> 	call	_fdr
  5105 000028D4 EB81                <1> 	jmp	_rex_accumulate
  5106                              <1> 
  5107 000028D6 E850FFFFFF          <1> r_tz:	call	_rex_prime_final_count
  5108 000028DB 80F904              <1> 	cmp	cl, 4			; may not be [ i xi ]
  5109 000028DE 732C                <1> 	jnb	r_noskip		; but pointers are updated on no_op
  5110 000028E0 E864DAFFFF          <1> 	call	_operand_read
  5111 000028E5 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
  5112 000028EA 7520                <1> 	jnz	r_noskip
  5113                              <1> 
  5114 000028EC E9D5030000          <1> 	jmp	r_skipout		; stop search repeat
  5115                              <1> 
  5116 000028F1 E835FFFFFF          <1> r_tp:	call	_rex_prime_final_count
  5117 000028F6 80F904              <1> 	cmp	cl, 4			; may not be [ i xi ]
  5118 000028F9 7311                <1> 	jnb	r_noskip		; but pointers are updated on no_op
  5119 000028FB E849DAFFFF          <1> 	call	_operand_read
  5120 00002900 A900008000          <1> 	test	eax, 00800000h
  5121 00002905 7505                <1> 	jnz	r_noskip
  5122                              <1> 
  5123 00002907 E9BA030000          <1> 	jmp	r_skipout		; stop search repeat
  5124                              <1> 
  5125 0000290C C3                  <1> r_noskip:	ret
  5126                              <1> 
  5127 0000290D E867FFFFFF          <1> r_sb:	call	_rex_chex_126
  5128 00002912 43                  <1> 	inc	ebx			; starboard lane
  5129 00002913 E905000000          <1> 	jmp	r_s
  5130 00002918 E84AFFFFFF          <1> r_sa:	call	_rex_chex_127
  5131 0000291D 80F904              <1> r_s:	cmp	cl, 4			; may not be [ i xi ]
  5132 00002920 7309                <1> 	jnb	r_no_op_s		; but pointers are updated 
  5133 00002922 8B5C9D00            <1> 	mov	ebx, dword ptr [ebp+ebx*4]
  5134 00002926 E8DDDBFFFF          <1> 	call	_operand_write
  5135                              <1> r_no_op_s:
  5136 0000292B E927FFFFFF          <1> 	jmp	_rex_accumulate
  5137 00002930 C3                  <1> 	ret
  5138                              <1> 
  5139 00002931 E8F5FEFFFF          <1> r_z:	call	_rex_prime_final_count
  5140 00002936 80F904              <1> 	cmp	cl, 4			; may not be [ i xi ]
  5141 00002939 7307                <1> 	jnb	r_no_op_z		; but pointers are updated
  5142 0000293B 31DB                <1> 	xor	ebx, ebx
  5143 0000293D E9C6DBFFFF          <1> 	jmp	_operand_write
  5144                              <1> r_no_op_z
  5145 00002942 C3                  <1> 	ret
  5146                              <1> 
  5147 00002943 E831FFFFFF          <1> r_lb:	call	_rex_chex_126
  5148 00002948 43                  <1> 	inc	ebx			; starboard lane
  5149 00002949 E905000000          <1> 	jmp	r_l
  5150 0000294E E814FFFFFF          <1> r_la:	call	_rex_chex_127
  5151 00002953 53                  <1> r_l:	push	ebx
  5152 00002954 E8F0D9FFFF          <1> 	call	_operand_read
  5153 00002959 5B                  <1> 	pop	ebx
  5154 0000295A 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
  5155 0000295E E9F4FEFFFF          <1> 	jmp	_rex_accumulate
  5156                              <1> 
  5157 00002963 E811FFFFFF          <1> r_orB:	call	_rex_chex_126
  5158 00002968 43                  <1> 	inc	ebx			; starboard lane
  5159 00002969 E905000000          <1> 	jmp	r_OR
  5160 0000296E E8F4FEFFFF          <1> r_or:	call	_rex_chex_127
  5161 00002973 53                  <1> r_OR:	push	ebx
  5162 00002974 E8D0D9FFFF          <1> 	call	_operand_read
  5163 00002979 5B                  <1> 	pop	ebx
  5164 0000297A 0B449D00            <1> 	or	eax, dword ptr [ebp+ebx*4]
  5165 0000297E 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
  5166 00002982 E9D0FEFFFF          <1> 	jmp	_rex_accumulate
  5167                              <1> 
  5168 00002987 E8EDFEFFFF          <1> r_andB:	call	_rex_chex_126
  5169 0000298C 43                  <1> 	inc	ebx		; starboard lane
  5170 0000298D E905000000          <1> 	jmp	r_AND
  5171 00002992 E8D0FEFFFF          <1> r_and:	call	_rex_chex_127
  5172 00002997 53                  <1> r_AND:	push	ebx
  5173 00002998 E8ACD9FFFF          <1> 	call	_operand_read
  5174 0000299D 5B                  <1> 	pop	ebx
  5175 0000299E 23449D00            <1> 	and	eax, dword ptr [ebp+ebx*4]
  5176 000029A2 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
  5177 000029A6 E9ACFEFFFF          <1> 	jmp	_rex_accumulate
  5178                              <1> 
  5179 000029AB E8C9FEFFFF          <1> r_xorB:	call	_rex_chex_126
  5180 000029B0 43                  <1> 	inc	ebx		; starboard lane
  5181 000029B1 E905000000          <1> 	jmp	r_XOR
  5182 000029B6 E8ACFEFFFF          <1> r_xor:	call	_rex_chex_127
  5183 000029BB 53                  <1> r_XOR:	push	ebx
  5184 000029BC E888D9FFFF          <1> 	call	_operand_read
  5185 000029C1 5B                  <1> 	pop	ebx
  5186 000029C2 33449D00            <1> 	xor	eax, dword ptr [ebp+ebx*4]
  5187 000029C6 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
  5188 000029CA E988FEFFFF          <1> 	jmp	_rex_accumulate
  5189                              <1> 
  5190 000029CF E8A5FEFFFF          <1> r_ab:	call	_rex_chex_126
  5191 000029D4 43                  <1> 	inc	ebx		; starboard lane
  5192 000029D5 E905000000          <1> 	jmp	r_a
  5193 000029DA E888FEFFFF          <1> r_aa:	call	_rex_chex_127
  5194 000029DF 53                  <1> r_a:	push	ebx
  5195 000029E0 E864D9FFFF          <1> 	call	_operand_read
  5196 000029E5 5F                  <1> 	pop	edi
  5197 000029E6 0344BD00            <1> 	add	eax, dword ptr [ebp+edi*4]
  5198 000029EA E94C030000          <1> 	jmp	r_store_carry
  5199                              <1> 
  5200 000029EF E885FEFFFF          <1> r_anb:	call	_rex_chex_126
  5201 000029F4 43                  <1> 	inc	ebx		; starboard lane
  5202 000029F5 E905000000          <1> 	jmp	r_an
  5203 000029FA E868FEFFFF          <1> r_ana:	call	_rex_chex_127
  5204 000029FF 53                  <1> r_an:	push	ebx
  5205 00002A00 E844D9FFFF          <1> 	call	_operand_read
  5206 00002A05 5F                  <1> 	pop	edi
  5207 00002A06 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
  5208 00002A0B 40                  <1> 	inc	eax
  5209 00002A0C 0344BD00            <1> 	add	eax, dword ptr [ebp+edi*4]
  5210 00002A10 E926030000          <1> 	jmp	r_store_carry
  5211                              <1> 
  5212 00002A15 E84DFEFFFF          <1> r_mf:	call    _rex_chex_127
  5213 00002A1A 52                  <1> 	push	edx
  5214 00002A1B 53                  <1> 	push	ebx
  5215 00002A1C E828D9FFFF          <1> 	call	_operand_read
  5216 00002A21 5F                  <1> 	pop	edi
  5217 00002A22 0FAF44BD00          <1> 	imul	eax, dword ptr [ebp+edi*4]
  5218 00002A27 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
  5219 00002A2C 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
  5220 00002A30 5A                  <1> 	pop	edx
  5221 00002A31 E921FEFFFF          <1> 	jmp	_rex_accumulate
  5222                              <1> 
  5223                              <1> ; use the platform unsigned multiply
  5224                              <1> ; work in positive magnitude
  5225                              <1> ; adjust the final sign after offset-adding products
  5226                              <1> 
  5227 00002A36 E83EFEFFFF          <1> r_m:	call	_rex_chex_126
  5228 00002A3B 52                  <1> 	push	edx
  5229 00002A3C 53                  <1> 	push	ebx			; register stack cursor
  5230 00002A3D E807D9FFFF          <1> 	call	_operand_read
  5231 00002A42 5F                  <1> 	pop	edi			; recover register stack cursor
  5232                              <1> 
  5233 00002A43 31C9                <1> 	xor	ecx, ecx		; final sign
  5234 00002A45 A900008000          <1> 	test	eax, 00800000h		;
  5235 00002A4A 740D                <1> 	jz	r_msigu?		; negative multiplier?
  5236 00002A4C F7D1                <1> 	not	ecx			; final sign reverse
  5237 00002A4E 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
  5238 00002A53 40                  <1> 	inc	eax			; 2s complement
  5239 00002A54 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
  5240                              <1> 
  5241                              <1> r_msigu?:
  5242 00002A59 89C3                <1> 	mov	ebx, eax		; multiplier 2b used twice
  5243 00002A5B 8B44BD00            <1> 	mov	eax, dword ptr [ebp+edi*4]
  5244 00002A5F A900008000          <1> 	test	eax, 00800000h		; multiply high order part 1st
  5245 00002A64 7426                <1> 	jz	r_mgoferit_yall
  5246                              <1> 
  5247 00002A66 F7D1                <1> 	not	ecx			; final sign reverse
  5248 00002A68 8B54BD04            <1> 	mov	edx, dword ptr [ebp+edi*4+4]
  5249 00002A6C 81F2FFFFFF00        <1> 	xor	edx, 00FFFFFFh
  5250 00002A72 42                  <1> 	inc	edx			; 2s complement
  5251 00002A73 C1C208              <1> 	rol	edx, 8
  5252 00002A76 0FB6F2              <1> 	movzx	esi, dl
  5253 00002A79 C1EA08              <1> 	shr	edx, 8
  5254 00002A7C 8954BD04            <1> 	mov	dword ptr [ebp+edi*4+4], edx
  5255 00002A80 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh		; ms register long multiplicand
  5256 00002A85 01F0                <1> 	add	eax, esi
  5257 00002A87 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
  5258                              <1> 
  5259                              <1> r_mgoferit_yall:
  5260 00002A8C F7E3                <1> 	mul	ebx			; multiply high order part
  5261 00002A8E 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax	; save lower half of product
  5262 00002A92 8B44BD04            <1> 	mov	eax, dword ptr [ebp+edi*4+4]	; multiply low order part
  5263 00002A96 F7E3                <1> 	mul	ebx
  5264 00002A98 C1E208              <1> 	shl	edx, 8			; 8 bits of eax must shift up to edx
  5265 00002A9B C1C008              <1> 	rol	eax, 8
  5266 00002A9E 88C2                <1> 	mov	dl, al
  5267 00002AA0 C1E808              <1> 	shr	eax, 8			; leaving 8 zeros in eax high end
  5268 00002AA3 0354BD00            <1> 	add	edx, dword ptr [ebp+edi*4]	; add2 lower half of 1st product
  5269 00002AA7 21C9                <1> 	and	ecx, ecx		; final sign?
  5270 00002AA9 7917                <1> 	jns	r_m_writeback
  5271                              <1> 
  5272 00002AAB 81F2FFFFFF00        <1> 	xor	edx, 00FFFFFFh
  5273 00002AB1 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
  5274 00002AB6 40                  <1> 	inc	eax			; 2s complement
  5275 00002AB7 C1C008              <1> 	rol	eax, 8			; carried out single bit?
  5276 00002ABA 0FB6F0              <1> 	movzx	esi, al			; must add to edx
  5277 00002ABD C1E808              <1> 	shr	eax, 8
  5278 00002AC0 01F2                <1> 	add	edx, esi
  5279                              <1> 
  5280                              <1> r_m_writeback:
  5281 00002AC2 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
  5282 00002AC7 81E2FFFFFF00        <1> 	and	edx, 00FFFFFFh
  5283 00002ACD 8944BD04            <1> 	mov	dword ptr [ebp+edi*4+4], eax	
  5284 00002AD1 8954BD00            <1> 	mov	dword ptr [ebp+edi*4], edx
  5285 00002AD5 5A                  <1> 	pop	edx
  5286 00002AD6 E97CFDFFFF          <1> 	jmp	_rex_accumulate
  5287                              <1> 
  5288 00002ADB E899FDFFFF          <1> r_d:	call	_rex_chex_126
  5289 00002AE0 89DF                <1> 	mov	edi, ebx		; register cursor
  5290 00002AE2 E8DBECFFFF          <1> 	call	_divide
  5291 00002AE7 895CBD04            <1> 	mov	dword ptr [ebp+edi*4+4], ebx
  5292 00002AEB 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
  5293 00002AEF F605[00000000]08    <1> 	test	byte ptr [_psr], FP_R
  5294 00002AF6 0F845BFDFFFF        <1> 	jz	_rex_accumulate
  5295 00002AFC 81FF7D000000        <1> 	cmp	edi, 125
  5296 00002B02 0F874FFDFFFF        <1> 	ja	_rex_accumulate
  5297 00002B08 894CBD08            <1> 	mov	dword ptr [ebp+edi*4+8], ecx
  5298 00002B0C E946FDFFFF          <1> r_dnor:	jmp	_rex_accumulate
  5299                              <1> 
  5300 00002B11 E863FDFFFF          <1> r_sbr:	call	_rex_chex_126
  5301 00002B16 43                  <1> 	inc	ebx		; starboard lane
  5302 00002B17 E905000000          <1> 	jmp	r_lsr
  5303 00002B1C E846FDFFFF          <1> r_sar:	call	_rex_chex_127
  5304 00002B21 88C1                <1> r_lsr	mov	cl, al
  5305 00002B23 8B449D00            <1> 	mov	eax, dword ptr [ebp+ebx*4]
  5306 00002B27 D3E8                <1> 	shr	eax, cl
  5307 00002B29 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
  5308 00002B2E 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
  5309 00002B32 E920FDFFFF          <1> 	jmp	_rex_accumulate
  5310                              <1> 
  5311 00002B37 E83DFDFFFF          <1> r_dsr:	call	_rex_chex_126
  5312 00002B3C 88C1                <1> 	mov	cl, al
  5313 00002B3E 89DF                <1> 	mov	edi, ebx
  5314 00002B40 8B44BD00            <1> 	mov	eax, dword ptr [ebp+edi*4]
  5315 00002B44 8B5CBD04            <1> 	mov	ebx, dword ptr [ebp+edi*4+4]
  5316 00002B48 E8BCEDFFFF          <1> 	call	dsr
  5317 00002B4D 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
  5318 00002B51 895CBD04            <1> 	mov	dword ptr [ebp+edi*4+4], ebx
  5319 00002B55 E9FDFCFFFF          <1> 	jmp	_rex_accumulate
  5320                              <1> 
  5321 00002B5A E81AFDFFFF          <1> r_sbl:	call	_rex_chex_126
  5322 00002B5F 43                  <1> 	inc	ebx		; starboard lane
  5323 00002B60 E905000000          <1> 	jmp	r_lsl
  5324 00002B65 E8FDFCFFFF          <1> r_sal:	call	_rex_chex_127
  5325 00002B6A 88C1                <1> r_lsl:	mov	cl, al
  5326 00002B6C 8B449D00            <1> 	mov	eax, dword ptr [ebp+ebx*4]
  5327 00002B70 D3E0                <1> 	shl	eax, cl
  5328 00002B72 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
  5329 00002B77 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
  5330 00002B7B E9D7FCFFFF          <1> 	jmp	_rex_accumulate
  5331                              <1> 
  5332 00002B80 E8F4FCFFFF          <1> r_dsl:	call	_rex_chex_126
  5333 00002B85 88C1                <1> 	mov	cl, al
  5334 00002B87 89DF                <1> 	mov	edi, ebx
  5335 00002B89 8B44BD00            <1> 	mov	eax, dword ptr [ebp+edi*4]
  5336 00002B8D 8B5CBD04            <1> 	mov	ebx, dword ptr [ebp+edi*4+4]
  5337 00002B91 E8A8EDFFFF          <1> 	call	dsl
  5338 00002B96 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
  5339 00002B9A 895CBD04            <1> 	mov	dword ptr [ebp+edi*4+4], ebx
  5340 00002B9E E9B4FCFFFF          <1> 	jmp	_rex_accumulate
  5341                              <1> 
  5342 00002BA3 E8D1FCFFFF          <1> r_rbr:	call	_rex_chex_126
  5343 00002BA8 43                  <1> 	inc	ebx		; starboard lane
  5344 00002BA9 E905000000          <1> 	jmp	r_rr
  5345 00002BAE E8B4FCFFFF          <1> r_rar:	call	_rex_chex_127
  5346 00002BB3 89DF                <1> r_rr:	mov	edi, ebx
  5347 00002BB5 8B5CBD00            <1> 	mov	ebx, dword ptr [ebp+edi*4]
  5348 00002BB9 E8EDEDFFFF          <1> 	call	rr
  5349 00002BBE 895CBD00            <1> 	mov	dword ptr [ebp+edi*4], ebx
  5350 00002BC2 E990FCFFFF          <1> 	jmp	_rex_accumulate
  5351                              <1> 
  5352 00002BC7 E8ADFCFFFF          <1> r_drr:	call	_rex_chex_126
  5353 00002BCC 88C1                <1> 	mov	cl, al
  5354 00002BCE 89DF                <1> 	mov	edi, ebx
  5355 00002BD0 8B44BD00            <1> 	mov	eax, dword ptr [ebp+edi*4]
  5356 00002BD4 8B5CBD04            <1> 	mov	ebx, dword ptr [ebp+edi*4+4]
  5357 00002BD8 E81CEEFFFF          <1> 	call	drr
  5358 00002BDD 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
  5359 00002BE1 895CBD04            <1> 	mov	dword ptr [ebp+edi*4+4], ebx
  5360 00002BE5 E96DFCFFFF          <1> 	jmp	_rex_accumulate
  5361                              <1> 
  5362 00002BEA E88AFCFFFF          <1> r_rbl:	call	_rex_chex_126
  5363 00002BEF 43                  <1> 	inc	ebx		; starboard lane
  5364 00002BF0 E905000000          <1> 	jmp	r_rl
  5365 00002BF5 E86DFCFFFF          <1> r_ral:	call	_rex_chex_127
  5366 00002BFA 89DF                <1> r_rl:	mov	edi, ebx
  5367 00002BFC 8B5CBD00            <1> 	mov	ebx, dword ptr [ebp+edi*4]
  5368 00002C00 E8CCEDFFFF          <1> 	call	rl
  5369 00002C05 895CBD00            <1> 	mov	dword ptr [ebp+edi*4], ebx
  5370 00002C09 E949FCFFFF          <1> 	jmp	_rex_accumulate
  5371                              <1> 
  5372 00002C0E E866FCFFFF          <1> r_drl:	call	_rex_chex_126
  5373 00002C13 88C1                <1> 	mov	cl, al
  5374 00002C15 89DF                <1> 	mov	edi, ebx
  5375 00002C17 8B44BD00            <1> 	mov	eax, dword ptr [ebp+edi*4]
  5376 00002C1B 8B5CBD04            <1> 	mov	ebx, dword ptr [ebp+edi*4+4]
  5377 00002C1F E82EEEFFFF          <1> 	call	drl
  5378 00002C24 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
  5379 00002C28 895CBD04            <1> 	mov	dword ptr [ebp+edi*4+4], ebx
  5380 00002C2C E926FCFFFF          <1> 	jmp	_rex_accumulate
  5381                              <1> 
  5382 00002C31 E843FCFFFF          <1> r_sba:	call	_rex_chex_126
  5383 00002C36 43                  <1> 	inc	ebx		; starboard lane
  5384 00002C37 E905000000          <1> 	jmp	r_asr
  5385 00002C3C E826FCFFFF          <1> r_saa:	call	_rex_chex_127
  5386 00002C41 88C1                <1> r_asr:	mov	cl, al
  5387 00002C43 8B449D00            <1> 	mov	eax, dword ptr [ebp+ebx*4]
  5388 00002C47 C1E008              <1> 	shl	eax, 8
  5389 00002C4A D3F8                <1> 	sar	eax, cl
  5390 00002C4C C1E808              <1> 	shr	eax, 8
  5391 00002C4F 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
  5392 00002C53 E9FFFBFFFF          <1> 	jmp	_rex_accumulate
  5393                              <1> 
  5394 00002C58 E81CFCFFFF          <1> r_dsa:	call	_rex_chex_126
  5395 00002C5D 88C1                <1> 	mov	cl, al
  5396 00002C5F 89DF                <1> 	mov	edi, ebx
  5397 00002C61 8B44BD00            <1> 	mov	eax, dword ptr [ebp+edi*4]
  5398 00002C65 8B5CBD04            <1> 	mov	ebx, dword ptr [ebp+edi*4+4]
  5399 00002C69 E807EDFFFF          <1> 	call	dsa
  5400 00002C6E 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
  5401 00002C72 895CBD04            <1> 	mov	dword ptr [ebp+edi*4+4], ebx
  5402 00002C76 E9DCFBFFFF          <1> 	jmp	_rex_accumulate
  5403                              <1> 
  5404 00002C7B E80BFCFFFF          <1> r_qs:	call	_rex_chex_124
  5405 00002C80 E8F1D7FFFF          <1> 	call	_burst_write4	; eax -> ea / ebx -> register cursor
  5406 00002C85 E9CDFBFFFF          <1> 	jmp	_rex_accumulate
  5407                              <1> 
  5408 00002C8A E8FCFBFFFF          <1> r_ql:	call	_rex_chex_124
  5409 00002C8F E876D6FFFF          <1> 	call	_burst_read4	; eax -> ea / ebx -> register cursor
  5410 00002C94 E9BEFBFFFF          <1> 	jmp	_rex_accumulate
  5411                              <1> 
  5412 00002C99 E88DFBFFFF          <1> r_dte:	call	_rex_prime_final_count
  5413 00002C9E E848D6FFFF          <1> 	call	_burst_read2
  5414 00002CA3 334510              <1> 	xor	eax, dword ptr [ebp+A]
  5415 00002CA6 752A                <1> 	jnz	r_mtax
  5416 00002CA8 335D14              <1> 	xor	ebx, dword ptr [ebp+B]
  5417 00002CAB 7525                <1> 	jnz	r_mtax
  5418 00002CAD E914000000          <1> 	jmp	r_skipout		; stop search repeat
  5419                              <1> 
  5420 00002CB2 E874FBFFFF          <1> r_mta:	call	_rex_prime_final_count
  5421 00002CB7 B100                <1> 	mov	cl, 0		; operand size 1 word
  5422 00002CB9 E88BD6FFFF          <1> 	call	_operand_read
  5423 00002CBE 334510              <1> 	xor	eax, dword ptr [ebp+A]
  5424 00002CC1 234504              <1> 	and	eax, dword ptr [ebp+K]
  5425 00002CC4 750C                <1> 	jnz	r_mtax
  5426                              <1> 
  5427                              <1> r_skipout:				; stop search repeat
  5428 00002CC6 81C204000000        <1> 	add	edx, 4
  5429 00002CCC 8BA57C040000        <1> 	mov	esp, dword ptr [ebp+287*4]
  5430 00002CD2 C3                  <1> r_mtax:	ret
  5431                              <1> 
  5432 00002CD3 E8A1FBFFFF          <1> r_ds:	call	_rex_chex_126
  5433 00002CD8 E8EFD7FFFF          <1> 	call	_burst_write2	; eax -> ea / ebx -> register cursor
  5434 00002CDD E975FBFFFF          <1> 	jmp	_rex_accumulate
  5435                              <1> 
  5436 00002CE2 E892FBFFFF          <1> r_dl:	call	 _rex_chex_126
  5437 00002CE7 53                  <1> 	push	ebx
  5438 00002CE8 E8FED5FFFF          <1> 	call	_burst_read2
  5439 00002CED 5F                  <1> 	pop	edi
  5440 00002CEE 895CBD04            <1> 	mov	dword ptr [ebp+edi*4+4], ebx
  5441 00002CF2 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
  5442 00002CF6 E95CFBFFFF          <1> 	jmp	_rex_accumulate
  5443                              <1> 
  5444 00002CFB E879FBFFFF          <1> r_dan:	call	 _rex_chex_126
  5445 00002D00 53                  <1> 	push	ebx
  5446 00002D01 E8E5D5FFFF          <1> 	call	_burst_read2
  5447 00002D06 5F                  <1> 	pop	edi
  5448 00002D07 81F3FFFFFF00        <1> 	xor	ebx, 00FFFFFFh
  5449 00002D0D 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
  5450 00002D12 43                  <1> 	inc	ebx
  5451 00002D13 E90C000000          <1> 	jmp	r_danad
  5452                              <1> 
  5453 00002D18 E85CFBFFFF          <1> r_da:	call	 _rex_chex_126
  5454 00002D1D 53                  <1> 	push	ebx
  5455 00002D1E E8C8D5FFFF          <1> 	call	_burst_read2
  5456 00002D23 5F                  <1> 	pop	edi
  5457                              <1> 
  5458                              <1> r_danad:
  5459 00002D24 035CBD04            <1> 	add	ebx, dword ptr [ebp+edi*4+4]
  5460 00002D28 C1E308              <1> 	shl	ebx, 8
  5461 00002D2B 1500000000          <1> 	adc	eax, 0
  5462 00002D30 C1EB08              <1> 	shr	ebx, 8
  5463 00002D33 895CBD04            <1> 	mov	dword ptr [ebp+edi*4+4], ebx
  5464 00002D37 0344BD00            <1> 	add	eax, dword ptr [ebp+edi*4]
  5465                              <1> 
  5466                              <1> r_store_carry:
  5467 00002D3B E87FEEFFFF          <1> 	call	_alu_carry
  5468 00002D40 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
  5469 00002D44 E90EFBFFFF          <1> 	jmp	_rex_accumulate
  5470                              <1> 	
  5471                                  					; data follows here
  5472                                  					; if it is in this assembly
  5473                                  	%if	RTA_MBANKS
  5474                                  
  5475                                  	section		.data
  5476                                  	%include	"rta_data.msm"
  5477                                  
  5478                                  	section		.bss
  5479                                  _memory	resd	MEMORY
  5480                                  
  5481                                  	%endif
  5482                                  
  5483                                  	end
  5484                                  
