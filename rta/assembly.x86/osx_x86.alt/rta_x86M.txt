     1                                  
     2                                  	%include	"rta_x86n.def"
     1                              <1> 
     2                              <1> __SMP		equ	8
     3                              <1> 
     4                              <1> TIME_UPDATE	equ     1
     5                              <1> LOCKSTEP	equ	2
     6                              <1> BREAKPOINT	equ	4
     7                              <1> CHILLDOWN	equ	8
     8                              <1> 
     9                              <1> EXTERNAL_INTERRUPT 	equ	00FF00h
    10                              <1> ATTENTION		equ	128
    11                              <1> INCREMENTER_CARRY	equ	64
    12                              <1> 
    13                              <1> 		%if	DRANG & 2
    14                              <1> INDICATIONS	equ	CHILLDOWN|TIME_UPDATE|LOCKSTEP
    15                              <1> 		%else
    16                              <1> INDICATIONS	equ	CHILLDOWN|TIME_UPDATE|LOCKSTEP|BREAKPOINT
    17                              <1> 		%endif
    18                              <1> 
    19                              <1> EXTERNAL_INDICATIONS equ EXTERNAL_INTERRUPT|ATTENTION|INCREMENTER_CARRY
    20                              <1> 
    21                              <1> IO_PORTS	equ	192
    22                              <1> 
    23                              <1> 	%if	RTA_MBANKS
    24                              <1> global	_metric
    25                              <1> global	_indication
    26                              <1> global	_iselect
    27                              <1> global	_iselectu
    28                              <1> global	_readout
    29                              <1> global	_readoutx
    30                              <1> global	_readoutp
    31                              <1> global	_psr
    32                              <1> global	_apc
    33                              <1> global	_apcz
    34                              <1> global	_breakpoint
    35                              <1> global	_b0_name
    36                              <1> global	_b0p
    37                              <1> global	_devices
    38                              <1> global	_base
    39                              <1> global	_register_set
    40                              <1> global	__register
    41                              <1> global	_memory
    42                              <1> 
    43                              <1> 	%if	RTA_MBANKS<1
    44                              <1> RTA_MPAGES	equ	32
    45                              <1> 	%else
    46                              <1> RTA_MPAGES	equ	RTA_MBANKS*64
    47                              <1> 	%endif
    48                              <1> 
    49                              <1> 	%else
    50                              <1> extern	_metric
    51                              <1> extern	_indication
    52                              <1> extern	_iselect
    53                              <1> extern	_iselectu
    54                              <1> extern	_psr
    55                              <1> extern	_apc
    56                              <1> extern	_apcu
    57                              <1> extern	_apcz
    58                              <1> extern	_breakpoint
    59                              <1> extern	_b0_name
    60                              <1> extern	_b0p
    61                              <1> extern	_devices
    62                              <1> extern	_base
    63                              <1> extern	_register_set
    64                              <1> extern	__register
    65                              <1> extern	_memory
    66                              <1> 
    67                              <1> _output equ     272
    68                              <1> _inputr equ     264
    69                              <1> _input2 equ     256
    70                              <1> 
    71                              <1> _OUTPUT	equ	__register+_output*4
    72                              <1> _INPUTR	equ	__register+_inputr*4
    73                              <1> _INPUT2 equ	__register+_input2*4
    74                              <1> _BIAS	equ	_OUTPUT
    75                              <1> 
    76                              <1> 	%endif
    77                              <1> 
    78                              <1> 	extern	_flag
    79                              <1> 	extern	_uflag
    80                              <1> 
    81                              <1> HALF_W	equ	128
    82                              <1> FP_R	equ	8
    83                              <1> B_STREAMZR  equ 64
    84                              <1> B_STREAM16R equ 32
    85                              <1> B_STREAM16W equ 16
    86                              <1> 
    87                              <1> r	equ	0
    88                              <1> k	equ	1
    89                              <1> x	equ	2
    90                              <1> y	equ	3
    91                              <1> a	equ	4
    92                              <1> b	equ	5
    93                              <1> mantissa2 equ	6
    94                              <1> mantissa3 equ	7
    95                              <1> residue	equ	8
    96                              <1> p	equ	12
    97                              <1> q	equ	13
    98                              <1> fp	equ	14
    99                              <1> s_p	equ	15
   100                              <1> 
   101                              <1> rdatac	equ	20
   102                              <1> rdata	equ	21
   103                              <1> wdatac	equ	22
   104                              <1> wdata	equ	23
   105                              <1> 
   106                              <1> 
   107                              <1> fp_guard equ	128+19
   108                              <1> 
   109                              <1> rt_clock equ	128+20
   110                              <1> priority equ	128+21
   111                              <1> dayclock_u equ	128+22
   112                              <1> dayclock equ	128+23
   113                              <1> 
   114                              <1> R	equ	r*4
   115                              <1> K	equ	k*4
   116                              <1> X	equ	x*4
   117                              <1> Y	equ	y*4
   118                              <1> A	equ	a*4
   119                              <1> B	equ	b*4
   120                              <1> MANTISSA2 equ	mantissa2*4
   121                              <1> MANTISSA3 equ	mantissa3*4
   122                              <1> RESIDUE	equ	residue*4
   123                              <1> 
   124                              <1> P	equ	p*4
   125                              <1> Q	equ	q*4
   126                              <1> FP	equ	fp*4
   127                              <1> S_P	equ	s_p*4
   128                              <1> 
   129                              <1> RDATAC	equ	rdatac*4
   130                              <1> RDATA	equ	rdata*4
   131                              <1> WDATAC	equ	wdatac*4
   132                              <1> WDATA	equ	wdata*4
   133                              <1> 
   134                              <1> FP_GUARD equ	fp_guard*4
   135                              <1> 
   136                              <1> RT_CLOCK equ	rt_clock*4
   137                              <1> PRIORITY equ	priority*4
   138                              <1> DAYCLOCK_U equ	dayclock_u*4
   139                              <1> DAYCLOCK equ	dayclock*4
   140                              <1> 
   141                              <1> I	equ	4
   142                              <1> XI	equ	5
   143                              <1> 
   144                              <1> DEVICE  equ	32768
   145                              <1> SYSMEM  equ	16384
   146                              <1> DATA16  equ	1
   147                              <1> FSYS24  equ	2
   148                              <1> 
   149                              <1> II_GUARD equ	64+31
   150                              <1> II_EXIT	equ	64+6
   151                              <1> II_YIELD equ	64+1
   152                              <1> II_SPAWN equ	64+2
   153                              <1> II_BANK equ	64+3
   154                              <1> II_ARRAY equ	64+4
   155                              <1> II_BANK_FREE equ 64+5
   156                              <1> II_TWAIT equ	64+27
   157                              <1> II_EVENT_WAIT equ 64+28
   158                              <1> II_FPXPO equ	0+3
   159                              <1> 
   160                              <1> II_XINT		equ	0+2
   161                              <1> II_MSECOND	equ	0+4
   162                              <1> II_ATTENTION	equ	0+5
   163                              <1> 
   164                              <1> LP_AUTHORITY	equ	1		; latent parameters GUARD$
   165                              <1> LP_ADDRESS	equ	14
   166                              <1> 
   167                              <1> LP_TIMESLICE	equ	10		; latent parameter timeslice -> yield
   168                              <1> LP_RANGE	equ	12		; latent parameter FP$XPO
   169                              <1> LP_AUTOEXIT	equ	11		; latent parameter return -> EXIT$
     3                                  
     4                                  ;	this is not PIC code
     5                                  ;	but does relative jumps for compactness
     6                                  
     7                                  %define ptr
     8                                  %define include
     9                                  %define .model
    10                                  %define .code
    11                                  
    12                                  SYSMEM_FLAG	equ	00800000h
    13                                  DATA16_FLAG	equ	00400000h
    14                                  FSYS24_FLAG	equ	00C00000h
    15                                  
    16                                  					; instruction code starts here
    17                                  	section		.text
    18                                  	global		_leloup
    19                                  	global		_execute
    20                                  	global		_device_readp
    21                                  	global		_bus_readp
    22                                  	global		_memory_read
    23                                  	global		_bus_read
    24                                  	global		_device_read
    25                                  
    26                                  	%include	"leloup.msm"
     1                              <1> _leloup:
     2 00000000 55                  <1> 	push	ebp
     3 00000001 56                  <1> 	push	esi
     4 00000002 57                  <1> 	push	edi
     5                              <1> 
     6 00000003 50                  <1> 	push	eax
     7 00000004 53                  <1> 	push	ebx
     8 00000005 51                  <1> 	push	ecx
     9 00000006 52                  <1> 	push	edx
    10                              <1> 
    11 00000007 8B15[00000000]      <1> 	mov	edx, dword ptr [_apc]
    12 0000000D 8B2D[00000000]      <1> 	mov	ebp, dword ptr [_register_set]
    13                              <1> 
    14 00000013 3B15[00000000]      <1> loup:	cmp	edx, dword ptr [_apcz]
    15 00000019 773D                <1> 	ja	off_limits
    16                              <1> 
    17 0000001B 8B02                <1> 	mov	eax, dword ptr [edx]
    18 0000001D 0FC8                <1> 	bswap	eax
    19 0000001F 83C204              <1> 	add	edx, 4
    20 00000022 E8F7000000          <1> 	call	_execute
    21                              <1> 
    22                              <1> 	%if	RATIO
    23                              <1> 	%else
    24                              <1> 	%if	METRIC
    25                              <1> 	inc	dword ptr [_metric]
    26                              <1> 	%endif
    27                              <1> 	%endif
    28                              <1> 
    29                              <1> 	%if	TSLICE
    30 00000027 F705[00000000]0000- <1> 	test	dword ptr [_psr], 00870000h	; not while ISR or interrupt mask
    30 0000002F 8700                <1>
    31 00000031 752F                <1> 	jnz	louping
    32 00000033 F705[50020000]FFFF- <1> 	test	dword ptr [__register+RT_CLOCK], 00FFFFFFh
    32 0000003B FF00                <1>
    33 0000003D 7423                <1> 	jz	louping
    34                              <1> 
    35 0000003F FF0D[50020000]      <1> 	dec	dword ptr [__register+RT_CLOCK]
    36 00000045 751B                <1> 	jnz	louping
    37                              <1> 
    38 00000047 B841000000          <1> 	mov	eax, II_YIELD
    39 0000004C BE0A000000          <1> 	mov	esi, LP_TIMESLICE
    40 00000051 E8A00D0000          <1> 	call	_ii
    41                              <1> 	%endif
    42                              <1> 
    43 00000056 EB0A                <1> 	jmp	louping
    44                              <1> 
    45                              <1> off_limits:
    46 00000058 B85F000000          <1> 	mov	eax, II_GUARD
    47 0000005D E8940D0000          <1> 	call	_ii
    48                              <1> 
    49                              <1> louping:
    50                              <1> 	%if	DRANG & 1
    51                              <1> 	dec	dword ptr [__register+282*4]
    52                              <1> 	jnz	loup_adrang
    53                              <1> 	or	word ptr [_indication], LOCKSTEP
    54                              <1> loup_adrang
    55                              <1> 	%endif
    56                              <1> 
    57                              <1> 	%if	DRANG & 2
    58 00000062 A1[00000000]        <1> 	mov	eax, dword ptr [_breakpoint]
    59 00000067 31D0                <1> 	xor	eax, edx
    60 00000069 744A                <1> 	jz	indicated
    61                              <1> 	%endif
    62                              <1> 
    63                              <1> 	%if	RATIO
    64 0000006B FF0D[6C040000]      <1> 	dec	dword ptr [__register+283*4]
    65 00000071 7508                <1> 	jnz	loup_away
    66 00000073 66830D[00000000]01  <1> 	or	word ptr [_indication], TIME_UPDATE
    67                              <1> loup_away:
    68                              <1> 	%endif
    69                              <1> 
    70 0000007B 66A1[00000000]      <1> 	mov	ax, word ptr [_indication]
    71 00000081 8A0D[02000000]      <1> 	mov	cl, byte ptr [_psr+2]
    72 00000087 80E107              <1> 	and	cl, 7				; highest interrupt mask?
    73 0000008A 80F107              <1> 	xor	cl, 7
    74 0000008D 7417                <1> 	jz	internal_indications?		; maskable interrupts are masked
    75                              <1> 
    76 0000008F 66A9CBFF            <1>         test	ax, INDICATIONS|EXTERNAL_INDICATIONS
    77 00000093 0F847AFFFFFF        <1> 	jz	loup
    78 00000099 66A9C0FF            <1> 	test	ax, EXTERNAL_INDICATIONS
    79 0000009D 7416                <1> 	jz	indicated
    80 0000009F E8CE0C0000          <1> 	call	_xi
    81 000000A4 EBBC                <1> 	jmp	louping				; keep going intil pending flags are off
    82                              <1> 
    83                              <1> internal_indications?:
    84 000000A6 66F705[00000000]0B- <1> 	test	word ptr [_indication], INDICATIONS
    84 000000AE 00                  <1>
    85 000000AF 0F845EFFFFFF        <1> 	jz	loup
    86                              <1> 
    87                              <1> indicated:
    88 000000B5 892D[00000000]      <1> 	mov	dword ptr [_register_set], ebp
    89 000000BB 8915[00000000]      <1> 	mov	dword ptr [_apc], edx
    90                              <1> 
    91 000000C1 5A                  <1> 	pop	edx
    92 000000C2 59                  <1> 	pop	ecx
    93 000000C3 5B                  <1> 	pop	ebx
    94 000000C4 58                  <1> 	pop	eax
    95                              <1> 
    96 000000C5 5F                  <1> 	pop	edi
    97 000000C6 5E                  <1> 	pop	esi
    98 000000C7 5D                  <1> 	pop	ebp
    99 000000C8 C3                  <1> 	ret
   100                              <1> 
    27                                  	%include	"execute.msm"
     1                              <1> ;	include	rta_x86.h
     2                              <1> .model	small
     2          ******************  <1>  warning: label alone on a line without a colon might be in error [-w+orphan-labels]
     3                              <1> .code
     4                              <1> ;	_execute:
     5                              <1> ;        mov     dword ptr [__register+287*4], esp
     6                              <1> 
     7 000000C9 89C1                <1> __ea:	mov	ecx, eax
     8 000000CB C1E108              <1> 	shl	ecx, 8
     9 000000CE C1E913              <1> 	shr	ecx, 24-5		; instruction index in ch
    10 000000D1 C0E905              <1> 	shr	cl, 5			; operand designator in cl
    11                              <1> 
    12 000000D4 C1E010              <1> 	shl	eax, 16
    13 000000D7 80F905              <1> 	cmp	cl, XI			; sign extended immediate?
    14 000000DA 7508                <1> 	jnz	derive_ea
    15                              <1> 
    16 000000DC C1F808              <1> 	sar	eax, 8			; different from other EAs
    17 000000DF C1E808              <1> 	shr	eax, 8
    18 000000E2 EB39                <1> 	jmp	ea_derived
    19                              <1> 
    20                              <1> derive_ea:
    21 000000E4 C1E810              <1> 	shr	eax, 16			; no sign of it
    22 000000E7 6621C0              <1> 	and	ax, ax			; indexing / indirection ?
    23 000000EA 7931                <1> 	jns	ea_derived		; no
    24                              <1> 
    25 000000EC 89C3                <1> 	mov	ebx, eax
    26 000000EE 80E47F              <1> 	and	ah, 127			; ie: and ax 32767
    27 000000F1 66C1EB0C            <1> 	shr	bx, 12			; position index tag
    28 000000F5 F6C306              <1> 	test	bl, 6			; indirect or indexed ?
    29 000000F8 7415                <1> 	jz	indirect
    30                              <1> 					; pe = PF set
    31                              <1> 					; can only be tested on b7..0
    32 000000FA 7A03                <1> 	jpe	indexed_4bit		; indexed fp / sp
    33                              <1> 					; indexed x / y / a / b
    34 000000FC 80E307              <1> 	and	bl, 7			; zero bit 3
    35                              <1> 
    36                              <1> indexed_4bit:
    37 000000FF 6625FF0F            <1> 	and	ax, 4095		; isolate address offset
    38 00000103 03449D00            <1> 	add	eax, dword ptr [ebp+ebx*4]
    39                              <1> 
    40 00000107 C1E008              <1> 	shl	eax, 8			; truncate any overflow
    41 0000010A C1E808              <1> 	shr	eax, 8
    42                              <1> 
    43 0000010D EB0E                <1> 	jmp	ea_derived
    44                              <1> 
    45                              <1> indirect:				; indirect via page B0 / B1
    46 0000010F 6689CB              <1> 	mov	bx, cx
    47 00000112 6631C9              <1> 	xor	cx, cx			; cl <- zero to read 1-word indirection pointer
    48 00000115 E81C020000          <1> 	call	_operand_read
    49 0000011A 6689D9              <1> 	mov	cx, bx			; retrieve instruction:class into cx
    50                              <1> 
    51                              <1> ea_derived:
    52 0000011D C3                  <1> 	ret
    53                              <1> 
    54                              <1> _execute:
    55 0000011E 8925[7C040000]      <1> 	mov	dword ptr [__register+287*4], esp
    56 00000124 E8A0FFFFFF          <1> 	call	__ea
    57                              <1> 
    58 00000129 0FB6DD              <1> 	movzx	ebx, ch			; instruction index
    59 0000012C 80F906              <1> 	cmp	cl, 6
    60 0000012F 740B                <1> 	jz	joshi
    61 00000131 80F907              <1> 	cmp	cl, 7			; 2 quick questions about instruction class
    62 00000134 750B                <1> 	jnz	integer_operations
    63 00000136 E918010000          <1> 	jmp	large_operations
    64                              <1> 
    65 0000013B C3                  <1> escape:	ret
    66                              <1> 
    67 0000013C E989000000          <1> joshi:	jmp	shifts_jumps
    68                              <1> 
    69                              <1> integer_operations:
    70 00000141 8B1C9D[4A010000]    <1> 	mov	ebx, dword ptr [operations1+ebx*4]
    71 00000148 FFE3                <1> 	jmp	ebx
    72                              <1> 
    73                              <1> operations1:
    74 0000014A [63110000]          <1>         dd	_sr
    75 0000014E [7D110000]          <1>         dd	_sk
    76 00000152 [97110000]          <1>         dd	_sx
    77 00000156 [B1110000]          <1>         dd	_sy
    78 0000015A [CB110000]          <1>         dd	_sa
    79 0000015E [E5110000]          <1>         dd	_sb
    80 00000162 [FF110000]          <1>         dd	_z
    81 00000166 [18120000]          <1>         dd	_pop
    82                              <1> 
    83 0000016A [3E120000]          <1>         dd	_lr
    84 0000016E [47120000]          <1>         dd	_lk
    85 00000172 [50120000]          <1>         dd	_lx
    86 00000176 [59120000]          <1>         dd	_ly
    87 0000017A [62120000]          <1>         dd	_la
    88 0000017E [6B120000]          <1>         dd	_lb
    89 00000182 [74120000]          <1>         dd	_tz
    90 00000186 [9B120000]          <1>         dd	_tp
    91                              <1> 
    92 0000018A [C6150000]          <1>         dd	_ax
    93 0000018E [D7150000]          <1>         dd	_ay
    94 00000192 [E8150000]          <1>         dd	_or
    95 00000196 [F1150000]          <1>         dd	_orB
    96 0000019A [FA150000]          <1>         dd	_and
    97 0000019E [03160000]          <1>         dd	_andB
    98 000001A2 [0C160000]          <1>         dd	_xor
    99 000001A6 [15160000]          <1>         dd	_xorB
   100                              <1> 
   101 000001AA [1E160000]          <1>         dd	_aa
   102 000001AE [3E160000]          <1>         dd	_ab
   103 000001B2 [25160000]          <1>         dd	_ana
   104 000001B6 [45160000]          <1>         dd	_anb
   105 000001BA [5E160000]          <1>         dd	_m
   106 000001BE [8E160000]          <1>         dd	_mf
   107 000001C2 [EA160000]          <1>         dd	_d
   108 000001C6 [B9120000]          <1>         dd	_push
   109                              <1> 
   110                              <1> shifts_jumps:
   111 000001CA 8B1C9D[D3010000]    <1> 	mov	ebx, dword ptr [operations6+ebx*4]
   112 000001D1 FFE3                <1> 	jmp	ebx
   113                              <1> 
   114                              <1> operations6:
   115 000001D3 [8F170000]          <1>         dd	_sar
   116 000001D7 [A6170000]          <1>         dd	_sbr
   117 000001DB [BD170000]          <1>         dd	_dsr
   118 000001DF [DB120000]          <1>         dd	_jdr
   119 000001E3 [D1170000]          <1>         dd	_sal
   120 000001E7 [E8170000]          <1>         dd	_sbl
   121 000001EB [FF170000]          <1>         dd	_dsl
   122 000001EF [F5120000]          <1>         dd	_lcal
   123                              <1> 
   124 000001F3 [13180000]          <1>         dd	_rar
   125 000001F7 [1F180000]          <1>         dd	_rbr
   126 000001FB [2B180000]          <1>         dd	_drr
   127 000001FF [10130000]          <1>         dd	_jnc
   128 00000203 [C7190000]          <1>         dd	_ral
   129 00000207 [D3190000]          <1>         dd	_rbl
   130 0000020B [DF190000]          <1>         dd	_drl
   131 0000020F [1D130000]          <1>         dd	_jc
   132                              <1> 
   133 00000213 [F3190000]          <1>         dd	_saa
   134 00000217 [041A0000]          <1>         dd	_sba
   135 0000021B [151A0000]          <1>         dd	_dsa
   136 0000021F [2A130000]          <1>         dd	_jao
   137 00000223 [34130000]          <1>         dd	_jpa
   138 00000227 [3E130000]          <1>         dd	_jpb
   139 0000022B [48130000]          <1>         dd	_j
   140 0000022F [6A130000]          <1>         dd	_jpo
   141                              <1> 
   142 00000233 [72130000]          <1>         dd	_jza
   143 00000237 [7C130000]          <1>         dd	_jzb
   144 0000023B [86130000]          <1>         dd	_jnza
   145 0000023F [90130000]          <1>         dd	_jnzb
   146 00000243 [9A130000]          <1>         dd	_jna
   147 00000247 [A4130000]          <1>         dd	_jnb
   148 0000024B [AE130000]          <1>         dd	_jxge
   149 0000024F [BD130000]          <1>         dd	_jyge
   150                              <1> 
   151                              <1> 
   152                              <1> large_operations:
   153 00000253 8B1C9D[5E020000]    <1> 	mov	ebx, dword ptr [operations7+ebx*4]
   154 0000025A B100                <1> 	mov	cl, 0		; default size large operand
   155 0000025C FFE3                <1> 	jmp	ebx		; 1 word
   156                              <1> 
   157                              <1> operations7:
   158 0000025E [A5140000]          <1>         dd	_ts
   159 00000262 [291A0000]          <1>         dd	_n
   160 00000266 [381A0000]          <1>         dd	_inc
   161 0000026A [431A0000]          <1>         dd	_dec
   162 0000026E [BB140000]          <1>         dd	_sim
   163 00000272 [8A1A0000]          <1>         dd	_popA
   164 00000276 [4E1A0000]          <1>         dd	_src
   165 0000027A [6C1A0000]          <1>         dd	_slc
   166                              <1> 
   167 0000027E [D0130000]          <1>         dd	_qs
   168 00000282 [DA130000]          <1>         dd	_ql
   169 00000286 [4A140000]          <1>         dd	_dte
   170 0000028A [0B140000]          <1>         dd	_dpop
   171 0000028E [E0220000]          <1>         dd	_fa
   172 00000292 [FB220000]          <1>         dd	_fan
   173 00000296 [16230000]          <1>         dd	_fm
   174 0000029A [31230000]          <1>         dd	_fd
   175                              <1> 
   176 0000029E [E4130000]          <1>         dd	_qpop
   177 000002A2 [F7130000]          <1>         dd	_qpush
   178 000002A6 [9B140000]          <1>         dd	_ex
   179 000002AA [1E140000]          <1>         dd	_dpush
   180 000002AE [681B0000]          <1>         dd	_lsc
   181 000002B2 [39140000]          <1>         dd	_mta
   182 000002B6 [5D140000]          <1>         dd	_sc
   183 000002BA [6B140000]          <1>         dd	_mlb
   184                              <1> 
   185 000002BE [84140000]          <1>         dd	_ds
   186 000002C2 [8E140000]          <1>         dd	_dl
   187 000002C6 [BA1A0000]          <1>         dd	_da
   188 000002CA [C11A0000]          <1>         dd	_dan
   189 000002CE [791B0000]          <1>         dd	_dlsc
   190 000002D2 [9A140000]          <1>         dd	_spare
   191 000002D6 [00150000]          <1>         dd	_go
   192 000002DA [DC140000]          <1>         dd	_call
   193                              <1> 
    28                                  	%include	"rw.msm"
     1                              <1> 
     2                              <1> 
     3                              <1> ;	include	rta_x86.h
     4                              <1> ;	.model	large
     5                              <1> ;	.code
     6                              <1> 
     7                              <1> ;	this is the operand reader / writer
     8                              <1> ;	for emulated RTA1 on x86
     9                              <1> 
    10                              <1> ;	layout is
    11                              <1> 
    12                              <1> ;	RTA1 24-bit registers are modeled in an array of
    13                              <1> ;	platform-endian integers. In x86 these are 32-bit
    14                              <1> ;	little-endian integers
    15                              <1> 
    16                              <1> ;	platform-endian doesn't affect registers
    17                              <1> ;	because endianness is not at the CPU
    18                              <1> ;	side of the bus, but at the memory side
    19                              <1> 
    20                              <1> ;	when Intel circuitry in the x86 CPU staticises the value
    21                              <1> ;	of an emulated register, that value is big endian
    22                              <1> 
    23                              <1> ;	the stored integers where emulated registers are modeled
    24                              <1> ;	are platform-endian, with identical effect on big and
    25                              <1> ;	little endian emulator platforms
    26                              <1> 
    27                              <1> ;	RTA1 24-bit executable space storage words are modeled in
    28                              <1> ;	another array of platform-endian 32-bit integers. Emulation
    29                              <1> ;	on x86 swaps the byte order of storage words on read and
    30                              <1> ;	before write to conform with RTA1 canonical storage order
    31                              <1> 
    32                              <1> ;       RTA1 architecture has registers in the first 256 locations
    33                              <1> ;       of address space and access differentiates registers from
    34                              <1> ;       from memory according to effective address
    35                              <1> 
    36                              <1> ;	location of registers and storage are handed to read / write
    37                              <1> ;	routines as RTA1 word linear effective addresses
    38                              <1> 
    39                              <1> ;	These routines maintain the RTA1 linear addresses passed
    40                              <1> ;	in x86 registers and apply them with shifted scale plus
    41                              <1> ;	displacement, for example
    42                              <1> 
    43                              <1> ;		mov	eax, dword ptr [edi+esi*4+_memory]
    44                              <1> ;		bswap	eax
    45                              <1> ;		mov	dword_ptr [ebp+ebx*4], eax
    46                              <1> 
    47                              <1> ;	RTA1 register addresses are already absolute in terms of
    48                              <1> ;	the emulated RTA1 machine
    49                              <1> 
    50                              <1> ;	ebp points at the context register frame. There are two
    51                              <1> ;	register frames, application and interrupt. Registers
    52                              <1> ;	addressed as storage operand are in a single list
    53                              <1> 
    54                              <1> ;		mov	eax, dword ptr [esi*4+__register]
    55                              <1> 
    56                              <1> ;	RTA1 storage addresses are translated by RTA1 relocation
    57                              <1> ;	architecture before application. The updated linear addresses
    58                              <1> ;	of the emulated machine are in esi
    59                              <1> 
    60                              <1> ;	The operand routines in this file point edi to the x86 platform
    61                              <1> ;	storage array start of the storage device, most often emulated
    62                              <1> ;	RTA1 executable space
    63                              <1> 
    64                              <1> ;	instructions call these operand routines with RTA1 effective 
    65                              <1> ;	address in eax
    66                              <1> 
    67                              <1> ;	instructions receive load operand values in eax and ebx, or in
    68                              <1> ;	a list of RTA1 emulated register locations pointed by ebp+ebx
    69                              <1> 
    70                              <1> ;	store instructions submit a value in ebx, or values in list of
    71                              <1> ;	RTA1 emulated register locations pointed by ebp+ebx
    72                              <1> 
    73                              <1> ;	to preserve linear address consistency, application instruction
    74                              <1> ;	work areas, where needed in addition to x86 registers, are
    75                              <1> ;	implemented as sub-architectural extra RTA1 registers at the end
    76                              <1> ;	of the 256-longword register stack. x86 register ebp+ebx*4 identify
    77                              <1> ;	these locations by linear RTA1 word quantum as "registers"
    78                              <1> 
    79                              <1> ;	RTA1 registers and storage alike are in 24-bit word address quantum space
    80                              <1> 
    81                              <1> ;	emulated instructions loading or storing multiple hidden extra work
    82                              <1> ;	registers should unconditionally set ebp to the start or application
    83                              <1> ;	frame of the emulated register array, so that [ebp+ebx*4] accesses the
    84                              <1> ;	correct locations at register occurence 256+
    85                              <1> 
    86                              <1> ;               _floating_operand2 equ  256+12
    87                              <1> 
    88                              <1> ;		push	ebp
    89                              <1> ;		mov	ebp, __register	; point to application register frame[0]
    90                              <1> ;		mov	ebx, 256+_floating_operand2
    91                              <1> ;		call	_burst_read4
    92                              <1> 
    93                              <1> ;		pop	ebp		; return to previous register frame[0] application
    94                              <1> 					;                          or frame[1] interrupt
    95                              <1> 
    96                              <1> ;	Both internal stack pointers are also absolute, so for stack operations
    97                              <1> ;	ebp should be momentarily forced to the lower-addressed (application) stack
    98                              <1> ;	frame after being used to point the stack location of reference
    99                              <1> 
   100                              <1> ;		mov	ebx, dword ptr [ebp+S_P]	; read one of the two stack pointers
   101                              <1> ;		cmp	ebx, ebp+STACK_LOWER_LIMIT	; 24*4 within context of either stack
   102                              <1> ;		jl	II_GUARD
   103                              <1> ;		add	ebx, -1				; new stack top
   104                              <1> ;		mov	dword ptr [ebp+S_P], ebx
   105                              <1> ;		push	ebp				; which ever stack pointer it is, it points
   106                              <1> ;		mov	ebp,__register			; relative to all the register stack
   107                              <1> ;		call	_operand_read			; for I am the single-word push instruction
   108                              <1> ;		pop	ebp				;
   109                              <1> 
   110                              <1> ;	register identities supplied from emulated instructions to these routines
   111                              <1> ;	are their lowercase names equated to RTA1 word addresses
   112                              <1> 
   113                              <1> ;	There exist also uppercase spellings which instruction routines may
   114                              <1> ;	access internally. The uppercase names are four times in value the
   115                              <1> ;	equivalent lowercase ordinal names to give x86 platform offset values
   116                              <1> 
   117                              <1> ;       Assembly language equate is like parentheses! What's in a label
   118                              <1> ;       is not an expression but its value. Nothing like C preprocessor.
   119                              <1> ;       Just in case you're developing enhancements in assembly using
   120                              <1> ;       preprocessor and #define
   121                              <1> 
   122                              <1> ;		_floating_operand2 equ	256+12
   123                              <1> ;		FLOATING_OPERAND2 equ	_floating_operand2*4
   124                              <1> 
   125                              <1> 
   126                              <1> ;		a	equ	4
   127                              <1> ;		b	equ	5
   128                              <1> ;		mantissa2 equ	6
   129                              <1> 
   130                              <1> ;		A	equ	a*4
   131                              <1> ;		B	equ	b*4
   132                              <1> ;		MANTISSA2 equ	mantissa2*4
   133                              <1> 
   134                              <1> ;		mov	ebx, dword ptr [bp+MANTISSA2]	; the very same!
   135                              <1> ;		mov	ebx, dword ptr [bp+mantissa2*4]	; the very same
   136                              <1> 
   137                              <1> ;	but to identify an instruction-implied register to these operand routines
   138                              <1> 
   139                              <1> ;		mov	ebx, mantissa2		; bp already says which register set
   140                              <1> 
   141                              <1> ;	instruction evaluation supplies right-hand side operand EA in eax
   142                              <1> ;	Instruction implementation needs not examine EA. Call _operand_read
   143                              <1> ;	or _operand_write. eax must be as supplied to the instruction routine
   144                              <1> ;	on on operand retrieve and store
   145                              <1> 
   146                              <1> ;	simple instructions receive operand mode in cl from instruction
   147                              <1> ;	evaluation
   148                              <1> 
   149                              <1> ;	shifts and jumps use the ea which is already indexed or indirected
   150                              <1> ;	if necessary and make no operand call
   151                              <1> 
   152                              <1> ;	instructions call _burst_read2 or _burst_write2 for two-word operand cycles
   153                              <1> ;	instructions call _burst_read4 or _burst_write4 for four-word operand cycles
   154                              <1> 
   155                              <1> ;	operand reads of 1 or 2 words return values in eax:ebx
   156                              <1> 
   157                              <1> ;		call	_burst_read2
   158                              <1> ;		mov	dword ptr [ebp+A], eax
   159                              <1> ;		mov	dword ptr [ebp+B], ebx
   160                              <1> 
   161                              <1> ;	to store one operand word place it in ebx
   162                              <1> 
   163                              <1> ;	_sc	mov	ebx, dword ptr[_psr]	; I am the store carry instruction sc
   164                              <1> ;		and	ebx, 1			; CARRY
   165                              <1> ;		call	_operand_write
   166                              <1> 
   167                              <1> ;	to store two or four words or to load four words, point bx to register
   168                              <1> 
   169                              <1> ;	_qpop	mov	ebx, dword ptr [ebp+S_P] ; internal stack pointer
   170                              <1> ;						; either application sp or interrupt sp
   171                              <1> ;
   172                              <1> ;		add	dword ptr [ebp+S_P], 4	; internal stack+= 4
   173                              <1> ;		push	ebp			;
   174                              <1> ;		mov	ebp, __register		; in case context is interrupt registers
   175                              <1> ;		call	_burst_write4		; both internal stack pointers are absolute
   176                              <1> ;		pop	ebp			; point epb back to application registers
   177                              <1> ;						;                or interrupt registers
   178                              <1> 
   179                              <1> ;	more complex instructions do something to the registers after
   180                              <1> ;	acquiring operands
   181                              <1> 
   182                              <1> ;		call	_operand_read
   183                              <1> ;		add	eax, dword ptr [ebp+A]
   184                              <1> ;		rol	eax
   185                              <1> ;		and	al, CARRY		; 1
   186                              <1> ;		or	byte ptr [_psr], al	; low-order byte of longword _psr
   187                              <1> ;		shr	eax, 8
   188                              <1> ;		mov	dword ptr [ebp+A], eax
   189                              <1> 
   190                              <1> ;	emulated RTA1 instructions which both read and write (modify)
   191                              <1> ;	storage use the address in [edi+esi*4] to rewrite. edi is
   192                              <1> ;	NULL if it's not a suitable memory for a modify operation
   193                              <1> 
   194                              <1> ;	modify instructions which may have a register operand (not TS)
   195                              <1> ;	call _operand_write to rewrite a register. This guards aganst
   196                              <1> ;	applications writing interrupt registers.
   197                              <1>  
   198                              <1> ;	the effect of storage buses characteristically different
   199                              <1> ;	from RTA1 executable space is emulated in the routines
   200                              <1> ;	device_read and device_write
   201                              <1> 
   202                              <1> ;	Peripheral bus types implemented are
   203                              <1> 
   204                              <1> ;		filestore containing extents of up to 768K octets
   205                              <1> ;		accessible to RTA1 as up to 256K words in each extent.
   206                              <1> ;		The 3-octet words are in canonical order and packed
   207                              <1> 
   208                              <1> ;		network interface buffer store shared with the emulator
   209                              <1> ;		platform and reading out to RTA1 at 16 data bits per word
   210                              <1> ;		with eight high-order zero bits. RTA writes 16 data bits
   211                              <1> ;		to these locations from register low-order bit positions.
   212                              <1> ;		Storage byte order is canonical. These buffers are normal
   213                              <1> ;		and contiguous byte arrays of the emulator platform.
   214                              <1> ;		To RTA1 they are an attached device array of 16-bit words
   215                              <1> 
   216                              <1> ;	Device array types are
   217                              <1> 
   218                              <1> ;		executable space
   219                              <1> ;		24-bit filestore array
   220                              <1> ;		16-bit network interface array
   221                              <1> 
   222                              <1> ;	devices are identified in RTA1 memory relocation pointers and
   223                              <1> ;	tagged with device type. Executable space is device zero
   224                              <1> 
   225                              <1> _burst_read2:
   226 000002DE 66B90600            <1> 	mov	cx, 6
   227 000002E2 A900FFFF00          <1> 	test	eax, 00FFFF00h
   228 000002E7 7402                <1> 	jz	read2_registers
   229 000002E9 EB67                <1> 	jmp	_bus_read
   230                              <1> 
   231                              <1> read2_registers:				; load registers from registers
   232 000002EB 8B1C85[04000000]    <1> 	mov	ebx, dword ptr [eax*4+__register+4]
   233 000002F2 8B0485[00000000]    <1> 	mov	eax, dword ptr [eax*4+__register]
   234 000002F9 C3                  <1> 	ret
   235                              <1> 	
   236                              <1> _burst_read4:				; buffered read
   237 000002FA 66B90700            <1> 	mov	cx, 7			; that will help the caller
   238 000002FE A900FFFF00          <1> 	test	eax, 00FFFF00h		; ebp+ebx contains a register number
   239 00000303 7402                <1> 	jz	read4_registers		; may also identify extra
   240 00000305 EB4B                <1> 	jmp	_bus_read
   241                              <1> 					; workspace registers
   242                              <1> read4_registers:			; at register stack tail
   243 00000307 89C6                <1> 	mov	esi, eax
   244 00000309 8B04B5[0C000000]    <1> 	mov	eax, dword ptr [esi*4+__register+12]
   245 00000310 89449D0C            <1> 	mov	dword ptr [ebp+ebx*4+12], eax
   246 00000314 8B04B5[08000000]    <1> 	mov	eax, dword ptr [esi*4+__register+8]
   247 0000031B 89449D08            <1> 	mov	dword ptr [ebp+ebx*4+8], eax
   248 0000031F 8B04B5[04000000]    <1> 	mov	eax, dword ptr [esi*4+__register+4]
   249 00000326 89449D04            <1> 	mov	dword ptr [ebp+ebx*4+4], eax
   250 0000032A 8B04B5[00000000]    <1> 	mov	eax, dword ptr [esi*4+__register]
   251 00000331 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   252 00000335 C3                  <1> 	ret
   253                              <1> 
   254                              <1> _operand_read:			; call here with designator coded in cx
   255 00000336 80E107              <1> 	and	cl, 7		; and ea in eax
   256 00000339 80F904              <1> 	cmp	cl, 4
   257 0000033C 7413                <1> 	je	immediate	; EA is operand
   258 0000033E 80F905              <1> 	cmp	cl, 5
   259 00000341 740E                <1> 	je	immediate_xi	; EA is operand
   260                              <1> 
   261 00000343 A900FFFF00          <1> 	test	eax, 00FFFF00h
   262 00000348 7508                <1> 	jnz	_bus_read	; ea does not point to registers
   263 0000034A 8B0485[00000000]    <1> 	mov	eax, dword ptr [eax*4+__register]
   264                              <1> 
   265                              <1> immediate:
   266                              <1> immediate_xi:
   267 00000351 C3                  <1> 	ret 
   268                              <1> 
   269                              <1> _bus_read:			; readout any memory
   270                              <1> 
   271                              <1> 
   272 00000352 E8C8030000          <1> 	call	base_read_pointer
   273                              <1> 
   274 00000357 A900004000          <1> 	test	eax, 00400000h		; big block?
   275 0000035C 741B                <1> 	je	memory_read_4k_block
   276                              <1> 
   277 0000035E 80F906              <1> 	cmp	cl, 6			; multiword operation?
   278 00000361 720D                <1> 	jb	_bus_read_256k_block
   279                              <1> 
   280 00000363 81FEFCFF0300        <1> 	cmp	esi, 03FFFCh		; near the edge?
   281 00000369 7605                <1> 	jna	_bus_read_256k_block	; no
   282                              <1> 
   283 0000036B E889200000          <1> 	call	read_straddle_18b?
   284                              <1> 
   285                              <1> _bus_read_256k_block:
   286 00000370 A83F                <1> 	test	al, 63
   287 00000372 7429                <1> 	jz	memory_read_page
   288                              <1> 
   289 00000374 E940040000          <1> 	jmp	device_read
   290                              <1> 
   291                              <1> memory_read_4k_block:
   292 00000379 F7C600F00300        <1> 	test	esi, 0003F000h		; inside 4k block?
   293 0000037F 740A                <1> 	jz	memory_read_thru
   294                              <1> 
   295 00000381 BE0E000000          <1> 	mov	esi, LP_ADDRESS
   296 00000386 E9600A0000          <1> 	jmp	guard_ii_escape	; no
   297                              <1> 
   298                              <1> memory_read_thru:
   299 0000038B 80F906              <1> 	cmp	cl, 6
   300 0000038E 720D                <1> 	jb	memory_read_page
   301                              <1> 
   302 00000390 81FEFC0F0000        <1> 	cmp	esi, 0FFCh		; near the edge?
   303 00000396 7605                <1> 	jna	memory_read_page	; no
   304                              <1> 
   305 00000398 E834200000          <1> 	call	read_straddle_12b?
   306                              <1> 
   307                              <1> memory_read_page:
   308 0000039D C1E00C              <1> 	shl	eax, 12		; multiply by page and lose bit 00400000
   309 000003A0 01C6                <1> 	add	esi, eax
   310                              <1> 
   311 000003A2 BF[00000000]        <1> 	mov	edi, _memory	; byte address
   312                              <1> 
   313                              <1> 
   314                              <1> memory_read_on:
   315                              <1> 
   316 000003A7 0FB6C1              <1> 	movzx	eax, cl
   317 000003AA 8B0485[B3030000]    <1> 	mov	eax, dword ptr [read_action+eax*4]
   318 000003B1 FFE0                <1> 	jmp	eax
   319                              <1> read_action:
   320 000003B3 [D3030000]          <1> 	dd	memory_read_w0
   321 000003B7 [1B040000]          <1> 	dd	memory_t1
   322 000003BB [23040000]          <1> 	dd	memory_t2	; or h1
   323 000003BF [34040000]          <1> 	dd	memory_t3	; or h2
   324 000003C3 [51030000]          <1> 	dd	immediate	; don't get here
   325 000003C7 [51030000]          <1> 	dd	immediate_xi	; don't get here
   326 000003CB [DB030000]          <1> 	dd	memory_read2
   327 000003CF [EB030000]          <1> 	dd	memory_read4
   328                              <1> 
   329                              <1> memory_read_w0:			; readout system memory 1 word
   330                              <1> ;	mov	dword ptr [__register+154*4], edi
   331                              <1> ;	mov	dword ptr [__register+155*4], esi
   332 000003D3 8B04B7              <1> 	mov	eax, dword ptr [edi+esi*4]
   333 000003D6 B000                <1> 	mov	al, 0
   334 000003D8 0FC8                <1> 	bswap	eax
   335                              <1> ; immediate:
   336                              <1> ; immediate_xi:
   337 000003DA C3                  <1>  	ret
   338                              <1> 
   339                              <1> memory_read2:			; readout system memory 2 words
   340 000003DB 8B5CB704            <1> 	mov	ebx, dword ptr [edi+esi*4+4]
   341 000003DF 8B04B7              <1> 	mov	eax, dword ptr [edi+esi*4]
   342                              <1> 
   343 000003E2 B000                <1> 	mov	al, 0
   344 000003E4 B300                <1> 	mov	bl, 0
   345 000003E6 0FC8                <1> 	bswap	eax
   346 000003E8 0FCB                <1> 	bswap	ebx
   347 000003EA C3                  <1> 	ret
   348                              <1> 				; readout system memory 4 words
   349                              <1> memory_read4:			; store by pointer
   350                              <1> 				; this will be useful to the caller
   351                              <1> 
   352 000003EB 8B04B7              <1> 	mov	eax, dword ptr [edi+esi*4]
   353 000003EE B000                <1> 	mov	al, 0
   354 000003F0 0FC8                <1> 	bswap	eax
   355 000003F2 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   356 000003F6 8B44B704            <1> 	mov	eax, dword ptr [edi+esi*4+4]
   357 000003FA B000                <1> 	mov	al, 0
   358 000003FC 0FC8                <1> 	bswap	eax
   359 000003FE 89449D04            <1> 	mov	dword ptr [ebp+ebx*4+4], eax
   360 00000402 8B44B708            <1> 	mov	eax, dword ptr [edi+esi*4+8]
   361 00000406 B000                <1> 	mov	al, 0
   362 00000408 0FC8                <1> 	bswap	eax
   363 0000040A 89449D08            <1> 	mov	dword ptr [ebp+ebx*4+8], eax
   364 0000040E 8B44B70C            <1> 	mov	eax, dword ptr [edi+esi*4+12]
   365 00000412 B000                <1> 	mov	al, 0
   366 00000414 0FC8                <1> 	bswap	eax
   367 00000416 89449D0C            <1> 	mov	dword ptr [ebp+ebx*4+12], eax
   368 0000041A C3                  <1> 	ret
   369                              <1> 
   370                              <1> memory_t1:
   371 0000041B 8B04B7              <1> 	mov	eax, dword ptr [edi+esi*4]
   372 0000041E C1E010              <1> 	shl	eax, 16		; t1 = 3.2.THIS.zero
   373 00000421 EB1D                <1> 	jmp	memory_tw
   374                              <1> 
   375                              <1> memory_t2:
   376 00000423 8B04B7              <1> 	mov	eax, dword ptr [edi+esi*4]
   377 00000426 F605[00000000]80    <1> 	test	byte ptr[_psr], HALF_W
   378 0000042D 7518                <1> 	jnz	memory_h1
   379 0000042F C1E008              <1> 	shl	eax, 8		; t2 = 3.THIS.1.zero
   380 00000432 EB0C                <1> 	jmp	memory_tw
   381                              <1> 
   382                              <1> memory_t3:
   383 00000434 8B04B7              <1> 	mov	eax, dword ptr [edi+esi*4]
   384 00000437 F605[00000000]80    <1> 	test	byte ptr[_psr], HALF_W
   385 0000043E 750E                <1> 	jnz	memory_h2
   386                              <1> memory_tw:
   387 00000440 C1F810              <1> 	sar	eax, 16		; t3 = THIS.2.1.zero
   388 00000443 C1E808              <1> 	shr	eax, 8
   389 00000446 C3                  <1> 	ret
   390                              <1> 
   391                              <1> memory_h1:
   392 00000447 0FC8                <1> 	bswap	eax		; already loaded but not swapped
   393 00000449 C1E008              <1> 	shl	eax, 8		; h1 = zero.HERE.2.3
   394 0000044C EB05                <1> 	jmp	memory_hw
   395                              <1> 
   396                              <1> memory_h2:
   397 0000044E 0FC8                <1> 	bswap	eax		; already loaded but not swapped
   398 00000450 C1E014              <1> 	shl	eax, 8+12
   399                              <1> memory_hw:
   400 00000453 C1F80C              <1> 	sar	eax, 12
   401 00000456 C1E808              <1> 	shr	eax, 8
   402 00000459 C3                  <1> 	ret
   403                              <1> 
   404                              <1> 				; store system memory
   405                              <1> _burst_write4:
   406 0000045A 66B90700            <1> 	mov	cx, 7
   407 0000045E A900FFFF00          <1> 	test	eax, 00FFFF00h
   408 00000463 0F85A6000000        <1> 	jnz	NEAR bus_write
   409                              <1> 
   410                              <1> 	; store emulated registers to emulated registers
   411                              <1> 
   412 00000469 F705[00000000]0000- <1> 	test	dword ptr [_psr], 0800000h	; ISR ?
   412 00000471 8000                <1>
   413 00000473 750A                <1> 	jnz	write4_registers	; ISRs may write some spare registers
   414 00000475 83F87C              <1> 	cmp	eax, 124
   415 00000478 7605                <1> 	jna	write4_registers
   416 0000047A E967090000          <1> 	jmp	guard_ii_authority	; but applications may not write
   417                              <1> 					; any interrupt registers
   418                              <1> 
   419                              <1> write4_registers:
   420 0000047F 89C7                <1> 	mov	edi, eax		; eax can be freed
   421                              <1> 
   422 00000481 8B449D00            <1> 	mov	eax, dword ptr [ebp+ebx*4]	; data for store
   423                              <1> 					; ebp+ebx is a register number
   424                              <1> 					; which can be extra register locations
   425                              <1> 					; serving as workspace at the tail of
   426                              <1> 					; the register stack
   427                              <1> 
   428 00000485 8904BD[00000000]    <1> 	mov	dword ptr [edi*4+__register], eax
   429 0000048C 8B449D04            <1> 	mov	eax, dword ptr [ebp+ebx*4+4]
   430 00000490 8904BD[04000000]    <1> 	mov	dword ptr [edi*4+__register+4], eax
   431                              <1> 
   432 00000497 8B449D08            <1> 	mov	eax, dword ptr [ebp+ebx*4+8]
   433 0000049B 8904BD[08000000]    <1> 	mov	dword ptr [edi*4+__register+8], eax
   434 000004A2 8B449D0C            <1> 	mov	eax, dword ptr [ebp+ebx*4+12]
   435 000004A6 8904BD[0C000000]    <1> 	mov	dword ptr [edi*4+__register+12], eax
   436 000004AD C3                  <1> 	ret
   437                              <1> 
   438                              <1> _burst_write2:
   439 000004AE 66B90600            <1> 	mov	cx, 6
   440 000004B2 A900FFFF00          <1> 	test	eax, 00FFFF00h
   441 000004B7 7556                <1> 	jnz	bus_write
   442                              <1> 
   443                              <1> 	; store to emulated registers
   444                              <1> 
   445 000004B9 F705[00000000]0000- <1> 	test	dword ptr [_psr], 0800000h	; ISR ?
   445 000004C1 8000                <1>
   446 000004C3 750A                <1> 	jnz	write2_registers	; there are spare registers at the end
   447 000004C5 83F87E              <1> 	cmp	eax, 126		; but applications may not write
   448 000004C8 7605                <1> 	jna	write2_registers	; any interrupt registers
   449 000004CA E917090000          <1> 	jmp	guard_ii_authority
   450                              <1> 
   451                              <1> write2_registers:
   452 000004CF 89C7                <1> 	mov	edi, eax			; time to free eax
   453 000004D1 8B449D00            <1> 	mov	eax, dword ptr [ebp+ebx*4]
   454 000004D5 8B5C9D04            <1> 	mov	ebx, dword ptr [ebp+ebx*4+4]
   455 000004D9 8904BD[00000000]    <1> 	mov	dword ptr [edi*4+__register], eax
   456 000004E0 891CBD[04000000]    <1> 	mov	dword ptr [edi*4+__register+4], ebx
   457 000004E7 C3                  <1> 	ret
   458                              <1> 
   459                              <1> _operand_write:
   460 000004E8 A900FFFF00          <1> 	test	eax, 00FFFF00h
   461 000004ED 7520                <1> 	jnz	bus_write
   462                              <1> 
   463                              <1> _operand_write_register:
   464 000004EF A980000000          <1> 	test	eax, 80h		; in the interrupt registers?
   465 000004F4 7411                <1> 	jz	write1_register
   466 000004F6 F705[00000000]0000- <1> 	test	dword ptr [_psr], 0800000h
   466 000004FE 8000                <1>
   467 00000500 7505                <1> 	jnz	write1_register
   468 00000502 E9DF080000          <1> 	jmp	guard_ii_authority
   469                              <1> 
   470                              <1> write1_register:
   471 00000507 891C85[00000000]    <1> 	mov	dword ptr [eax*4+__register], ebx
   472 0000050E C3                  <1> 	ret
   473                              <1> 
   474                              <1> bus_write:				; write any memory
   475                              <1> 
   476 0000050F E84E020000          <1> 	call	base_write_pointer
   477                              <1> 
   478 00000514 A900004000          <1> 	test	eax, 00400000h		; big block?
   479 00000519 741E                <1> 	jz	memory_write_4k_block	; no
   480 0000051B 80F906              <1> 	cmp	cl, 6			; multiword operation?
   481 0000051E 720D                <1> 	jb	bus_write_256k_block	; no
   482                              <1> 
   483 00000520 81FEFCFF0300        <1> 	cmp	esi, 03FFFCh		; near the edge?
   484 00000526 7605                <1> 	jna	bus_write_256k_block	; no
   485                              <1> 
   486 00000528 E8351F0000          <1> 	call	write_straddle_18b?
   487                              <1> 
   488                              <1> bus_write_256k_block:
   489 0000052D A93F000000          <1> 	test	eax, 63			; a device array?
   490 00000532 7429                <1> 	jz	memory_write_page	; no. scaling shift will scrub bit 400000
   491 00000534 E97B030000          <1> 	jmp	_device_write		; yes a device array
   492                              <1> 
   493                              <1> memory_write_4k_block:
   494 00000539 F7C600F00300        <1> 	test	esi, 0003F000h		; inside a 4k page?
   495 0000053F 740A                <1> 	jz	memory_write_thru
   496 00000541 BE0E000000          <1> 	mov	esi, LP_ADDRESS
   497 00000546 E9A0080000          <1> 	jmp	guard_ii_escape		; no
   498                              <1> 
   499                              <1> memory_write_thru:
   500 0000054B 80F906              <1> 	cmp	cl, 6			; multiword operation?
   501 0000054E 720D                <1> 	jb	memory_write_page	; no
   502                              <1> 
   503 00000550 81FEFC0F0000        <1> 	cmp	esi, 0FFCh		; near the edge?
   504 00000556 7605                <1> 	jna	memory_write_page	; no
   505                              <1> 
   506 00000558 E8D81E0000          <1> 	call	write_straddle_12b?
   507                              <1> 
   508                              <1> memory_write_page:
   509 0000055D 3B05[F0010000]      <1> 	cmp	eax, dword ptr [_base+124*4]
   510 00000563 0F827D080000        <1> 	jb	near guard_ii_authority	; guard the NVRAM whether real or emulated
   511                              <1> 
   512 00000569 C1E00C              <1> 	shl	eax, 12			; multiply by page and lose bit 00400000
   513 0000056C 01C6                <1> 	add	esi, eax		; add offset
   514                              <1> 
   515 0000056E BF[00000000]        <1> 	mov	edi, _memory
   516                              <1> 
   517                              <1> memory_write_on:
   518 00000573 0FB6C1              <1> 	movzx	eax, cl
   519 00000576 8B0485[7F050000]    <1> 	mov	eax, dword ptr [write_action+eax*4]
   520 0000057D FFE0                <1> 	jmp	eax
   521                              <1> 
   522                              <1> write_action:
   523 0000057F [9F050000]          <1> 	dd	memory_write
   524 00000583 [A5050000]          <1> 	dd	write_t1
   525 00000587 [AA050000]          <1> 	dd	write_t2	; or h1
   526 0000058B [BB050000]          <1> 	dd	write_t3	; or h2
   527 0000058F [A4050000]          <1> 	dd	just_dont
   528 00000593 [A4050000]          <1> 	dd	just_dont
   529 00000597 [FC050000]          <1> 	dd	memory_write2
   530 0000059B [10060000]          <1> 	dd	memory_write4
   531                              <1> 
   532                              <1> memory_write:					; store system memory 1 word
   533 0000059F 0FCB                <1> 	bswap	ebx
   534 000005A1 891CB7              <1> 	mov	dword ptr [edi+esi*4], ebx
   535                              <1> just_dont:
   536 000005A4 C3                  <1> 	ret
   537                              <1> 
   538                              <1> write_t1:
   539 000005A5 885CB701            <1> 	mov	byte ptr [edi+esi*4+1], bl
   540 000005A9 C3                  <1> 	ret
   541                              <1> 
   542                              <1> write_t2:
   543 000005AA F705[00000000]8000- <1> 	test	dword ptr [_psr], HALF_W
   543 000005B2 0000                <1>
   544 000005B4 7516                <1> 	jnz	write_h1
   545 000005B6 885CB702            <1> 	mov	byte ptr [edi+esi*4+2], bl
   546 000005BA C3                  <1> 	ret
   547                              <1> 
   548                              <1> write_t3:
   549 000005BB F705[00000000]8000- <1> 	test	dword ptr [_psr], HALF_W
   549 000005C3 0000                <1>
   550 000005C5 751C                <1> 	jnz	write_h2
   551 000005C7 885CB703            <1> 	mov	byte ptr [edi+esi*4+3], bl
   552 000005CB C3                  <1> 	ret
   553                              <1> 
   554                              <1> write_h1:
   555 000005CC 8B04B7              <1> 	mov	eax, dword ptr [edi+esi*4]
   556 000005CF 0FC8                <1> 	bswap	eax
   557 000005D1 81E3FF0F0000        <1> 	and	ebx, 4095
   558 000005D7 C1E30C              <1> 	shl	ebx, 12
   559 000005DA 25FF0F0000          <1> 	and	eax, 4095
   560 000005DF 09D8                <1> 	or	eax, ebx
   561 000005E1 EB13                <1> 	jmp	write_hw
   562                              <1> 
   563                              <1> write_h2:
   564 000005E3 8B04B7              <1> 	mov	eax, dword ptr [edi+esi*4]
   565 000005E6 0FC8                <1> 	bswap	eax
   566 000005E8 C1E80C              <1> 	shr	eax, 12
   567 000005EB C1E00C              <1> 	shl	eax, 12
   568 000005EE 81E3FF0F0000        <1> 	and	ebx, 4095
   569 000005F4 09D8                <1> 	or	eax, ebx
   570                              <1> 
   571                              <1> write_hw:
   572 000005F6 0FC8                <1> 	bswap	eax
   573 000005F8 8904B7              <1> 	mov	dword ptr [edi+esi*4], eax
   574 000005FB C3                  <1> 	ret
   575                              <1> 					; store system memory 2 words
   576                              <1> memory_write2:				; eax is already free
   577 000005FC 8B449D00            <1> 	mov	eax, dword ptr [ebp+ebx*4]
   578 00000600 0FC8                <1> 	bswap	eax
   579 00000602 8904B7              <1> 	mov	dword ptr [edi+esi*4], eax
   580                              <1> 
   581 00000605 8B449D04            <1> 	mov	eax, dword ptr [ebp+ebx*4+4]
   582 00000609 0FC8                <1> 	bswap	eax
   583 0000060B 8944B704            <1> 	mov	dword ptr [edi+esi*4+4], eax
   584 0000060F C3                  <1> 	ret
   585                              <1> 
   586                              <1> memory_write4:					; store system memory 4 words
   587 00000610 8B449D00            <1> 	mov	eax, dword ptr [ebp+ebx*4]	; bx is a register number and may
   588                              <1> 						; identify extra workspace registers
   589                              <1> 						; at register stack tail
   590 00000614 0FC8                <1> 	bswap	eax
   591 00000616 8904B7              <1> 	mov	dword ptr [edi+esi*4], eax
   592 00000619 8B449D04            <1> 	mov	eax, dword ptr [ebp+ebx*4+4]
   593 0000061D 0FC8                <1> 	bswap	eax
   594 0000061F 8944B704            <1> 	mov	dword ptr [edi+esi*4+4], eax
   595 00000623 8B449D08            <1> 	mov	eax, dword ptr [ebp+ebx*4+8]
   596 00000627 0FC8                <1> 	bswap	eax
   597 00000629 8944B708            <1> 	mov	dword ptr [edi+esi*4+8], eax
   598 0000062D 8B449D0C            <1> 	mov	eax, dword ptr [ebp+ebx*4+12]
   599 00000631 0FC8                <1> 	bswap	eax
   600 00000633 8944B70C            <1> 	mov	dword ptr [edi+esi*4+12], eax
   601 00000637 C3                  <1> 	ret
   602                              <1> 
   603                              <1> ;	modify instructions n inc dec src slc sim popA
   604                              <1> ;	rewrite here
   605                              <1> 
   606                              <1> memoreg_writeback:
   607 00000638 F7C300FFFFFF        <1> 	test	ebx, -256			; save EA is ?
   608 0000063E 750C                <1> 	jnz	memory_direct			; a memory device
   609 00000640 93                  <1> 	xchg	eax, ebx			; a register
   610 00000641 81E3FFFFFF00        <1> 	and	ebx, 00FFFFFFh
   611 00000647 E9A3FEFFFF          <1> 	jmp	_operand_write_register
   612                              <1> 
   613                              <1> ;	if not a register rewrite
   614                              <1> ;	n inc dec src slc sim popA
   615                              <1> ;	write RTA memory at its saved platform address
   616                              <1> 
   617                              <1> memory_direct:
   618 0000064C 0FC8                <1> 	bswap	eax
   619 0000064E 30C0                <1> 	xor	al, al
   620 00000650 8904B7              <1> 	mov	[edi+esi*4], eax
   621 00000653 C3                  <1> 	ret
   622                              <1> 
   623                              <1> ;	execute calls memory read
   624                              <1> ;	ea < 256 is not for execute a register
   625                              <1> ;	operand is at a readable address in system memory or array
   626                              <1> 
   627                              <1> memory_read:					; for execute and modify instructions:
   628 00000654 E854000000          <1> 	call	memory_point			; read only executable space
   629 00000659 8B04B7              <1> 	mov	eax, dword ptr [edi+esi*4]	; and similar memory types
   630 0000065C 0FC8                <1> 	bswap	eax
   631 0000065E C3                  <1> 	ret
   632                              <1> 
   633                              <1> ;	modify instructions n inc dec src slc sim popA call here
   634                              <1> ;	ea < 256 is a register
   635                              <1> 
   636                              <1> memoreg:					; read-modify-write registers
   637 0000065F 89C3                <1> 	mov	ebx, eax			; or system-type memory
   638 00000661 A900FFFFFF          <1> 	test	eax, -256			; but nothing marked as a peripheral bus
   639 00000666 7508                <1> 	jnz	memory_read_lock
   640 00000668 8B0485[00000000]    <1> 	mov	eax, dword ptr [eax*4+__register]
   641 0000066F C3                  <1> 	ret
   642                              <1> 
   643                              <1> ;	RAM boundary in port 124 defines the upper page limit
   644                              <1> ;	of a real or emulated NVRAM containing the fixed system image
   645                              <1> 
   646                              <1> ;	fixed system image may be kernel + loader in a dozen pages
   647                              <1> ;	or it may be the entire application
   648                              <1> 
   649                              <1> ;	emulated machine applies the update limit
   650                              <1> ;	whether NVRAM is emulated or real
   651                              <1> 
   652                              <1> ;	if not a register
   653                              <1> ;	n inc dec src slc sim popA read a memory word which is legal to write
   654                              <1> ;	and keep the platform address to write the modified value
   655                              <1> ;	modify instructions do not lock memory between read and rewrite
   656                              <1> 
   657                              <1> memory_read_lock:
   658 00000670 E806000000          <1> 	call	memory_lock
   659 00000675 8B04B7              <1> 	mov	eax, dword ptr [edi+esi*4]
   660 00000678 0FC8                <1> 	bswap	eax
   661 0000067A C3                  <1> 	ret
   662                              <1> 
   663                              <1> ;	memory_read_lock calls here for modify instructions if ea > registers
   664                              <1> ;	ts calls here with ea whatever range always -> memory
   665                              <1> 
   666                              <1> ;	ea must be a legally writable memory word
   667                              <1> ;	memory_lock does not lock but identifies a platform write address  
   668                              <1> ;	ts reads / unconditionally replaces word.t1
   669                              <1> ;	under platform locking protocol, xchg platform instruction
   670                              <1> 
   671                              <1> memory_lock:					; point for update
   672                              <1> 						; barred below RAM boundary as write is
   673                              <1> 
   674 0000067B E8E2000000          <1> 	call	base_write_pointer		; resolve device:block:offset from EA
   675 00000680 A900004000          <1> 	test	eax, 00400000h			; update block name is a big bank ?
   676 00000685 7419                <1> 	jz	memory_lock_page		; no
   677 00000687 A93F000000          <1> 	test	eax, 63				; a device outside executable space ?
   678 0000068C 754D                <1> 	jnz	_yspace_read			; yes
   679 0000068E 25FFFF3F00          <1> 	and	eax, 003FFFFFh			; bit 0400000 is gets stripped later anyway
   680 00000693 3B05[F0010000]      <1> 	cmp	eax, dword ptr [_base+124*4]	; below RAM boundary?
   681 00000699 7339                <1> 	jnb	_xspace_read			; no, go ahead
   682 0000069B E946070000          <1> 	jmp	guard_ii_authority
   683                              <1> 
   684                              <1> memory_lock_page:
   685 000006A0 3B05[F0010000]      <1> 	cmp	eax, dword ptr [_base+124*4]	; below RAM boundary?
   686 000006A6 731A                <1> 	jnb	_xspace_read4K			; no, go head if offset < 1000 hex
   687 000006A8 E939070000          <1> 	jmp	guard_ii_authority
   688                              <1> 
   689                              <1> 
   690                              <1> ;	memory_read calls here for execute
   691                              <1> ;	identify a platform read address of an RTA memory word
   692                              <1> 
   693                              <1> memory_point:
   694 000006AD E86D000000          <1> 	call	base_read_pointer
   695                              <1> 
   696 000006B2 A900004000          <1> 	test	eax, 00400000h
   697 000006B7 7409                <1> 	jz	_xspace_read4K
   698                              <1> 
   699 000006B9 A93F000000          <1> 	test	eax, 63
   700 000006BE 7414                <1> 	jz	_xspace_read
   701 000006C0 EB19                <1> 	jmp	_yspace_read			; ie a device either appropriate or not
   702                              <1> 
   703                              <1> _xspace_read4K:
   704 000006C2 F7C600F00300        <1> 	test	esi, 003F000h
   705 000006C8 740A                <1> 	jz	_xspace_read
   706 000006CA BE0E000000          <1> 	mov	esi, LP_ADDRESS
   707 000006CF E917070000          <1> 	jmp	guard_ii_escape
   708                              <1> 
   709                              <1> _xspace_read:
   710 000006D4 BF[00000000]        <1> 	mov	edi, _memory
   711 000006D9 EB34                <1> 	jmp	_memory_deliver			; device array zero
   712                              <1> 
   713                              <1> _yspace_read:
   714 000006DB A900008000          <1> 	test	eax, 00800000h			; a tripsy non-space?
   715 000006E0 7533                <1> 	jnz	_zspace_read			; not allowed
   716                              <1> 
   717 000006E2 89C7                <1> 	mov	edi, eax
   718 000006E4 83E73F              <1> 	and	edi, 63
   719 000006E7 8B3CBD[00020000]    <1> 	mov	edi, dword ptr [_base+128*4+edi*4]
   720 000006EE F7C700008000        <1> 	test	edi, SYSMEM_FLAG
   721 000006F4 741F                <1> 	jz	_zspace_read
   722 000006F6 F7C700004000        <1> 	test	edi, DATA16_FLAG
   723 000006FC 7517                <1> 	jnz	_zspace_read
   724                              <1> 
   725 000006FE C1E002              <1> 	shl	eax, 2				; al = 4 * device index
   726 00000701 0FB6F8              <1> 	movzx	edi, al
   727                              <1> 
   728 00000704 8BBF[00000000]      <1> 	mov	edi, dword ptr [_devices+edi]
   729 0000070A 30C0                <1> 	xor	al, al				; necessary to lose the device bits now
   730 0000070C C1E802              <1> 	shr	eax, 2
   731                              <1> 
   732                              <1> _memory_deliver:
   733 0000070F C1E00C              <1> 	shl	eax, 12		; multiply by page and lose bit 00400000
   734 00000712 01C6                <1> 	add	esi, eax
   735                              <1> 
   736                              <1> 	%if	__SMP
   737                              <1> 	%else
   738                              <1> 	mov	eax, dword ptr [edi+esi*4]
   739                              <1> 	bswap	eax
   740                              <1> 	%endif
   741 00000714 C3                  <1> 	ret
   742                              <1> 
   743                              <1> _zspace_read:
   744 00000715 BE01000000          <1> 	mov	esi, LP_AUTHORITY
   745 0000071A E9CC060000          <1> 	jmp	guard_ii_escape
   746                              <1> 
   747                              <1> 
   748                              <1> base_read_pointer:
   749 0000071F 89C7                <1> 	mov	edi, eax	; set aside EA for split operations
   750                              <1> 
   751 00000721 C1C910              <1> 	ror	ecx, 16		; save designator
   752 00000724 C1C812              <1> 	ror	eax, 18
   753 00000727 A83F                <1> 	test	al, 63
   754 00000729 7407                <1> 	jz	page_read_pointer
   755 0000072B 88C1                <1> 	mov	cl, al
   756 0000072D C1E80E              <1> 	shr	eax, 14
   757 00000730 EB08                <1> 	jmp	read_pointer
   758                              <1> 
   759                              <1> page_read_pointer:
   760 00000732 C1C006              <1> 	rol	eax, 6
   761 00000735 88C1                <1> 	mov	cl, al
   762 00000737 C1E814              <1> 	shr	eax, 20
   763                              <1> 
   764                              <1> read_pointer:
   765 0000073A 89C6                <1>         mov	esi, eax
   766 0000073C 80E13F              <1> 	and	cl, 63
   767 0000073F 7413                <1> 	jz	direct_pointer	; there is no alternate to B0
   768                              <1> 				; ROM constant reads clear from here
   769 00000741 F6C138              <1> 	test	cl, 56
   770 00000744 750E                <1> 	jnz	direct_pointer	; shift radix 8-1 might get slipped
   771                              <1> 				; high memory writes clear from here
   772 00000746 A1[00000000]        <1> 	mov	eax, dword ptr [_psr]		; now read out _psr
   773                              <1> 
   774                              <1> alternate_pointer?:		; only base_write_pointer may jump to here
   775 0000074B D2E4                <1> 	shl	ah, cl		; so long as radix 31 applies to 8-bit shifts
   776 0000074D D0EC                <1> 	shr	ah, 1		; any base-tag > 7 delivers zero
   777 0000074F 80E440              <1> 	and	ah, 64
   778 00000752 08E1                <1> 	or	cl, ah
   779                              <1> 
   780                              <1> direct_pointer:
   781 00000754 0FB6C1              <1> 	movzx	eax, cl
   782 00000757 8B0485[00000000]    <1> 	mov	eax, dword ptr [eax*4+_base]
   783 0000075E C1C910              <1> 	ror	ecx, 16		; restore designator
   784                              <1> 
   785 00000761 C3                  <1> 	ret
   786                              <1> 
   787                              <1> base_write_pointer:
   788 00000762 89C7                <1> 	mov	edi, eax	; set aside EA for split write operations
   789 00000764 C1C910              <1> 	ror	ecx, 16		; save designator
   790 00000767 C1C812              <1> 	ror	eax, 18
   791 0000076A A83F                <1> 	test	al, 63
   792 0000076C 7407                <1> 	jz	page_write_pointer
   793 0000076E 88C1                <1> 	mov	cl, al
   794 00000770 C1E80E              <1> 	shr	eax, 14
   795 00000773 EB08                <1> 	jmp	write_pointer
   796                              <1> 
   797                              <1> page_write_pointer:
   798 00000775 C1C006              <1> 	rol	eax, 6
   799 00000778 88C1                <1> 	mov	cl, al
   800 0000077A C1E814              <1> 	shr	eax, 20
   801                              <1> 
   802                              <1> write_pointer:
   803 0000077D 89C6                <1> 	mov	esi, eax
   804                              <1> 
   805 0000077F 80E13F              <1> 	and	cl, 63		; even if an ISR has reason to write its iframe
   806                              <1> 				; it can base it in a data window
   807 00000782 0F845E060000        <1> 	jz	NEAR guard_ii_authority	; so on attempted write in B0
   808                              <1> 				; application: thread gets withdrawn
   809                              <1> 				; ISR: forced to auto-restart the system
   810 00000788 F6C138              <1> 	test	cl, 56
   811 0000078B 751E                <1> 	jnz	write_allowed	; shift radix 32-1 might get slipped
   812                              <1> 				; high memory operand writes clear from here
   813                              <1> 				; 386 shift radix on a byte is 7 anyway
   814 0000078D A1[00000000]        <1> 	mov	eax, dword ptr [_psr]	; last of all red out the psr
   815 00000792 A900008000          <1> 	test	eax, 00800000h		; interrupt code?
   816 00000797 75B2                <1> 	jnz	alternate_pointer?	; ISRs write anything
   817                              <1> 					; unless it isn't there
   818                              <1> 
   819 00000799 88E0                <1> 	mov	al, ah		; gate windows [ 0 2 TCB kernel ]
   820 0000079B 0CA0                <1> 	or	al, 128+32	; applications may not write them
   821 0000079D D2E0                <1> 	shl	al, cl
   822                              <1> 
   823 0000079F 790A                <1> 	jns	write_allowed
   824                              <1> 
   825 000007A1 BE01000000          <1> 	mov	esi, LP_AUTHORITY
   826 000007A6 E940060000          <1> 	jmp	guard_ii_escape	; not allowed
   827                              <1> 
   828                              <1> write_allowed:
   829 000007AB 0FB6C1              <1> 	movzx	eax, cl		; allowed
   830 000007AE 8B0485[00000000]    <1> 	mov	eax, dword ptr [eax*4+_base]
   831                              <1> 
   832 000007B5 C1C910              <1> 	ror	ecx, 16		; restore designator
   833 000007B8 C3                  <1> 	ret
   834                              <1> 
   835                              <1> ;	sub-architectural measure on sabr and reload instructions
   836                              <1> 
   837                              <1> ;	check the target memory block is in range and the bus characteristic
   838                              <1> ;	of the memory device when selecting blocks of memory, not when
   839                              <1> ;	accessing them. Use 8 spare bits in the word containing _base[]
   840                              <1> ;	for a quick recall of the emulated bus attribute on reference
   841                              <1> 
   842                              <1> ;	because this software emulation needs to act differently for
   843                              <1> 
   844                              <1> ;		executable space	rta1 24-bit words canonical memory
   845                              <1> ;					modeled in platform 32-bit words
   846                              <1> 
   847                              <1> ;		shared network buffers	16-bit words canonical in memory
   848                              <1> ;					and zero extend on readout to RTA1
   849                              <1> 
   850                              <1> ;		24-bit filestore array	3-octet words stored big-endian
   851                              <1> ;					in packed array
   852                              <1> 
   853                              <1> ;	concept RTA1 device arrays with bus behaviour differences are completely
   854                              <1> ;	emulated on PC emulations because device arrays are modeled in PC RAM.
   855                              <1> 
   856                              <1> ;	Various bus behaviours are emulated transparently to RTA1 target software
   857                              <1> ;	in anticipation	that different memories for different uses may be attached
   858                              <1> ;	on product boards, making core-emulated RTA1s much more efficient for not
   859                              <1> ;	needing this part of emulation
   860                              <1> 
   861                              <1> ;	devices
   862                              <1> 
   863                              <1> ;	device 0 is always executable space, but there may be more devices
   864                              <1> ;	with bus characteristics like device 0. The device descriptors are
   865                              <1> 
   866                              <1> ;		_________________________________________________________________
   867                              <1> ;		| 16 bits flags	| 16 bits banks	|       32 bits pointer		|
   868                              <1> ;		|_______________|____high index_|_______________________________|
   869                              <1> 
   870                              <1> 
   871                              <1> ;	[out]	sabr	[go]	[call]	reload instructions call here
   872                              <1> ;	go and call can probably check quicker themself
   873                              <1> ;	out can be trusted because applications don't out memory _base[] ports
   874                              <1> 
   875                              <1> ;	a big block in an RTA1 address window is 262144 words.
   876                              <1> ;	this checking concerns address windows tagged 2..63
   877                              <1> ;	a device is an array up to 65536 big blocks or banks
   878                              <1> 
   879                              <1> ;	you get here with the relocation handle in ebx
   880                              <1> ;	and the target window tag in eax, because that is the EA of a sabr instruction
   881                              <1> 
   882                              <1> device_read:				; readout device arrays
   883 000007B9 A900008000          <1>         test    eax, 0800000h           ; the vilainous bank index?
   884 000007BE 752A                <1>         jnz     device_read_escape
   885                              <1> 
   886 000007C0 C1E002              <1> 	shl	eax, 2			;  al = device pointer * 4
   887 000007C3 0FB6F8              <1> 	movzx	edi, al			; edi = device pointer * 4
   888 000007C6 30C0                <1> 	xor	al, al			; eax = memory block * 256
   889 000007C8 C1E00A              <1> 	shl	eax, 10			; eax = memory block * 262144
   890 000007CB 01C6                <1> 	add	esi, eax		; offset += base
   891 000007CD 89F8                <1> 	mov	eax, edi
   892 000007CF 8BB8[00000000]      <1> 	mov	edi, dword ptr [_devices+eax] ; physical array storage
   893                              <1> _device_read_xpanded:
   894 000007D5 8B80[00020000]      <1> 	mov	eax, dword ptr [_base+128*4+eax]
   895                              <1> 
   896 000007DB C1E816              <1> 	shr	eax, 22			; following conditions use parity
   897                              <1> 					; parity only generated from LS octet
   898                              <1> 					; how dumb can you get?
   899                              <1> 
   900 000007DE 2403                <1> 	and	al, 3			; what sort of device array?
   901                              <1> 
   902 000007E0 7408                <1> 	jz	device_read_escape	; that's double-checked option 00
   903 000007E2 7A61                <1> 	jpe	device_read_array24	; and option 11 shorten
   904 000007E4 A802                <1> 	test	al, SYSMEM_FLAG>>22
   905 000007E6 7411                <1> 	jz	device_read_data16	; and option 01
   906 000007E8 EB0A                <1> 	jmp	device_read_sysmem	; and option 10
   907                              <1> 	
   908                              <1> device_read_escape:
   909 000007EA BE0E000000          <1> 	mov	esi, LP_ADDRESS
   910 000007EF E9F7050000          <1> 	jmp	guard_ii_escape
   911                              <1> 
   912                              <1> 
   913                              <1> device_read_sysmem:			; readout system memory array
   914 000007F4 E9AEFBFFFF          <1> 	jmp	memory_read_on		; allow all variations partial word / multiword
   915                              <1> ;	ret
   916                              <1> 
   917                              <1> device_read_data16:			; readout 16-bit array
   918 000007F9 80F907              <1> 	cmp	cl, 7
   919 000007FC 741F                <1> 	jz	device_read_data16_4
   920 000007FE 80F906              <1> 	cmp	cl, 6
   921 00000801 740E                <1> 	jz	device_read_data16_2
   922 00000803 EB00                <1> 	jmp	device_read_data16_1
   923                              <1> 
   924                              <1> device_read_data16_1:			; readout 1 word of 16-bit array
   925 00000805 0FB70477            <1> 	movzx	eax, word ptr [edi+esi*2]
   926 00000809 86E0                <1> 	xchg	ah, al
   927 0000080B A3[90020000]        <1> 	mov	dword ptr [__register+164*4], eax
   928 00000810 C3                  <1> 	ret
   929                              <1> 
   930                              <1> device_read_data16_2:			; readout 2 words of 16-bit array
   931 00000811 8B0477              <1> 	mov	eax, dword ptr [edi+esi*2]	; 4.3.2.1
   932                              <1> 
   933 00000814 0FC8                <1> 	bswap	eax				; 1.2.3.4
   934 00000816 0FB7D8              <1> 	movzx	ebx, ax				; 0.0.3.4
   935 00000819 C1E810              <1> 	shr	eax, 16				; 0.0.1.2
   936 0000081C C3                  <1> 	ret
   937                              <1> 
   938                              <1> device_read_data16_4:			; readout 4 words of 16-bit array
   939 0000081D 8B0477              <1> 	mov	eax, dword ptr [edi+esi*2]
   940 00000820 0FC8                <1> 	bswap	eax				; 1.2.3.4
   941 00000822 0FB7C8              <1> 	movzx	ecx, ax
   942 00000825 C1E810              <1> 	shr	eax, 16
   943 00000828 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   944 0000082C 894C9D04            <1> 	mov	dword ptr [ebp+ebx*4+4], ecx
   945                              <1> 
   946 00000830 8B447704            <1> 	mov     eax, dword ptr [edi+esi*2+4]
   947 00000834 0FC8                <1> 	bswap	eax				; 5.6.7.8
   948 00000836 0FB7C8              <1> 	movzx	ecx, ax
   949 00000839 C1E810              <1> 	shr	eax, 16
   950 0000083C 89449D08            <1> 	mov	dword ptr [ebp+ebx*4+8], eax
   951 00000840 894C9D0C            <1> 	mov	dword ptr [ebp+ebx*4+12], ecx
   952 00000844 C3                  <1> 	ret
   953                              <1> 
   954                              <1> device_read_array24:			; readout from packed 24-bit array
   955 00000845 E82F010000          <1> 	call	device_array24_setpointer
   956                              <1> 
   957 0000084A 80F907              <1> 	cmp	cl, 7
   958 0000084D 7440                <1> 	jz	device_read_array24_4
   959 0000084F 80F906              <1> 	cmp	cl, 6
   960 00000852 7430                <1> 	jz	device_read_array24_2
   961 00000854 EB00                <1> 	jmp	device_read_array24_1
   962                              <1> 
   963                              <1> device_read_array24_1:			; readout a word of packed 24-bit array
   964 00000856 660FB60437          <1> 	movzx	ax, byte ptr [edi+esi]
   965 0000085B C1E008              <1> 	shl	eax, 8
   966 0000085E 8A443701            <1> 	mov	al, byte ptr [edi+esi+1]
   967 00000862 C1E008              <1> 	shl	eax, 8
   968 00000865 8A443702            <1> 	mov	al, byte ptr [edi+esi+2]
   969 00000869 83C603              <1> 	add	esi, 3
   970 0000086C C3                  <1> 	ret
   971                              <1> 
   972                              <1> device_read_array24_1R:
   973 0000086D 660FB61C37          <1> 	movzx	bx, byte ptr [edi+esi]
   974 00000872 C1E308              <1> 	shl	ebx, 8
   975 00000875 8A5C3701            <1> 	mov	bl, byte ptr [edi+esi+1]
   976 00000879 C1E308              <1> 	shl	ebx, 8
   977 0000087C 8A5C3702            <1> 	mov	bl, byte ptr [edi+esi+2]
   978 00000880 83C603              <1> 	add	esi, 3
   979 00000883 C3                  <1> 	ret
   980                              <1> 
   981                              <1> device_read_array24_2:			; readout 2 words of packed 24-bit array
   982 00000884 E8CDFFFFFF          <1> 	call	device_read_array24_1
   983 00000889 E8DFFFFFFF          <1> 	call	device_read_array24_1R
   984 0000088E C3                  <1> 	ret
   985                              <1> 
   986                              <1> device_read_array24_4:			; readout 4 words of packed 24-bit array
   987 0000088F E8C2FFFFFF          <1> 	call	device_read_array24_1
   988 00000894 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   989 00000898 E8B9FFFFFF          <1> 	call	device_read_array24_1
   990 0000089D 89449D04            <1> 	mov	dword ptr [ebp+ebx*4+4], eax
   991 000008A1 E8B0FFFFFF          <1> 	call	device_read_array24_1
   992 000008A6 89449D08            <1> 	mov	dword ptr [ebp+ebx*4+8], eax
   993 000008AA E8A7FFFFFF          <1> 	call	device_read_array24_1
   994 000008AF 89449D0C            <1> 	mov	dword ptr [ebp+ebx*4+12], eax
   995 000008B3 C3                  <1> 	ret
   996                              <1> 
   997                              <1> _device_write:				; store device arrays
   998 000008B4 A900008000          <1> 	test	eax, 0800000h		; the vilainous bank index?
   999                              <1> 
  1000 000008B9 752A                <1> 	jnz	device_write_escape
  1001                              <1> 
  1002 000008BB C1E002              <1> 	shl	eax, 2			;  al = device ID * 4
  1003 000008BE 0FB6F8              <1> 	movzx	edi, al			; edi = device ID * 4
  1004 000008C1 30C0                <1> 	xor	al, al			; eax = 256 * block pointer
  1005 000008C3 C1E00A              <1> 	shl	eax, 10			; block pointer *= 262144
  1006 000008C6 01C6                <1> 	add	esi, eax
  1007 000008C8 89F8                <1> 	mov	eax, edi
  1008 000008CA 8BB8[00000000]      <1> 	mov	edi, dword ptr [eax+_devices]	; physical buffer device array
  1009 000008D0 8B80[00020000]      <1> 	mov	eax, dword ptr [eax+_base+128*4] ; descriptor port of device
  1010                              <1> 
  1011 000008D6 C1E816              <1> 	shr	eax, 22			; following conditions use parity
  1012                              <1> 					; which is only generated from LS octet
  1013                              <1> 
  1014 000008D9 2403                <1> 	and	al, 3			; isolate the device type
  1015 000008DB 7408                <1> 	jz	device_write_escape
  1016 000008DD 7A4E                <1> 	jpe	device_write_array24
  1017 000008DF A802                <1> 	test	al, SYSMEM_FLAG>>22
  1018 000008E1 7411                <1> 	jz	device_write_data16
  1019 000008E3 EB0A                <1> 	jmp	device_write_sysmem
  1020                              <1> 
  1021                              <1> device_write_escape:
  1022 000008E5 BE0E000000          <1> 	mov	esi, LP_ADDRESS
  1023 000008EA E9FC040000          <1> 	jmp	guard_ii_escape
  1024                              <1> 
  1025                              <1> 
  1026                              <1> device_write_sysmem:
  1027 000008EF E97FFCFFFF          <1> 	jmp	memory_write_on		; allow all variations partial word / multiword
  1028                              <1> 
  1029                              <1> device_write_data16:
  1030                              <1> 
  1031 000008F4 80F907              <1> 	cmp	cl, 7
  1032 000008F7 740E                <1> 	jz	device_write_data16_4
  1033 000008F9 80F906              <1> 	cmp	cl, 6
  1034 000008FC 741C                <1> 	jz	device_write_data16_2
  1035 000008FE EB00                <1> 	jmp	device_write_data16_1
  1036                              <1> 
  1037                              <1> device_write_data16_1:			; store 16-bit array
  1038 00000900 86FB                <1> 	xchg	bh, bl
  1039 00000902 66891C77            <1> 	mov	word ptr [edi+esi*2], bx
  1040 00000906 C3                  <1> 	ret
  1041                              <1> 
  1042                              <1> 
  1043                              <1> device_write_data16_4:			; store 4 words in 16-bit array
  1044                              <1> 					; low-order half is swapped on bus read
  1045                              <1> 					; and canonical in eax
  1046 00000907 668B449D08          <1> 	mov	ax, word ptr [ebp+ebx*4+8]	; get low-order half 3rd register
  1047 0000090C C1E010              <1> 	shl	eax, 16				; 5.6.0.0
  1048 0000090F 668B449D0C          <1> 	mov	ax, word ptr [ebp+ebx*4+12]	; 5.6.7.8
  1049 00000914 0FC8                <1> 	bswap	eax				; it's correct so swap for bus write
  1050 00000916 89447704            <1> 	mov	dword ptr [edi+esi*2+4], eax
  1051                              <1> 
  1052                              <1> 
  1053                              <1> device_write_data16_2:			; store 2 words in 16-bit array
  1054                              <1> 					; registers are modeled in storage
  1055                              <1> 					; so each bus read corrects an octet pair
  1056                              <1> 
  1057 0000091A 668B449D00          <1> 	mov	ax, word ptr [ebp+ebx*4]	; get low-order half 1st register
  1058 0000091F C1E010              <1> 	shl	eax, 16				; 1.2.0.0
  1059 00000922 668B449D04          <1> 	mov	ax, word ptr [ebp+ebx*4+4]	; 1.2.3.4
  1060 00000927 0FC8                <1> 	bswap	eax				; it's correct, so swap for bus write
  1061 00000929 890477              <1> 	mov	dword ptr [edi+esi*2], eax
  1062 0000092C C3                  <1> 	ret
  1063                              <1> 
  1064                              <1> device_write_array24:			; store 24-bit packed array
  1065 0000092D E847000000          <1> 	call	device_array24_setpointer
  1066                              <1> 
  1067 00000932 80F907              <1> 	cmp	cl, 7
  1068 00000935 7434                <1> 	jz	device_write_array24_4
  1069 00000937 80F906              <1> 	cmp	cl, 6
  1070 0000093A 741C                <1> 	jz	device_write_array24_2
  1071 0000093C EB00                <1> 	jmp	device_write_array24_1
  1072                              <1> 
  1073                              <1> device_write_array24_1:			; store 1 word in packed 24-bit array
  1074 0000093E 89D8                <1> 	mov	eax, ebx
  1075                              <1> device_write_array24_x:
  1076 00000940 C1C010              <1> 	rol	eax, 16
  1077 00000943 880437              <1> 	mov	byte ptr [edi+esi], al
  1078 00000946 C1C008              <1> 	rol	eax, 8
  1079 00000949 88443701            <1> 	mov	byte ptr [edi+esi+1], al
  1080 0000094D C1C008              <1> 	rol	eax, 8
  1081 00000950 88443702            <1> 	mov	byte ptr [edi+esi+2], al
  1082 00000954 83C603              <1> 	add	esi, 3
  1083 00000957 C3                  <1> 	ret
  1084                              <1> 
  1085                              <1> device_write_array24_2:			; store 2 words in packed 24-bit array
  1086 00000958 8B449D00            <1> 	mov	eax, [ebp+ebx*4]
  1087 0000095C E8DFFFFFFF          <1> 	call	device_write_array24_x
  1088 00000961 8B449D04            <1> 	mov	eax, [ebp+ebx*4+4]
  1089 00000965 E8D6FFFFFF          <1> 	call	device_write_array24_x
  1090                              <1> ;	add	ebx, 2
  1091 0000096A C3                  <1> 	ret
  1092                              <1> 
  1093                              <1> device_write_array24_4:			; store 4 words in packed 24-bit array
  1094 0000096B E8E8FFFFFF          <1> 	call	device_write_array24_2
  1095 00000970 83C302              <1> 	add	ebx, 2
  1096 00000973 E8E0FFFFFF          <1> 	call	device_write_array24_2
  1097 00000978 C3                  <1> 	ret
  1098                              <1> 
  1099                              <1> device_array24_setpointer:
  1100 00000979 89F0                <1> 	mov	eax, esi			; think of a number
  1101 0000097B D1E0                <1> 	shl	eax, 1				; double it
  1102 0000097D 01C6                <1> 	add	esi, eax			; add it to the number you first thought of...
  1103 0000097F C3                  <1> 	ret
  1104                              <1> 
    29                                  	%include	"sr.msm"
     1                              <1> 
     2                              <1> ;	read staging register
     3                              <1> ;	read bits from a stream of bits
     4                              <1> 
     5 00000980 8B0D[50000000]      <1> _rsr:	mov	ecx, dword ptr [__register+RDATAC]
     6 00000986 88CD                <1> 	mov	ch, cl
     7 00000988 88C1                <1> 	mov	cl, al
     8                              <1> 
     9 0000098A 31C0                <1> 	xor	eax, eax
    10 0000098C F705[00000000]4000- <1> 	test	dword ptr [_psr], B_STREAMZR
    10 00000994 0000                <1>
    11 00000996 7505                <1> 	jnz	_rsr_zadd
    12 00000998 A1[10000000]        <1> 	mov	eax, dword ptr [__register+A]
    13                              <1> _rsr_zadd:
    14 0000099D 20C9                <1> 	and	cl, cl
    15 0000099F 745C                <1> 	jz	_rsr_x
    16 000009A1 8B1D[54000000]      <1> 	mov	ebx, dword ptr [__register+RDATA]
    17                              <1> 
    18 000009A7 20ED                <1> 	and	ch, ch			; any data loaded yet?
    19 000009A9 740F                <1> 	jz	_rsr_read		; if not read first no question 
    20 000009AB 38CD                <1> 	cmp	ch, cl			; otherwise, already enough for request?
    21 000009AD 7333                <1> 	jnb	_rsr_draw		; if so deliver data
    22 000009AF 28E9                <1> 	sub	cl, ch			; if not trim the oustanding count
    23 000009B1 86CD                <1> 	xchg	cl, ch			
    24 000009B3 E8BC0E0000          <1> 	call	dsl			; and deliver available data
    25 000009B8 86E9                <1> 	xchg	ch, cl			; before reading some more
    26                              <1> _rsr_read:
    27 000009BA E8AF000000          <1> 	call	stream_read
    28 000009BF C705[50000000]1800- <1> 	mov	dword ptr [__register+RDATAC], 24
    28 000009C7 0000                <1>
    29 000009C9 F705[00000000]2000- <1> 	test	dword ptr [_psr], B_STREAM16R
    29 000009D1 0000                <1>
    30 000009D3 740D                <1> 	jz	_rsr_draw
    31 000009D5 C705[50000000]1000- <1> 	mov	dword ptr [__register+RDATAC], 16
    31 000009DD 0000                <1>
    32 000009DF C1E308              <1> 	shl	ebx, 8
    33                              <1> _rsr_draw:
    34 000009E2 6651                <1> 	push	cx
    35 000009E4 E88B0E0000          <1> 	call	dsl
    36 000009E9 6659                <1> 	pop	cx
    37 000009EB 81E1FF000000        <1> 	and	ecx, 255
    38 000009F1 290D[50000000]      <1> 	sub	dword ptr [__register+RDATAC], ecx
    39 000009F7 891D[54000000]      <1> 	mov	dword ptr [__register+RDATA], ebx
    40                              <1> _rsr_x:
    41 000009FD A3[10000000]        <1> 	mov	dword ptr [__register+A], eax
    42 00000A02 C3                  <1> 	ret
    43                              <1> 
    44                              <1> 
    45                              <1> ;	write staging register
    46                              <1> ;	write bits to a stream of bits
    47                              <1> 
    48 00000A03 8B0D[58000000]      <1> _wsr:	mov	ecx, dword ptr [__register+WDATAC]
    49 00000A09 88CD                <1> 	mov	ch, cl					; accumulated count
    50 00000A0B 88C1                <1> 	mov	cl, al					; new request
    51                              <1> 
    52 00000A0D A1[5C000000]        <1> 	mov	eax, dword ptr [__register+WDATA]	; accumulated data
    53 00000A12 8B1D[10000000]      <1> 	mov	ebx, dword ptr [__register+A]		; source new data
    54                              <1> 
    55 00000A18 80C5E8              <1> 	add	ch, -24				; space for new data expressed negative
    56 00000A1B F705[00000000]1000- <1> 	test	dword ptr [_psr], B_STREAM16W	; 16 bits / word flag
    56 00000A23 0000                <1>
    57 00000A25 7403                <1> 	jz	_wsr24
    58 00000A27 80C508              <1> 	add	ch, 8
    59                              <1> 
    60 00000A2A 00CD                <1> _wsr24:	add	ch, cl			; increment towards zero
    61 00000A2C 7404                <1> 	jz	_wsr_write		; accumulated word exactly full
    62 00000A2E 731D                <1> 	jnc	_wsr_add		; not yet full
    63                              <1> 
    64 00000A30 28E9                <1> 	sub	cl, ch			; full + some more
    65                              <1> 
    66                              <1> _wsr_write:
    67 00000A32 E83D0E0000          <1> 	call	dsl			; fill output word
    68 00000A37 88E9                <1> 	mov	cl, ch			; position outstanding count
    69 00000A39 E84A000000          <1> 	call	stream_write
    70 00000A3E B800000000          <1> 	mov	eax, 0
    71 00000A43 C705[58000000]0000- <1> 	mov	dword ptr [__register+WDATAC], 0
    71 00000A4B 0000                <1>
    72                              <1> 
    73                              <1> _wsr_add:
    74 00000A4D 6651                <1> 	push	cx
    75 00000A4F E8200E0000          <1> 	call	dsl			; add to output word
    76 00000A54 6659                <1> 	pop	cx
    77 00000A56 81E1FF000000        <1> 	and	ecx, 255		; format ecx for add to accumulated count 
    78 00000A5C 010D[58000000]      <1> 	add	dword ptr [__register+WDATAC], ecx
    79 00000A62 A3[5C000000]        <1> 	mov	dword ptr [__register+WDATA], eax
    80 00000A67 891D[10000000]      <1> 	mov	dword ptr [__register+A], ebx
    81 00000A6D C3                  <1> 	ret
    82                              <1> 
    83                              <1> stream_read:
    84 00000A6E 51                  <1> 	push	ecx
    85 00000A6F 50                  <1> 	push	eax
    86 00000A70 A1[34000000]        <1> 	mov	eax, dword ptr [__register+Q]
    87 00000A75 8305[34000000]01    <1> 	add	dword ptr [__register+Q], 1
    88 00000A7C 30C9                <1> 	xor	cl, cl
    89 00000A7E E8B3F8FFFF          <1> 	call	_operand_read
    90 00000A83 89C3                <1> 	mov	ebx, eax
    91 00000A85 58                  <1> 	pop	eax
    92 00000A86 59                  <1> 	pop	ecx
    93 00000A87 C3                  <1> 	ret
    94                              <1> 
    95                              <1> stream_write:
    96 00000A88 51                  <1> 	push	ecx
    97 00000A89 53                  <1> 	push	ebx
    98 00000A8A 89C3                <1> 	mov	ebx, eax
    99 00000A8C A1[30000000]        <1> 	mov	eax, dword ptr [__register+P]
   100 00000A91 8305[30000000]01    <1> 	add	dword ptr [__register+P], 1
   101 00000A98 30C9                <1> 	xor	cl, cl
   102 00000A9A E849FAFFFF          <1> 	call	_operand_write
   103 00000A9F 5B                  <1> 	pop	ebx
   104 00000AA0 59                  <1> 	pop	ecx
   105 00000AA1 C3                  <1> 	ret
   106                              <1> 
    30                                  	%include	"io.msm"
     1 00000AA2 8B1C85[00000000]    <1> _inA:	mov	ebx, dword ptr [eax*4+_base]
     2 00000AA9 895D10              <1> 	mov	dword ptr [ebp+A], ebx
     3 00000AAC C3                  <1> _inA_:	ret
     4                              <1> 
     5 00000AAD 8B1C85[00000000]    <1> _inB:	mov	ebx, dword ptr [eax*4+_base]
     6 00000AB4 895D14              <1> 	mov	dword ptr [ebp+B], ebx
     7 00000AB7 C3                  <1> _inB_:	ret
     8                              <1> 
     9 00000AB8 8B5D10              <1> _outA:	mov	ebx, dword ptr [ebp+A]
    10 00000ABB E999010000          <1> 	jmp	oport
    11                              <1> 
    12 00000AC0 8B5D14              <1> _outB:	mov	ebx, dword ptr [ebp+B]
    13 00000AC3 E991010000          <1> 	jmp	oport
    14                              <1> 
    15                              <1> 
    16                              <1> ISR_ONLY equ	8
    17                              <1> MEMTYPE	equ	1
    18                              <1> MEMZERONLY equ	2
    19                              <1> EXTERNAL_IO equ	4
    20                              <1> BROADCAST equ	16
    21                              <1> 
    22                              <1> B_1	equ	MEMTYPE
    23                              <1> B_TCB	equ	MEMTYPE+ISR_ONLY
    24                              <1> B_KERN	equ	MEMTYPE+ISR_ONLY
    25                              <1> A_THREP	equ	MEMZERONLY+ISR_ONLY
    26                              <1> I_PORT	equ	EXTERNAL_IO
    27                              <1> O_PORT	equ	EXTERNAL_IO
    28                              <1> O_INDICA equ	EXTERNAL_IO
    29                              <1> O_CHILL	equ	EXTERNAL_IO
    30                              <1> I_TZONE	equ	EXTERNAL_IO
    31                              <1> RAM_THRESH equ	ISR_ONLY+MEMZERONLY
    32                              <1> XI_ACK	equ	ISR_ONLY+EXTERNAL_IO
    33                              <1> O_LEDS	equ	EXTERNAL_IO
    34                              <1> O_INC	equ	ISR_ONLY+EXTERNAL_IO
    35                              <1> O_MCAST	equ	ISR_ONLY+BROADCAST
    36                              <1> 
    37                              <1> 
    38                              <1> mask_port_outAB
    38          ******************  <1>  warning: label alone on a line without a colon might be in error [-w+orphan-labels]
    39 00000AC8 000100000000000000- <1> 	db	0, B_1, 0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    39 00000AD1 00000000000000      <1>
    40 00000AD8 000000000000000000- <1> 	db	    0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    40 00000AE1 00000000000000      <1>
    41                              <1> 
    42 00000AE8 000000000000000000- <1> 	db	    0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    42 00000AF1 00000000000000      <1>
    43 00000AF8 000000000000000000- <1> 	db	    0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    43 00000B01 00000000000000      <1>
    44                              <1> 
    45 00000B08 0009090909090909    <1> 	db	0,  B_TCB,B_KERN,B_KERN,B_KERN,B_KERN,B_KERN,B_KERN
    46 00000B10 0A00000C0C000018    <1> 	db	A_THREP, 0, 0, XI_ACK,  O_INC, 0,0, O_MCAST
    47                              <1> 
    48 00000B18 0404040404040404    <1> 	db	I_PORT,I_PORT,I_PORT,I_PORT,I_PORT,I_PORT,I_PORT,I_PORT
    49 00000B20 0404040404040404    <1> 	db	O_PORT,O_PORT,O_PORT,O_PORT,O_PORT,O_PORT,O_PORT,O_PORT
    50                              <1> 
    51 00000B28 0000000000040404    <1> 	db	0,0,0,0, 0, I_TZONE, O_INDICA, O_CHILL
    52 00000B30 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  RAM_THRESH, 0,0, O_LEDS
    52 00000B39 0000000A000004      <1>
    53                              <1> 
    54 00000B40 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    54 00000B49 00000000000000      <1>
    55 00000B50 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    55 00000B59 00000000000000      <1>
    56 00000B60 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    56 00000B69 00000000000000      <1>
    57 00000B70 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    57 00000B79 00000000000000      <1>
    58                              <1> 
    59                              <1> 					; outA|B rules flags per I/O port
    60                              <1> 
    61                              <1> 	%if	0
    62                              <1> 
    63                              <1> oport:	cmp	eax, 192
    64                              <1> 	jnb	ocheck
    65                              <1> 	mov	cl, byte ptr [mask_port_outAB+eax]
    66                              <1> 	and	cl, cl
    67                              <1> 	jz	ocheck
    68                              <1> 	test	cl, ISR_ONLY
    69                              <1> 	jz	check_ahead
    70                              <1> 	test	byte ptr [_psr+2], 128
    71                              <1> 	jz	ocheck
    72                              <1> 
    73                              <1> check_ahead:
    74                              <1> 	test	cl, EXTERNAL_IO
    75                              <1> 	jz	check_mpointer		; no restriction if the port is flagged
    76                              <1> 
    77                              <1> 	mov	dword ptr [_base+eax*4], ebx
    78                              <1> 					; effects of some outA|B cases
    79                              <1> 	cmp	eax, 102
    80                              <1> 	jnz	io_ack_pins?
    81                              <1> 	or	dword ptr [_indication], ebx
    82                              <1> 	jmp	outxio_complete
    83                              <1> 
    84                              <1> io_ack_pins?:
    85                              <1> 	cmp	eax, 75			; turn off an ISR pending pin
    86                              <1> 	jnz	alert_multicast?	; corresponding to the ACK pin in bl
    87                              <1> 	not	bl
    88                              <1> 	and	byte ptr [_base+74*4], bl
    89                              <1> 	jmp	outxio_complete
    90                              <1> 
    91                              <1> alert_multicast?:			; raise core2core broadcast signal
    92                              <1> 	cmp	eax, 79
    93                              <1> 	jnz	outxio_complete
    94                              <1> 	test	bl, 1			; only 1 core is emulated
    95                              <1> 	jz	outxio_complete		; = bit 0 of broadcast mask
    96                              <1> 	or	byte ptr [_indication], ATTENTION
    97                              <1> 
    98                              <1> outxio_complete:
    99                              <1> 	ret				; for requester type [ ISR | anyone ]
   100                              <1> 					; and is not a memory pointer [ 1..63 65..72 124 ]
   101                              <1> ocheck:
   102                              <1> 	mov	esi, LP_AUTHORITY
   103                              <1> 	jmp	guard_ii_escape
   104                              <1> 					; rules for ports
   105                              <1> 					; wnich are pointers to memory
   106                              <1> 					; outA|B isn't allowed 
   107                              <1> check_mpointer:				; on ports [ 2..63 ]
   108                              <1> 	test	cl, MEMTYPE		; they are in scope of sabr insrtuction
   109                              <1> 	jnz	check_mdevice
   110                              <1> 
   111                              <1> 	test	ebx, 0400000h		; only the plain page pointer accepted
   112                              <1> 	jnz	ocheck
   113                              <1> 
   114                              <1> check_mpointer_zero
   115                              <1> 	mov	ecx, dword ptr [_base+128*4]
   116                              <1> 	and	ecx, 003fffffh		; can't be higher than device zero pages
   117                              <1> 	cmp	ecx, ebx
   118                              <1> 	jb	ocheck
   119                              <1> 	mov	dword ptr [_base+eax*4], ebx
   120                              <1> 	ret
   121                              <1> 
   122                              <1> check_mdevice:
   123                              <1> 	test	ebx, 00400000h		; page pointer is good & quick
   124                              <1> 	jz	check_mpointer_zero
   125                              <1> 	test	ebx, 63			; device zero = system memory
   126                              <1> 	jz	check_device_zero	; is good & quick
   127                              <1> 
   128                              <1> 	mov	cl, bl			; otherwise measure the device
   129                              <1> 	and	ecx, 63
   130                              <1> 	mov	ecx, dword ptr [_base+128*4+ecx*4]
   131                              <1> 	rol	ecx, 10			; the device must have
   132                              <1> 	and	cl, 3			; the same type as system memory
   133                              <1> 	cmp	cl, 2
   134                              <1> 	jne	ocheck
   135                              <1> 
   136                              <1> 	shr	ecx, 10			; a page #, last 6 bits always 63 (03F)
   137                              <1> 
   138                              <1> 	mov	esi, ebx		; a page #, last 6 bits zero for comparison
   139                              <1> 	and	esi, 00BFFFC0h
   140                              <1> 	cmp	ecx, esi
   141                              <1> 	jb	ocheck
   142                              <1> 	mov	dword ptr [_base+eax*4], ebx
   143                              <1> 	ret
   144                              <1> 
   145                              <1> check_device_zero:
   146                              <1> 	mov	ecx, dword ptr [_base+128*4]
   147                              <1> 	and	ecx, 003FFFFFh
   148                              <1> 	or	ecx, 00400000h
   149                              <1> 	cmp	ecx, ebx
   150                              <1> 	jb	ocheck
   151                              <1> 	mov	dword ptr [_base+eax*4], ebx
   152                              <1> 	ret
   153                              <1> 
   154                              <1> 	%endif
   155                              <1> 
   156                              <1> _reload:
   157 00000B80 50                  <1> 	push	eax
   158 00000B81 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
   159 00000B84 83451002            <1> 	add	dword ptr [ebp+A], 2
   160 00000B88 E851F7FFFF          <1> 	call	_burst_read2
   161 00000B8D 5F                  <1> 	pop	edi
   162 00000B8E 8904BD[00000000]    <1> 	mov	dword ptr [edi*4+_base], eax
   163 00000B95 891CBD[04000000]    <1> 	mov	dword ptr [edi*4+_base+4], ebx
   164 00000B9C C3                  <1> 	ret
   165                              <1> 
   166 00000B9D C3                  <1> _emulator_cool: ret
   167                              <1> 
   168                              <1> ;	sabr checks what it places in operand space windows
   169                              <1> ;	there are no subsequent range checks on reference
   170                              <1> 
   171 00000B9E A93E000000          <1> _sabr:	test	eax, 0000003Eh		; target window must be 2..63
   172 00000BA3 0F843D020000        <1> 	jz	near guard_ii_authority
   173 00000BA9 A9C0FFFF00          <1> 	test	eax, 00FFFFC0h
   174 00000BAE 0F8532020000        <1> 	jnz	near guard_ii_authority
   175 00000BB4 89C6                <1> 	mov	esi, eax		; target window
   176 00000BB6 8B4510              <1> 	mov	eax, dword ptr [ebp+A]	; requested storage block index
   177 00000BB9 89C3                <1> 	mov	ebx, eax		; cache a copy
   178                              <1> 
   179 00000BBB 8B0D[00020000]      <1> 	mov	ecx, dword ptr [_base+128*4]
   180                              <1> 					; device zero = executable space
   181                              <1> 					; load its size parameter
   182 00000BC1 A900004000          <1> 	test	eax, 00400000h		; big and maybe not system memory?
   183 00000BC6 742C                <1> 	jz	_sabr_executable_space	; yes executable space
   184                              <1> 
   185 00000BC8 F7C33F000000        <1> 	test	ebx, 63
   186 00000BCE 7424                <1> 	jz	_sabr_executable_space	; yes executable space
   187                              <1> 					; no some other space
   188                              <1> 
   189 00000BD0 83E33F              <1> 	and	ebx, 63
   190 00000BD3 8B0C9D[00020000]    <1> 	mov	ecx, dword ptr [_base+128*4+ebx*4]
   191 00000BDA F7C100004000        <1> 	test	ecx, DATA16_FLAG
   192 00000BE0 752C                <1> 	jnz	 _sabr_device_array
   193 00000BE2 F7C100008000        <1> 	test	ecx, 00800000h
   194 00000BE8 7449                <1> 	jz	_sabr_guard		; range issue. The device is void
   195                              <1> 
   196 00000BEA 89C3                <1> 	mov	ebx, eax
   197 00000BEC 81E3C0FFBF00        <1> 	and	ebx, 00BFFFC0h		; blocks of 64 pages if not device zero
   198 00000BF2 EB0E                <1> 	jmp	_sabr_executable_type	; devices usable as system memory
   199                              <1> 	
   200                              <1> _sabr_executable_space:			; is the target page @+ application space?
   201 00000BF4 81E3FFFFBF00        <1> 	and	ebx, 00BFFFFFh		; just the page, not any flags
   202 00000BFA 3B1D[20010000]      <1> 	cmp	ebx, dword ptr [_base+72*4]
   203 00000C00 7831                <1> 	js	_sabr_guard		; neither ISrs nor applications may base ISR space
   204                              <1> 
   205                              <1> _sabr_executable_type:			; has the device this much memory?
   206 00000C02 81E1FFFF3F00        <1> 	and	ecx, 003FFFFFh		; 4K-word page high index of device
   207                              <1> 					; has the device this many pages?
   208 00000C08 29D9                <1> 	sub	ecx, ebx
   209                              <1> 
   210 00000C0A 792C                <1> 	jns	_sabr_thru		; yes
   211 00000C0C EB25                <1> 	jmp	_sabr_guard		; no
   212                              <1> 
   213                              <1> _sabr_device_array:
   214 00000C0E F705[00000000]0000- <1> 	test	dword ptr [_psr], 00800000h
   214 00000C16 8000                <1>
   215 00000C18 0F84C8010000        <1> 	jz	near guard_ii_authority	; only be here if you are an ISR
   216 00000C1E 89C3                <1> 	mov	ebx, eax		; refresh the requested block index
   217 00000C20 81E3FFFF3F00        <1> 	and	ebx, 003FFFFFh
   218 00000C26 C1EB06              <1> 	shr	ebx, 6			; align it with high index from device port
   219 00000C29 81E1FFFF3F00        <1> 	and	ecx, 003FFFFFh		; has the device array this many blocks?
   220                              <1> 
   221 00000C2F 29D9                <1> 	sub	ecx, ebx
   222 00000C31 7905                <1> 	jns	_sabr_thru		; yes
   223                              <1> 					; no
   224                              <1> _sabr_guard:
   225 00000C33 B80100C000          <1> 	mov	eax, 00C00001h		; no-access value
   226                              <1> 					; will trip on reference in target window
   227                              <1> _sabr_thru:
   228 00000C38 8904B5[00000000]    <1> 	mov	dword ptr [_base+esi*4], eax
   229                              <1> 					; esi = target window
   230 00000C3F 8B1D[04010000]      <1> 	mov	ebx, dword ptr [_base+65*4]	; thread TCB
   231 00000C45 C1E30E              <1> 	shl	ebx, 12+2		; 4K page * 4 platform bytes
   232 00000C48 BF[00000000]        <1> 	mov	edi, _memory		; so system memory of emulated machine
   233 00000C4D 01DF                <1> 	add	edi, ebx		; + offset of TCB 
   234 00000C4F 0FC8                <1> 	bswap	eax			; big endian store at TCB + ABT + esi * 4 
   235 00000C51 8984B700010000      <1> 	mov	dword ptr [edi+esi*4+64*4], eax
   236                              <1> 					; -> TCB + ABT + window index
   237 00000C58 C3                  <1> _sabrx:	ret
   238                              <1> 
    31                                  	%include	"oport.msm"
     1                              <1> 							; static void oport(int ea, int value, smp *xcore)
     2                              <1> 							; {
     3                              <1> oport:		; write I / O port			;    int		 rule,
     4                              <1> 		; RTA instructions outA outB		;			 device;
     5                              <1> 							; 
     6                              <1> 		; ports which are memory pointers	;    int		 mask,
     7                              <1> 		; must have a block that exists		;			 from,
     8                              <1> 		; ISRs can write trap value C00001 	;                 	 index;
     9                              <1> 		; = device 400001 | illegal 800000	; 
    10                              <1> 		; port # = effective address = eax	;    int		 device_index = 0;
    11                              <1> 		; write value in ebx			; 
    12                              <1> 		; multicast bits in RTA register k	;    smp		*ascor;
    13                              <1> 		 					;    unsigned	*register_set = xcore->register_set;
    14 00000C59 3DC0000000          <1> 	cmp	eax, IO_PORTS				; 
    15 00000C5E 7361                <1> 	jnb	no_port					;    if (ea < IO_PORTS)
    16                              <1> 							;    {
    17 00000C60 8A88[C80A0000]      <1> 	mov	cl, byte ptr [eax+mask_port_outAB]	;       rule = mask_port_outAB[ea];
    18 00000C66 20C9                <1> 	and	cl, cl					; 
    19 00000C68 7457                <1> 	jz	no_rule					;       if (rule)
    20 00000C6A F6C108              <1> 	test	cl, ISR_ONLY				;       {
    21 00000C6D 7409                <1> 	jz	application_plus_isr_rule		;          if (((rule & ISR_ONLY) == 0) || (psr & 0x00800000))
    22 00000C6F F605[02000000]80    <1> 	test	byte ptr [_psr+2], 128			;          {
    23 00000C76 7449                <1> 	jz	no_authority				;
    24                              <1> 							;
    25                              <1> application_plus_isr_rule:				;
    26 00000C78 F6C104              <1> 	test	cl, EXTERNAL_IO				;             if (rule & EXTERNAL_IO)
    27 00000C7B 7423                <1> 	jz	broadcast_rule?				;             {
    28 00000C7D 891C85[00000000]    <1> 	mov	dword ptr [eax*4+_base], ebx		;                base[ea] = value;
    29 00000C84 83F866              <1> 	cmp	eax, 102	; INDICATION$		;                if (ea == 102) indication |= value;
    30 00000C87 7506                <1> 	jne	xi_ack?		 			;
    31 00000C89 091D[00000000]      <1> 	or	dword ptr [_indication], ebx		;
    32                              <1>  							;
    33                              <1> xi_ack?:							;
    34 00000C8F 83F84B              <1> 	cmp	eax, 75					;                if (ea == 75)
    35 00000C92 750B                <1> 	jne	xi_no_ack				;                {
    36 00000C94 F6D3                <1> 	not	bl					;                    base[74] &= (value & 255) ^ 255;
    37 00000C96 0FB6DB              <1> 	movzx	ebx, bl					;                    // indication |= (value & 255) << 8;
    38                              <1> 							;                }
    39 00000C99 211D[28010000]      <1> 	and	dword ptr [_base+74*4], ebx		; 
    40                              <1> xi_no_ack:						; //               if ((ea == 79) && (value & 1)) indication |= ATTENTION;
    41 00000C9F C3                  <1> 	ret						;                return;
    42                              <1> 							;             }
    43                              <1> 							; 
    44                              <1> broadcast_rule?:					;             if (rule & BROADCAST)
    45 00000CA0 F6C110              <1> 	test	cl, BROADCAST				;             {
    46 00000CA3 7426                <1> 	jz	memory_rule?				;                mask = k;
    47 00000CA5 F6450501            <1> 	test	byte ptr [ebp+K+1], 1			;                from = base[77];
    48                              <1> 	; there is only core 0				; 
    49 00000CA9 740E                <1> 	jz	storecast				;                for (index = 0; index < RTA_SMP; index++)
    50                              <1> ;	 write the port still means write the port	;                {
    51 00000CAB 800D[39010000]01    <1> 	or	byte ptr [_base+78*4+1], 1		;                   if (mask & 1)
    52 00000CB2 800D[00000000]80    <1> 	or	byte ptr [_indication], ATTENTION	;                   {
    53                              <1> 							;                      ascor = core + index;
    54                              <1> storecast:						;                      ascor->BASE[78] |= 1 << from;
    55 00000CB9 891C85[00000000]    <1> 	mov	dword ptr [eax*4+_base], ebx		;                      ascor->INDICATION |= ATTENTION;
    56 00000CC0 C3                  <1> 	ret						;                   }
    57                              <1> 							; 
    58                              <1> 							;                   mask >>= 1;
    59                              <1> 							;                }
    60                              <1> no_port:						; 
    61                              <1> no_rule:						;                /**************************************************
    62                              <1> no_authority:						; 			keep these on the sending side
    63 00000CC1 BE01000000          <1> 	mov	esi, LP_AUTHORITY			; 			until constructing interrupt frame
    64 00000CC6 E920010000          <1> 	jmp	guard_ii_escape				; 			between instructions at target core
    65                              <1> 							;                         to avoid overwrites from other cores
    66                              <1> 							;                **************************************************/
    67                              <1> 							; 
    68                              <1> 							;                base[ea] = value;	/* latent parameter	*/
    69                              <1> 							;                return;
    70                              <1> 							;             }
    71                              <1> 							; 
    72                              <1> memory_rule?:	; system memory type only		;             else if (rule & MEMTYPE)
    73 00000CCB F6C101              <1> 	test	cl, MEMTYPE				;             {
    74 00000CCE 7459                <1> 	jz	page_pointer?				;                if (value & 0x00400000) device_index = value & 63;
    75 00000CD0 F7C300004000        <1> 	test	ebx, 0400000h	; bank sized?		; 
    76 00000CD6 745E                <1> 	jz	memory_page_pointer			;                if (device_index)
    77 00000CD8 89DE                <1> 	mov	esi, ebx				;                {
    78 00000CDA 83E63F              <1> 	and	esi, 63					;                   if (value & 0x00800000)
    79 00000CDD 7419                <1> 	jz	device_is_pointed			;                   {
    80 00000CDF F7C300008000        <1> 	test	ebx, 0800000h	; the trap device?	;                      if (psr & 0x00800000)
    81 00000CE5 7411                <1> 	jz	device_is_pointed			;                      {
    82 00000CE7 F605[02000000]80    <1> 	test	byte ptr [_psr+2], 128	; ISR?		;                         base[ea] = value;
    83 00000CEE 74D1                <1> 	jz	no_authority				;                         return;
    84 00000CF0 891C85[00000000]    <1> 	mov	[eax*4+_base], ebx			;                      }
    85 00000CF7 C3                  <1> 	ret						; 
    86                              <1> 							;                      GUARD_AUTHORITY
    87                              <1> device_is_pointed:					;                      return;
    88 00000CF8 8B0CB5[00020000]    <1> 	mov	ecx, dword ptr [esi*4+128*4+_base]	;                   }
    89 00000CFF F7C100008000        <1> 	test	ecx, 00800000h				;                }
    90 00000D05 74BA                <1> 	jz	no_authority				; 
    91 00000D07 F7C100004000        <1> 	test	ecx, 00400000h				;                device = base[128+device_index];
    92 00000D0D 75B2                <1> 	jnz	no_authority				;            
    93 00000D0F 81E1FFFF3F00        <1> 	and	ecx, 003FFFFFh				;                if ((device & 0x00C00000) == 0x00800000)
    94 00000D15 89DE                <1> 	mov	esi, ebx				;                {
    95 00000D17 81E6FFFFBF00        <1> 	and	esi, 00BFFFFFh	; catch any 00800000	;                   if ((value & 0x003FFFC0) > (device & 0x003FFFFF))
    96 00000D1D 39F1                <1> 	cmp	ecx, esi				;                   {
    97 00000D1F 7233                <1> 	jb	outwith		; beyond memory		;                   }
    98 00000D21 891C85[00000000]    <1> 	mov	[eax*4+_base], ebx			;                   else
    99 00000D28 C3                  <1> 	ret						;                   {
   100                              <1> 							;                      base[ea] = value;
   101                              <1> 							;                      return;
   102                              <1> 							;                   }
   103                              <1> 							;                }
   104                              <1> 							;             }
   105                              <1> 							;             else
   106                              <1> 							;             {
   107                              <1> 							;                /*******************************************
   108                              <1> ;	only a device zero page index will do		; 			page pointer to system memory
   109                              <1> 							;                *******************************************/
   110                              <1> page_pointer?:						; 
   111 00000D29 F6C102              <1> 	test	cl, MEMZERONLY				;                if ((value & 0x00400000) == 0)
   112 00000D2C 7493                <1> 	jz	no_rule					;                {
   113 00000D2E F7C30000C000        <1> 	test	ebx, 00C00000h				;                   if (value > (base[128] & 0x003FFFFF))
   114 00000D34 758B                <1> 	jnz	no_authority				;                   {
   115                              <1> 							;                   }
   116                              <1> memory_page_pointer:					;                   else
   117 00000D36 8B0D[00020000]      <1> 	mov	ecx, dword ptr [_base+128*4]		;                   {
   118 00000D3C 81E1FFFF3F00        <1> 	and	ecx, 003FFFFFh				;                      base[ea] = value;
   119 00000D42 81E3FFFFFF00        <1> 	and	ebx, 00FFFFFFh				;                      return;
   120 00000D48 39D9                <1> 	cmp	ecx, ebx				;                   }
   121 00000D4A 7208                <1> 	jb	outwith					;                }
   122 00000D4C 891C85[00000000]    <1> 	mov	[eax*4+_base], ebx			;             }
   123 00000D53 C3                  <1> 	ret						;          }
   124                              <1> 							;       }
   125                              <1> 							;    }
   126                              <1> outwith:							; 
   127 00000D54 BE0E000000          <1> 	mov	esi, LP_ADDRESS				;    GUARD_AUTHORITY;
   128 00000D59 E98D000000          <1> 	jmp	guard_ii_escape				; }							; 
    32                                  	%include	"ii.msm"
     1 00000D5E 660905[00000000]    <1> _on:	or	word ptr [_psr], ax	; only touch low-order 16 bits
     2 00000D65 C3                  <1> 	ret
     3                              <1> 
     4 00000D66 6683F0FF            <1> _off:	xor	ax, 0000FFFFh
     5 00000D6A 662105[00000000]    <1> 	and	word ptr [_psr], ax	; only touch low-order 16 bits
     6 00000D71 C3                  <1> 	ret
     7                              <1> 
     8 00000D72 20E4                <1> _xi:	and	ah, ah				; 8 external interrupts
     9 00000D74 7418                <1> 	jz	_xix
    10                              <1> 
    11 00000D76 30C9                <1> 	xor	cl, cl
    12                              <1> 
    13                              <1> _xi_next:					; external interrupt pending signals[8]
    14 00000D78 8825[28010000]      <1> 	mov	byte ptr [_base+74*4], ah	; position for inA|B from port XI_PENDING$	LL.mm.hh.zz
    15 00000D7E C605[01000000]00    <1> 	mov	byte ptr [_indication+1], 0	; clear from platform indications fabric	ll.MM.hh.zz
    16 00000D85 31F6                <1> 	xor	esi, esi			; clear latent param
    17 00000D87 B802000000          <1> 	mov	eax, II_XINT			; select external interrupt
    18                              <1> 
    19 00000D8C EB7D                <1> 	jmp	_ii_
    20                              <1> 	
    21 00000D8E A880                <1> _xix:	test	al, ATTENTION			; core2core interrupt
    22                              <1> 
    23 00000D90 8035[00000000]80    <1> 	xor	byte ptr [_indication], ATTENTION
    24                              <1> 
    25 00000D97 F605[38010000]01    <1> 	test	byte ptr [_base+78*4], 1	; the 1 core
    26 00000D9E 7414                <1> 	jz	_xiy				; has not selected itself
    27                              <1> 
    28 00000DA0 B805000000          <1> 	mov	eax, II_ATTENTION
    29 00000DA5 8B35[3C010000]      <1> 	mov	esi, dword ptr [_base+79*4]	; latent parameter
    30 00000DAB 8025[38010000]FE    <1> 	and	byte ptr [_base+78*4], -2	; 
    31                              <1> 
    32 00000DB2 EB57                <1> 	jmp	_ii_
    33                              <1> 
    34 00000DB4 A840                <1> _xiy:	test	al, INCREMENTER_CARRY		; nanosecond or other counter 
    35 00000DB6 7410                <1> 	jz	_xiz				; from minus to carrry on zero
    36                              <1> 						; to feed millisecond dayclock
    37 00000DB8 8035[00000000]40    <1> 	xor	byte ptr [_indication], INCREMENTER_CARRY
    38 00000DBF B804000000          <1> 	mov	eax, II_MSECOND
    39 00000DC4 31F6                <1> 	xor	esi, esi
    40 00000DC6 EB43                <1> 	jmp	_ii_
    41                              <1> 
    42 00000DC8 C3                  <1> _xiz:	ret
    43                              <1> 
    44                              <1> _ii_instruction:
    45 00000DC9 89C3                <1> 	mov	ebx, eax
    46 00000DCB C1EB06              <1> 	shr	ebx, 6
    47 00000DCE 2B1D[20010000]      <1> 	sub	ebx, dword ptr [_base+72*4]	; application threshold
    48 00000DD4 7910                <1> 	jns	guard_ii_authority	; must have executed a character string
    49                              <1> 					; like 757575
    50 00000DD6 A9C0FFFFFF          <1> 	test	eax, -64
    51 00000DDB 7519                <1> 	jnz	_ii			; not in restart page OK
    52 00000DDD F605[02000000]80    <1> 	test	byte ptr [_psr+2], 128	; psr + 1 in BE-speak LE:L_M_H_Z
    53 00000DE4 7510                <1> 	jnz	_ii			; ISR may interrupt to restart page
    54                              <1> 
    55                              <1> 		; service call application to restart page not allowed
    56                              <1> 		; most likely to be an accident
    57                              <1> 		; drop thru and be quelled
    58                              <1> 
    59                              <1> guard_ii_authority:
    60 00000DE6 BE01000000          <1> 	mov	esi, LP_AUTHORITY
    61                              <1> guard_ii_escape:
    62 00000DEB B85F000000          <1> 	mov	eax, II_GUARD
    63                              <1> _ii_escape:
    64 00000DF0 8B25[7C040000]      <1> 	mov	esp, dword ptr [__register+287*4]
    65                              <1> 
    66 00000DF6 83F85F              <1> _ii:	cmp	eax, II_GUARD
    67 00000DF9 7510                <1> 	jnz	_ii_
    68 00000DFB F605[19000000]01    <1> 	test	byte ptr [_uflag+'Z'-'A'], 1	; break to debug console?
    69 00000E02 7407                <1> 	jz	_ii_				; not if not opted
    70 00000E04 800D[00000000]02    <1> 	or	byte ptr [_indication], LOCKSTEP
    71                              <1> 	
    72 00000E0B BD[00020000]        <1> _ii_:	mov	ebp, __register+128*4
    73 00000E10 892D[00000000]      <1> 	mov	dword ptr [_register_set], ebp
    74 00000E16 C705[00000000]8000- <1> 	mov	dword ptr [_iselect], 128
    74 00000E1E 0000                <1>
    75                              <1> 
    76                              <1> 	%if	1
    77 00000E20 8B5D3C              <1> 	mov	ebx, dword ptr [ebp+S_P]
    78 00000E23 81FB00010000        <1> 	cmp	ebx, 256
    79 00000E29 0F87D9010000        <1> 	ja	near guard_stack
    80 00000E2F 83C3FC              <1> 	add	ebx, -4
    81 00000E32 895D3C              <1> 	mov	dword ptr [ebp+S_P], ebx
    82 00000E35 81FB98000000        <1> 	cmp	ebx, 128+24
    83 00000E3B 0F82C7010000        <1> 	jb	near guard_stack
    84                              <1> 
    85                              <1> 	%else
    86                              <1> 	add	dword ptr [ebp+S_P], -4
    87                              <1> 	jns	_ii_ahead
    88                              <1> 	mov	dword ptr [ebp+S_P], 256
    89                              <1> 
    90                              <1> _ii_ahead:
    91                              <1> 	mov	ebx, dword ptr [ebp+S_P]
    92                              <1> 	%endif
    93                              <1> 
    94 00000E41 2B15[00000000]      <1> 	sub	edx, dword ptr [_b0p]
    95 00000E47 C1EA02              <1> 	shr	edx, 2
    96 00000E4A 89149D[0C000000]    <1> 	mov	dword ptr [ebx*4+__register+12], edx	; save PC offset
    97 00000E51 8B15[00000000]      <1> 	mov	edx, dword ptr [_b0_name]
    98 00000E57 89149D[08000000]    <1> 	mov	dword ptr [ebx*4+__register+8], edx	; save bank ID
    99 00000E5E 8B15[00000000]      <1> 	mov	edx, dword ptr [_psr]
   100 00000E64 89149D[04000000]    <1> 	mov	dword ptr [ebx*4+__register+4], edx	; saved PSR
   101 00000E6B 89349D[00000000]    <1> 	mov	dword ptr [ebx*4+__register], esi	; latent parameter
   102 00000E72 F7C200008000        <1> 	test	edx, 00800000h				; nested interrupt ?
   103 00000E78 7503                <1> 	jnz	_ii_ii
   104 00000E7A 895D38              <1> 	mov	dword ptr [ebp+FP], ebx			; if not, mark interrupted
   105                              <1> 							; application stack frame
   106                              <1> _ii_ii:
   107 00000E7D 81CA00008000        <1> 	or	edx, 00800000h				; ISR active
   108 00000E83 8915[00000000]      <1> 	mov	dword ptr [_psr], edx
   109                              <1> 
   110 00000E89 89C2                <1> 	mov	edx, eax				; get to the operand
   111 00000E8B 83E23F              <1> 	and	edx, 63					; address from interrupt vector
   112 00000E8E C1E806              <1> 	shr	eax, 6
   113 00000E91 25FF030000          <1> 	and	eax, 000003FFh				; eax -> page containing ISR ; edx  -> vector
   114 00000E96 31DB                <1> 	xor	ebx, ebx				; single page ISR
   115 00000E98 E9A6060000          <1> 	jmp	_go2_frame
   116                              <1> 
   117                              <1> ;	_ir	sign extended ea is in eax
   118                              <1> 
   119 00000E9D F605[02000000]80    <1> _ir:	test	byte ptr [_psr+2], 128		; eax = EA = variation on return offset
   120 00000EA4 0F843CFFFFFF        <1> 	jz	guard_ii_authority		; not good to do Interrupt Return from application space
   121 00000EAA 89D7                <1> 	mov	edi, edx			; save in case the operation interrupts itself
   122 00000EAC 89C2                <1> 	mov	edx, eax			; +- displacement operand, offset in stack added later
   123                              <1> 
   124 00000EAE E88C010000          <1> 	call	stack_read4			; [ebp+ebx*4] -> interrupt stack frame
   125                              <1> 						; interrupt stack pointer is already updated ebx+4
   126                              <1> 
   127 00000EB3 8B449D08            <1> 	mov	eax, dword ptr [ebp+ebx*4+2*4]		; interrupted b0_name
   128                              <1> 
   129 00000EB7 8B4C9D04            <1> 	mov	ecx, dword ptr [ebp+ebx*4+1*4]		; interrupted psr
   130                              <1> 
   131 00000EBB 03549D0C            <1> 	add	edx, dword ptr [ebp+ebx*4+3*4]		; add interrupted iframe offset to EA
   132                              <1> 
   133 00000EBF 31DB                <1> 	xor	ebx, ebx				; 
   134 00000EC1 A900008000          <1> 	test	eax, 00800000h
   135 00000EC6 7410                <1> 	jz	ir_4k_iframe				; 1-page iframe return target
   136                              <1> 
   137 00000EC8 89C3                <1> 	mov	ebx, eax				; larger
   138 00000ECA C1E30C              <1> 	shl	ebx, 12					; read page high index
   139 00000ECD 0FB61C9D[01010000]  <1> 	movzx	ebx, byte ptr [_memory+ebx*4+64*4+1]	; from high order 6 bits
   140 00000ED5 C1EB02              <1> 	shr	ebx, 2					; of sample gate at iframe+64 
   141                              <1> 
   142                              <1> ir_4k_iframe:
   143 00000ED8 890D[00000000]      <1> 	mov	dword ptr [_psr], ecx
   144 00000EDE F7C100008000        <1> 	test	ecx, 00800000h				; returning ISR -> ISR ?
   145 00000EE4 741A                <1> 	jz	ir_application				; no
   146 00000EE6 BD[00020000]        <1> 	 mov	ebp, __register+128*4			; for nested interrupts
   147 00000EEB 892D[00000000]      <1> 	 mov	dword ptr [_register_set], ebp		; positively maintain
   148 00000EF1 C705[00000000]8000- <1> 	 mov	dword ptr [_iselect], 128		; interrupt register set
   148 00000EF9 0000                <1>
   149 00000EFB E943060000          <1> 	jmp	_go2_frame				; yes
   150                              <1> 
   151                              <1> ir_application:
   152 00000F00 BD[00000000]        <1> 	mov	ebp, __register
   153 00000F05 892D[00000000]      <1> 	mov	dword ptr [_register_set], ebp
   154 00000F0B C705[00000000]0000- <1> 	mov	dword ptr [_iselect], 0
   154 00000F13 0000                <1>
   155 00000F15 E929060000          <1> 	jmp	_go2_frame
   156                              <1> 
    33                                  	%include	"stack.msm"
     1                              <1> ;	stack operations call these to add or subract stack
     2                              <1> ;	limits are checked here
     3                              <1> ;	these routines always leave epb -> all registers 0..255
     4                              <1> ;	because both  interrupt internal stack pointer register 128 + 15
     5                              <1> ;		and application internal stack pointer register 15
     6                              <1> 
     7                              <1> ;	are absolute pointers to the entire register stack
     8                              <1> 
     9                              <1> ;	therefore instructions calling here must afterwards
    10                              <1> 
    11                              <1> ;		mov	ebp, dword ptr [_register_set]
    12                              <1> 
    13                              <1> ;	to get ebp back to application registers 0..127
    14                              <1> ;			or interrupt registers 128..255
    15                              <1> 
    16                              <1> ;	ebp governs which r k x y a b mantissa2 mantissa3 fp sp is implied in the instruction opcode
    17                              <1> ;	registers addressed as operand are always absolute in the range 0..255
    18                              <1> 
    19                              <1> ;	these don't move any data but leave [ebp+ebx*4] pointing to the required stack frame
    20                              <1> ;	and update the stack pointer
    21                              <1> 
    22                              <1> ;	although applications can and must read interrupt registers with load instructions
    23                              <1> ;	they can't read interrupt registers with runaway pop instructions
    24                              <1> ;	because the problem is easier to find with an interrupt as soon as 128+ gets popped
    25                              <1> 
    26                              <1> 
    27 00000F1A 8B5D3C              <1> stack1:	mov	ebx, dword ptr [ebp+S_P]
    28 00000F1D F605[02000000]80    <1> 	test	byte ptr [_psr+2], 128
    29 00000F24 742D                <1> 	jz	stack1_a
    30 00000F26 81FB00010000        <1> 	cmp	ebx, 256
    31 00000F2C 0F87D6000000        <1> 	ja	near guard_stack
    32 00000F32 4B                  <1> 	dec	ebx
    33 00000F33 0F88CF000000        <1> 	js	near guard_stack
    34 00000F39 81FB98000000        <1> 	cmp	ebx, 128+24
    35 00000F3F 7309                <1> 	jnb	stack1_j			; in range
    36 00000F41 83FB7F              <1> 	cmp	ebx, 128-1			; new sp value
    37 00000F44 0F87BE000000        <1> 	ja	near guard_stack		; in working registers page
    38                              <1> stack1_j:
    39 00000F4A 895D3C              <1> 	mov	dword ptr [ebp+S_P], ebx
    40 00000F4D BD[00000000]        <1> 	mov	ebp, __register
    41 00000F52 C3                  <1> 	ret
    42                              <1> 
    43                              <1> stack1_a:
    44 00000F53 81FB80000000        <1> 	cmp	ebx, 128			; application push high limit 128,  ISR 256
    45 00000F59 0F87A9000000        <1> 	ja	near guard_stack
    46 00000F5F 4B                  <1> 	dec	ebx
    47 00000F60 83FB18              <1> 	cmp	ebx, 24
    48 00000F63 0F829F000000        <1> 	jb	near guard_stack		; stack top limit zero ISR and application
    49 00000F69 895D3C              <1> 	mov	dword ptr [ebp+S_P], ebx
    50 00000F6C BD[00000000]        <1> 	mov	ebp, __register
    51 00000F71 C3                  <1> 	ret
    52                              <1> 
    53 00000F72 8B5D3C              <1> stack2:	mov	ebx, dword ptr [ebp+S_P]
    54 00000F75 F605[02000000]80    <1> 	test	byte ptr [_psr+2], 128
    55 00000F7C 742F                <1> 	jz	stack2_a
    56 00000F7E 81FB00010000        <1> 	cmp	ebx, 256
    57 00000F84 0F877E000000        <1> 	ja	near guard_stack
    58 00000F8A 83C3FE              <1> 	add	ebx, -2
    59 00000F8D 0F8875000000        <1> 	js	near guard_stack
    60 00000F93 81FB98000000        <1> 	cmp	ebx, 128+24
    61 00000F99 7309                <1> 	jnb	stack2_j
    62 00000F9B 83FB7E              <1> 	cmp	ebx, 128-2
    63 00000F9E 0F8764000000        <1> 	ja	near guard_stack
    64                              <1> 
    65                              <1> stack2_j:
    66 00000FA4 895D3C              <1> 	mov	dword ptr [ebp+S_P], ebx
    67 00000FA7 BD[00000000]        <1> 	mov	ebp, __register
    68 00000FAC C3                  <1> 	ret
    69                              <1> 
    70                              <1> stack2_a:
    71 00000FAD 81FB80000000        <1> 	cmp	ebx, 128			; application push high limit 128,  ISR 256
    72 00000FB3 7753                <1> 	ja	guard_stack
    73 00000FB5 83C3FE              <1> 	add	ebx, -2
    74 00000FB8 83FB18              <1> 	cmp	ebx, 24
    75 00000FBB 724B                <1> 	jb	guard_stack			; stack top limit zero ISR and application
    76 00000FBD 895D3C              <1> 	mov	dword ptr [ebp+S_P], ebx
    77 00000FC0 BD[00000000]        <1> 	mov	ebp, __register
    78 00000FC5 C3                  <1> 	ret
    79                              <1> 
    80 00000FC6 8B5D3C              <1> stack4:	mov	ebx, dword ptr [ebp+S_P]
    81 00000FC9 F605[02000000]80    <1> 	test	byte ptr [_psr+2], 128		; read psr interrupt bit
    82 00000FD0 7420                <1> 	jz	stack4_a			; stack is registers 24..127
    83 00000FD2 81FB00010000        <1> 	cmp	ebx, 256			; stack is registers  0..255
    84 00000FD8 772E                <1> 	ja	guard_stack
    85 00000FDA 83C3FC              <1> 	add	ebx, -4				; proposed frame
    86 00000FDD 7829                <1> 	js	guard_stack			; not lower than register zero
    87 00000FDF 81FB98000000        <1> 	cmp	ebx, 128+24
    88 00000FE5 7305                <1> 	jnb	stack4_j
    89 00000FE7 83FB7C              <1> 	cmp	ebx, 128-4			; in working registers page
    90 00000FEA 771C                <1> 	ja	guard_stack
    91                              <1> 
    92                              <1> stack4_j:
    93 00000FEC BD[00000000]        <1> 	mov	ebp, __register			; registers means all of them
    94 00000FF1 C3                  <1> 	ret					; both sp are absolute pointers
    95                              <1> 
    96                              <1> stack4_a:
    97 00000FF2 81FB80000000        <1> 	cmp	ebx, 128			; don't push into a higher register than 127
    98 00000FF8 770E                <1> 	ja	guard_stack
    99 00000FFA 83C3FC              <1> 	add	ebx, -4
   100 00000FFD 83FB18              <1> 	cmp	ebx, 24				; dont push lower than 24
   101 00001000 7206                <1> 	jb	guard_stack
   102                              <1> 
   103 00001002 BD[00000000]        <1> 	mov	ebp, __register			; registers means all of them
   104 00001007 C3                  <1> 	ret					; both sp are absolute pointers
   105                              <1> 
   106                              <1> guard_stack:
   107                              <1> stack_underflow:
   108 00001008 8B2D[00000000]      <1> 	mov	ebp, dword ptr [_register_set]	; application or interrupt register set
   109 0000100E F705[00000000]0000- <1> 	test	dword ptr [_psr], 00800000h
   109 00001016 8000                <1>
   110 00001018 0F84C8FDFFFF        <1> 	jz	guard_ii_authority		; sideline the application
   111 0000101E C7453C00010000      <1> 	mov	dword ptr [ebp+S_P], 256	; restart the interrupt stack
   112 00001025 B801000000          <1> 	mov	eax, 1				; so the interrupt can be interrupted
   113 0000102A F605[19000000]01    <1> 	test	byte ptr [_uflag+'Z'-'A'], 1
   114 00001031 7407                <1> 	jz	gsago
   115 00001033 800D[00000000]02    <1> 	or	byte ptr [_indication], LOCKSTEP
   116 0000103A E9B1FDFFFF          <1> gsago:	jmp	_ii_escape
   117                              <1> 
   118                              <1> stack_read4:
   119 0000103F BB04000000          <1> 	mov	ebx, 4
   120 00001044 035D3C              <1> 	add	ebx, dword ptr [ebp+S_P]
   121 00001047 81FB80000000        <1> 	cmp	ebx, 128			; you can have stack locations up to here
   122 0000104D 7611                <1> 	jna	stack_r4			; whoever you are
   123 0000104F F605[02000000]80    <1> 	test	byte ptr [_psr+2], 128		; any higher you have to be an ISR
   124 00001056 74B0                <1> 	jz	stack_underflow
   125 00001058 81FB00010000        <1> 	cmp	ebx, 256			; and then not any higher than this
   126 0000105E 77A8                <1> 	ja	stack_underflow
   127                              <1> 
   128                              <1> stack_r4:
   129 00001060 875D3C              <1> 	xchg	ebx, dword ptr [ebp+S_P]
   130 00001063 BD[00000000]        <1> 	mov	ebp, __register
   131 00001068 C3                  <1> 	ret
   132                              <1> 
   133                              <1> stack_read2:
   134 00001069 BB02000000          <1> 	mov	ebx, 2
   135 0000106E 035D3C              <1> 	add	ebx, dword ptr [ebp+S_P]
   136 00001071 81FB80000000        <1> 	cmp	ebx, 128			; you can have stack locations up to here
   137 00001077 7615                <1> 	jna	stack_r2			; whoever you are
   138 00001079 F605[02000000]80    <1> 	test	byte ptr [_psr+2], 128		; any higher you have to be an ISR
   139 00001080 7486                <1> 	jz	stack_underflow
   140 00001082 81FB00010000        <1> 	cmp	ebx, 256			; and then not any higher than this
   141 00001088 0F877AFFFFFF        <1> 	ja	stack_underflow
   142                              <1> 
   143                              <1> stack_r2:
   144 0000108E 875D3C              <1> 	xchg	ebx, dword ptr [ebp+S_P]
   145 00001091 BD[00000000]        <1> 	mov	ebp, __register
   146 00001096 C3                  <1> 	ret
   147                              <1> 
   148                              <1> stack_read1:
   149 00001097 BB01000000          <1> 	mov	ebx, 1
   150 0000109C 035D3C              <1> 	add	ebx, dword ptr [ebp+S_P]
   151 0000109F 81FB80000000        <1> 	cmp	ebx, 128			; you can have stack locations up to here
   152 000010A5 7619                <1> 	jna	stack_r1			; whoever you are
   153 000010A7 F605[02000000]80    <1> 	test	byte ptr [_psr+2], 128		; any higher you have to be an ISR
   154 000010AE 0F8454FFFFFF        <1> 	jz	stack_underflow
   155 000010B4 81FB00010000        <1> 	cmp	ebx, 256			; and then not any higher than this
   156 000010BA 0F8748FFFFFF        <1> 	ja	stack_underflow
   157                              <1> 
   158                              <1> stack_r1:
   159 000010C0 875D3C              <1> 	xchg	ebx, dword ptr [ebp+S_P]	; already updated
   160 000010C3 BD[00000000]        <1> 	mov	ebp, __register
   161 000010C8 C3                  <1> 	ret
   162                              <1> 
    34                                  	%include	"return.msm"
     1                              <1> _autoexit:
     2 000010C9 B846000000          <1> 	mov	eax, II_EXIT
     3 000010CE BE0B000000          <1> 	mov	esi, LP_AUTOEXIT
     4 000010D3 E918FDFFFF          <1> 	jmp	_ii_escape
     5                              <1> 
     6 000010D8 F705[00000000]0000- <1> _lret:	test	dword ptr [_psr], 00800000h
     6 000010E0 8000                <1>
     7 000010E2 7509                <1> 	jnz	_lret_
     8                              <1> 
     9 000010E4 817D3C80000000      <1> 	cmp	dword ptr [ebp+S_P], 128
    10 000010EB 74DC                <1> 	jz	_autoexit
    11                              <1> 
    12 000010ED E8A5FFFFFF          <1> _lret_:	call	stack_read1
    13 000010F2 03449D00            <1> 	add	eax, dword ptr [ebp+ebx*4]
    14 000010F6 8B2D[00000000]      <1> 	mov	ebp, dword ptr [_register_set]
    15 000010FC 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
    16 00001101 E942020000          <1> 	jmp	_j
    17                              <1> 
    18 00001106 F705[00000000]0000- <1> _fret:	test	dword ptr [_psr], 00800000h
    18 0000110E 8000                <1>
    19 00001110 7509                <1> 	jnz	_fret_
    20                              <1> 
    21 00001112 817D3C80000000      <1> 	cmp	dword ptr [ebp+S_P], 128
    22 00001119 74AE                <1> 	jz	_autoexit
    23                              <1> 
    24 0000111B E849FFFFFF          <1> _fret_:	call	stack_read2
    25 00001120 8915[00000000]      <1> 	mov	dword ptr [_apc], edx
    26 00001126 89C2                <1> 	mov	edx, eax
    27 00001128 03549D04            <1> 	add	edx, dword ptr [ebp+ebx*4+1*4]	; add EA as displacement to offset on stack
    28 0000112C 8B449D00            <1> 	mov	eax, dword ptr [ebp+ebx*4]
    29 00001130 8B2D[00000000]      <1> 	mov	ebp, dword ptr [_register_set]
    30 00001136 31DB                <1> 	xor	ebx, ebx			; 1-page frame?
    31 00001138 A900008000          <1> 	test	eax, 00800000h			; multipages frame?
    32 0000113D 7410                <1> 	jz	_fret_1page
    33 0000113F 89C3                <1> 	mov	ebx, eax
    34 00001141 C1E30C              <1> 	shl	ebx, 12
    35 00001144 0FB61C9D[01010000]  <1> 	movzx	ebx, byte ptr [_memory+ebx*4+64*4+1]
    36 0000114C C1EB02              <1> 	shr	ebx, 2
    37                              <1> 
    38                              <1> _fret_1page:
    39 0000114F E9EF030000          <1> 	jmp	_go2_frame
    40                              <1> 
    41 00001154 B803000000          <1> _fpxpo:	mov	eax, II_FPXPO
    42 00001159 BE0C000000          <1> 	mov	esi, LP_RANGE
    43 0000115E E98DFCFFFF          <1> 	jmp	_ii_escape
    44                              <1> 
    35                                  	%include	"rta.msm"
     1                              <1> 
     2 00001163 80F904              <1> _sr:	cmp	cl, I
     3 00001166 0F8436F9FFFF        <1> 	jz	_inA
     4 0000116C 80F905              <1> 	cmp	cl, XI
     5 0000116F 0F84E9FBFFFF        <1> 	jz	_on
     6                              <1> 
     7 00001175 8B5D00              <1> 	mov	ebx, dword ptr [ebp+R]
     8 00001178 E96BF3FFFF          <1> 	jmp	_operand_write
     9                              <1> 
    10 0000117D 80F904              <1> _sk:	cmp	cl, I
    11 00001180 0F8427F9FFFF        <1> 	jz	_inB
    12 00001186 80F905              <1> 	cmp	cl, XI
    13 00001189 0F84D7FBFFFF        <1> 	jz	_off
    14                              <1> 
    15 0000118F 8B5D04              <1> 	mov	ebx, dword ptr [ebp+K]
    16 00001192 E951F3FFFF          <1> 	jmp	_operand_write
    17                              <1> 
    18 00001197 80F904              <1> _sx:	cmp	cl, I
    19 0000119A 0F8418F9FFFF        <1> 	jz	_outA
    20 000011A0 80F905              <1> 	cmp	cl, XI
    21 000011A3 0F84D7F7FFFF        <1> 	jz	_rsr
    22                              <1> 
    23 000011A9 8B5D08              <1> 	mov	ebx, dword ptr [ebp+X]
    24 000011AC E937F3FFFF          <1> 	jmp	_operand_write
    25                              <1> 
    26 000011B1 80F904              <1> _sy:	cmp	cl, I
    27 000011B4 0F8406F9FFFF        <1> 	jz	_outB
    28 000011BA 80F905              <1> 	cmp	cl, XI
    29 000011BD 0F8440F8FFFF        <1> 	jz	_wsr
    30                              <1> 
    31 000011C3 8B5D0C              <1> 	mov	ebx, dword ptr [ebp+Y]
    32 000011C6 E91DF3FFFF          <1> 	jmp	_operand_write;
    33                              <1> 
    34 000011CB 80F904              <1> _sa:	cmp	cl, I
    35 000011CE 0F84ACF9FFFF        <1> 	jz	_reload
    36 000011D4 80F905              <1> 	cmp	cl, XI
    37 000011D7 0F845EEFFFFF        <1> 	jz	escape
    38                              <1> 
    39 000011DD 8B5D10              <1> 	mov	ebx, dword ptr [ebp+A]
    40 000011E0 E903F3FFFF          <1> 	jmp	_operand_write
    41                              <1> 
    42 000011E5 80F904              <1> _sb:	cmp	cl, I
    43 000011E8 0F84AFF9FFFF        <1> 	jz	_emulator_cool
    44 000011EE 80F905              <1> 	cmp	cl, XI
    45 000011F1 0F8444EFFFFF        <1> 	jz	escape
    46                              <1> 
    47 000011F7 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]
    48 000011FA E9E9F2FFFF          <1> 	jmp	_operand_write
    49                              <1> 
    50 000011FF 80F904              <1> _z:	cmp	cl, I
    51 00001202 0F8496F9FFFF        <1> 	jz	_sabr
    52 00001208 80F905              <1> 	cmp	cl, XI
    53 0000120B 0F84C7FEFFFF        <1> 	jz	_lret
    54 00001211 31DB                <1> 	xor	ebx, ebx
    55 00001213 E9D0F2FFFF          <1> 	jmp	_operand_write
    56                              <1> 
    57 00001218 80F904              <1> _pop:	cmp	cl, I
    58 0000121B 0F841AEFFFFF        <1> 	jz	escape
    59 00001221 80F905              <1> 	cmp	cl, XI
    60 00001224 0F84DCFEFFFF        <1> 	jz	_fret
    61                              <1> 
    62 0000122A E868FEFFFF          <1> 	call	stack_read1
    63 0000122F 8B5C9D00            <1> 	mov	ebx, dword ptr [ebp+ebx*4]
    64 00001233 8B2D[00000000]      <1> 	mov	ebp, dword ptr [_register_set]
    65 00001239 E9AAF2FFFF          <1> 	jmp	_operand_write
    66                              <1> 
    67 0000123E E8F3F0FFFF          <1> _lr:	call	_operand_read
    68 00001243 894500              <1> 	mov	dword ptr [ebp+R], eax
    69 00001246 C3                  <1> 	ret
    70                              <1> 
    71 00001247 E8EAF0FFFF          <1> _lk:	call	_operand_read
    72 0000124C 894504              <1> 	mov	dword ptr [ebp+K], eax
    73 0000124F C3                  <1> 	ret
    74 00001250 E8E1F0FFFF          <1> _lx:	call	_operand_read
    75 00001255 894508              <1> 	mov	dword ptr [ebp+X], eax
    76 00001258 C3                  <1> 	ret
    77                              <1> 
    78 00001259 E8D8F0FFFF          <1> _ly:	call	_operand_read
    79 0000125E 89450C              <1> 	mov	dword ptr [ebp+Y], eax
    80 00001261 C3                  <1> 	ret
    81                              <1> 
    82 00001262 E8CFF0FFFF          <1> _la:	call	_operand_read
    83 00001267 894510              <1> 	mov	dword ptr [ebp+A], eax
    84 0000126A C3                  <1> 	ret
    85                              <1> 
    86 0000126B E8C6F0FFFF          <1> _lb:	call	_operand_read
    87 00001270 894514              <1> 	mov	dword ptr [ebp+B], eax
    88 00001273 C3                  <1> 	ret
    89                              <1> 
    90 00001274 80F904              <1> _tz:	cmp	cl, I
    91 00001277 0F8496130000        <1> 	jz	near _rex
    92 0000127D 80F905              <1> 	cmp	cl, XI
    93 00001280 BE00000000          <1> 	mov	esi, 0
    94 00001285 0F843EFBFFFF        <1> 	jz	_ii_instruction
    95                              <1> 
    96 0000128B E8A6F0FFFF          <1> 	call	_operand_read
    97 00001290 A9FFFFFF00          <1> 	test	eax, 00FFFFFFh
    98 00001295 7503                <1> 	jnz	_tz_
    99 00001297 83C204              <1> 	add	edx, 4
   100 0000129A C3                  <1> _tz_:	ret
   101                              <1> 
   102 0000129B 80F904              <1> _tp:	cmp	cl, I
   103 0000129E 742E                <1> 	jz	_jdz
   104 000012A0 80F905              <1> 	cmp	cl, XI
   105 000012A3 0F84F4FBFFFF        <1> 	jz	_ir
   106                              <1> 
   107 000012A9 E888F0FFFF          <1> 	call	_operand_read
   108 000012AE A900008000          <1> 	test	eax, 00800000h
   109 000012B3 7503                <1> 	jnz	_tp_
   110 000012B5 83C204              <1> 	add	edx, 4
   111 000012B8 C3                  <1> _tp_:	ret
   112                              <1> 
   113 000012B9 E878F0FFFF          <1> _push:	call	_operand_read	; this 1st in case sp is pushed
   114 000012BE E857FCFFFF          <1> 	call	stack1
   115 000012C3 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   116 000012C7 8B2D[00000000]      <1> 	mov	ebp, dword ptr [_register_set]
   117                              <1> 	
   118                              <1> ;	add	dword ptr [ebp+S_P], -1
   119                              <1> ;	mov	ebx, dword ptr [ebp+S_P]
   120                              <1> ;	mov	dword ptr [ebx*4+__register], eax
   121                              <1> 
   122 000012CD C3                  <1> 	ret
   123                              <1> 
   124 000012CE 8B5D14              <1> _jdz:	mov	ebx, dword ptr [ebp+B]
   125 000012D1 0B5D10              <1> 	or	ebx, dword ptr [ebp+A]
   126 000012D4 0F846E000000        <1> 	jz	near _j
   127 000012DA C3                  <1> 	ret
   128                              <1> 
   129 000012DB 8B5D00              <1> _jdr:	mov	ebx, dword ptr [ebp+R]	; dec r and jump if it passed from zero to -1
   130 000012DE 81C3FFFFFF00        <1> 	add	ebx, 00FFFFFFh
   131 000012E4 C1C308              <1> 	rol	ebx, 8
   132 000012E7 88D9                <1> 	mov	cl, bl
   133 000012E9 C1EB08              <1> 	shr	ebx, 8			; write back to registers only 00000000 thru 00FFFFFF
   134 000012EC 895D00              <1> 	mov	dword ptr [ebp+R], ebx
   135 000012EF F6C101              <1> 	test	cl, 1
   136 000012F2 7554                <1> 	jnz	_j
   137 000012F4 C3                  <1> 	ret
   138                              <1> 
   139 000012F5 E820FCFFFF          <1> _lcal:	call	stack1
   140 000012FA 2B15[00000000]      <1> 	sub	edx, dword ptr [_b0p]
   141 00001300 C1EA02              <1> 	shr	edx, 2
   142 00001303 89549D00            <1> 	mov	dword ptr [ebp+ebx*4], edx
   143 00001307 8B2D[00000000]      <1> 	mov	ebp, dword ptr [_register_set]
   144 0000130D EB39                <1> 	jmp	_j			; EA is in eax
   145 0000130F C3                  <1> 	ret
   146                              <1> 
   147 00001310 F705[00000000]0100- <1> _jnc:	test	dword ptr [_psr], 1
   147 00001318 0000                <1>
   148 0000131A 742C                <1> 	jz	_j
   149 0000131C C3                  <1> 	ret
   150                              <1> 
   151 0000131D F705[00000000]0100- <1> _jc:	test	dword ptr [_psr], 1
   151 00001325 0000                <1>
   152 00001327 751F                <1> 	jnz	_j
   153 00001329 C3                  <1> 	ret
   154                              <1> 
   155 0000132A F7451001000000      <1> _jao:	test	dword ptr [ebp+A], 1
   156 00001331 7515                <1> 	jnz	_j
   157 00001333 C3                  <1> 	ret
   158                              <1> 
   159 00001334 F7451000008000      <1> _jpa:	test	dword ptr [ebp+A], 00800000h
   160 0000133B 740B                <1> 	jz	_j
   161 0000133D C3                  <1> 	ret
   162                              <1> 
   163 0000133E F7451400008000      <1> _jpb:	test	dword ptr [ebp+B], 00800000h
   164 00001345 7401                <1> 	jz	_j
   165 00001347 C3                  <1> 	ret
   166                              <1> 
   167 00001348 89D7                <1> _j:	mov	edi, edx			; save updated apc
   168 0000134A 8B15[00000000]      <1> 	mov	edx, dword ptr [_b0p]
   169 00001350 C1E002              <1> 	shl	eax, 2
   170 00001353 01C2                <1> 	add	edx, eax
   171 00001355 3B15[00000000]      <1> 	cmp	edx, dword ptr [_apcz]
   172 0000135B 7701                <1> 	ja	_j_check
   173 0000135D C3                  <1> 	ret
   174                              <1> 
   175                              <1> _j_check:
   176 0000135E 89FA                <1> 	mov	edx, edi			; restore updated apc
   177 00001360 BE0E000000          <1> 	mov	esi, LP_ADDRESS
   178 00001365 E981FAFFFF          <1> 	jmp	guard_ii_escape			; for interrupt come-from
   179                              <1> 
   180 0000136A E854100000          <1> _jpo:	call	NEAR _get_parity
   181 0000136F 7BD7                <1> 	jpo	_j
   182 00001371 C3                  <1> 	ret
   183                              <1> 
   184 00001372 816510FFFFFF00      <1> _jza:	and	dword ptr [ebp+A], 00FFFFFFh
   185 00001379 74CD                <1> 	jz	_j
   186 0000137B C3                  <1> 	ret
   187                              <1> 
   188 0000137C 816514FFFFFF00      <1> _jzb:	and	dword ptr [ebp+B], 00FFFFFFh
   189 00001383 74C3                <1> 	jz	_j
   190 00001385 C3                  <1> 	ret
   191                              <1> 
   192 00001386 816510FFFFFF00      <1> _jnza:	and	dword ptr [ebp+A], 00FFFFFFh
   193 0000138D 75B9                <1> 	jnz	_j
   194 0000138F C3                  <1> 	ret
   195                              <1> 
   196 00001390 816514FFFFFF00      <1> _jnzb:	and	dword ptr [ebp+B], 00FFFFFFh
   197 00001397 75AF                <1> 	jnz	_j
   198 00001399 C3                  <1> 	ret
   199                              <1> 
   200 0000139A F7451000008000      <1> _jna:	test	dword ptr [ebp+A], 00800000h
   201 000013A1 75A5                <1> 	jnz	_j
   202 000013A3 C3                  <1> 	ret
   203                              <1> 
   204 000013A4 F7451400008000      <1> _jnb:	test	dword ptr [ebp+B], 00800000h
   205 000013AB 759B                <1> 	jnz	_j
   206 000013AD C3                  <1> 	ret
   207                              <1> 
   208 000013AE 8B5D08              <1> _jxge:	mov	ebx, dword ptr [ebp+X]
   209 000013B1 2B5D00              <1> 	sub	ebx, dword ptr [ebp+R]
   210 000013B4 F7C300000001        <1> 	test	ebx, 01000000h		; microcarry?
   211 000013BA 748C                <1> 	jz	_j			; no:  x <  r,    jump
   212 000013BC C3                  <1> 	ret				; yes: x >= r, no jump
   213                              <1> 
   214 000013BD 8B5D0C              <1> _jyge:	mov	ebx, dword ptr [ebp+Y]
   215 000013C0 2B5D00              <1> 	sub	ebx, dword ptr [ebp+R]
   216 000013C3 F7C300000001        <1> 	test	ebx, 01000000h		; microcarry?
   217 000013C9 0F8479FFFFFF        <1> 	jz	_j			; no:  y <  r,    jump
   218 000013CF C3                  <1> 	ret				; yes: y >= r, no jump
   219                              <1> 
   220 000013D0 BB04000000          <1> _qs:	mov	ebx, a
   221 000013D5 E980F0FFFF          <1> 	jmp	_burst_write4
   222                              <1> 
   223 000013DA BB04000000          <1> _ql:	mov	ebx, a
   224 000013DF E916EFFFFF          <1> 	jmp	_burst_read4
   225                              <1> 
   226 000013E4 50                  <1> _qpop:	push	eax				; EA
   227 000013E5 E855FCFFFF          <1> 	call	stack_read4			; places 4 stack registers in the scope of burst write
   228 000013EA 58                  <1> 	pop	eax				; EA
   229 000013EB E86AF0FFFF          <1> 	call	_burst_write4
   230 000013F0 8B2D[00000000]      <1> 	mov	ebp, dword ptr [_register_set]	; stack ops have ebp->total register set
   231                              <1> 
   232 000013F6 C3                  <1> 	ret					; stack pointers are absolute
   233                              <1> 
   234 000013F7 E8CAFBFFFF          <1> _qpush: call	stack4
   235 000013FC E8F9EEFFFF          <1> 	call	_burst_read4
   236 00001401 8B2D[00000000]      <1> 	mov	ebp, dword ptr [_register_set]
   237 00001407 895D3C              <1> 	mov	dword ptr [ebp+S_P], ebx	; updated sp written after burst read
   238 0000140A C3                  <1> 	ret
   239                              <1> 
   240 0000140B 50                  <1> _dpop:	push	eax
   241 0000140C E858FCFFFF          <1> 	call	stack_read2
   242 00001411 58                  <1> 	pop	eax
   243 00001412 E897F0FFFF          <1> 	call	_burst_write2
   244 00001417 8B2D[00000000]      <1> 	mov	ebp, dword ptr [_register_set]	; stack op had register set of all registers
   245 0000141D C3                  <1> 	ret
   246                              <1> 
   247 0000141E E8BBEEFFFF          <1> _dpush:	call	_burst_read2
   248 00001423 53                  <1> 	push	ebx
   249 00001424 E849FBFFFF          <1> 	call	stack2
   250 00001429 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   251 0000142D 58                  <1> 	pop	eax
   252 0000142E 89449D04            <1> 	mov	dword ptr [ebp+ebx*4+1*4], eax
   253 00001432 8B2D[00000000]      <1> 	mov	ebp, dword ptr [_register_set]
   254 00001438 C3                  <1> 	ret
   255                              <1> 
   256 00001439 E8F8EEFFFF          <1> _mta:	call	_operand_read
   257 0000143E 334510              <1> 	xor	eax, dword ptr [ebp+A]
   258 00001441 234504              <1> 	and	eax, dword ptr [ebp+K]
   259 00001444 7503                <1> 	jnz	_mta_
   260 00001446 83C204              <1> 	add	edx, 4		; k AND (a XOR operand) = 0, skip 1 instruction
   261 00001449 C3                  <1> _mta_:	ret
   262                              <1> 
   263 0000144A E88FEEFFFF          <1> _dte:	call	_burst_read2
   264 0000144F 334510              <1> 	xor	eax, dword ptr [ebp+A]
   265 00001452 7508                <1> 	jnz	_dte_
   266 00001454 335D14              <1> 	xor	ebx, dword ptr [ebp+B]
   267 00001457 7503                <1> 	jnz	_dte_
   268 00001459 83C204              <1> 	add	edx, 4
   269 0000145C C3                  <1> _dte_:	ret	
   270                              <1> 
   271 0000145D 8B1D[00000000]      <1> _sc:	mov	ebx, dword ptr [_psr]
   272 00001463 83E301              <1> 	and	ebx, 1		; store carry 
   273 00001466 E97DF0FFFF          <1> 	jmp	_operand_write
   274                              <1> 
   275 0000146B E8C6EEFFFF          <1> _mlb:	call	_operand_read
   276 00001470 8B5D04              <1> 	mov	ebx, dword ptr [ebp+K]
   277 00001473 21D8                <1> 	and	eax, ebx
   278 00001475 81F3FFFFFF00        <1> 	xor	ebx, 00FFFFFFh
   279 0000147B 235D14              <1> 	and	ebx, dword ptr [ebp+B]
   280 0000147E 09C3                <1> 	or	ebx, eax
   281 00001480 895D14              <1> 	mov	dword ptr [ebp+B], ebx	; b = (b AND (NOT k)) OR (operand AND k)
   282 00001483 C3                  <1> 	ret
   283                              <1> 
   284 00001484 BB04000000          <1> _ds:	mov	ebx, a
   285 00001489 E920F0FFFF          <1> 	jmp	_burst_write2
   286                              <1> 
   287 0000148E E84BEEFFFF          <1> _dl:	call	_burst_read2
   288 00001493 895D14              <1> 	mov	dword ptr [ebp+B], ebx
   289 00001496 894510              <1> 	mov	dword ptr [ebp+A], eax
   290 00001499 C3                  <1> 	ret
   291                              <1> 
   292 0000149A C3                  <1> _spare:	ret
   293                              <1> 
   294 0000149B E8B4F1FFFF          <1> _ex:	call	memory_read
   295 000014A0 E979ECFFFF          <1> 	jmp	_execute
   296                              <1> 
   297                              <1> 	%if	__SMP
   298                              <1> 
   299 000014A5 E8D1F1FFFF          <1> _ts:	call	memory_lock
   300 000014AA 66B80080            <1> 	mov	ax, 08000h
   301 000014AE 668704B7            <1> 	xchg	ax, word ptr [edi+esi*4]	; swap -> t1 for 080 under lock
   302 000014B2 6621C0              <1> 	and	ax, ax
   303 000014B5 7803                <1> 	js	_ts___				; no action if already locked
   304                              <1> 
   305 000014B7 83C204              <1> 	add	edx, 4				; skip if ms bit was clear before
   306                              <1> 
   307 000014BA C3                  <1> _ts___:	ret
   308                              <1> 
   309                              <1> 	%else
   310                              <1> 
   311                              <1> _ts:	call	memory_read_lock
   312                              <1> 	test	eax, 00800000h
   313                              <1> 	jz	_ts___
   314                              <1> 
   315                              <1> 	ret					; not obtained
   316                              <1> 
   317                              <1> _ts___:	add	edx, 4				; successful, skip one instruction
   318                              <1> 	or	eax, 00800000h			; claim
   319                              <1> 	jmp	memory_direct
   320                              <1> 
   321                              <1> 	%endif
   322                              <1> 
   323 000014BB E89FF1FFFF          <1> _sim:	call	memoreg	
   324 000014C0 66C1E008            <1> 	shl	ax, 8				; mask 3 bits
   325 000014C4 A0[02000000]        <1> 	mov	al, byte ptr [_psr+2]		; read the psr mask part
   326 000014C9 C1C803              <1> 	ror	eax, 3
   327 000014CC C0C003              <1> 	rol	al, 3
   328 000014CF A2[02000000]        <1> 	mov	byte ptr [_psr+2], al
   329 000014D4 C1E81D              <1> 	shr	eax, 32-3
   330 000014D7 E95CF1FFFF          <1> 	jmp	memoreg_writeback
   331                              <1> 
   332 000014DC 52                  <1> _call:	push	edx
   333 000014DD E890FAFFFF          <1> 	call	stack2
   334 000014E2 2B15[00000000]      <1> 	sub	edx, dword ptr [_b0p]
   335 000014E8 C1EA02              <1> 	shr	edx, 2
   336 000014EB 89549D04            <1> 	mov	dword ptr [ebp+ebx*4+1*4], edx
   337 000014EF 8B15[00000000]      <1> 	mov	edx, dword ptr [_b0_name]
   338 000014F5 89549D00            <1> 	mov	dword ptr [ebp+ebx*4], edx
   339 000014F9 5A                  <1> 	pop	edx		; in case the jump goes wrong
   340                              <1> 				; and an interrupt frame needs constructed
   341 000014FA 8B2D[00000000]      <1> 	mov	ebp, dword ptr [_register_set]
   342                              <1> 
   343 00001500 8915[00000000]      <1> _go:	mov	dword ptr [_apc], edx
   344 00001506 E82BEEFFFF          <1> 	call	_operand_read	; may be memory or register
   345                              <1> 
   346 0000150B 89C2                <1> 	mov	edx, eax	; lookaside to calculate the vector
   347 0000150D A900008000          <1> 	test	eax, 00800000h	; gate?
   348 00001512 7422                <1> 	jz	_go2_4k_frame
   349                              <1> 
   350 00001514 25FFFF7F00          <1> 	and	eax, 007FFFFFh	; read the gate constant
   351 00001519 E8C0EDFFFF          <1> 	call	_burst_read2	;
   352 0000151E 89C2                <1> 	mov	edx, eax	; page high index ++ word offset
   353 00001520 89D8                <1> 	mov	eax, ebx	; storage block base page index
   354 00001522 C1C20E              <1> 	rol	edx, 6+8
   355 00001525 89D3                <1> 	mov	ebx, edx	; instruction frame page high index
   356 00001527 83E33F              <1> 	and	ebx, 63
   357 0000152A 7405                <1> 	jz	_go_gate	; one page iframe
   358 0000152C 0D00008000          <1> 	or	eax, 00800000h	; two+ page iframe
   359                              <1> 
   360                              <1> _go_gate:
   361 00001531 C1EA0E              <1> 	shr	edx, 6+8	; net word offset
   362                              <1> 
   363 00001534 EB0D                <1> 	jmp	_go2_frame
   364                              <1> 	
   365                              <1> _go2_4k_frame:
   366 00001536 83E23F              <1> 	and	edx, 63		; target is in 4k block, 64 vectors
   367 00001539 C1E806              <1> 	shr	eax, 6		; new b0_name
   368 0000153C 25FFFF0000          <1> 	and	eax, 0000FFFFh	; bit 22 of GO / CALL word reserved
   369 00001541 31DB                <1> 	xor	ebx, ebx	; frame high page index
   370                              <1> 
   371                              <1> _go2_frame:
   372 00001543 F605[02000000]80    <1> 	test	byte ptr [_psr+2], 128	; already in interrupt code?
   373 0000154A 7520                <1> 	jnz	_go2_base_frame	; 	; may branch into interrupt code
   374                              <1> 					; because he is interrupt code
   375 0000154C 89C1                <1> 	mov	ecx, eax
   376 0000154E 81E1FFFF3F00        <1> 	and	ecx, 03FFFFFh
   377 00001554 2B0D[20010000]      <1> 	sub	ecx, dword ptr [_base+72*4]	; applications lower limit
   378 0000155A 7D10                <1> 	jnl	_go2_base_frame
   379                              <1> 
   380 0000155C 8B15[00000000]      <1> 	mov	edx, dword ptr [_apc]
   381 00001562 BE01000000          <1> 	mov	esi, LP_AUTHORITY
   382 00001567 E97FF8FFFF          <1> 	jmp	guard_ii_escape
   383                              <1> 
   384                              <1> _go2_base_frame:
   385                              <1> 
   386 0000156C A3[00000000]        <1> 	mov	dword ptr [_b0_name], eax	; with flags
   387 00001571 25FFFF3F00          <1> 	and	eax, 003FFFFFh			; base page index only
   388 00001576 01C3                <1> 	add	ebx, eax
   389 00001578 891D[00010000]      <1> 	mov	dword ptr [_base+64*4], ebx
   390                              <1> 
   391                              <1> 	%if	1
   392 0000157E 8B0D[00020000]      <1> 	mov	ecx, dword ptr [_base+128*4]	; memory page high index
   393 00001584 81E1FFFF3F00        <1> 	and	ecx, 003FFFFFh			; strip memory type bits
   394 0000158A 29D9                <1> 	sub	ecx, ebx			; iframe high page may be = not >
   395 0000158C 7910                <1> 	jns	_go2_frame_in_range
   396                              <1> 
   397 0000158E BE0E000000          <1> 	mov	esi, LP_ADDRESS
   398 00001593 8B15[00000000]      <1> 	mov	edx, dword ptr [_apc]
   399 00001599 E94DF8FFFF          <1> 	jmp	guard_ii_escape
   400                              <1> 
   401                              <1> _go2_frame_in_range:
   402                              <1> 
   403                              <1> 	%else
   404                              <1> 	mov	ecx, dword ptr [_base+128*4]	; have we the highest frame page?
   405                              <1> 	and	ecx, 003FFFFFh			; read highest page index
   406                              <1> 	mov	esi, LP_ADDRESS			; trim off flags
   407                              <1> 	sub	ecx, ebx			; compare
   408                              <1> 	xchg	edx, dword ptr [_apc]
   409                              <1> 	js	guard_ii_escape			; if negative that should catch it
   410                              <1> 	xchg	edx, dword ptr [_apc]
   411                              <1> 	%endif
   412                              <1> 
   413 0000159E C1E30C              <1> 	shl	ebx, 12
   414 000015A1 8D1C9D[FC3F0000]    <1> 	lea	ebx, [_memory+ebx*4+4095*4]	; last instruction word in iframe
   415                              <1> 						; higher = wrong
   416 000015A8 891D[00000000]      <1> 	mov	dword ptr [_apcz], ebx	; set execution limit pointer
   417                              <1> 
   418 000015AE A3[00000000]        <1> 	mov	dword ptr [_base], eax
   419 000015B3 C1E00E              <1> 	shl	eax, 12+2	; 4kword block multiplied by 4 for word
   420 000015B6 05[00000000]        <1> 	add	eax, _memory	; add the platform location of executable space
   421 000015BB A3[00000000]        <1> 	mov	dword ptr [_b0p], eax
   422 000015C0 C1E202              <1> 	shl	edx, 2		; add the vector offset * 4 for word
   423 000015C3 01C2                <1> 	add	edx, eax
   424 000015C5 C3                  <1> _go_:	ret
   425                              <1> 
    36                                  	%include	"alu.msm"
     1                              <1> 
     2                              <1> 
     3 000015C6 E86BEDFFFF          <1> _ax:	call	_operand_read
     4 000015CB 034508              <1> 	add	eax, dword ptr [ebp+X]
     5 000015CE 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
     6 000015D3 894508              <1> 	mov	dword ptr [ebp+X], eax
     7 000015D6 C3                  <1> 	ret
     8                              <1> 
     9 000015D7 E85AEDFFFF          <1> _ay:	call	_operand_read
    10 000015DC 03450C              <1> 	add	eax, dword ptr [ebp+Y]
    11 000015DF 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
    12 000015E4 89450C              <1> 	mov	dword ptr [ebp+Y], eax
    13 000015E7 C3                  <1> 	ret
    14                              <1> 
    15 000015E8 E849EDFFFF          <1> _or:	call	_operand_read
    16 000015ED 094510              <1> 	or	dword ptr [ebp+A], eax
    17 000015F0 C3                  <1> 	ret
    18                              <1> 
    19 000015F1 E840EDFFFF          <1> _orB:	call	_operand_read
    20 000015F6 094514              <1> 	or	dword ptr [ebp+B], eax
    21 000015F9 C3                  <1> 	ret
    22                              <1> 
    23 000015FA E837EDFFFF          <1> _and:	call	_operand_read
    24 000015FF 214510              <1> 	and	dword ptr [ebp+A], eax
    25 00001602 C3                  <1> 	ret
    26                              <1> 
    27 00001603 E82EEDFFFF          <1> _andB:	call	_operand_read
    28 00001608 214514              <1> 	and	dword ptr [ebp+B], eax
    29 0000160B C3                  <1> 	ret
    30                              <1> 
    31 0000160C E825EDFFFF          <1> _xor:	call	_operand_read
    32 00001611 314510              <1> 	xor	dword ptr [ebp+A], eax
    33 00001614 C3                  <1> 	ret
    34                              <1> 
    35 00001615 E81CEDFFFF          <1> _xorB:	call	_operand_read
    36 0000161A 314514              <1> 	xor	dword ptr [ebp+B], eax
    37 0000161D C3                  <1> 	ret
    38                              <1> 
    39 0000161E E813EDFFFF          <1> _aa:	call	_operand_read
    40 00001623 EB0D                <1> 	jmp	_aa_
    41 00001625 E80CEDFFFF          <1> _ana:	call	_operand_read
    42 0000162A 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
    43 0000162F 83C001              <1> 	add	eax, 1
    44 00001632 034510              <1> _aa_:	add	eax, dword ptr [ebp+A]
    45 00001635 E8B3040000          <1> 	call	_alu_carry
    46                              <1> 
    47                              <1> 	%if	0
    48                              <1> 	rol	eax, 8
    49                              <1> 	and	al, 1
    50                              <1> 	and	byte ptr [_psr], 254
    51                              <1> 	or	byte ptr [_psr], al
    52                              <1> 	shr	eax, 8
    53                              <1> 	%endif
    54                              <1> 
    55 0000163A 894510              <1> 	mov	dword ptr [ebp+A], eax
    56 0000163D C3                  <1> 	ret
    57                              <1> 
    58 0000163E E8F3ECFFFF          <1> _ab:	call	_operand_read
    59 00001643 EB0D                <1> 	jmp	_ab_
    60 00001645 E8ECECFFFF          <1> _anb:	call	_operand_read
    61 0000164A 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
    62 0000164F 83C001              <1> 	add	eax, 1
    63 00001652 034514              <1> _ab_:	add	eax, dword ptr [ebp+B]
    64 00001655 E893040000          <1> 	call	_alu_carry
    65                              <1> 
    66                              <1> 	%if	0
    67                              <1> 	rol	eax, 8
    68                              <1> 	and	al, 1
    69                              <1>         and     byte ptr [_psr], 254
    70                              <1> 	or	byte ptr [_psr], al
    71                              <1> 	shr	eax, 8
    72                              <1> 	%endif
    73                              <1> 
    74 0000165A 894514              <1> 	mov	dword ptr [ebp+B], eax
    75 0000165D C3                  <1> 	ret
    76                              <1> 
    77 0000165E 52                  <1> _m:	push	edx			; 80386 platform has it ready made, so
    78 0000165F E8D2ECFFFF          <1> 	call	_operand_read
    79 00001664 C1E008              <1> 	shl	eax, 8			; prepare multiplier to be multiplicand 
    80 00001667 C1F808              <1> 	sar	eax, 8			; sign it in eax
    81 0000166A 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]	; this is register side multiplicand but
    82                              <1> 					; it makes no difference which is which
    83 0000166D C1E308              <1> 	shl	ebx, 8			; so use it as multiplier if that is OK
    84 00001670 C1FB08              <1> 	sar	ebx, 8			; sign it first
    85                              <1> 
    86 00001673 F7EB                <1> 	imul	ebx
    87                              <1> 
    88 00001675 C1C008              <1> 	rol	eax, 8			; move 8 bits up from eax to edx
    89 00001678 C1E208              <1> 	shl	edx, 8
    90 0000167B 88C2                <1> 	mov	dl, al
    91 0000167D C1E808              <1> 	shr	eax, 8
    92 00001680 894514              <1> 	mov	dword ptr [ebp+B], eax	; product bits 23..0
    93 00001683 C1E208              <1> 	shl	edx, 8
    94 00001686 C1EA08              <1> 	shr	edx, 8
    95 00001689 895510              <1> 	mov	dword ptr [ebp+A], edx	; product high order bits
    96 0000168C 5A                  <1> 	pop	edx
    97 0000168D C3                  <1> 	ret
    98                              <1> 
    99 0000168E 52                  <1> _mf:	push	edx		; the multiplier is signed the multiplicand unsigned
   100 0000168F E8A2ECFFFF          <1> 	call	_operand_read
   101 00001694 89C1                <1> 	mov	ecx, eax	; just to remember the multiplier sign
   102 00001696 A900008000          <1> 	test	eax, 00800000h
   103 0000169B 7408                <1> 	jz	_mfplusplus
   104 0000169D 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   105 000016A2 83C001              <1> 	add	eax, 1
   106                              <1> _mfplusplus:
   107 000016A5 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]	; this is the multiplicand, unsigned
   108 000016A8 F7E3                <1> 	mul	ebx		; two 24-bit unsigned values should be OK here
   109 000016AA C1C008              <1> 	rol	eax, 8
   110 000016AD C1E208              <1> 	shl	edx, 8
   111 000016B0 88C2                <1> 	mov	dl, al
   112 000016B2 C1E808              <1> 	shr	eax, 8
   113 000016B5 C1E208              <1> 	shl	edx, 8
   114 000016B8 C1EA08              <1> 	shr	edx, 8
   115 000016BB F7C100008000        <1> 	test	ecx, 00800000h	; was the multiplier signed?
   116 000016C1 741F                <1> 	jz	_mfstore
   117 000016C3 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   118 000016C8 81F2FFFFFF00        <1> 	xor	edx, 00FFFFFFh
   119 000016CE 83C001              <1> 	add	eax, 1
   120 000016D1 C1C008              <1> 	rol	eax, 8
   121 000016D4 0FB6C8              <1> 	movzx	ecx, al
   122 000016D7 C1E808              <1> 	shr	eax, 8
   123 000016DA 01CA                <1> 	add	edx, ecx
   124 000016DC 81E2FFFFFF00        <1> 	and	edx, 00FFFFFFh
   125                              <1> _mfstore:
   126 000016E2 894514              <1> 	mov	dword ptr [ebp+B], eax
   127 000016E5 895510              <1> 	mov	dword ptr [ebp+A], edx
   128 000016E8 5A                  <1> 	pop	edx
   129 000016E9 C3                  <1> 	ret
   130                              <1> 
   131 000016EA BF04000000          <1> _d:	mov	edi, a
   132 000016EF E80A000000          <1> 	call	_divide
   133 000016F4 895D10              <1> 	mov	dword ptr [ebp+A], ebx
   134 000016F7 894518              <1> 	mov	dword ptr [ebp+MANTISSA2], eax
   135 000016FA 894D14              <1> 	mov	dword ptr [ebp+B], ecx
   136 000016FD C3                  <1> 	ret
   137                              <1> 
   138                              <1> 	%if	1
   139                              <1> 
   140                              <1> ;	this divide made from 2 Intel divides should be a better method
   141                              <1> ;	than the procession of 1-bit shifts and test subtracts
   142                              <1> ;	which is the %else which it replaces. That also works
   143                              <1> 
   144                              <1> ;	this converts to and from positive magnitude
   145                              <1> ;	because zoning the 2nd divide with a zero 1st remainder
   146                              <1> ;	can't tell +0 from -0 in platform 2s complement
   147                              <1> 
   148                              <1> ;	polarity conversions before and after need no explanation
   149                              <1> 
   150                              <1> ;	1st dividend is 48 zero bits and high order 16 data bits
   151                              <1> ;	of the the 48-bit RTA1 dividend
   152                              <1> 
   153                              <1> ;	2nd dividend is 1st remainder and the remaining 32 bits
   154                              <1> ;	the the RTA1 dividend
   155                              <1> 
   156                              <1> ;	input is compressed from 24-bit words and output unpacked
   157                              <1> ;	to 24-bit words
   158                              <1> 
   159                              <1> ;	64-bit dividend in 386 mode is high order bits in edx, low in eax
   160                              <1> ;	platform faults if quotient carries from eax. Remainder in edx
   161                              <1> 
   162                              <1> ;	RTA1 quotient is 48 bits so it takes 2 divides in 32-bit mode
   163                              <1> 
   164                              <1> _divide:
   165 000016FE 52                  <1> 	push	edx
   166 000016FF 57                  <1> 	push	edi
   167 00001700 E831ECFFFF          <1> 	call	_operand_read	; read divisor
   168 00001705 5F                  <1> 	pop	edi
   169 00001706 31C9                <1> 	xor	ecx, ecx	; final sign
   170 00001708 A900008000          <1> 	test	eax, 00800000h
   171 0000170D 7408                <1> 	jz	_dsig?
   172 0000170F 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   173 00001714 F7D1                <1> 	not	ecx		; reverse final sign
   174 00001716 40                  <1> 	inc	eax
   175 00001717 25FFFFFF00          <1> _dsig?:	and	eax, 00FFFFFFh	; check zerodiv here mebbes
   176 0000171C 89C3                <1> 	mov	ebx, eax	; eax will be used twice as divisor LS word
   177 0000171E 746D                <1> 	jz	_d_ont		; zero results in eax ebx already
   178                              <1> 
   179 00001720 8B44BD04            <1> 	mov	eax, dword ptr [ebp+edi*4+4]
   180 00001724 8B54BD00            <1> 	mov	edx, dword ptr [ebp+edi*4]
   181 00001728 C1E008              <1> 	shl	eax, 8		; pack two 24-bit words to 64 bits 
   182 0000172B 88D0                <1> 	mov	al, dl
   183 0000172D C1C808              <1> 	ror	eax, 8
   184 00001730 C1E208              <1> 	shl	edx, 8
   185 00001733 C1EA10              <1> 	shr	edx, 16
   186 00001736 6689D1              <1> 	mov	cx, dx		; save dividend sign
   187 00001739 6621D2              <1> 	and	dx, dx		; bit 47 on?
   188 0000173C 7912                <1> 	jns	_dive_in
   189                              <1> 
   190 0000173E 81F10000FFFF        <1> 	xor	ecx, 0FFFF0000h	; reverse final sign
   191 00001744 F7D0                <1> 	not	eax
   192 00001746 66F7D2              <1> 	not	dx
   193 00001749 83C001              <1> 	add	eax, 1
   194 0000174C 6683D200            <1> 	adc	dx, 0
   195                              <1> 
   196                              <1> _dive_in:
   197 00001750 89C6                <1> 	mov	esi, eax	; reserve 2nd dividend
   198 00001752 89D0                <1> 	mov	eax, edx	; position 1st dividend
   199 00001754 31D2                <1> 	xor	edx, edx	; with leading zero
   200 00001756 F7F3                <1> 	div	ebx
   201 00001758 96                  <1> 	xchg	eax, esi	; save 1st quotient
   202 00001759 F7F3                <1> 	div	ebx		; generate 2nd quotient
   203                              <1> 
   204 0000175B 6621C9              <1> 	and	cx, cx		; dividend negative?
   205 0000175E 7903                <1> 	jns	_d_remainder_plus
   206 00001760 F7D2                <1> 	not	edx
   207 00001762 42                  <1> 	inc	edx
   208                              <1> 
   209                              <1> _d_remainder_plus:
   210 00001763 81E2FFFFFF00        <1> 	and	edx, 00FFFFFFh
   211 00001769 87D1                <1> 	xchg	edx, ecx	; remainder -> ecx / final sign -> edx
   212                              <1> 
   213 0000176B 89C3                <1> 	mov	ebx, eax	; low order quotient
   214 0000176D 89F0                <1> 	mov	eax, esi	; high order quotient
   215                              <1> 
   216 0000176F 21D2                <1> 	and	edx, edx	; final sign?
   217 00001771 790C                <1> 	jns	_d_quotient_plus
   218                              <1> 
   219 00001773 F7D3                <1> 	not	ebx		; invert + increment quotient
   220 00001775 66F7D0              <1> 	not	ax		; RTA1 integer is also 2s complement
   221 00001778 83C301              <1> 	add	ebx, 1
   222 0000177B 6683D000            <1> 	adc	ax, 0
   223                              <1> 
   224                              <1> _d_quotient_plus:
   225 0000177F 0FB7C0              <1> 	movzx	eax, ax		; unpack from 32-bit words to 24-bit words
   226 00001782 C1E008              <1> 	shl	eax, 8		; move 8 bits up
   227 00001785 C1C308              <1> 	rol	ebx, 8
   228 00001788 88D8                <1> 	mov	al, bl
   229 0000178A C1EB08              <1> 	shr	ebx, 8		; quotient in eax:ebx
   230                              <1> 
   231 0000178D 5A                  <1> _d_ont:	pop	edx		; give back the emulated program counter
   232 0000178E C3                  <1> 	ret
   233                              <1> 
   234                              <1> 	%else
   235                              <1> 
   236                              <1> _divide:
   237                              <1> 	xor	ebx, ebx
   238                              <1> 	push	ebx		;
   239                              <1> 	push	ebx		; quotient
   240                              <1> 	push	ebx		; dividend[b]
   241                              <1> 	push	ebx		; dividend[a]
   242                              <1> 	push	ebx		; trailing divisor
   243                              <1> 	push	ebx		; divisor
   244                              <1> 	push	ebx		; signs2 
   245                              <1> 	push	ebx		; signs1
   246                              <1> 	mov	ebx, 24
   247                              <1> 	push	ebx		; beats
   248                              <1> 
   249                              <1> 
   250                              <1> _D_BEATS	equ	0
   251                              <1> _D_SIGNS1	equ	1*4
   252                              <1> _D_SIGNS2	equ	2*4
   253                              <1> _D_DIVISORU	equ	3*4
   254                              <1> _D_DIVISORL	equ	4*4
   255                              <1> _D_DIVIDENDU	equ	5*4
   256                              <1> _D_DIVIDENDL	equ	6*4
   257                              <1> _D_QUOTIENTU	equ	7*4
   258                              <1> _D_QUOTIENTL	equ	8*4
   259                              <1> 
   260                              <1> 	push	edi
   261                              <1> 	call	_operand_read
   262                              <1> 	pop	edi
   263                              <1> 
   264                              <1> 	test	eax, 00800000h
   265                              <1> 	jnz	_d_nmagnitude1			; must be stored negative
   266                              <1> 	xor	eax, 00FFFFFFh
   267                              <1> 	jmp	_d_nmagnitude2
   268                              <1> _d_nmagnitude1:
   269                              <1> 	add	eax, -1				; if it's already negative
   270                              <1> 	mov	dword ptr [esp+_D_SIGNS2], 0FFFFFFFFh
   271                              <1> _d_nmagnitude2:
   272                              <1> 	call	qscale
   273                              <1> 	cmp	bl, 24
   274                              <1> 	jz	_d_allsigns
   275                              <1> 	add	dword ptr [esp+_D_BEATS], ebx
   276                              <1> _d_allsigns:
   277                              <1> 	mov	ebx, 00FFFFFF00h ; make the divisor 48 bits contiguous	
   278                              <1> 	mov	bl, al
   279                              <1> 	ror	ebx, 8
   280                              <1> 	shl	eax, 8
   281                              <1> 	mov	ax, 65535
   282                              <1> 	ror	eax, 16
   283                              <1> 
   284                              <1> 	mov	dword ptr [esp+_D_DIVISORL], ebx
   285                              <1> 	mov	dword ptr [esp+_D_DIVISORU], eax
   286                              <1> 
   287                              <1> 	mov	ecx, 1				; precarry
   288                              <1> 
   289                              <1> ;	mov	ebx, dword ptr [ebp+B]	; dividend
   290                              <1> ;	mov	eax, dword ptr [ebp+A]
   291                              <1> 
   292                              <1> 	mov	ebx, dword ptr [ebp+edi*4+4]
   293                              <1> 	mov	eax, dword ptr [ebp+edi*4] 
   294                              <1> 
   295                              <1> 	test	eax, 00800000h
   296                              <1> 	jz	_d_pmagnitude			; must be stored positive
   297                              <1> 	mov	dword ptr [esp+_D_SIGNS1], 00FFFFFFFFh
   298                              <1> 	xor	ebx, 00FFFFFFh
   299                              <1> 	xor	eax, 00FFFFFFh
   300                              <1> 	add	ecx, ebx
   301                              <1> 	mov	ebx, ecx
   302                              <1> 	and	ebx, 00FFFFFFh
   303                              <1> 	shr	ecx, 24
   304                              <1> 	add	eax, ecx
   305                              <1> 	and	eax, 00FFFFFFh
   306                              <1> 
   307                              <1> _d_pmagnitude:
   308                              <1> 	shl	ebx, 8
   309                              <1> 	mov	bl, al
   310                              <1> 	ror	ebx, 8
   311                              <1> 	shl	eax, 8
   312                              <1> 	shr	eax, 16
   313                              <1> 	mov	dword ptr [esp+_D_DIVIDENDL], ebx
   314                              <1> 	mov	dword ptr [esp+_D_DIVIDENDU], eax
   315                              <1> 
   316                              <1> 	mov	ecx, dword ptr [esp+_D_BEATS]
   317                              <1> 
   318                              <1> 	add	ecx, -1
   319                              <1> _d_beat:			; iterative part as quick as possible
   320                              <1> 				; could study doing a pair of Intel divides here
   321                              <1> 	stc
   322                              <1> 	rcr	dword ptr [esp+_D_DIVISORU], 1
   323                              <1> 	rcr	dword ptr [esp+_D_DIVISORL], 1
   324                              <1> 
   325                              <1> 	stc
   326                              <1> 	adc	ebx, dword ptr [esp+_D_DIVISORL]
   327                              <1> 	adc	eax, dword ptr [esp+_D_DIVISORU]
   328                              <1> 
   329                              <1> 	jc	_d_carried
   330                              <1> 	mov	ebx, dword ptr [esp+_D_DIVIDENDL]
   331                              <1> 	mov	eax, dword ptr [esp+_D_DIVIDENDU]
   332                              <1> 	jmp	_d_carried_or_not
   333                              <1> 
   334                              <1> _d_carried:
   335                              <1> 	mov	dword ptr [esp+_D_DIVIDENDL], ebx
   336                              <1> 	mov	dword ptr [esp+_D_DIVIDENDU], eax
   337                              <1> 
   338                              <1> _d_carried_or_not:
   339                              <1> 	rcl	dword ptr [esp+_D_QUOTIENTL], 1
   340                              <1> 	rcl	dword ptr [esp+_D_QUOTIENTU], 1
   341                              <1> 	
   342                              <1> 	add	ecx, -1
   343                              <1> 	jc	_d_beat
   344                              <1> 
   345                              <1> 	pop	ecx		; BEATS
   346                              <1> 	pop	ecx		; SIGNS1
   347                              <1> 	pop	eax		; SIGNS2
   348                              <1> 	pop	ebx		; DIVISORU
   349                              <1> 	pop	ebx		; DIVISORL
   350                              <1> 	pop	ebx		; DIVIDENDU
   351                              <1> 	pop	ebx		; DIVIDENDL
   352                              <1> 
   353                              <1> 	xor	ebx, ecx	; set remainder to sign of dividend
   354                              <1> 	jns	_d_remplus
   355                              <1> 	inc	ebx		; set -remainder 2s complement
   356                              <1> 
   357                              <1> _d_remplus:
   358                              <1> 	and	ebx, 00FFFFFFh	; store remainder
   359                              <1> ;	mov	dword ptr [ebp+B], ebx
   360                              <1> 
   361                              <1> 	xor	ecx, eax	; set sign of quotient to difference of signs
   362                              <1> 	mov	ecx, ebx	; remainder for return
   363                              <1> 	pop	eax		; QUOTIENTU
   364                              <1> 	pop	ebx		; QUOTIENTL
   365                              <1> 
   366                              <1> 	jns	_d_quotient_plus		; cc set from xor of signy
   367                              <1> 
   368                              <1> 	not	eax
   369                              <1> 	not	ebx
   370                              <1> 	add	ebx, 1
   371                              <1> 	adc	eax, 0
   372                              <1> 
   373                              <1> _d_quotient_plus:
   374                              <1> 	shl	eax, 8
   375                              <1> 	rol	ebx, 8
   376                              <1> 	mov	al, bl
   377                              <1> 	shr	ebx, 8
   378                              <1> 	shl	eax, 8
   379                              <1> 	shr	eax, 8
   380                              <1> 
   381                              <1> ;	mov	dword ptr [ebp+A], ebx
   382                              <1> ;	mov	dword ptr [ebp+MANTISSA2], eax
   383                              <1> 	ret
   384                              <1> 
   385                              <1> 	%endif
   386                              <1> 
   387                              <1> 
   388 0000178F 88C1                <1> _sar:	mov	cl, al			; eax shift radix is 31
   389 00001791 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
   390 00001794 F6C1E0              <1> 	test	cl, -32
   391 00001797 7402                <1> 	jz	_sardo
   392 00001799 31C0                <1> 	xor	eax, eax		; shift 32+ clears same as 24+
   393 0000179B D3E8                <1> _sardo:	shr	eax, cl
   394 0000179D 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   395 000017A2 894510              <1> 	mov	dword ptr [ebp+A], eax
   396 000017A5 C3                  <1> 	ret
   397                              <1> 
   398 000017A6 88C1                <1> _sbr:	mov	cl, al
   399 000017A8 8B4514              <1> 	mov	eax, dword ptr [ebp+B]
   400 000017AB F6C1E0              <1> 	test	cl, -32
   401 000017AE 7402                <1> 	jz	_sbrdo
   402 000017B0 31C0                <1> 	xor	eax, eax		; shift 32+ clears same as 24+
   403 000017B2 D3E8                <1> _sbrdo:	shr	eax, cl
   404 000017B4 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   405 000017B9 894514              <1> 	mov	dword ptr [ebp+B], eax
   406 000017BC C3                  <1> 	ret
   407                              <1> 
   408                              <1> 
   409 000017BD 88C1                <1> _dsr:	mov	cl, al
   410 000017BF 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]
   411 000017C2 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
   412 000017C5 E875000000          <1> 	call	dsr
   413 000017CA 895D14              <1> 	mov	dword ptr [ebp+B], ebx
   414 000017CD 894510              <1> 	mov	dword ptr [ebp+A], eax
   415 000017D0 C3                  <1> 	ret
   416                              <1> 
   417 000017D1 88C1                <1> _sal:	mov	cl, al			; shift radix eax is 31
   418 000017D3 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
   419 000017D6 F6C1E0              <1> 	test	cl, -32
   420 000017D9 7402                <1> 	jz	_saldo
   421 000017DB 31C0                <1> 	xor	eax, eax		; shift 32+ clears same as 24+
   422 000017DD D3E0                <1> _saldo:	shl	eax, cl
   423 000017DF 25FFFFFF00          <1> 	and	eax, 00FFFFFFh		; write back to registers only 00000000 thru 00FFFFFF
   424 000017E4 894510              <1> 	mov	dword ptr [ebp+A], eax
   425 000017E7 C3                  <1> 	ret
   426                              <1> 
   427 000017E8 88C1                <1> _sbl:	mov	cl, al
   428 000017EA 8B4514              <1> 	mov	eax, dword ptr [ebp+B]
   429 000017ED F6C1E0              <1> 	test	cl,-32
   430 000017F0 7402                <1> 	jz	_sbldo
   431 000017F2 31C0                <1> 	xor	eax, eax		; shift 32+ clears same as 24+
   432 000017F4 D3E0                <1> _sbldo:	shl	eax, cl
   433 000017F6 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   434 000017FB 894514              <1> 	mov	dword ptr [ebp+B], eax
   435 000017FE C3                  <1> 	ret
   436                              <1> 
   437 000017FF 88C1                <1> _dsl	mov	cl, al
   438 00001801 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]
   439 00001804 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
   440 00001807 E868000000          <1> 	call	dsl
   441 0000180C 895D14              <1> 	mov	dword ptr [ebp+B], ebx
   442 0000180F 894510              <1> 	mov	dword ptr [ebp+A], eax
   443 00001812 C3                  <1> 	ret
   444                              <1> 
   445 00001813 8B5D10              <1> _rar:	mov	ebx, dword ptr [ebp+A]
   446 00001816 E8C6000000          <1> 	call	rr
   447 0000181B 895D10              <1> 	mov	dword ptr [ebp+A], ebx
   448 0000181E C3                  <1> 	ret
   449                              <1> 
   450 0000181F 8B5D14              <1> _rbr:	mov	ebx, dword ptr [ebp+B]
   451 00001822 E8BA000000          <1> 	call	rr
   452 00001827 895D14              <1> 	mov	dword ptr [ebp+B], ebx
   453 0000182A C3                  <1> 	ret
   454                              <1> 
   455 0000182B 88C1                <1> _drr:	mov	cl, al
   456 0000182D 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]
   457 00001830 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
   458 00001833 E8F7000000          <1> 	call	drr
   459 00001838 895D14              <1> 	mov	dword ptr [ebp+B], ebx
   460 0000183B 894510              <1> 	mov	dword ptr [ebp+A], eax
   461 0000183E C3                  <1> 	ret
   462                              <1> 
   463                              <1> 
   464 0000183F C1E008              <1> dsr:	shl	eax, 8
   465 00001842 C1E308              <1> 	shl	ebx, 8
   466 00001845 80C1E8              <1> dsru:	add	cl, -24
   467 00001848 7306                <1> 	jnc	dsrl
   468 0000184A 89C3                <1> 	mov	ebx, eax
   469 0000184C 31C0                <1> 	xor	eax, eax
   470 0000184E EBF5                <1> 	jmp	dsru
   471 00001850 80C110              <1> dsrl:	add	cl, 16
   472 00001853 730D                <1> 	jnc	dsr7
   473 00001855 C1E808              <1> dsr8:	shr	eax, 8
   474 00001858 88C3                <1> 	mov	bl, al
   475 0000185A C1CB08              <1> 	ror	ebx, 8
   476 0000185D 80C1F8              <1> 	add	cl,-8
   477 00001860 72F3                <1> 	jc	dsr8
   478 00001862 80E107              <1> dsr7:	and	cl, 7
   479 00001865 D3E8                <1> 	shr	eax, cl
   480 00001867 88C3                <1> 	mov	bl, al		; bits from al in high-order positions bl
   481 00001869 D2C3                <1> 	rol	bl, cl		; roll them to low-order positions
   482 0000186B D3CB                <1> 	ror	ebx, cl
   483 0000186D C1EB08              <1> 	shr	ebx, 8
   484 00001870 C1E808              <1> 	shr	eax, 8
   485 00001873 C3                  <1> 	ret
   486                              <1> 
   487 00001874 C1E008              <1> dsl:	shl	eax, 8
   488 00001877 C1E308              <1> 	shl	ebx, 8
   489 0000187A 80C1E8              <1> dslu:	add	cl, -24
   490 0000187D 7306                <1> 	jnc	dsll
   491 0000187F 89D8                <1> 	mov	eax, ebx
   492 00001881 31DB                <1> 	xor	ebx, ebx
   493 00001883 EBF5                <1> 	jmp	dslu
   494 00001885 80C110              <1> dsll:	add	cl, 16
   495 00001888 730F                <1> 	jnc	dsl7
   496 0000188A C1C308              <1> dsl8:	rol	ebx, 8
   497 0000188D 88D8                <1> 	mov	al, bl
   498 0000188F 30DB                <1> 	xor	bl, bl
   499 00001891 C1E008              <1> 	shl	eax, 8
   500 00001894 80C1F8              <1> 	add	cl, -8
   501 00001897 72F1                <1> 	jc	dsl8
   502 00001899 80E107              <1> dsl7:	and	cl, 7
   503 0000189C D3C3                <1> 	rol	ebx, cl
   504 0000189E 88D8                <1> 	mov	al, bl		; bits from bl in low-order positions al
   505 000018A0 D2C8                <1> 	ror	al, cl		; roll them to high-order positions
   506 000018A2 D3E0                <1> 	shl	eax, cl
   507 000018A4 C1EB08              <1> 	shr	ebx, 8
   508 000018A7 C1E808              <1> 	shr	eax, 8
   509 000018AA C3                  <1> 	ret
   510                              <1> 
   511 000018AB C1E008              <1> dsa:	shl	eax, 8
   512 000018AE C1E308              <1> 	shl	ebx, 8
   513 000018B1 80C1E8              <1> dsa24:	add	cl, -24
   514 000018B4 7307                <1> 	jnc	dsa16
   515 000018B6 89C3                <1> 	mov	ebx, eax
   516 000018B8 C1F818              <1> 	sar	eax, 24
   517 000018BB EBF4                <1> 	jmp	dsa24
   518 000018BD 80C110              <1> dsa16:	add	cl, 16
   519 000018C0 730D                <1> 	jnc	dsa7
   520 000018C2 C1F808              <1> dsa8:	sar	eax, 8
   521 000018C5 88C3                <1> 	mov	bl, al
   522 000018C7 C1CB08              <1> 	ror	ebx, 8
   523 000018CA 80C1F8              <1> 	add	cl, -8
   524 000018CD 72F3                <1> 	jc	dsa8
   525 000018CF 80E107              <1> dsa7:	and	cl, 7
   526 000018D2 D3F8                <1> 	sar	eax, cl
   527 000018D4 88C3                <1> 	mov	bl, al		; bits from al in high-order positions bl
   528 000018D6 D2C3                <1> 	rol	bl, cl		; roll them to low-order positions
   529 000018D8 D3CB                <1> 	ror	ebx, cl
   530 000018DA C1E808              <1> 	shr	eax, 8
   531 000018DD C1EB08              <1> 	shr	ebx, 8
   532 000018E0 C3                  <1> 	ret	
   533                              <1> 
   534                              <1> 
   535 000018E1 88C1                <1> rr:	mov	cl, al
   536 000018E3 C1E308              <1> 	shl	ebx, 8
   537 000018E6 F6C118              <1> 	test	cl, 24		; bits 16:8 are self-cancelling
   538 000018E9 7A11                <1> 	jpe	rr7
   539 000018EB F6C110              <1> 	test	cl, 16
   540 000018EE 7407                <1> 	jz	rr8		; 16 is off so 8 is on
   541 000018F0 C1C308              <1> 	rol	ebx, 8		; 8 left in 24-bit ring = 16 right
   542 000018F3 88DF                <1> 	mov	bh, bl		; compress 32-bit ring to 24-bit
   543 000018F5 EB05                <1> 	jmp	short rr7
   544 000018F7 88FB                <1> rr8:	mov	bl, bh		; extend 24-bit ring to 32-bit
   545 000018F9 C1CB08              <1> 	ror	ebx, 8
   546 000018FC 80E107              <1> rr7:	and	cl, 7		; isolate remaining count bits
   547 000018FF 88FB                <1> 	mov	bl, bh		; don't ask, just do it
   548 00001901 D3CB                <1> 	ror	ebx, cl
   549 00001903 C1EB08              <1> 	shr	ebx, 8
   550 00001906 C3                  <1> 	ret
   551                              <1> 
   552 00001907 88C1                <1> rl:	mov	cl, al
   553 00001909 C1E308              <1> 	shl	ebx, 8
   554 0000190C F6C118              <1> 	test	cl, 24		; bits 16:8 are self-cancelling
   555 0000190F 7A11                <1> 	jpe	rl7
   556 00001911 F6C110              <1> 	test	cl, 16
   557 00001914 7407                <1> 	jz	rl8		; 16 is off so 8 is on
   558 00001916 88FB                <1> 	mov	bl, bh		; extend 24-bit ring to 32-bit
   559 00001918 C1CB08              <1> 	ror	ebx, 8		; 8 right in 24-bit ring = 16 left
   560 0000191B EB05                <1> 	jmp	short rl7
   561 0000191D C1C308              <1> rl8:	rol	ebx, 8
   562 00001920 88DF                <1> 	mov	bh, bl		; compress 32-bit ring to 24-bit	
   563 00001922 80E107              <1> rl7:	and	cl, 7
   564 00001925 30DB                <1> 	xor	bl, bl
   565 00001927 D3C3                <1> 	rol	ebx, cl
   566 00001929 08DF                <1> 	or	bh, bl
   567 0000192B C1EB08              <1> 	shr	ebx, 8
   568 0000192E C3                  <1> 	ret
   569                              <1> 
   570 0000192F C1E008              <1> drr:	shl	eax, 8
   571 00001932 C1E308              <1> 	shl	ebx, 8
   572                              <1> 
   573 00001935 F6C130              <1> 	test	cl, 48		; bits 32:16 are self-cancelling
   574 00001938 7B07                <1> 	jpo	drr24		; rotate 48 = zero or 56 = 8 positions
   575 0000193A F6C108              <1> 	test	cl, 8		; parity = pe dans le pays d'Intel
   576 0000193D 741C                <1> 	jz	drr7
   577 0000193F EB15                <1> 	jmp	drr_cdrr8
   578                              <1> 
   579 00001941 93                  <1> drr24:	xchg	eax, ebx	; rotate 24 right or left as you wish
   580 00001942 F6C118              <1> 	test	cl, 24
   581 00001945 7A0D                <1> 	jpe	drr24_32	; pattern is 100xxx or 011xxx
   582 00001947 F6C108              <1> 	test	cl, 8		; pattern is 010xxx or 101xxx
   583 0000194A 7401                <1> 	jz	drrl8		; pattern is 010
   584 0000194C 93                  <1> 	xchg	eax, ebx	; swap back, pattern 101 = 40 right = 8 left 
   585 0000194D E828000000          <1> drrl8:	call	near drl8	; pattern is 010
   586 00001952 EB07                <1> 	jmp	short drr7 	; already rotated 24 right, now 8 left
   587                              <1> 
   588                              <1> drr24_32:
   589 00001954 7505                <1> 	jnz	drr7		; pattern is 011 = rotate 24. We did
   590                              <1> drr_cdrr8:
   591 00001956 E814000000          <1> 	call	near drr8	; pattern is 100 = rotate 32
   592 0000195B 80E107              <1> drr7:	and	cl, 7
   593 0000195E 7408                <1> 	jz	drrx
   594 00001960 88E3                <1> 	mov	bl, ah		; rotate low bits ebx 31:8 to eax high positions
   595 00001962 88F8                <1> 	mov	al, bh		; rotate low bits eax 31:8 to ebx high positions
   596 00001964 D3C8                <1> 	ror	eax, cl		; bits from bh in low order positions al
   597 00001966 D3CB                <1> 	ror	ebx, cl		; bits from ah in low order positions bl
   598 00001968 C1E808              <1> drrx:	shr	eax, 8
   599 0000196B C1EB08              <1> 	shr	ebx, 8
   600 0000196E C3                  <1> 	ret
   601                              <1> 
   602 0000196F 88E3                <1> drr8:   mov     bl, ah          ; cross 8 bits from one 32-bit ring to another
   603 00001971 88F8                <1>         mov     al, bh		
   604 00001973 C1C808              <1>         ror     eax, 8
   605 00001976 C1CB08              <1>         ror     ebx, 8
   606 00001979 C3                  <1>         ret
   607                              <1> 
   608 0000197A C1C008              <1> drl8:   rol     eax, 8
   609 0000197D C1C308              <1>         rol     ebx, 8
   610 00001980 88DC                <1>         mov     ah, bl          ; cross 8 bits from one 32-bit ring to another
   611 00001982 88C7                <1>         mov     bh, al
   612 00001984 C3                  <1>         ret
   613                              <1> 
   614 00001985 C1E008              <1> drl:	shl	eax, 8
   615 00001988 C1E308              <1> 	shl	ebx, 8
   616 0000198B F6C130              <1> 	test	cl, 48		; values 32:16 cancel each other
   617 0000198E 7B07                <1> 	jpo	drl24
   618 00001990 F6C108              <1> 	test	cl, 8
   619 00001993 741C                <1> 	jz	drl7
   620 00001995 EB15                <1> 	jmp	short drl_cdrl8
   621                              <1> 
   622 00001997 93                  <1> drl24:	xchg	eax, ebx
   623 00001998 F6C118              <1> 	test	cl, 24
   624 0000199B 7A0D                <1> 	jpe	drl24_32	; pattern is 011xxx or 100xxx
   625 0000199D F6C108              <1> 	test	cl, 8		; pattern is 010xxx or 101xxx
   626 000019A0 7401                <1> 	jz	drlr8		; pattern is 010 = 16 left = 8 right
   627 000019A2 93                  <1> 	xchg	eax, ebx	; swap back, pattern = 101 = 40 left = 8 right
   628 000019A3 E8C7FFFFFF          <1> drlr8:	call	drr8
   629 000019A8 EB07                <1> 	jmp	short drl7
   630                              <1> 
   631                              <1> drl24_32:
   632 000019AA 7505                <1> 	jnz	drl7		; pattern is 011 = rotate24. We did
   633                              <1> drl_cdrl8:			; pattern = 100xxx or 001xxx, rotate 8 more
   634 000019AC E8C9FFFFFF          <1> 	call	drl8
   635 000019B1 80E107              <1> drl7:	and	cl, 7		; rotate positions 0..7
   636 000019B4 30C0                <1> 	xor	al, al
   637 000019B6 30DB                <1> 	xor	bl, bl
   638 000019B8 D3C0                <1> 	rol	eax, cl
   639 000019BA D3C3                <1> 	rol	ebx, cl
   640 000019BC 08DC                <1> 	or	ah, bl
   641 000019BE 08C7                <1> 	or	bh, al
   642 000019C0 C1E808              <1> 	shr	eax, 8
   643 000019C3 C1EB08              <1> 	shr	ebx, 8
   644 000019C6 C3                  <1> 	ret
   645                              <1> 
   646 000019C7 8B5D10              <1> _ral:	mov	ebx, dword ptr [ebp+A]
   647 000019CA E838FFFFFF          <1> 	call	rl
   648 000019CF 895D10              <1> 	mov	dword ptr [ebp+A], ebx
   649 000019D2 C3                  <1> 	ret
   650                              <1> 
   651 000019D3 8B5D14              <1> _rbl:	mov	ebx, dword ptr [ebp+B]
   652 000019D6 E82CFFFFFF          <1> 	call	rl
   653 000019DB 895D14              <1> 	mov	dword ptr [ebp+B], ebx
   654 000019DE C3                  <1> 	ret	
   655                              <1> 
   656 000019DF 88C1                <1> _drl:	mov	cl, al
   657 000019E1 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
   658 000019E4 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]
   659 000019E7 E899FFFFFF          <1> 	call	drl
   660 000019EC 895D14              <1> 	mov	dword ptr [ebp+B], ebx
   661 000019EF 894510              <1> 	mov	dword ptr [ebp+A], eax
   662 000019F2 C3                  <1> 	ret
   663                              <1> 
   664 000019F3 88C1                <1> _saa:	mov	cl, al
   665 000019F5 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
   666 000019F8 C1E008              <1> 	shl	eax, 8
   667 000019FB D3F8                <1> 	sar	eax, cl
   668 000019FD C1E808              <1> 	shr	eax, 8
   669 00001A00 894510              <1> 	mov	dword ptr [ebp+A], eax
   670 00001A03 C3                  <1> 	ret
   671                              <1> 
   672 00001A04 88C1                <1> _sba:	mov	cl, al
   673 00001A06 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]
   674 00001A09 C1E308              <1> 	shl	ebx, 8
   675 00001A0C D3FB                <1> 	sar	ebx, cl
   676 00001A0E C1EB08              <1> 	shr	ebx, 8
   677 00001A11 895D14              <1> 	mov	dword ptr [ebp+B], ebx
   678 00001A14 C3                  <1> 	ret
   679                              <1> 
   680 00001A15 88C1                <1> _dsa:	mov	cl, al
   681 00001A17 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]
   682 00001A1A 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
   683 00001A1D E889FEFFFF          <1> 	call	dsa
   684 00001A22 895D14              <1> 	mov	dword ptr [ebp+B], ebx
   685 00001A25 894510              <1> 	mov	dword ptr [ebp+A], eax
   686 00001A28 C3                  <1> 	ret
   687                              <1> 
   688 00001A29 E831ECFFFF          <1> _n:	call	memoreg
   689 00001A2E 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   690 00001A33 E900ECFFFF          <1> 	jmp	memoreg_writeback
   691                              <1> 
   692 00001A38 E822ECFFFF          <1> _inc:	call	memoreg
   693 00001A3D 40                  <1> 	inc	eax
   694 00001A3E E9F5EBFFFF          <1> 	jmp	memoreg_writeback
   695                              <1> 
   696 00001A43 E817ECFFFF          <1> _dec:	call	memoreg
   697 00001A48 48                  <1> 	dec	eax
   698 00001A49 E9EAEBFFFF          <1> 	jmp	memoreg_writeback
   699                              <1> 
   700 00001A4E E80CECFFFF          <1> _src:	call	memoreg
   701 00001A53 C1E008              <1> 	shl	eax, 8
   702 00001A56 A0[00000000]        <1> 	mov	al, byte ptr [_psr]
   703 00001A5B D1C8                <1> 	ror	eax, 1
   704 00001A5D D0C0                <1> 	rol	al, 1
   705 00001A5F A2[00000000]        <1> 	mov	byte ptr [_psr], al
   706 00001A64 C1E808              <1> 	shr	eax, 8
   707 00001A67 E9CCEBFFFF          <1> 	jmp	memoreg_writeback
   708                              <1> 
   709 00001A6C E8EEEBFFFF          <1> _slc:	call	memoreg
   710 00001A71 C1E008              <1> 	shl	eax, 8
   711 00001A74 A0[00000000]        <1> 	mov	al, byte ptr [_psr]
   712 00001A79 D0C8                <1> 	ror	al, 1
   713 00001A7B D1C0                <1> 	rol	eax, 1
   714 00001A7D A2[00000000]        <1> 	mov	byte ptr [_psr], al
   715 00001A82 C1E808              <1> 	shr	eax, 8
   716 00001A85 E9AEEBFFFF          <1> 	jmp	memoreg_writeback
   717                              <1> 
   718 00001A8A 50                  <1> _popA:	push	eax			; EA
   719 00001A8B E8CFEBFFFF          <1> 	call	memoreg			; register or system memory, no peripheral bus
   720 00001A90 E802F6FFFF          <1> 	call	stack_read1
   721 00001A95 03449D00            <1> 	add	eax, dword ptr [ebp+ebx*4]
   722 00001A99 8B2D[00000000]      <1> 	mov	ebp, dword ptr [_register_set]
   723 00001A9F C1E007              <1> 	shl	eax, 7
   724 00001AA2 D1C0                <1> 	rol	eax, 1
   725 00001AA4 8025[00000000]FE    <1> 	and	byte ptr [_psr], 254
   726 00001AAB 0805[00000000]      <1> 	or	byte ptr [_psr], al
   727 00001AB1 C1E808              <1> 	shr	eax, 8
   728                              <1> ;	mov	ebx, eax
   729 00001AB4 5B                  <1> 	pop	ebx			; EA
   730 00001AB5 E97EEBFFFF          <1> 	jmp	memoreg_writeback
   731                              <1> 	
   732 00001ABA E81FE8FFFF          <1> _da:	call	_burst_read2
   733 00001ABF EB11                <1> 	jmp	_da_
   734                              <1> 
   735 00001AC1 E818E8FFFF          <1> _dan:	call	_burst_read2
   736 00001AC6 81F3FFFFFF00        <1> 	xor	ebx, 00FFFFFFh
   737 00001ACC 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   738 00001AD1 43                  <1> 	inc	ebx			; carry from bit 23 
   739                              <1> 					; remains in bit 24 for now
   740                              <1> 	%if	0
   741                              <1> 
   742                              <1> _da_:	add	ebx, dword ptr [ebp+B]
   743                              <1> 	mov	dword ptr [ebp+B], ebx
   744                              <1> 	and	dword ptr [ebp+B], 00FFFFFFh
   745                              <1> 	shr	ebx, 24			; zone carry value from bit 23
   746                              <1> 	add	eax, ebx
   747                              <1> 	add	eax, dword ptr [ebp+A]
   748                              <1> 	mov	dword ptr [ebp+A], eax
   749                              <1> 	and	dword ptr [ebp+A], 00FFFFFFh
   750                              <1> 	shr	eax, 24
   751                              <1> 	mov	ebx, dword ptr [_psr]
   752                              <1> 	and	bl, 254
   753                              <1> 	or	bl, al
   754                              <1> 	mov	dword ptr [_psr], ebx
   755                              <1> 	ret
   756                              <1> 
   757                              <1> 	%else
   758                              <1> 
   759 00001AD2 035D14              <1> _da_:	add	ebx, [ebp+B]
   760 00001AD5 C1E308              <1> 	shl	ebx, 8
   761 00001AD8 83D000              <1> 	adc	eax, 0
   762 00001ADB C1EB08              <1> 	shr	ebx, 8
   763 00001ADE 895D14              <1> 	mov	[ebp+B], ebx
   764 00001AE1 034510              <1> 	add	eax, [ebp+A]
   765 00001AE4 E804000000          <1> 	call	_alu_carry
   766 00001AE9 894510              <1> 	mov	[ebp+A], eax
   767 00001AEC C3                  <1> 	ret
   768                              <1> 
   769                              <1> _alu_carry:
   770 00001AED C1C008              <1> 	rol	eax, 8
   771 00001AF0 2401                <1> 	and	al, 1
   772 00001AF2 8025[00000000]FE    <1> 	and	byte ptr [_psr], 254
   773 00001AF9 0805[00000000]      <1> 	or	byte ptr [_psr], al
   774 00001AFF C1E808              <1> 	shr	eax, 8
   775 00001B02 C3                  <1> 	ret
   776                              <1> 
   777                              <1> 	%endif
   778                              <1> 
   779 00001B03 040302020101010100- <1> scalex	db	4,3,2,2, 1,1,1,1, 0,0,0,0, 0,0,0,0
   779 00001B0C 00000000000000      <1>
   780                              <1> 
   781                              <1> field_scale:			; examine 24-bit integer in 8-position steps
   782 00001B13 C1C008              <1> 	rol	eax, 8		; until high-order 8 bits are not all signs
   783 00001B16 88C4                <1> 	mov	ah, al
   784 00001B18 30E8                <1> 	xor	al, ch
   785 00001B1A 7509                <1> 	jnz	not8signs
   786 00001B1C 80C108              <1> 	add	cl, 8
   787 00001B1F 80F918              <1> 	cmp	cl, 24
   788 00001B22 72EF                <1> 	jb	field_scale
   789 00001B24 C3                  <1> 	ret			; 24 signs = the RTA1 computer word
   790                              <1> not8signs:			; al = 0 indicates it
   791 00001B25 A8F0                <1> 	test	al, 240		; move back some positions but keep counting up
   792 00001B27 7506                <1> 	jnz	scale_u
   793 00001B29 80C104              <1> 	add	cl, 4
   794 00001B2C C0C004              <1> 	rol	al, 4
   795                              <1> scale_u:
   796 00001B2F C0E804              <1> 	shr	al, 4
   797 00001B32 0FB6F0              <1> 	movzx	esi, al		; add to count-up 1..7
   798 00001B35 2E028E[031B0000]    <1> 	add	cl, [cs:esi+scalex]
   799 00001B3C 6651                <1> 	push	cx		; roll back 7..1 positions
   800 00001B3E 80E107              <1> 	and	cl, 7
   801 00001B41 80F107              <1> 	xor	cl, 7
   802 00001B44 80C101              <1> 	add	cl, 1
   803 00001B47 88E0                <1> 	mov	al, ah
   804 00001B49 D3C8                <1> 	ror	eax, cl
   805 00001B4B 6659                <1> 	pop	cx
   806 00001B4D C3                  <1> 	ret
   807                              <1> 
   808 00001B4E C1E008              <1> qscale:	shl	eax, 8		; 1.2.3
   809 00001B51 C1F808              <1> 	sar	eax, 8		; s.1.2.3
   810 00001B54 C1C008              <1> 	rol	eax, 8		; 1.2.3.s
   811 00001B57 6631C9              <1> 	xor	cx, cx
   812 00001B5A 88C5                <1> 	mov	ch, al		; keep 8 sign bits
   813 00001B5C E8B2FFFFFF          <1> 	call	field_scale
   814                              <1> ;	call	scale8
   815                              <1> ;	mov	al, ah		; reverse 8 rotate positions
   816                              <1> ;	ror	eax, 8
   817 00001B61 0FB6D9              <1> 	movzx	ebx, cl
   818                              <1> ;	and	cl, 7		; last part rotate
   819                              <1> ;	xor	al, al
   820                              <1> ;	rol	eax, cl
   821                              <1> ;	or	ah, al
   822 00001B64 C1E808              <1> 	shr	eax, 8
   823 00001B67 C3                  <1> 	ret
   824                              <1> 
   825 00001B68 E8C9E7FFFF          <1> _lsc:	call	_operand_read
   826 00001B6D E8DCFFFFFF          <1> 	call	qscale
   827 00001B72 895D14              <1> 	mov	dword ptr [ebp+B], ebx	; store the scale
   828 00001B75 894510              <1> 	mov	dword ptr [ebp+A], eax	; store the rotated value
   829 00001B78 C3                  <1> 	ret
   830                              <1> 
   831 00001B79 E860E7FFFF          <1> _dlsc:	call	_burst_read2
   832 00001B7E 894510              <1> 	mov	dword ptr [ebp+A], eax		; keep original 1st word
   833 00001B81 C1E008              <1> 	shl	eax, 8
   834 00001B84 C1F808              <1> 	sar	eax, 8
   835 00001B87 C1C008              <1> 	rol	eax, 8
   836 00001B8A 6631C9              <1> 	xor	cx, cx
   837 00001B8D 88C5                <1> 	mov	ch, al				; keep 8 sign bits
   838 00001B8F E87FFFFFFF          <1> 	call	field_scale
   839 00001B94 20C0                <1> 	and	al, al
   840 00001B96 7415                <1> 	jz	_dlsc24				; if the first word is all signs
   841                              <1> ;	call	scale8
   842 00001B98 0FB6C1              <1> 	movzx	eax, cl
   843 00001B9B 894518              <1> 	mov	dword ptr [ebp+MANTISSA2], eax	; store the scale
   844 00001B9E 8B4510              <1> 	mov	eax, dword ptr [ebp+A]		; retrieve the input high order word
   845 00001BA1 E8DFFDFFFF          <1> 	call	drl				; scale the two input words per cl
   846 00001BA6 895D14              <1> 	mov	dword ptr [ebp+B], ebx
   847 00001BA9 894510              <1> 	mov	dword ptr [ebp+A], eax  	; store the rotated value
   848 00001BAC C3                  <1> 	ret
   849                              <1> 
   850                              <1> _dlsc24:				; different when high order word is all signs
   851 00001BAD C1E808              <1> 	shr	eax, 8			; one result word of signs
   852 00001BB0 894514              <1> 	mov	dword ptr [ebp+B], eax	; into the low-order result word
   853 00001BB3 89D8                <1> 	mov	eax, ebx		; scale the low-order input
   854 00001BB5 C1E008              <1> 	shl	eax, 8
   855 00001BB8 30C9                <1> 	xor	cl, cl			; restart the scale count-up
   856 00001BBA E854FFFFFF          <1> 	call	field_scale
   857 00001BBF 80C118              <1> 	add	cl, 24			; restore the early part of the count-up
   858                              <1> ;	call	scale8
   859 00001BC2 0FB6D9              <1> 	movzx	ebx, cl
   860 00001BC5 895D18              <1> 	mov	dword ptr [ebp+MANTISSA2], ebx	; store the scale
   861                              <1> ;	mov	al, ah
   862                              <1> ;	ror	eax, 8			; reverse the last 8 rotation positions
   863                              <1> ;	and	cl, 7			; do the last part of the rotate
   864                              <1> ;	xor	al, al
   865                              <1> ;	rol	eax, 7
   866                              <1> ;	or	ah, al
   867 00001BC8 C1E808              <1> 	shr	eax, 8
   868 00001BCB 894510              <1> 	mov	dword ptr [ebp+A], eax	; store the rotated value
   869 00001BCE C3                  <1> 	ret
   870                              <1> 
   871                              <1> 	%if	0
   872                              <1> 
   873                              <1> _fpx:	call	_burst_read2		; data read in eax ebx
   874                              <1> 	push	ebx			; ebx is used in RTA1 stack frame
   875                              <1> 	call	stack4			; construct RTA1 stack frame
   876                              <1> 
   877                              <1> 	shl	eax, 4			; move 12 mantissa bits out of eax
   878                              <1> 	movsx	ecx, ax			; and extend the normalising bit
   879                              <1> 
   880                              <1> 	rol	eax, 4+1		; shelter sign in eax bit 0
   881                              <1> 	shl	ax, 12			; better still in eax bit 12
   882                              <1> 	sar	eax, 12			; propagate the value at midpoint position
   883                              <1> 	ror	eax, 1			; have the sign back
   884                              <1> 	shr	eax, 8			; clear eax 31..24
   885                              <1> 	xor	eax, 003ffc00h		; reverse the 12 copies of midpoint bit
   886                              <1> 					; yon's ra complicated bit done
   887                              <1> 	mov	dword ptr [ebp+ebx*4], eax
   888                              <1> 
   889                              <1> 	xor	eax, ecx		; is the normalising bit opposite to signs ?
   890                              <1> 	test	eax, 00800000h
   891                              <1> 	jz	_fpx_allsigns		; no so unnormalised = zero
   892                              <1> 
   893                              <1> 	pop	eax			; the 2nd operand word, ya remember?
   894                              <1> 	shl	eax, 4			; get them 2 halves over the centre
   895                              <1> 
   896                              <1> 	shr	cx, 4			; zero quartets at high order of 16 bits
   897                              <1> 	shr	ax, 4
   898                              <1> 
   899                              <1> 	xchg	ax, cx			; low-order mantissa bits with unsigns in ecx
   900                              <1> 					; high-order mantissa bits with middle part in eax
   901                              <1> 
   902                              <1> 	shl	eax, 4			; LLLz | HHHz
   903                              <1> 	shr	ax, 4			; LLLz | zHHH
   904                              <1> 	rol	eax, 12			; zzHH | HLLL
   905                              <1> 
   906                              <1> 	mov	dword ptr [ebp+ebx*4+1*4], eax
   907                              <1> 	rol	ecx, 12
   908                              <1> 	xor	ecx, 0FFFh		; 12 normalising bits = 12 inverted signs
   909                              <1> 	mov	dword ptr [ebp+ebx*4+2*4], ecx
   910                              <1> 	not	ecx			; convert high order quartet to signs
   911                              <1> 	sar	ecx, 20			; 24 of them
   912                              <1> 	shr	ecx, 8
   913                              <1> 	mov	dword ptr [ebp+ebx*4+3*4], ecx
   914                              <1> 	mov	ebp, dword ptr [_register_set]
   915                              <1> 	mov	dword ptr [ebp+S_P], ebx	; update whichever sp that is
   916                              <1> 	ret
   917                              <1> 
   918                              <1> _fpx_allsigns:
   919                              <1> 	add	esp, 4			; take saved operand word back from stack
   920                              <1> 	sar	ecx, 8			; 16 unnormalised normalising bits
   921                              <1> 	shr	ecx, 8			; = 24 sign bits
   922                              <1> 
   923                              <1> 	mov	dword ptr [ebp+ebx*4], ecx
   924                              <1> 	mov	dword ptr [ebp+ebx*4+1*4], ecx
   925                              <1> 	mov	dword ptr [ebp+ebx*4+2*4], ecx
   926                              <1> 	mov	dword ptr [ebp+ebx*4+3*4], ecx
   927                              <1> 
   928                              <1> 	mov	ebp, dword ptr [_register_set]
   929                              <1> 	mov	dword ptr [ebp+S_P], ebx	; update whichever sp that is
   930                              <1> 	ret
   931                              <1> 
   932                              <1> _fpp:	call	stack_read4
   933                              <1> 	push	eax				; thats EA
   934                              <1> 
   935                              <1> 	mov	eax, dword ptr [ebp+ebx*4]	; s + 23 exponent bits
   936                              <1> 	rol	eax, 8+2			; save sign and midpoint
   937                              <1> 	shl	eax, 12				; squeeze out 12 exponent bits
   938                              <1> 	shr	ax, 12				; bring sign + midpoint back
   939                              <1> 	ror	eax, 2				; and roll them back in
   940                              <1> 	shr	eax, 4				; position 12 bits low in 16 bits
   941                              <1> 	mov	ecx, dword ptr [ebp+ebx*4+1*4]	; take 1st mantissa word from the stack
   942                              <1> 	ror	ecx, 12				; rotate 12 bits down
   943                              <1> 	shl	cx, 4				; position 12 bits high in 16 bits
   944                              <1> 	mov	ax, cx				; merge
   945                              <1> 	shr	eax, 4				; position 24 bits low in 32 bits
   946                              <1> 	mov	dword ptr [ebp+ebx*4], eax	; place back in RTA1 stack frame
   947                              <1> 						; next 12 mantissa bits in ecx 31..20
   948                              <1> 
   949                              <1> 	mov	eax, dword ptr [ebp+ebx*4+2*4]	; read 24 more
   950                              <1> 	shr	eax, 12-4			; position 12 bits at ax 15..4
   951                              <1> 	shr	ecx, 4				;				
   952                              <1> 	mov	cx, ax				; juxtapose with mantissa 23..12
   953                              <1> 	shr	ecx, 4				; wirraff
   954                              <1> 
   955                              <1> 	mov	dword ptr [ebp+ebx*4+1*4], ecx	; making 2nd and final output word
   956                              <1> 
   957                              <1> 	pop	eax				; recover EA
   958                              <1> 	mov	ebp, dword ptr [_register_set]	; do this after all stack_readX
   959                              <1> 	jmp	_burst_write2
   960                              <1> 
   961                              <1> 	%endif
    37                                  	%include	"fpu.msm"
     1                              <1> compress4to8:			; readout floating operand
     2                              <1> 				; and pack to 32-bit words
     3                              <1> 				; for 1 bit-distance shifting
     4                              <1> 				; acquired operand is in 1st half of 
     5                              <1> 				; 8-register block [esi]
     6                              <1> 
     7 00001BCF 8B06                <1> 	mov	eax, dword ptr [esi]	; 1s-complement scale field
     8 00001BD1 C1E008              <1> 	shl	eax, 8			; 1st data bit reveals sign
     9 00001BD4 C1F808              <1> 	sar	eax, 8			; propagate that sign some
    10 00001BD7 89C3                <1> 	mov	ebx, eax
    11 00001BD9 C1F818              <1> 	sar	eax, 24			; propagate signs to 32 bits
    12 00001BDC 31C3                <1> 	xor	ebx, eax		; change scale to unsigned magnitude
    13 00001BDE 891E                <1> 	mov	dword ptr [esi], ebx	; position scale magnitude in 1st register
    14 00001BE0 89461C              <1> 	mov	dword ptr [esi+7*4], eax	; 96 trailing signs
    15 00001BE3 894618              <1> 	mov	dword ptr [esi+6*4], eax
    16 00001BE6 894614              <1> 	mov	dword ptr [esi+5*4], eax
    17 00001BE9 8B5E0C              <1> 	mov	ebx, dword ptr [esi+3*4]	; read low-order mantissa word
    18 00001BEC 88D8                <1> 	mov	al, bl				; low-order octet
    19 00001BEE C1C808              <1> 	ror	eax, 8				; is followed by 24 signs
    20 00001BF1 894610              <1> 	mov	dword ptr [esi+4*4], eax	; ebx also contains mantissa 23..8
    21                              <1> 						; in positions 23..8
    22                              <1> 
    23 00001BF4 8B4608              <1> 	mov	eax, dword ptr [esi+2*4]	; eax now contains mantissa 47..24
    24 00001BF7 C1E308              <1> 	shl	ebx, 8
    25 00001BFA 6689C3              <1> 	mov	bx, ax				; mantissa 39..24 -> ebx
    26 00001BFD C1C310              <1> 	rol	ebx, 16				; ebx now contains mantissa 40..8
    27 00001C00 895E0C              <1> 	mov	dword ptr [esi+3*4], ebx
    28 00001C03 8B5E04              <1> 	mov	ebx, dword ptr [esi+1*4]	; mantissa 71..48
    29 00001C06 C1E308              <1> 	shl	ebx, 8
    30 00001C09 C1E810              <1> 	shr	eax, 16				; mantissa 47..40
    31 00001C0C 88C3                <1> 	mov	bl, al
    32 00001C0E 895E08              <1> 	mov	dword ptr [esi+2*4], ebx	; mantissa 71..40
    33 00001C11 8B4614              <1> 	mov	eax, dword ptr [esi+5*4]	; copy 32 signs
    34 00001C14 894604              <1> 	mov	dword ptr [esi+1*4], eax	; to 2nd word of register block
    35 00001C17 C3                  <1> 	ret
    36                              <1> 
    37                              <1> 
    38                              <1> ;	___________________________________
    39                              <1> ;	| magnitude scale|     32 signs   |
    40                              <1> ;	|________________|________________|
    41                              <1> ;	| platform word 7| platform word 6|
    42                              <1> 
    43                              <1> 
    44                              <1> ;	<------------ 168-bit mantissa 167..72-------------|
    45                              <1> ;	<------------  72-bit mantissa ------>
    46                              <1> ;	_____________|___________|____________|____________________________
    47                              <1> ;	|      24    | 8 |   16  |   16   | 8 |    24 signs|96 more signs for
    48                              <1> ;	|____________|___|______ |________|___|____________|residue calculation
    49                              <1> ;	| platform word 5| platform word 4|   +rounding <--- @  96-bit operation
    50                              <1> 
    51                              <1> ;	                 <---------------------------------[ platform words 2..0
    52                              <1> ;	                 :
    53                              <1> ;	                 [                                                  ]
    54                              <1> 
    55                              <1> ;	                 |--- 168-bit mantissa 71:0   -------->
    56                              <1> ;	                      rounding @ 192-bit operation --->+
    57                              <1> ;      	                 _________________________|____________|_____________
    58                              <1> ;	                 |      24    | 8 |   16  |   16   | 8 |    24 signs|
    59                              <1> ;	                 |____________|___|_______|________|___|____________|
    60                              <1> ;	                 | platform word 2| platform word 1| platform word 0|
    61                              <1> 
    62                              <1> ;	                 |    residue rounding -->+
    63                              <1> ;	                 |--- 144-bit mantissa -->	                                    
    64                              <1> 
    65                              <1> _deliver_edi:
    66 00001C18 89FE                <1> 	mov	esi, edi
    67                              <1> _deliver_:
    68 00001C1A F705[00000000]0800- <1> 	test	dword ptr [_psr], FP_R
    68 00001C22 0000                <1>
    69 00001C24 0F847A000000        <1> 	jz	near _deliver
    70 00001C2A 53                  <1> 	push	ebx		; save result register index
    71 00001C2B 8B1E                <1> 	mov	ebx, dword ptr [esi]		; read scale unsigned magnitude
    72                              <1> 						; not yet signed
    73                              <1> 
    74                              <1> 				; all results except scale have been polarised
    75                              <1> 				; ebx = positive magnitude of major exponent
    76                              <1> 				; deliver floating residue
    77 00001C2D 83C3B8              <1> 	add	ebx, -72	; calculate exponent of residue
    78 00001C30 B148                <1> 	mov	cl, 72
    79                              <1> 
    80 00001C32 8B4610              <1> 	mov	eax, dword ptr [esi+4*4]	; mantissa */ 64 bits
    81 00001C35 C1E008              <1> 	shl	eax, 8		; separate residual mantissa
    82 00001C38 C1E808              <1> 	shr	eax, 8
    83 00001C3B 50                  <1> 	push	eax
    84 00001C3C 8B4614              <1> 	mov	eax, dword ptr [esi+5*4]	; mantissa */ 96 bits
    85 00001C3F 50                  <1> 	push	eax
    86 00001C40 8B4618              <1> 	mov	eax, dword ptr [esi+6*4]	; mantissa */ 128 bits
    87 00001C43 668B4604            <1> 	mov	ax, word ptr [esi+1*4]		; change low-order half trailing word to signs
    88 00001C47 50                  <1> 	push	eax				; before normalising
    89                              <1> 
    90                              <1> _normalise_residue:
    91 00001C48 8B442408            <1> 	mov	eax, dword ptr [esp+2*4]	; residual mantissa high-order word
    92 00001C4C 334604              <1> 	xor	eax, dword ptr [esi+1*4]	; signs
    93 00001C4F 2500008000          <1> 	and	eax, 00800000h			; normalising position
    94 00001C54 751A                <1> 	jnz	_residue_normalised
    95 00001C56 8B4604              <1> 	mov	eax, dword ptr [esi+1*4]	; signs again
    96 00001C59 D1D0                <1> 	rcl	eax, 1				; place a sign in carry				
    97 00001C5B D11424              <1> 	rcl	dword ptr [esp], 1		; rotate 96 bits residual mantissa
    98 00001C5E D1542404            <1> 	rcl	dword ptr [esp+1*4], 1
    99 00001C62 D1542408            <1> 	rcl	dword ptr [esp+2*4], 1		; thirdly the high-order word
   100 00001C66 83C3FF              <1> 	add	ebx, -1
   101 00001C69 80C1FF              <1> 	add	cl, -1
   102 00001C6C 72DA                <1> 	jc	_normalise_residue
   103 00001C6E 31DB                <1> 	xor	ebx, ebx			; residue all signs zero -> scale
   104                              <1> _residue_normalised:
   105 00001C70 F7C3000080FF        <1> 	test	ebx, 0FF800000h
   106 00001C76 7574                <1> 	jnz	_xpo4				; nonzero mantissa
   107                              <1> 						; and exponent underflow / overflow
   108                              <1> 						
   109                              <1> ;			residual mantissa on the stack now is
   110                              <1> ;			______________________________________________
   111                              <1> ;	sp------------->| mantissa bits 15..0 | 16 sign bits discard |
   112                              <1> ;			|_____________________|______________________|
   113                              <1> ;			|            mantissa bits 47..16            |
   114                              <1> ;			|____________________________________________| 
   115                              <1> ;			| 0000 0000  mantissa bits 71..48            |
   116                              <1> ;			|____________________________________________|
   117                              <1> ;			|	     result register indication      |
   118                              <1> ;			|____________________________________________|
   119                              <1> 
   120 00001C78 8B4604              <1> 	mov	eax, dword ptr [esi+1*4]	; signs
   121 00001C7B 31D8                <1> 	xor	eax, ebx			; sign residue exponent now
   122 00001C7D C1E008              <1> 	shl	eax, 8				; trim characteristic to RTA1 24-bit word
   123 00001C80 C1E808              <1> 	shr	eax, 8
   124 00001C83 894520              <1> 	mov	dword ptr [ebp+8*4], eax	; scale XOR signs -> residue characteristic
   125                              <1> 
   126 00001C86 5B                  <1> 	pop	ebx				; low order mantissa part
   127 00001C87 58                  <1> 	pop	eax				; middle order mantissa part
   128 00001C88 88C3                <1> 	mov	bl, al				; donate 8 bits
   129 00001C8A C1CB08              <1> 	ror	ebx, 8				; distribute as RTA1 24-bit words
   130 00001C8D C1EB08              <1> 	shr	ebx, 8				; mantissa 23..0
   131 00001C90 C1E808              <1> 	shr	eax, 8				; mantissa 47..24
   132 00001C93 895D2C              <1> 	mov	dword ptr [ebp+11*4], ebx
   133 00001C96 894528              <1> 	mov	dword ptr [ebp+10*4], eax
   134 00001C99 58                  <1> 	pop	eax				; high order residual mantissa part
   135 00001C9A 5B                  <1> 	pop	ebx				; saved result register index
   136 00001C9B C1E008              <1> 	shl	eax, 8
   137 00001C9E C1E808              <1> 	shr	eax, 8				; normalising position is bit 23
   138 00001CA1 894524              <1> 	mov	dword ptr [ebp+9*4], eax	; mantissa 71..48
   139                              <1> 
   140                              <1> _deliver:					; deliver floating result
   141                              <1> 						; ebx = target register index
   142                              <1> 						; result register index [ebp+]ebx*4
   143 00001CA4 8B06                <1> 	mov	eax, dword ptr [esi]		; unsigned scale magnitude
   144 00001CA6 A9000080FF          <1> 	test	eax, 0FF800000h
   145 00001CAB 0F85A3F4FFFF        <1> 	jnz	_fpxpo				; exponent underflow / overflow
   146 00001CB1 334604              <1> 	xor	eax, dword ptr [esi+1*4]	; sign it
   147 00001CB4 C1E008              <1> 	shl	eax, 8
   148 00001CB7 C1E808              <1> 	shr	eax, 8
   149                              <1> 
   150                              <1> _store_float:
   151 00001CBA 89449D00            <1>         mov     dword ptr [ebp+ebx*4], eax      ; store characteristic = scale XOR signs
   152 00001CBE 8B4608              <1>         mov     eax, dword ptr [esi+2*4]	; read bits 71..40 major mantissa
   153 00001CC1 0FB6C8              <1>         movzx   ecx, al
   154 00001CC4 C1E808              <1>         shr     eax, 8
   155 00001CC7 89449D04            <1>         mov     dword ptr [ebp+ebx*4+4], eax	; store mantissa bits 71..48
   156 00001CCB 8B460C              <1>         mov     eax, dword ptr [esi+3*4]	; read mantissa bits 39..8
   157 00001CCE C1E110              <1>         shl     ecx, 16				; position mantissa bits 47..40
   158 00001CD1 C1C810              <1>         ror     eax, 16
   159 00001CD4 6689C1              <1>         mov     cx, ax				; position mantissa bits 39..24
   160 00001CD7 894C9D08            <1>         mov     dword ptr [ebp+ebx*4+8], ecx	; store mantissa bits 47..24
   161 00001CDB 8B4E10              <1>         mov     ecx, dword ptr [esi+4*4]	; read mantissa bits 7..0 plus 24 trailing bits
   162 00001CDE C1E910              <1>         shr     ecx, 16				; position after mantissa 23..8
   163 00001CE1 6689C8              <1>         mov     ax, cx
   164 00001CE4 C1E808              <1>         shr     eax, 8				; store mantissa bits 23..0
   165 00001CE7 89449D0C            <1>         mov     dword ptr [ebp+ebx*4+12], eax
   166 00001CEB C3                  <1> 	ret
   167                              <1> 
   168 00001CEC 5B                  <1> _xpo4:	pop	ebx				; exponent underflow / overflow
   169 00001CED 5B                  <1> 	pop	ebx				; with 128 bits on the stack
   170 00001CEE 5B                  <1> 	pop	ebx
   171 00001CEF 5B                  <1> 	pop	ebx
   172 00001CF0 E95FF4FFFF          <1> 	jmp	_fpxpo
   173                              <1> 
   174                              <1> 
   175                              <1> ;	_output equ	272
   176                              <1> ;	_inputr equ	264
   177                              <1> ;	_input2 equ	256
   178                              <1> 
   179                              <1> ;	_OUTPUT	equ	__register+_output*4
   180                              <1> ;	_INPUTR equ	__register+_inputr*4
   181                              <1> ;	_INPUT2 equ	__register+_input2*4
   182                              <1> ;	_BIAS	equ	_OUTPUT
   183                              <1> 
   184                              <1> zoutput:
   185 00001CF5 31C0                <1> 	xor	eax, eax
   186 00001CF7 8906                <1> 	mov	dword ptr [esi], eax
   187 00001CF9 894604              <1> 	mov	dword ptr [esi+1*4], eax
   188 00001CFC 894608              <1> 	mov	dword ptr [esi+2*4], eax
   189 00001CFF 89460C              <1> 	mov	dword ptr [esi+3*4], eax
   190 00001D02 894610              <1> 	mov	dword ptr [esi+4*4], eax
   191 00001D05 894614              <1> 	mov	dword ptr [esi+5*4], eax
   192 00001D08 894618              <1> 	mov	dword ptr [esi+6*4], eax
   193 00001D0B 89461C              <1> 	mov	dword ptr [esi+7*4], eax
   194 00001D0E C3                  <1> 	ret
   195                              <1> 
   196                              <1> 
   197                              <1> ;	round before add or divide
   198                              <1> ;	XOR rounding pattern to guard field
   199                              <1> 
   200 00001D0F 0FB6DD              <1> round1:	movzx	ebx, ch
   201 00001D12 A1[4C020000]        <1> 	mov	eax, dword ptr [__register+FP_GUARD]
   202 00001D17 D3E8                <1> 	shr	eax, cl
   203 00001D19 C1E008              <1> 	shl	eax, 8
   204 00001D1C 31449F08            <1> 	xor	dword ptr [edi+ebx*4+2*4], eax
   205 00001D20 C3                  <1> 	ret
   206                              <1> 
   207 00001D21 0FB6DD              <1> round2:	movzx	ebx, ch
   208 00001D24 A1[4C020000]        <1> 	mov	eax, dword ptr [__register+FP_GUARD]
   209 00001D29 D3E8                <1> 	shr	eax, cl
   210 00001D2B C1E008              <1> 	shl	eax, 8
   211 00001D2E 01449F08            <1> 	add	dword ptr [edi+ebx*4+2*4], eax
   212                              <1> round2more:
   213 00001D32 83549F0400          <1> 	adc	dword ptr [edi+ebx*4+1*4], 0
   214 00001D37 4B                  <1> 	dec	ebx
   215 00001D38 75F8                <1> 	jnz	round2more
   216 00001D3A C3                  <1> 	ret
   217                              <1> 
   218                              <1> end_around_down:
   219 00001D3B B8FFFFFFFF          <1> 	mov	eax, -1
   220 00001D40 D3E8                <1> 	shr	eax, cl
   221 00001D42 F7D0                <1> 	not	eax
   222 00001D44 EB07                <1> 	jmp	eoc1
   223                              <1> end_around_carry:
   224 00001D46 B801000000          <1> 	mov	eax, 1				; don't call this if there is no carry
   225 00001D4B D3C8                <1> 	ror	eax, cl
   226                              <1> 
   227 00001D4D 0FB6DD              <1> eoc1:	movzx	ebx, ch
   228 00001D50 01449F08            <1> 	add	dword ptr [edi+ebx*4+2*4], eax
   229 00001D54 9C                  <1> 	pushf
   230 00001D55 C1F81F              <1> 	sar	eax, 31
   231 00001D58 9D                  <1> 	popf
   232 00001D59 43                  <1> 	inc	ebx
   233 00001D5A 11049F              <1> eoc:	adc	dword ptr [edi+ebx*4], eax
   234 00001D5D 4B                  <1> 	dec	ebx
   235 00001D5E 75FA                <1> 	jnz	eoc
   236 00001D60 C3                  <1> 	ret
   237                              <1> 
   238                              <1> restore_trailing_signs:
   239 00001D61 0FB6DD              <1> 	movzx	ebx, ch
   240 00001D64 8B4704              <1> 	mov	eax, dword ptr [edi+1*4]
   241                              <1> 
   242 00001D67 89471C              <1> 	mov	dword ptr [edi+7*4], eax
   243                              <1> 
   244 00001D6A 21C0                <1> 	and	eax, eax
   245 00001D6C 780B                <1> 	js	restore_trailing_ones
   246 00001D6E F7D0                <1> 	not	eax
   247 00001D70 D3E8                <1> 	shr	eax, cl
   248 00001D72 F7D0                <1> 	not	eax
   249 00001D74 21449F08            <1> 	and	dword ptr [edi+ebx*4+2*4], eax
   250 00001D78 C3                  <1> 	ret
   251                              <1> restore_trailing_ones:
   252 00001D79 D3E8                <1> 	shr	eax, cl
   253 00001D7B 09449F08            <1> 	or	dword ptr [edi+ebx*4+2*4], eax
   254 00001D7F C3                  <1> 	ret
   255                              <1> 	
   256                              <1> bias_addend:					; input mantissa [esi] is biased into location _BIAS
   257 00001D80 56                  <1> 	push	esi
   258 00001D81 57                  <1> 	push	edi
   259                              <1> 
   260 00001D82 BF[40040000]        <1> 	mov	edi, _BIAS
   261 00001D87 E803000000          <1> 	call	biasfp
   262                              <1> 
   263 00001D8C 5F                  <1> 	pop	edi
   264 00001D8D 5E                  <1> 	pop	esi
   265 00001D8E C3                  <1> 	ret
   266                              <1> 
   267 00001D8F 52                  <1> biasfp:	push	edx
   268 00001D90 51                  <1> 	push	ecx
   269                              <1> 
   270 00001D91 BB01000000          <1> 	mov	ebx, 1				; output index
   271 00001D96 66C1E003            <1> 	shl	ax, 3				; words sign fill
   272 00001D9A C0E803              <1> 	shr	al, 3				; bits sign fill
   273 00001D9D 6689C1              <1> 	mov	cx, ax
   274 00001DA0 83C604              <1> 	add	esi, 4				; input pointer
   275 00001DA3 8B06                <1> 	mov	eax, dword ptr [esi]		; there shall be this word of signs at least
   276                              <1> 
   277 00001DA5 89049F              <1> bias32:	mov	dword ptr [edi+ebx*4], eax	; write 1 word of signs
   278 00001DA8 43                  <1> 	inc	ebx				; consider the next output word
   279 00001DA9 FECD                <1> 	dec	ch				; any more words of signs?
   280 00001DAB 79F8                <1> 	jns	bias32
   281                              <1> 
   282 00001DAD 20C9                <1> 	and	cl, cl
   283 00001DAF 7422                <1> 	jz	bias_fast			; there is no 32-bit shift
   284                              <1> 
   285 00001DB1 B520                <1> 	mov	ch, 32				; demonstrate the missing advantage
   286 00001DB3 28CD                <1> 	sub	ch, cl				; of instruction architectures
   287                              <1> 						; with 2-register shifts
   288                              <1> biasup2:
   289 00001DB5 83FB08              <1> 	cmp	ebx, 8
   290 00001DB8 742B                <1> 	jz	bias_addx
   291 00001DBA 83C604              <1> 	add	esi, 4				; read new mantissa word
   292 00001DBD 8B16                <1> 	mov	edx, dword ptr [esi]		; it becomes word # new in edx
   293 00001DBF 86E9                <1> 	xchg	ch, cl
   294 00001DC1 D3E0                <1> 	shl	eax, cl				; shift buffered word left 32 - bit offset
   295 00001DC3 86E9                <1> 	xchg	ch, cl
   296 00001DC5 D3EA                <1> 	shr	edx, cl				; shift new mantissa word right bit offset
   297 00001DC7 09D0                <1> 	or	eax, edx
   298 00001DC9 89049F              <1> 	mov	dword ptr [edi+ebx*4], eax	; write 1 merged word
   299 00001DCC 8B06                <1> 	mov	eax, dword ptr [esi]		; read the same mantissa word again
   300 00001DCE 83C301              <1> 	add	ebx, 1				; it becomes word # previous in eax
   301 00001DD1 EBE2                <1> 	jmp	biasup2
   302                              <1> 
   303                              <1> bias_fast:
   304 00001DD3 83FB08              <1> 	cmp	ebx, 8
   305 00001DD6 740D                <1> 	jz	bias_addx
   306 00001DD8 83C604              <1> 	add	esi, 4
   307 00001DDB 8B06                <1> 	mov	eax, dword ptr [esi]
   308 00001DDD 89049F              <1> 	mov	dword ptr [edi+ebx*4], eax
   309 00001DE0 83C301              <1> 	add	ebx, 1
   310 00001DE3 EBEE                <1> 	jmp	bias_fast
   311                              <1> 
   312                              <1> bias_addx:
   313 00001DE5 59                  <1> 	pop	ecx
   314 00001DE6 5A                  <1> 	pop	edx				; restore the program counter
   315 00001DE7 C3                  <1> 	ret
   316                              <1> 
   317                              <1> frame_mantissa:
   318                              <1> ;	ror	ecx, 16				; words count is up, beats index down
   319 00001DE8 80C501              <1> 	add	ch, 1				; up the beats index to beats count
   320 00001DEB 66C1E905            <1> 	shr	cx, 5				; positions / 32 in ch
   321 00001DEF C0E903              <1> 	shr	cl, 3				; positions /// 32 in cl
   322 00001DF2 0FB6DD              <1> 	movzx	ebx, ch				; derive platform words rounded down
   323 00001DF5 C3                  <1> 	ret
   324                              <1> 
   325                              <1> renormalise:					; rule 1: restore sign fill in
   326                              <1> 						; low-order containing platform word
   327                              <1> ; done before end-around-carry, and saved
   328                              <1> ;;	call	frame_mantissa			; it was mashed by rounding and adding
   329 00001DF6 E866FFFFFF          <1> 	call	restore_trailing_signs
   330 00001DFB C1C910              <1> 	ror	ecx, 16				; the governing parameter is now
   331                              <1> 						; the containing words count in cx
   332                              <1> renormalise32:
   333 00001DFE 8B4708              <1> 	mov	eax, dword ptr [edi+2*4]	; sample 32 mantissa bits
   334 00001E01 3B4704              <1> 	cmp	eax, dword ptr [edi+1*4]	; compare it with 32 signs
   335 00001E04 750C                <1> 	jnz	renormalise8
   336 00001E06 E83E000000          <1> 	call	rotate32left			; this also discovers if it's ALL signs = 0
   337 00001E0B 21C0                <1> 	and	eax, eax			; and is the only place that needs examined
   338 00001E0D 75EF                <1> 	jnz	renormalise32
   339                              <1> 
   340 00001E0F 8907                <1> 	mov	dword ptr [edi], eax		; mantissa is signed zero, +0 -> scale
   341                              <1> renormalised:
   342 00001E11 C3                  <1> 	ret
   343                              <1> 
   344                              <1> renormalise8:					; from this point on the value is nonzero
   345 00001E12 C1C008              <1> 	rol	eax, 8				; are there 8 signs at head of mantissa?
   346 00001E15 3A4707              <1> 	cmp	al, byte ptr [edi+1*4+3]	; this is Intel and the 4th byte is high-order
   347 00001E18 750A                <1> 	jnz	renormalise1			; you have found the 8 bits containing the
   348                              <1> 						; normalising bit
   349 00001E1A E849000000          <1> 	call	rotate8left			; or else you haven't
   350 00001E1F 8B4708              <1> 	mov     eax, dword ptr [edi+2*4]	; sample the moved mantissa
   351 00001E22 EBEE                <1> 	jmp	renormalise8
   352                              <1> 
   353                              <1> renormalise1:
   354                              <1> ;	movzx	ebx, cx	
   355 00001E24 8B4704              <1> 	mov	eax, dword ptr [edi+1*4]		
   356                              <1> ;	mov	dword ptr [edi+ebx*4+1*4], eax	; in case polarity has changed
   357 00001E27 334708              <1> 	xor	eax, dword ptr [edi+2*4]	; normalising bit opposite polarity to sign?
   358 00001E2A 78E5                <1> 	js	renormalised			; arrived
   359 00001E2C E802000000          <1> 	call	bitwise_scale			; almost arrived
   360 00001E31 EBF1                <1> 	jmp	renormalise1
   361                              <1> 
   362                              <1> 
   363                              <1> bitwise_scale:
   364 00001E33 D1571C              <1> 	rcl	dword ptr [edi+7*4], 1	; so it doesn't matter whether 0 or 1
   365 00001E36 D15718              <1> 	rcl	dword ptr [edi+6*4], 1	; gets shifted into the 192nd bit
   366 00001E39 D15714              <1> 	rcl	dword ptr [edi+5*4], 1
   367 00001E3C D15710              <1> 	rcl	dword ptr [edi+4*4], 1	; it's quicker to shift 6 words
   368 00001E3F D1570C              <1> 	rcl	dword ptr [edi+3*4], 1	; than a counted loop of 4 or 5 or 6 words
   369 00001E42 D15708              <1> 	rcl	dword ptr [edi+2*4], 1
   370                              <1> 
   371 00001E45 8307FF              <1> 	add	dword ptr [edi], -1	; scale down
   372 00001E48 C3                  <1> 	ret
   373                              <1> 
   374                              <1> rotate32left:				; rotate all containing platform words of mantissa
   375 00001E49 52                  <1> 	push	edx			; 32 bit positions left and report if all signs
   376 00001E4A 51                  <1> 	push	ecx
   377 00001E4B 0FB7D9              <1> 	movzx	ebx, cx
   378 00001E4E 31D2                <1> 	xor	edx, edx		; initialise equality = all signs
   379                              <1> 
   380                              <1> rotate32next:				; the word initially loaded in eax is all signs
   381 00001E50 4B                  <1> 	dec	ebx
   382 00001E51 87449F08            <1> 	xchg	eax, dword ptr [edi+ebx*4+2*4]
   383 00001E55 89C1                <1> 	mov	ecx, eax
   384 00001E57 334F04              <1> 	xor	ecx, dword ptr [edi+1*4] ; difference between this word and signs
   385 00001E5A 09CA                <1> 	or	edx, ecx		; sum of differences
   386 00001E5C 21DB                <1> 	and	ebx, ebx
   387 00001E5E 75F0                <1> 	jnz	rotate32next
   388 00001E60 8307E0              <1> 	add	dword ptr [edi], -32	; scale down
   389 00001E63 89D0                <1> 	mov	eax, edx
   390 00001E65 59                  <1> 	pop	ecx
   391 00001E66 5A                  <1> 	pop	edx
   392 00001E67 C3                  <1> 	ret
   393                              <1> 
   394                              <1> rotate8left:				; rotate all containing platform words of mantissa
   395 00001E68 51                  <1> 	push	ecx			; 8 bit positions left. 1st word is rotated already
   396 00001E69 0FB7D9              <1> 	movzx	ebx, cx			; and contains signs in 8 low-order bit positions
   397                              <1> rotate8next:
   398 00001E6C 8B4C9F08            <1> 	mov	ecx, dword ptr [edi+ebx*4+2*4]
   399 00001E70 C1C108              <1> 	rol	ecx, 8
   400 00001E73 86C1                <1> 	xchg	al, cl
   401 00001E75 894C9F08            <1> 	mov	dword ptr [edi+ebx*4+2*4], ecx
   402 00001E79 83C3FF              <1> 	add	ebx, -1
   403 00001E7C 72EE                <1> 	jc	rotate8next
   404 00001E7E 8307F8              <1> 	add	dword ptr [edi], -8	; scale down
   405 00001E81 59                  <1> 	pop	ecx
   406 00001E82 C3                  <1> 	ret
   407                              <1> 
   408 00001E83 F75608              <1> zover:	not	dword ptr [esi+2*4]
   409 00001E86 F7560C              <1> 	not	dword ptr [esi+3*4]
   410 00001E89 F75610              <1> 	not	dword ptr [esi+4*4]
   411 00001E8C F75614              <1> 	not	dword ptr [esi+5*4]
   412 00001E8F F75618              <1> 	not	dword ptr [esi+6*4]
   413 00001E92 F7561C              <1> 	not	dword ptr [esi+7*4]
   414 00001E95 C3                  <1> 	ret
   415                              <1> 
   416                              <1> _add_low:
   417 00001E96 8B15[1C040000]      <1>         mov     edx, dword ptr [_INPUT2+7*4]
   418 00001E9C 1315[3C040000]      <1>         adc     edx, dword ptr [_INPUTR+7*4]
   419 00001EA2 8B1D[18040000]      <1>         mov     ebx, dword ptr [_INPUT2+6*4]
   420 00001EA8 131D[38040000]      <1>         adc     ebx, dword ptr [_INPUTR+6*4]
   421 00001EAE A1[14040000]        <1>         mov     eax, dword ptr [_INPUT2+5*4]
   422 00001EB3 1305[34040000]      <1>         adc     eax, dword ptr [_INPUTR+5*4]
   423 00001EB9 C3                  <1>         ret
   424                              <1> 
   425                              <1> _add_high:
   426 00001EBA 8B15[10040000]      <1>         mov     edx, dword ptr [_INPUT2+4*4]
   427 00001EC0 1315[30040000]      <1>         adc     edx, dword ptr [_INPUTR+4*4]
   428 00001EC6 8B1D[0C040000]      <1>         mov     ebx, dword ptr [_INPUT2+3*4]
   429 00001ECC 131D[2C040000]      <1>         adc     ebx, dword ptr [_INPUTR+3*4]
   430 00001ED2 A1[08040000]        <1>         mov     eax, dword ptr [_INPUT2+2*4]
   431 00001ED7 1305[28040000]      <1>         adc     eax, dword ptr [_INPUTR+2*4]
   432 00001EDD C3                  <1>         ret
   433                              <1> 
   434 00001EDE BE[00040000]        <1> fan:	mov	esi, _INPUT2
   435 00001EE3 E89BFFFFFF          <1> 	call	zover				; mantissa
   436 00001EE8 F715[04040000]      <1> 	not	dword ptr [_INPUT2+1*4]		; 32 signs
   437                              <1> 
   438 00001EEE BE[00040000]        <1> fa:	mov	esi, _INPUT2
   439 00001EF3 BF[20040000]        <1> 	mov	edi, _INPUTR
   440                              <1> 
   441 00001EF8 8B4604              <1> 	mov	eax, dword ptr [esi+1*4]	; normalised?
   442 00001EFB 334608              <1> 	xor	eax, dword ptr [esi+2*4]	; normalising bit must ^ signs
   443 00001EFE 7801                <1> 	js	fa_addend_normalised		; yes
   444 00001F00 C3                  <1> fa_nop:	ret					; accumulator block unchanged
   445                              <1> 
   446                              <1> fa_addend_normalised:
   447 00001F01 8B4704              <1> 	mov	eax, dword ptr [edi+1*4]	; register side operand normalised?
   448 00001F04 334708              <1> 	xor	eax, dword ptr [edi+2*4]	; normalising bit must ^ signs
   449 00001F07 7806                <1> 	js	fa_promote_magnitude		; normalised, get on with it
   450 00001F09 BF[00040000]        <1> 	mov	edi, _INPUT2			; accumulator block is not normalised
   451 00001F0E C3                  <1> 	ret					; storage addend zero-added
   452                              <1> 
   453                              <1> fa_promote_magnitude:
   454                              <1> ;	mov	eax, dword ptr [esi]		; subtract addend2 scale magnitude
   455                              <1> ;	neg	eax
   456                              <1> ;	add	eax, dword ptr [edi]		; from target scale magnitude
   457                              <1> 
   458 00001F0F 8B07                <1> 	mov	eax, dword ptr [edi]
   459 00001F11 2B06                <1> 	sub	eax, dword ptr [esi]
   460                              <1> 
   461 00001F13 790C                <1> 	jns	fa_add				; register-side operand is not lower
   462 00001F15 BE[20040000]        <1> 	mov	esi, _INPUTR			; not so, importance is reversed
   463 00001F1A BF[00040000]        <1> 	mov	edi, _INPUT2
   464 00001F1F F7D8                <1> 	neg	eax
   465                              <1> 
   466                              <1> fa_add:	;	call	frame_mantissa
   467 00001F21 50                  <1> 	push	eax
   468 00001F22 E8E8FDFFFF          <1> 	call	round1
   469                              <1> 
   470 00001F27 58                  <1> 	pop	eax
   471                              <1> 
   472 00001F28 21C0                <1> 	and	eax, eax
   473 00001F2A 7411                <1> 	jz	fa_addfast
   474                              <1> 
   475 00001F2C 3DBF000000          <1> 	cmp	eax, 191			; do they touch?
   476 00001F31 77CD                <1> 	ja	fa_nop
   477                              <1> 
   478 00001F33 E848FEFFFF          <1> 	call	bias_addend
   479 00001F38 BE[40040000]        <1> 	mov	esi, _BIAS			; shifted addend
   480                              <1> 
   481                              <1> fa_addfast:
   482 00001F3D 8B4704              <1> 	mov	eax, dword ptr [edi+1*4]
   483 00001F40 A3[40040000]        <1> 	mov	dword ptr [__register+272*4], eax	; destination signs
   484                              <1> 
   485 00001F45 C1C910              <1> 	ror	ecx, 16				; get containing compute words
   486 00001F48 0FB7D9              <1> 	movzx	ebx, cx				; index / count
   487 00001F4B C1C910              <1> 	ror	ecx, 16
   488                              <1> 
   489 00001F4E F8                  <1> 	clc
   490                              <1> 
   491                              <1> fa_action:
   492 00001F4F 8B049E              <1> 	mov	eax, dword ptr [esi+ebx*4]
   493 00001F52 11049F              <1> 	adc	dword ptr [edi+ebx*4], eax
   494 00001F55 4B                  <1> 	dec	ebx				; process word 1
   495 00001F56 75F7                <1> 	jnz	fa_action			; leave word 0 alone
   496                              <1> 
   497 00001F58 A1[40040000]        <1> 	mov	eax, dword ptr [__register+272*4]
   498 00001F5D 334704              <1> 	xor	eax, dword ptr [edi+1*4]
   499 00001F60 7930                <1> 	jns	fa_testcarry
   500                              <1> 
   501 00001F62 F7571C              <1> 	not	dword ptr [edi+7*4]
   502 00001F65 F605[00000000]08    <1> 	test	byte ptr [_psr], 8
   503 00001F6C 7506                <1> 	jnz	switch_long
   504                              <1> 
   505 00001F6E F75718              <1> 	not	dword ptr [edi+6*4]
   506 00001F71 F75714              <1> 	not	dword ptr [edi+5*4]
   507                              <1> switch_long:
   508                              <1> 
   509 00001F74 F715[40040000]      <1> 	not	dword ptr [__register+272*4]	; thru zero
   510 00001F7A F705[40040000]FFFF- <1> 	test	dword ptr [__register+272*4], -1
   510 00001F82 FFFF                <1>
   511 00001F84 7807                <1> 	js	fa_change2negative
   512                              <1> 
   513 00001F86 E8BBFDFFFF          <1> 	call	end_around_carry
   514                              <1> 
   515 00001F8B EB05                <1> 	jmp	fa_testcarry
   516                              <1> 
   517                              <1> fa_change2negative:
   518 00001F8D E8A9FDFFFF          <1> 	call	end_around_down
   519                              <1> 
   520                              <1> fa_testcarry:
   521                              <1> 
   522 00001F92 8B4704              <1> 	mov	eax, dword ptr [edi+1*4]
   523 00001F95 3305[40040000]      <1> 	xor	eax, dword ptr [__register+272*4]
   524 00001F9B A801                <1> 	test	al, 1
   525 00001F9D 7421                <1> 	jz	fa_normalise
   526 00001F9F FF07                <1> 	inc	dword ptr [edi]			; exponent magnitude++
   527                              <1> 
   528 00001FA1 D15F04              <1> 	rcr	dword ptr [edi+1*4], 1
   529 00001FA4 D15F08              <1> 	rcr	dword ptr [edi+2*4], 1
   530 00001FA7 D15F0C              <1> 	rcr	dword ptr [edi+3*4], 1
   531 00001FAA D15F10              <1> 	rcr	dword ptr [edi+4*4], 1
   532 00001FAD D15F14              <1> 	rcr	dword ptr [edi+5*4], 1
   533 00001FB0 D15F18              <1> 	rcr	dword ptr [edi+6*4], 1
   534 00001FB3 D15F1C              <1> 	rcr	dword ptr [edi+7*4], 1
   535                              <1> 
   536 00001FB6 A1[40040000]        <1> 	mov	eax, dword ptr [__register+272*4]
   537 00001FBB 894704              <1> 	mov	dword ptr [edi+1*4], eax	; make sure that is one 
   538                              <1> 						; complete word of signs again
   539 00001FBE EB05                <1> 	jmp	fa_normalised
   540                              <1> 
   541                              <1> fa_normalise:
   542 00001FC0 E831FEFFFF          <1> 	call	renormalise			; in case the sum is plenty positions
   543                              <1> fa_normalised:					; below the fractional point
   544 00001FC5 C3                  <1> 	ret
   545                              <1> 	
   546 00001FC6 BE[40040000]        <1> fm:	mov	esi, _OUTPUT			; initialise final accumulation
   547 00001FCB E825FDFFFF          <1> 	call	zoutput
   548                              <1> 
   549 00001FD0 8B1D[24040000]      <1> 	mov	ebx, dword ptr [_INPUTR+1*4]	; read register-side signs
   550 00001FD6 A1[28040000]        <1> 	mov	eax, dword ptr [_INPUTR+2*4]	; and high-end mantissa
   551 00001FDB 31D8                <1> 	xor	eax, ebx	 		; cache if-normalised in eax
   552 00001FDD 331D[04040000]      <1> 	xor	ebx, dword ptr [_INPUT2+1*4]	; multiply signs
   553 00001FE3 891D[44040000]      <1> 	mov	dword ptr [_OUTPUT+1*4], ebx	; save the output sign
   554 00001FE9 21C0                <1> 	and	eax, eax			; test the cached if-normalised
   555 00001FEB 790D                <1> 	jns	fmdont
   556                              <1> 
   557 00001FED A1[04040000]        <1> 	mov	eax, dword ptr [_INPUT2+1*4]	; is the multiplier normalised?
   558 00001FF2 3305[08040000]      <1> 	xor	eax, dword ptr [_INPUT2+2*4]	; sign XOR normalising bit?
   559 00001FF8 782F                <1> 	js	fmgo				; yes, proceed
   560                              <1> 
   561 00001FFA 891D[48040000]      <1> fmdont:	mov	dword ptr [_OUTPUT+2*4], ebx
   562 00002000 891D[4C040000]      <1> 	mov	dword ptr [_OUTPUT+3*4], ebx
   563 00002006 891D[50040000]      <1> 	mov	dword ptr [_OUTPUT+4*4], ebx
   564 0000200C 891D[54040000]      <1> 	mov	dword ptr [_OUTPUT+5*4], ebx
   565 00002012 891D[58040000]      <1> 	mov	dword ptr [_OUTPUT+6*4], ebx
   566 00002018 891D[5C040000]      <1> 	mov	dword ptr [_OUTPUT+7*4], ebx
   567 0000201E C705[40040000]0000- <1> 	mov	dword ptr [_OUTPUT], 0		; mantissa to go
   567 00002026 0000                <1>
   568                              <1> 
   569 00002028 C3                  <1> 	ret					; no, effective zero multiplier
   570                              <1> 
   571 00002029 51                  <1> fmgo:	push	ecx
   572 0000202A A1[24040000]        <1> 	mov	eax, dword ptr [_INPUTR+1*4]
   573 0000202F B148                <1> 	mov	cl, 72				; beats count exactly 72
   574 00002031 21C0                <1> 	and	eax, eax
   575 00002033 790A                <1> 	jns	fmp1
   576 00002035 BE[20040000]        <1> 	mov	esi, _INPUTR
   577 0000203A E844FEFFFF          <1> 	call	zover
   578                              <1> 
   579 0000203F A1[04040000]        <1> fmp1:	mov	eax, dword ptr [_INPUT2+1*4]
   580 00002044 21C0                <1> 	and	eax, eax
   581 00002046 790A                <1> 	jns	fmadd
   582 00002048 BE[00040000]        <1> 	mov	esi, _INPUT2
   583 0000204D E831FEFFFF          <1> 	call	zover
   584                              <1> 
   585 00002052 F8                  <1> fmadd:	clc
   586                              <1> 
   587 00002053 BE[20040000]        <1> 	mov	esi, _INPUTR
   588 00002058 D15E08              <1> 	rcr	dword ptr [esi+2*4], 1		; addend shift right
   589 0000205B D15E0C              <1> 	rcr	dword ptr [esi+3*4], 1
   590 0000205E D15E10              <1> 	rcr	dword ptr [esi+4*4], 1
   591 00002061 D15E14              <1> 	rcr	dword ptr [esi+5*4], 1
   592 00002064 D15E18              <1> 	rcr	dword ptr [esi+6*4], 1
   593 00002067 D15E1C              <1> 	rcr	dword ptr [esi+7*4], 1
   594                              <1> 
   595 0000206A BE[00040000]        <1> 	mov	esi, _INPUT2
   596                              <1> ;	rcl	dword ptr [esi+7*4], 1		; multiplier shift left
   597                              <1> ;	rcl	dword ptr [esi+6*4], 1
   598                              <1> ;	rcl	dword ptr [esi+5*4], 1		; multiplier mantissa is only 72 bits
   599 0000206F D15610              <1> 	rcl	dword ptr [esi+4*4], 1
   600 00002072 D1560C              <1> 	rcl	dword ptr [esi+3*4], 1
   601 00002075 D15608              <1> 	rcl	dword ptr [esi+2*4], 1
   602                              <1> 
   603 00002078 BE[40040000]        <1> 	mov	esi, _OUTPUT
   604 0000207D 7330                <1> 	jnc	fmadx
   605                              <1> 						; 1 shifted from multiplier
   606 0000207F A1[3C040000]        <1> fmadc:	mov	eax, dword ptr [_INPUTR+7*4]	
   607 00002084 01461C              <1> 	add	dword ptr [esi+7*4], eax	; do not use carry
   608 00002087 A1[38040000]        <1> 	mov	eax, dword ptr [_INPUTR+6*4]
   609 0000208C 114618              <1> 	adc	dword ptr [esi+6*4], eax	; start using carry
   610 0000208F A1[34040000]        <1> 	mov	eax, dword ptr [_INPUTR+5*4]
   611 00002094 114614              <1> 	adc	dword ptr [esi+5*4], eax
   612 00002097 A1[30040000]        <1> 	mov	eax, dword ptr [_INPUTR+4*4]
   613 0000209C 114610              <1> 	adc	dword ptr [esi+4*4], eax
   614 0000209F A1[2C040000]        <1> 	mov	eax, dword ptr [_INPUTR+3*4]
   615 000020A4 11460C              <1> 	adc	dword ptr [esi+3*4], eax
   616 000020A7 A1[28040000]        <1> 	mov	eax, dword ptr [_INPUTR+2*4]
   617 000020AC 114608              <1> 	adc	dword ptr [esi+2*4], eax
   618                              <1> 
   619 000020AF FEC9                <1> fmadx:	dec	cl
   620 000020B1 759F                <1> 	jnz	fmadd
   621                              <1> 
   622 000020B3 59                  <1> 	pop	ecx
   623                              <1> 
   624 000020B4 8B4608              <1> 	mov	eax, dword ptr [esi+2*4] 	; normalised?
   625 000020B7 D1D0                <1> 	rcl	eax, 1
   626 000020B9 721B                <1> 	jc	fm_normalised
   627                              <1> 
   628 000020BB 8305[20040000]FF    <1> 	add	dword ptr [_INPUTR], -1		; take 1 from scale
   629                              <1> 
   630 000020C2 D1561C              <1> 	rcl	dword ptr [esi+7*4], 1
   631 000020C5 D15618              <1> 	rcl	dword ptr [esi+6*4], 1
   632 000020C8 D15614              <1> 	rcl	dword ptr [esi+5*4], 1
   633 000020CB D15610              <1> 	rcl	dword ptr [esi+4*4], 1
   634 000020CE D1560C              <1> 	rcl	dword ptr [esi+3*4], 1
   635 000020D1 D15608              <1> 	rcl	dword ptr [esi+2*4], 1
   636                              <1> 
   637 000020D4 EB25                <1> 	jmp	fm_inrange
   638                              <1> 
   639                              <1> fm_normalised:
   640 000020D6 BF[40040000]        <1> 	mov	edi, _OUTPUT
   641                              <1> 
   642 000020DB E841FCFFFF          <1> 	call	round2
   643                              <1> 
   644 000020E0 7319                <1> 	jnc	fm_inrange
   645 000020E2 D15E08              <1> 	rcr	dword ptr [esi+2*4], 1
   646 000020E5 D15E0C              <1> 	rcr	dword ptr [esi+3*4], 1
   647 000020E8 D15E10              <1> 	rcr	dword ptr [esi+4*4], 1
   648 000020EB D15E14              <1> 	rcr	dword ptr [esi+5*4], 1
   649 000020EE D15E18              <1> 	rcr	dword ptr [esi+6*4], 1
   650 000020F1 D15E1C              <1> 	rcr	dword ptr [esi+7*4], 1
   651 000020F4 8305[20040000]01    <1> 	add	dword ptr [_INPUTR], 1
   652                              <1> 
   653                              <1> fm_inrange:
   654                              <1> 
   655 000020FB A1[20040000]        <1> 	mov	eax, dword ptr [_INPUTR]
   656 00002100 0305[00040000]      <1> 	add	eax, dword ptr [_INPUT2]
   657 00002106 050000C0FF          <1> 	add	eax, -00400000h
   658 0000210B 8906                <1> 	mov	dword ptr [esi], eax		; insert unsigned magnitude product scale
   659 0000210D 8B4604              <1> 	mov	eax, dword ptr [esi+1*4]
   660 00002110 314608              <1> 	xor	dword ptr [esi+2*4], eax	; the mantissa gets polarised here
   661 00002113 31460C              <1> 	xor	dword ptr [esi+3*4], eax
   662 00002116 314610              <1> 	xor	dword ptr [esi+4*4], eax
   663 00002119 314614              <1> 	xor	dword ptr [esi+5*4], eax
   664 0000211C 314618              <1> 	xor	dword ptr [esi+6*4], eax
   665 0000211F 31461C              <1> 	xor	dword ptr [esi+7*4], eax
   666 00002122 C3                  <1> 	ret
   667                              <1> 
   668 00002123 BE[40040000]        <1> fd:	mov	esi, _OUTPUT
   669 00002128 E8C8FBFFFF          <1> 	call	zoutput				; result which may stay zero
   670 0000212D A1[04040000]        <1> 	mov	eax, dword ptr [_INPUT2+1*4]	; signs
   671 00002132 89C3                <1> 	mov	ebx, eax
   672 00002134 3305[08040000]      <1> 	xor	eax, dword ptr [_INPUT2+2*4]	; normalising bit 31
   673 0000213A 780C                <1> 	js	fdgo
   674 0000213C F715[44040000]      <1> 	not	dword ptr [_OUTPUT+1*4]		; divisor 0 or otherwise unnormalised
   675 00002142 E83CFDFFFF          <1> 	call	zover				; return -0.0
   676 00002147 C3                  <1> fdnop:	ret					; not normalised = zero divisor
   677                              <1> 
   678 00002148 A1[24040000]        <1> fdgo:	mov     eax, dword ptr [_INPUTR+1*4]	; make sure the dividend is present
   679 0000214D 3305[28040000]      <1> 	xor	eax, dword ptr [_INPUTR+2*4]	; normalising bit must be not sign
   680 00002153 7833                <1> 	js	fdop				; go after all
   681                              <1> 						; unnormalised = 0 = unnormalised
   682 00002155 A1[24040000]        <1> 	mov	eax, dword ptr [_INPUTR+1*4]	; read the signs I tell you
   683 0000215A C705[40040000]0000- <1> 	mov	dword ptr [_OUTPUT], 0		; exponent magnitude of nowhere
   683 00002162 0000                <1>
   684 00002164 A3[44040000]        <1> 	mov	dword ptr [_OUTPUT+1*4], eax	; signs
   685 00002169 A3[48040000]        <1> 	mov	dword ptr [_OUTPUT+2*4], eax	; and as much mantissa as you like
   686 0000216E A3[4C040000]        <1> 	mov	dword ptr [_OUTPUT+3*4], eax
   687 00002173 A3[50040000]        <1> 	mov	dword ptr [_OUTPUT+4*4], eax
   688 00002178 A3[54040000]        <1> 	mov	dword ptr [_OUTPUT+5*4], eax
   689 0000217D A3[58040000]        <1> 	mov	dword ptr [_OUTPUT+6*4], eax
   690 00002182 A3[5C040000]        <1> 	mov	dword ptr [_OUTPUT+7*4], eax
   691 00002187 C3                  <1> 	ret
   692                              <1> 
   693 00002188 21DB                <1> fdop:	and	ebx, ebx			; divisor either is negative magnitude
   694 0000218A 780A                <1> 	js	fd_comp1	
   695 0000218C BE[00040000]        <1> 	mov	esi, _INPUT2			; or shall be
   696 00002191 E8EDFCFFFF          <1> 	call	zover
   697                              <1> fd_comp1:
   698 00002196 F705[24040000]0000- <1> 	test	dword ptr [_INPUTR+1*4], 080000000h
   698 0000219E 0080                <1>
   699 000021A0 740A                <1> 	jz	fd_upright			; dividend must be positive magnitude
   700 000021A2 BE[20040000]        <1> 	mov	esi, _INPUTR
   701 000021A7 E8D7FCFFFF          <1> 	call	zover
   702                              <1> fd_upright:
   703 000021AC BF[20040000]        <1> 	mov	edi, _INPUTR
   704 000021B1 E859FBFFFF          <1> 	call	round1				; this also sets counters
   705                              <1> 
   706 000021B6 52                  <1> 	push	edx
   707 000021B7 51                  <1> 	push	ecx
   708                              <1> 
   709                              <1> ;	add	cx, 01818h		; a divide needs 24 more beats
   710                              <1> 					; than a multiply
   711                              <1> 
   712 000021B8 89C8                <1> 	mov	eax, ecx		; save words count in add range
   713 000021BA B15F                <1> 	mov	cl, 95
   714                              <1> 
   715 000021BC C1E810              <1> 	shr	eax, 16			; isolate words count in add range
   716 000021BF 6683C0FA            <1> 	add	ax, -6			; is it big?
   717 000021C3 0F838D000000        <1> 	jnc	near fd_72
   718                              <1> 
   719                              <1> ;	test	ch, 128
   720                              <1> ;	jz	near fd_72
   721                              <1> 
   722 000021C9 89E7                <1> 	mov	edi, esp
   723                              <1> 
   724 000021CB B1BF                <1> 	mov	cl, 191			; maybe
   725                              <1> 
   726 000021CD F9                  <1> fd_144:	stc				; add negative mantissa
   727 000021CE E8C3FCFFFF          <1> 	call	_add_low		; to positive dividend
   728 000021D3 52                  <1> 	push	edx			; save the low half in the stack
   729 000021D4 53                  <1> 	push	ebx
   730 000021D5 50                  <1> 	push	eax
   731 000021D6 E8DFFCFFFF          <1> 	call	_add_high			; add the high half in eax edx ebx
   732                              <1> 
   733 000021DB 7323                <1> 	jnc	fd_144level			; no carry = drop the result
   734                              <1> 
   735 000021DD A3[28040000]        <1> 	mov	dword ptr [_INPUTR+2*4], eax	; carry = update the dividend
   736 000021E2 891D[2C040000]      <1> 	mov	dword ptr [_INPUTR+3*4], ebx
   737 000021E8 8915[30040000]      <1> 	mov	dword ptr [_INPUTR+4*4], edx
   738                              <1> 
   739 000021EE 58                  <1> 	pop	eax
   740 000021EF A3[34040000]        <1> 	mov	dword ptr [_INPUTR+5*4], eax
   741 000021F4 58                  <1> 	pop	eax
   742 000021F5 A3[38040000]        <1> 	mov	dword ptr [_INPUTR+6*4], eax
   743 000021FA 58                  <1> 	pop	eax
   744 000021FB A3[3C040000]        <1> 	mov	dword ptr [_INPUTR+7*4], eax
   745                              <1> fd_144level:
   746 00002200 89FC                <1> 	mov	esp, edi			; clear stack whether popped or not
   747 00002202 D115[5C040000]      <1> 	rcl	dword ptr [_OUTPUT+7*4], 1	; shift value of carry into quotient
   748 00002208 D115[58040000]      <1> 	rcl	dword ptr [_OUTPUT+6*4], 1
   749 0000220E D115[54040000]      <1> 	rcl	dword ptr [_OUTPUT+5*4], 1
   750 00002214 D115[50040000]      <1> 	rcl	dword ptr [_OUTPUT+4*4], 1
   751 0000221A D115[4C040000]      <1> 	rcl	dword ptr [_OUTPUT+3*4], 1
   752 00002220 D115[48040000]      <1> 	rcl	dword ptr [_OUTPUT+2*4], 1
   753                              <1> 
   754 00002226 F9                  <1> 	stc
   755 00002227 D11D[08040000]      <1> 	rcr	dword ptr [_INPUT2+2*4], 1	; shift negative addend
   756 0000222D D11D[0C040000]      <1> 	rcr	dword ptr [_INPUT2+3*4], 1	; 1 position starboard
   757 00002233 D11D[10040000]      <1> 	rcr	dword ptr [_INPUT2+4*4], 1
   758 00002239 D11D[14040000]      <1> 	rcr	dword ptr [_INPUT2+5*4], 1
   759 0000223F D11D[18040000]      <1> 	rcr	dword ptr [_INPUT2+6*4], 1
   760 00002245 D11D[1C040000]      <1> 	rcr	dword ptr [_INPUT2+7*4], 1
   761                              <1> 
   762 0000224B 80C1FF              <1> 	add	cl, -1
   763 0000224E 0F8279FFFFFF        <1> 	jc	fd_144
   764 00002254 EB43                <1> 	jmp	fd_restore	
   765                              <1> 
   766 00002256 F9                  <1> fd_72:	stc					; add negative mantissa
   767 00002257 E85EFCFFFF          <1> 	call	_add_high			; to positive dividend
   768 0000225C 7311                <1> 	jnc	fd_72level			; no carry = drop the result
   769                              <1> 
   770 0000225E A3[28040000]        <1> 	mov	dword ptr [_INPUTR+2*4], eax	; carry = update the dividend
   771 00002263 891D[2C040000]      <1> 	mov	dword ptr [_INPUTR+3*4], ebx
   772 00002269 8915[30040000]      <1> 	mov	dword ptr [_INPUTR+4*4], edx
   773                              <1> fd_72level:
   774 0000226F D115[50040000]      <1> 	rcl	dword ptr [_OUTPUT+4*4], 1	; shift value of carry into quotient
   775 00002275 D115[4C040000]      <1> 	rcl	dword ptr [_OUTPUT+3*4], 1
   776 0000227B D115[48040000]      <1> 	rcl	dword ptr [_OUTPUT+2*4], 1
   777                              <1> 
   778 00002281 F9                  <1> 	stc
   779 00002282 D11D[08040000]      <1> 	rcr	dword ptr [_INPUT2+2*4], 1	; shift negative addend
   780 00002288 D11D[0C040000]      <1> 	rcr	dword ptr [_INPUT2+3*4], 1	; 1 position starboard
   781 0000228E D11D[10040000]      <1> 	rcr	dword ptr [_INPUT2+4*4], 1	;
   782                              <1> 
   783 00002294 80C1FF              <1> 	add	cl, -1
   784 00002297 72BD                <1> 	jc	fd_72
   785                              <1> 
   786 00002299 59                  <1> fd_restore:	pop	ecx
   787 0000229A 5A                  <1> 		pop	edx				; hand the program counter back
   788 0000229B A1[20040000]        <1> 		mov	eax, dword ptr [_INPUTR]	; + magnitude dividend exponent
   789 000022A0 2B05[00040000]      <1> 		sub	eax, dword ptr [_INPUT2]	; + magnitude divisor exponent
   790 000022A6 0501004000          <1> 		add	eax, 00400001h			; midpoint + 1
   791 000022AB A3[40040000]        <1> 		mov	dword ptr [_OUTPUT], eax	; magnitude of quotient scale
   792                              <1> 							; -> front of delivery string
   793                              <1> 
   794 000022B0 BF[40040000]        <1> 		mov	edi, _OUTPUT
   795                              <1> 
   796 000022B5 E83CFBFFFF          <1> 		call	renormalise
   797                              <1> 
   798 000022BA BE[40040000]        <1> 		mov	esi, _OUTPUT			; tell rewrite where it is
   799 000022BF A1[24040000]        <1> 		mov	eax, dword ptr [_INPUTR+1*4]	; determine sign of quotient
   800 000022C4 3305[04040000]      <1> 		xor	eax, dword ptr [_INPUT2+1*4]
   801 000022CA 894604              <1> 		mov	[esi+1*4], eax			; output 32 signs
   802                              <1> 							; _deliver_ polarises the quotient scale
   803 000022CD 314608              <1> 		xor	dword ptr [esi+2*4], eax	; switch quotient mantissa
   804 000022D0 31460C              <1> 		xor	dword ptr [esi+3*4], eax
   805 000022D3 314610              <1> 		xor	dword ptr [esi+4*4], eax
   806 000022D6 314614              <1> 		xor	dword ptr [esi+5*4], eax	; switch the long mantissa
   807 000022D9 314618              <1> 		xor	dword ptr [esi+6*4], eax
   808 000022DC 31461C              <1> 		xor	dword ptr [esi+7*4], eax
   809                              <1> 
   810 000022DF C3                  <1> 		ret
   811                              <1> 
   812                              <1> 	;	these instructions take the left-side + target as
   813                              <1> 	;	[register_set]->a:b:mantissa2:mantissa3
   814                              <1> 	;	and the right side as [ea]
   815                              <1> 
   816                              <1> 	;	after acquisition and before delivery they call modules
   817                              <1> ;	fa fan fm fd
   818                              <1> ;	which may be used in extended instruction sets
   819                              <1> ;	using source and target registers in the internal stack
   820                              <1> ;	with maximum mantissa size 168 bits
   821                              <1> 
   822                              <1> 
   823 000022E0 BB04000000          <1> _fa:	mov	ebx, a
   824 000022E5 53                  <1> _far:	push	ebx
   825 000022E6 E861000000          <1> 	call	fp_operands
   826 000022EB E889000000          <1> 	call	fp_registers_a
   827 000022F0 E8F9FBFFFF          <1> 	call	fa
   828 000022F5 5B                  <1> 	pop	ebx
   829 000022F6 E91DF9FFFF          <1> 	jmp	_deliver_edi
   830                              <1> 
   831 000022FB BB04000000          <1> _fan:	mov	ebx, a
   832 00002300 53                  <1> _fanr:	push	ebx
   833 00002301 E846000000          <1> 	call	fp_operands
   834 00002306 E86E000000          <1> 	call	fp_registers_a
   835 0000230B E8CEFBFFFF          <1> 	call	fan
   836 00002310 5B                  <1> 	pop	ebx
   837 00002311 E902F9FFFF          <1> 	jmp	_deliver_edi
   838                              <1> 
   839 00002316 BB04000000          <1> _fm:	mov	ebx, a
   840 0000231B 53                  <1> _fmr:	push	ebx
   841 0000231C E82B000000          <1> 	call	fp_operands
   842 00002321 E86A000000          <1> 	call	fp_registers_m
   843 00002326 E89BFCFFFF          <1> 	call	fm
   844 0000232B 5B                  <1> 	pop	ebx
   845 0000232C E9E9F8FFFF          <1> 	jmp	 _deliver_
   846                              <1> 
   847 00002331 BB04000000          <1> _fd:	mov	ebx, a				; default target register
   848 00002336 53                  <1> _fdr:	push	ebx
   849 00002337 E810000000          <1> 	call	fp_operands
   850 0000233C E84F000000          <1> 	call	fp_registers_m
   851 00002341 E8DDFDFFFF          <1> 	call	fd
   852 00002346 5B                  <1> 	pop	ebx
   853 00002347 E9CEF8FFFF          <1> 	jmp	_deliver_
   854                              <1> 
   855                              <1> fp_operands:
   856 0000234C 50                  <1> 	push	eax				; effective address often useful
   857 0000234D BE[20040000]        <1> 	mov	esi, _INPUTR
   858 00002352 E850000000          <1> 	call	_load_quad
   859 00002357 E873F8FFFF          <1> 	call	compress4to8
   860 0000235C 58                  <1> 	pop	eax				; effective address
   861 0000235D 55                  <1> 	push	ebp
   862 0000235E BD[00000000]        <1> 	mov	ebp, __register			; registers absolute array
   863 00002363 BB00010000          <1> 	mov	ebx, _input2			; if source2 is a register
   864 00002368 E88DDFFFFF          <1> 	call	_burst_read4
   865 0000236D BE[00040000]        <1> 	mov	esi, _INPUT2
   866 00002372 E858F8FFFF          <1> 	call	compress4to8
   867 00002377 5D                  <1> 	pop	ebp				; App / Int register context
   868 00002378 C3                  <1> 	ret
   869                              <1> 
   870                              <1> fp_registers_a:
   871 00002379 B908020400          <1> 	mov	ecx, 00040208h
   872 0000237E F705[00000000]0800- <1> 	test	dword ptr [_psr], FP_R
   872 00002386 0000                <1>
   873 00002388 7405                <1> 	jz	fp_registers_x
   874 0000238A B910040600          <1> 	mov	ecx, 00060410h
   875                              <1> fp_registers_x:
   876 0000238F C3                  <1> 	ret
   877                              <1> 
   878                              <1> fp_registers_m:
   879 00002390 B908020400          <1> 	mov	ecx, 00040208h
   880 00002395 F705[00000000]0800- <1> 	test	dword ptr [_psr], FP_R
   880 0000239D 0000                <1>
   881 0000239F 7405                <1> 	jz	fp_registers_z
   882 000023A1 B910040600          <1> 	mov	ecx, 00060410h
   883                              <1> fp_registers_z:
   884 000023A6 C3                  <1> 	ret
   885                              <1> 
   886                              <1> _load_quad:
   887 000023A7 8B449D0C            <1> 	mov	eax, dword ptr[ebp+ebx*4+3*4]
   888 000023AB 89460C              <1> 	mov	dword ptr [esi+3*4], eax
   889 000023AE 8B449D08            <1> 	mov	eax, dword ptr  [ebp+ebx*4+2*4]
   890 000023B2 894608              <1> 	mov	dword ptr [esi+2*4], eax
   891 000023B5 8B449D04            <1> 	mov	eax, dword ptr [ebp+ebx*4+1*4]
   892 000023B9 894604              <1> 	mov	dword ptr [esi+1*4], eax
   893 000023BC 8B449D00            <1> 	mov	eax, dword ptr [ebp+ebx*4]
   894 000023C0 8906                <1> 	mov	dword ptr [esi], eax
   895 000023C2 C3                  <1> 	ret
   896                              <1> 
    38                                  	%include	"parity.msm"
     1                              <1> _get_parity:
     2 000023C3 8B5D10              <1>         mov     ebx, dword ptr [ebp+A]
     3 000023C6 235D04              <1>         and     ebx, dword ptr [ebp+K]
     4                              <1> _fold_parity:
     5 000023C9 30DF                <1>         xor     bh, bl
     6 000023CB C1EB08              <1>         shr     ebx, 8
     7 000023CE 30FB                <1>         xor     bl, bh
     8 000023D0 C3                  <1>         ret
     9                              <1> 
    39                                  	%include	"margin.msm"
     1                              <1> read_straddle_12b?:
     2 000023D1 F6C101              <1> 	test	cl, 1				; 4 words? You are here because
     3 000023D4 7531                <1> 	jnz	split_read4w			; offset is within last 3 of page
     4                              <1> 						; 2 words then
     5 000023D6 81FEFF0F0000        <1> 	cmp	esi, 0FFFh			; starting @ last word of page?
     6 000023DC 7228                <1> 	jb	readout				; not so, go ahead with burst read
     7                              <1> 
     8                              <1> split_read2w:
     9 000023DE 893C24              <1> 	mov	dword ptr [esp], edi		; delete 1st return address + save EA
    10 000023E1 89F8                <1> 	mov	eax, edi			; recover EA
    11 000023E3 30C9                <1> 	xor	cl, cl				; request 1 word
    12 000023E5 E868DFFFFF          <1> 	call	_bus_read			;
    13 000023EA 870424              <1> 	xchg	eax, dword ptr [esp]		; save 1st word read + load updated EA
    14 000023ED 40                  <1> 	inc	eax				; advance EA onto next page
    15 000023EE 30C9                <1> 	xor	cl, cl				; request 1 word
    16 000023F0 E85DDFFFFF          <1> 	call	_bus_read			; read new page or block
    17 000023F5 89C3                <1> 	mov	ebx, eax
    18 000023F7 58                  <1> 	pop	eax				; recover 1st read word
    19 000023F8 C3                  <1> 	ret					; return to caller of operand_read
    20                              <1> 
    21                              <1> read_straddle_18b?:
    22 000023F9 F6C101              <1> 	test	cl, 1				; 4 words? You are here because 
    23 000023FC 7509                <1> 	jnz	split_read4w			; offset is within last 3 of of bank
    24                              <1> 						; 2 words then
    25 000023FE 81FEFFFF0300        <1> 	cmp	esi, 0003FFFFh			; starting @ last word of bank?
    26 00002404 73D8                <1> 	jnb	split_read2w			; otherwise fall thru to burst read
    27                              <1> 
    28                              <1> readout:
    29 00002406 C3                  <1> 	ret					; burst read in order
    30                              <1> 
    31                              <1> split_read4w:					; write EA over stack top return address
    32 00002407 893C24              <1> 	mov	dword ptr [esp], edi		; one or other of these 2-word reads
    33 0000240A 89F8                <1> 	mov	eax, edi			; splits down to 1-word reads
    34 0000240C E807000000          <1> 	call	read2				; when offset is [3F]FFD
    35 00002411 E802000000          <1> 	call	read2				;             or [3F]FFF
    36 00002416 58                  <1> 	pop	eax				;   but not when [3F]FFE
    37 00002417 C3                  <1> 	ret					; return to caller of caller
    38                              <1> 	
    39 00002418 50                  <1> read2:	push	eax				; EA
    40 00002419 53                  <1> 	push	ebx				; destination index on stack top
    41 0000241A B106                <1> 	mov	cl, 6				; ask bus for 2 words
    42 0000241C E831DFFFFF          <1> 	call	_bus_read			; replaces eax and ebx
    43 00002421 871C24              <1> 	xchg	ebx, dword ptr [esp]		; get destination index up again
    44 00002424 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax	; write 1st result word
    45 00002428 58                  <1> 	pop	eax				; recover 2nd result word
    46 00002429 89449D04            <1> 	mov	dword ptr [ebp+ebx*4+1*4], eax	; write 2nd result word
    47 0000242D 58                  <1> 	pop	eax				; EA
    48 0000242E 83C002              <1> 	add	eax, 2
    49 00002431 83C302              <1> 	add	ebx, 2
    50 00002434 C3                  <1> 	ret	
    51                              <1> 
    40                                  	%include	"margin_w.msm"
     1                              <1> write_straddle_12b?:				; multiword write request
     2                              <1> write_straddle12b?:				; in last 3 words of block
     3 00002435 F6C101              <1> 	test	cl, 1				; 4-word write request?
     4 00002438 7536                <1> 	jnz	split_write4w			;
     5 0000243A 81FEFF0F0000        <1> 	cmp	esi, 0FFFH			; 2 words then. In last word?
     6 00002440 722D                <1> 	jb	writeout			; no
     7                              <1> 						; yes
     8                              <1> split_write2w:
     9 00002442 891C24              <1> 	mov	dword ptr [esp], ebx		; not returning to there
    10 00002445 57                  <1> 	push	edi				; esp -> saved eax [ea], saved ebx
    11 00002446 89F8                <1> 	mov	eax, edi			; place ea in eax
    12 00002448 30C9                <1> 	xor	cl, cl				; request 1-word write
    13 0000244A 8B5C9D00            <1> 	mov	ebx, dword ptr [ebp+ebx*4]	; data from register array
    14 0000244E E8BCE0FFFF          <1> 	call	bus_write
    15 00002453 58                  <1> 	pop	eax				; retrieve ea from stack
    16 00002454 5B                  <1> 	pop	ebx				; retrieve register index
    17 00002455 40                  <1> 	inc	eax				; advance ea to next block
    18 00002456 8B5C9D04            <1> 	mov	ebx, dword ptr [ebp+ebx*4+4]	; data from register array
    19 0000245A 30C9                <1> 	xor	cl, cl				; request 1-word write
    20 0000245C E8AEE0FFFF          <1> 	call	bus_write
    21 00002461 C3                  <1> 	ret					; return caller of caller
    22                              <1> 
    23                              <1> write_straddle_18b?:				; multiword write request
    24                              <1> write_straddle18b?:				; in last 3 words of block
    25 00002462 F6C101              <1> 	test	cl, 1				; 4 words?
    26 00002465 7509                <1> 	jnz	split_write4w
    27 00002467 81FEFFFF0300        <1> 	cmp	esi, 0003FFFFh			; 2 words then. In last word?
    28 0000246D 73D3                <1> 	jnb	split_write2w			; yes
    29                              <1> 						; no
    30                              <1> writeout:
    31 0000246F C3                  <1> 	ret					; return to burst write
    32                              <1> 
    33                              <1> split_write4w:
    34 00002470 893C24              <1> 	mov	dword ptr [esp], edi		; return address at stack top not used
    35 00002473 89F8                <1> 	mov	eax, edi			; copy ea
    36 00002475 E807000000          <1> 	call	write2				; request 2 writes word pairs
    37 0000247A E802000000          <1> 	call	write2				; if 1 of them straddles it splits again
    38 0000247F 58                  <1> 	pop	eax				; this is ea
    39 00002480 C3                  <1> 	ret					; return to caller of caller
    40                              <1> 
    41                              <1> 
    42 00002481 B106                <1> write2:	mov	cl, 6				; request 2-word bus write
    43 00002483 50                  <1> 	push	eax				; save ea
    44 00002484 53                  <1> 	push	ebx				; save register array index
    45 00002485 E885E0FFFF          <1> 	call	bus_write			; send write pair request
    46 0000248A 5B                  <1> 	pop	ebx				; retrieve register index
    47 0000248B 58                  <1> 	pop	eax				; and ea
    48 0000248C 83C302              <1> 	add	ebx, 2				; update register index
    49 0000248F 83C002              <1> 	add	eax, 2				; and ea
    50 00002492 C3                  <1> 	ret
    41                                  	%include	"rex.msm"
     1                              <1> 
     2                              <1> _rextable_1
     2          ******************  <1>  warning: label alone on a line without a colon might be in error [-w+orphan-labels]
     3 00002493 000000000000000000- <1> 	dd	0, 0, 0, 0,		r_sa, r_sb, r_z, 0
     3 0000249C 00000000000000-     <1>
     3 000024A3 [D9270000]-         <1>
     3 000024A7 [D1270000]-         <1>
     3 000024AB [F2270000]00000000  <1>
     4 000024B3 000000000000000000- <1> 	dd	0, 0, 0, 0,		r_la, r_lb, r_tz, r_tp
     4 000024BC 00000000000000-     <1>
     4 000024C3 [0C280000]-         <1>
     4 000024C7 [04280000]-         <1>
     4 000024CB [9A270000]-         <1>
     4 000024CF [B5270000]          <1>
     5 000024D3 0000000000000000-   <1> 	dd	0, 0, r_or, r_orB,	r_and, r_andB, r_xor, r_xorB
     5 000024DB [29280000]-         <1>
     5 000024DF [21280000]-         <1>
     5 000024E3 [4A280000]-         <1>
     5 000024E7 [42280000]-         <1>
     5 000024EB [6B280000]-         <1>
     5 000024EF [63280000]          <1>
     6 000024F3 [8C280000]-         <1> 	dd	r_aa, r_ab, r_ana, r_anb, r_m, r_mf, r_d, 0
     6 000024F7 [84280000]-         <1>
     6 000024FB [A9280000]-         <1>
     6 000024FF [A1280000]-         <1>
     6 00002503 [E5280000]-         <1>
     6 00002507 [C4280000]-         <1>
     6 0000250B [8A290000]00000000  <1>
     7                              <1> 
     8                              <1> _rextable_6
     8          ******************  <1>  warning: label alone on a line without a colon might be in error [-w+orphan-labels]
     9 00002513 [C5290000]-         <1> 	dd	r_sar, r_sbr, r_dsr, 0, r_sal, r_sbl, r_dsl, 0
     9 00002517 [BD290000]-         <1>
     9 0000251B [E0290000]00000000- <1>
     9 00002523 [0B2A0000]-         <1>
     9 00002527 [032A0000]-         <1>
     9 0000252B [262A0000]00000000  <1>
    10 00002533 [512A0000]-         <1> 	dd	r_rar, r_rbr, r_drr, 0, r_ral, r_rbl, r_drl, 0
    10 00002537 [492A0000]-         <1>
    10 0000253B [6A2A0000]00000000- <1>
    10 00002543 [952A0000]-         <1>
    10 00002547 [8D2A0000]-         <1>
    10 0000254B [AE2A0000]00000000  <1>
    11 00002553 [D92A0000]-         <1> 	dd	r_saa, r_sba, r_dsa, 0, 0, 0, 0, 0
    11 00002557 [D12A0000]-         <1>
    11 0000255B [F52A0000]00000000- <1>
    11 00002563 000000000000000000- <1>
    11 0000256C 00000000000000      <1>
    12 00002573 000000000000000000- <1> 	dd	0, 0, 0, 0, 		0, 0, 0, 0
    12 0000257C 000000000000000000- <1>
    12 00002585 000000000000000000- <1>
    12 0000258E 0000000000          <1>
    13                              <1> 
    14                              <1> _rextable_7
    14          ******************  <1>  warning: label alone on a line without a colon might be in error [-w+orphan-labels]
    15 00002593 000000000000000000- <1> 	dd	0, 0, 0, 0,		0, 0, 0, 0
    15 0000259C 000000000000000000- <1>
    15 000025A5 000000000000000000- <1>
    15 000025AE 0000000000          <1>
    16 000025B3 [182B0000]-         <1> 	dd	r_qs, r_ql, r_dte, 0,	r_fa, r_fan, r_fm, r_fd
    16 000025B7 [272B0000]-         <1>
    16 000025BB [362B0000]00000000- <1>
    16 000025C3 [6A270000]-         <1>
    16 000025C7 [76270000]-         <1>
    16 000025CB [82270000]-         <1>
    16 000025CF [8E270000]          <1>
    17 000025D3 000000000000000000- <1> 	dd	0, 0, 0, 0, 		0, r_mta, 0, 0
    17 000025DC 000000000000000000- <1>
    17 000025E5 0000[4C2B0000]0000- <1>
    17 000025ED 000000000000        <1>
    18 000025F3 [6A2B0000]-         <1> 	dd	r_ds, r_dl, r_da, r_dan, 0, 0, 0, 0
    18 000025F7 [792B0000]-         <1>
    18 000025FB [AC2B0000]-         <1>
    18 000025FF [922B0000]00000000- <1>
    18 00002607 000000000000000000- <1>
    18 00002610 000000              <1>
    19                              <1> 
    20                              <1> 
    21 00002613 F605[02000000]80    <1> _rex:	test	byte ptr [_psr+2], 128
    22 0000261A 0F88E0000000        <1> 	js	near _rex_z				; ISRs can't do this
    23                              <1> 
    24 00002620 E82FE0FFFF          <1> 	call	memory_read				; ea -> instruction for repeat	
    25 00002625 A3[78040000]        <1> 	mov	dword ptr [__register+286*4], eax	; save instruction word
    26 0000262A E89ADAFFFF          <1> 	call	__ea					; get initial ea of repeated  instruction
    27 0000262F 0FB6DD              <1> 	movzx	ebx, ch					; spin-off is opcode index in ch
    28                              <1> 							; and operand type in cl
    29 00002632 80F906              <1> 	cmp	cl, 6
    30 00002635 7214                <1> 	jb	_rex_itable1
    31 00002637 7709                <1> 	ja	_rex_itable7
    32                              <1> 							; instruction list 6
    33 00002639 8B1C9D[13250000]    <1> 	mov	ebx, dword ptr [_rextable_6+ebx*4]	; shifts and jumps
    34 00002640 EB10                <1> 	jmp	_rex_evaluate
    35                              <1> 
    36                              <1> _rex_itable7:						; instruction list 7
    37 00002642 8B1C9D[93250000]    <1> 	mov	ebx, dword ptr [_rextable_7+ebx*4]	; large arithmetic
    38 00002649 EB07                <1> 	jmp	_rex_evaluate
    39                              <1> 
    40                              <1> _rex_itable1:						; instruction list 1
    41 0000264B 8B1C9D[93240000]    <1> 	mov	ebx, dword ptr [_rextable_1+ebx*4]	; single integer arithmetic
    42                              <1> 
    43                              <1> _rex_evaluate:
    44 00002652 21DB                <1> 	and	ebx, ebx				; instruction for repeat execute?
    45 00002654 0F84A6000000        <1> 	jz	near _rex_z				; no
    46 0000265A 891D[74040000]      <1> 	mov	dword ptr [__register+285*4], ebx	; yes: save execution logic pointer
    47                              <1> 
    48                              <1> 							; if repeat instruction is indexed:
    49                              <1> 							; quick lookup tag for index increment
    50 00002660 C705[70040000]0000- <1> 	mov	dword ptr [__register+284*4], 0		; default no index register referenced
    50 00002668 0000                <1>
    51 0000266A 8B1D[78040000]      <1> 	mov	ebx, dword ptr [__register+286*4]	; identify any index register tag
    52 00002670 6621DB              <1> 	and	bx, bx					; in the instruction word
    53 00002673 791A                <1> 	jns	_rex_ready				; by testing bit 15
    54 00002675 66C1EB0C            <1> 	shr	bx, 12
    55                              <1> 							; must be > indirection tags *B0+ *B1+
    56 00002679 80FB0A              <1> 	cmp	bl, 10					; pointers in storage not incremented
    57 0000267C 7211                <1> 	jb	_rex_ready				; index registers may increment
    58 0000267E 80FB0E              <1> 	cmp	bl, 14
    59 00002681 7303                <1> 	jnb	_rex_indexed				; [   fp sp ]  registers   [ 14 15 ]
    60 00002683 80E307              <1> 	and	bl, 7					; [ x y a b ]  registers [ 2 3 4 5 ]
    61                              <1> 
    62                              <1> _rex_indexed:
    63 00002686 83E30F              <1> 	and	ebx, 15					; make 32-bit index value
    64 00002689 891D[70040000]      <1> 	mov	dword ptr [__register+284*4], ebx	; write quick lookup
    65                              <1> 
    66                              <1> _rex_ready:
    67 0000268F 8B1D[34000000]      <1> 	mov	ebx, dword ptr [__register+Q]		; default target register [ q ] ->	
    68 00002695 FF15[74040000]      <1> 	call	dword ptr [__register+285*4]		; execute logic ->
    69                              <1> 
    70 0000269B A1[70040000]        <1> 	mov	eax, dword ptr [__register+284*4]	; index register tag?
    71 000026A0 6621C0              <1> 	and	ax, ax
    72 000026A3 7422                <1> 	jz	_rex_count				; no
    73                              <1> 
    74 000026A5 8B0D[5C000000]      <1> 	mov	ecx, dword ptr [__register+WDATA]
    75 000026AB 81E1FFFFFF00        <1> 	and	ecx, 00FFFFFFh				; index register increment configured?
    76 000026B1 7414                <1> 	jz	_rex_count				; no
    77                              <1> 
    78 000026B3 030C85[00000000]    <1> 	add	ecx, dword ptr [__register+eax*4]	; calculate index + increment
    79 000026BA 81E1FFFFFF00        <1> 	and	ecx, 00FFFFFFh				; 
    80 000026C0 890C85[00000000]    <1> 	mov	dword ptr [__register+eax*4], ecx	; write back to tagged index register
    81                              <1> 
    82                              <1> _rex_count:
    83 000026C7 A1[50000000]        <1> 	mov	eax, dword ptr [__register+RDATAC]
    84 000026CC 48                  <1> 	dec	eax
    85 000026CD 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
    86                              <1> 
    87 000026D2 A3[50000000]        <1> 	mov	dword ptr [__register+RDATAC], eax
    88 000026D7 A900008000          <1> 	test	eax, 00800000h
    89 000026DC 7522                <1> 	jnz	_rex_z					; reached -1 end
    90                              <1> 
    91 000026DE 66F705[00000000]C0- <1> 	test	word ptr [_indication], EXTERNAL_INDICATIONS
    91 000026E6 FF                  <1>
    92 000026E7 7405                <1> 	jz	_rex_along
    93                              <1> 
    94 000026E9 83C2FC              <1> 	add	edx, -4					; restart after
    95 000026EC EB12                <1> 	jmp	_rex_z					; yielding to interrupt
    96                              <1> 
    97                              <1> _rex_along:
    98 000026EE A1[78040000]        <1> 	mov	eax, [__register+286*4]			; instruction encoding
    99 000026F3 E8D1D9FFFF          <1> 	call	__ea
   100 000026F8 8B1D[74040000]      <1> 	mov	ebx, [__register+285*4]			; command pointer
   101 000026FE EB8F                <1> 	jmp	_rex_ready
   102 00002700 C3                  <1> _rex_z:	ret
   103                              <1> 
   104                              <1> _rex_prime_final_count:
   105 00002701 F7455000008000      <1> 	test	dword ptr [ebp+RDATAC], 00800000h
   106 00002708 7422                <1> 	jz	_rex_primed
   107 0000270A 8B5D58              <1> 	mov	ebx, dword ptr [ebp+WDATAC]
   108 0000270D 895D50              <1> 	mov	dword ptr [ebp+RDATAC], ebx
   109 00002710 C3                  <1> 	ret
   110                              <1> 
   111                              <1> _rex_prime:
   112 00002711 F7455000008000      <1> 	test	dword ptr [ebp+RDATAC], 00800000h
   113 00002718 7412                <1> 	jz	_rex_primed
   114 0000271A 8B5D58              <1> 	mov	ebx, dword ptr [ebp+WDATAC]
   115 0000271D 895D50              <1> 	mov	dword ptr [ebp+RDATAC], ebx
   116 00002720 8B5D3C              <1> 	mov	ebx, dword ptr [ebp+S_P]
   117 00002723 81E3FFFFFF00        <1> 	and	ebx, 00FFFFFFh
   118 00002729 895D34              <1> 	mov	dword ptr [ebp+Q], ebx
   119                              <1> _rex_primed:
   120 0000272C C3                  <1> 	ret
   121                              <1> 
   122                              <1> _rex_accumulate:
   123 0000272D 8B5D54              <1> 	mov	ebx, dword ptr [ebp+RDATA]
   124 00002730 035D34              <1> 	add	ebx, dword ptr [ebp+Q]
   125 00002733 81E3FFFFFF00        <1> 	and	ebx, 00FFFFFFh
   126 00002739 895D34              <1> 	mov	dword ptr [ebp+Q], ebx
   127 0000273C C3                  <1> 	ret
   128                              <1> 
   129                              <1> _rex_chex_127:
   130 0000273D E8CFFFFFFF          <1> 	call	_rex_prime
   131 00002742 83FB7F              <1> 	cmp	ebx, 127
   132 00002745 7618                <1> 	jna	_rex_chex_low
   133 00002747 EB1C                <1> 	jmp	_rex_chexit
   134                              <1> 
   135                              <1> _rex_chex_126:
   136 00002749 E8C3FFFFFF          <1> 	call	_rex_prime
   137 0000274E 83FB7E              <1> 	cmp	ebx, 126
   138 00002751 760C                <1> 	jna	_rex_chex_low
   139 00002753 EB10                <1> 	jmp	_rex_chexit
   140                              <1> 
   141                              <1> _rex_chex_124:
   142 00002755 E8B7FFFFFF          <1> 	call	_rex_prime
   143 0000275A 83FB7C              <1> 	cmp	ebx, 124
   144 0000275D 7706                <1> 	ja	_rex_chexit
   145                              <1> _rex_chex_low:
   146 0000275F 83FB18              <1> 	cmp	ebx, 24
   147 00002762 7201                <1> 	jb	_rex_chexit
   148 00002764 C3                  <1> 	ret
   149                              <1> 
   150                              <1> _rex_chexit:
   151 00002765 E97CE6FFFF          <1> 	jmp	guard_ii_authority
   152                              <1> 
   153                              <1> ;	eax = EA
   154                              <1> ;	q -> target register selected
   155                              <1> 
   156 0000276A E8E6FFFFFF          <1> r_fa:	call	_rex_chex_124
   157 0000276F E871FBFFFF          <1> 	call	_far
   158 00002774 EBB7                <1> 	jmp	_rex_accumulate
   159                              <1> 
   160 00002776 E8DAFFFFFF          <1> r_fan:	call	_rex_chex_124
   161 0000277B E880FBFFFF          <1> 	call	_fanr
   162 00002780 EBAB                <1> 	jmp	_rex_accumulate
   163                              <1> 
   164 00002782 E8CEFFFFFF          <1> r_fm:	call	_rex_chex_124
   165 00002787 E88FFBFFFF          <1> 	call	_fmr
   166 0000278C EB9F                <1> 	jmp	_rex_accumulate
   167                              <1> 
   168 0000278E E8C2FFFFFF          <1> r_fd:	call	_rex_chex_124
   169 00002793 E89EFBFFFF          <1> 	call	_fdr
   170 00002798 EB93                <1> 	jmp	_rex_accumulate
   171                              <1> 
   172 0000279A E862FFFFFF          <1> r_tz:	call	_rex_prime_final_count
   173 0000279F 80F904              <1> 	cmp	cl, 4			; may not be [ i xi ]
   174 000027A2 732C                <1> 	jnb	r_noskip		; but pointers are updated on no_op
   175 000027A4 E88DDBFFFF          <1> 	call	_operand_read
   176 000027A9 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   177 000027AE 7520                <1> 	jnz	r_noskip
   178                              <1> 
   179 000027B0 E9AB030000          <1> 	jmp	r_skipout		; stop search repeat
   180                              <1> 
   181 000027B5 E847FFFFFF          <1> r_tp:	call	_rex_prime_final_count
   182 000027BA 80F904              <1> 	cmp	cl, 4			; may not be [ i xi ]
   183 000027BD 7311                <1> 	jnb	r_noskip		; but pointers are updated on no_op
   184 000027BF E872DBFFFF          <1> 	call	_operand_read
   185 000027C4 A900008000          <1> 	test	eax, 00800000h
   186 000027C9 7505                <1> 	jnz	r_noskip
   187                              <1> 
   188 000027CB E990030000          <1> 	jmp	r_skipout		; stop search repeat
   189                              <1> 
   190 000027D0 C3                  <1> r_noskip:	ret
   191                              <1> 
   192 000027D1 E873FFFFFF          <1> r_sb:	call	_rex_chex_126
   193 000027D6 43                  <1> 	inc	ebx			; starboard lane
   194 000027D7 EB05                <1> 	jmp	r_s
   195 000027D9 E85FFFFFFF          <1> r_sa:	call	_rex_chex_127
   196 000027DE 80F904              <1> r_s:	cmp	cl, 4			; may not be [ i xi ]
   197 000027E1 7309                <1> 	jnb	r_no_op_s		; but pointers are updated 
   198 000027E3 8B5C9D00            <1> 	mov	ebx, dword ptr [ebp+ebx*4]
   199 000027E7 E8FCDCFFFF          <1> 	call	_operand_write
   200                              <1> r_no_op_s:
   201 000027EC E93CFFFFFF          <1> 	jmp	_rex_accumulate
   202 000027F1 C3                  <1> 	ret
   203                              <1> 
   204 000027F2 E80AFFFFFF          <1> r_z:	call	_rex_prime_final_count
   205 000027F7 80F904              <1> 	cmp	cl, 4			; may not be [ i xi ]
   206 000027FA 7307                <1> 	jnb	r_no_op_z		; but pointers are updated
   207 000027FC 31DB                <1> 	xor	ebx, ebx
   208 000027FE E9E5DCFFFF          <1> 	jmp	_operand_write
   209                              <1> r_no_op_z:
   210 00002803 C3                  <1> 	ret
   211                              <1> 
   212 00002804 E840FFFFFF          <1> r_lb:	call	_rex_chex_126
   213 00002809 43                  <1> 	inc	ebx			; starboard lane
   214 0000280A EB05                <1> 	jmp	r_l
   215 0000280C E82CFFFFFF          <1> r_la:	call	_rex_chex_127
   216 00002811 53                  <1> r_l:	push	ebx
   217 00002812 E81FDBFFFF          <1> 	call	_operand_read
   218 00002817 5B                  <1> 	pop	ebx
   219 00002818 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   220 0000281C E90CFFFFFF          <1> 	jmp	_rex_accumulate
   221                              <1> 
   222 00002821 E823FFFFFF          <1> r_orB:	call	_rex_chex_126
   223 00002826 43                  <1> 	inc	ebx			; starboard lane
   224 00002827 EB05                <1> 	jmp	r_OR
   225 00002829 E80FFFFFFF          <1> r_or:	call	_rex_chex_127
   226 0000282E 53                  <1> r_OR:	push	ebx
   227 0000282F E802DBFFFF          <1> 	call	_operand_read
   228 00002834 5B                  <1> 	pop	ebx
   229 00002835 0B449D00            <1> 	or	eax, dword ptr [ebp+ebx*4]
   230 00002839 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   231 0000283D E9EBFEFFFF          <1> 	jmp	_rex_accumulate
   232                              <1> 
   233 00002842 E802FFFFFF          <1> r_andB:	call	_rex_chex_126
   234 00002847 43                  <1> 	inc	ebx		; starboard lane
   235 00002848 EB05                <1> 	jmp	r_AND
   236 0000284A E8EEFEFFFF          <1> r_and:	call	_rex_chex_127
   237 0000284F 53                  <1> r_AND:	push	ebx
   238 00002850 E8E1DAFFFF          <1> 	call	_operand_read
   239 00002855 5B                  <1> 	pop	ebx
   240 00002856 23449D00            <1> 	and	eax, dword ptr [ebp+ebx*4]
   241 0000285A 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   242 0000285E E9CAFEFFFF          <1> 	jmp	_rex_accumulate
   243                              <1> 
   244 00002863 E8E1FEFFFF          <1> r_xorB:	call	_rex_chex_126
   245 00002868 43                  <1> 	inc	ebx		; starboard lane
   246 00002869 EB05                <1> 	jmp	r_XOR
   247 0000286B E8CDFEFFFF          <1> r_xor:	call	_rex_chex_127
   248 00002870 53                  <1> r_XOR:	push	ebx
   249 00002871 E8C0DAFFFF          <1> 	call	_operand_read
   250 00002876 5B                  <1> 	pop	ebx
   251 00002877 33449D00            <1> 	xor	eax, dword ptr [ebp+ebx*4]
   252 0000287B 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   253 0000287F E9A9FEFFFF          <1> 	jmp	_rex_accumulate
   254                              <1> 
   255 00002884 E8C0FEFFFF          <1> r_ab:	call	_rex_chex_126
   256 00002889 43                  <1> 	inc	ebx		; starboard lane
   257 0000288A EB05                <1> 	jmp	r_a
   258 0000288C E8ACFEFFFF          <1> r_aa:	call	_rex_chex_127
   259 00002891 53                  <1> r_a:	push	ebx
   260 00002892 E89FDAFFFF          <1> 	call	_operand_read
   261 00002897 5F                  <1> 	pop	edi
   262 00002898 0344BD00            <1> 	add	eax, dword ptr [ebp+edi*4]
   263 0000289C E92C030000          <1> 	jmp	r_store_carry
   264                              <1> 
   265 000028A1 E8A3FEFFFF          <1> r_anb:	call	_rex_chex_126
   266 000028A6 43                  <1> 	inc	ebx		; starboard lane
   267 000028A7 EB05                <1> 	jmp	r_an
   268 000028A9 E88FFEFFFF          <1> r_ana:	call	_rex_chex_127
   269 000028AE 53                  <1> r_an:	push	ebx
   270 000028AF E882DAFFFF          <1> 	call	_operand_read
   271 000028B4 5F                  <1> 	pop	edi
   272 000028B5 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   273 000028BA 40                  <1> 	inc	eax
   274 000028BB 0344BD00            <1> 	add	eax, dword ptr [ebp+edi*4]
   275 000028BF E909030000          <1> 	jmp	r_store_carry
   276                              <1> 
   277 000028C4 E874FEFFFF          <1> r_mf:	call    _rex_chex_127
   278 000028C9 52                  <1> 	push	edx
   279 000028CA 53                  <1> 	push	ebx
   280 000028CB E866DAFFFF          <1> 	call	_operand_read
   281 000028D0 5F                  <1> 	pop	edi
   282 000028D1 0FAF44BD00          <1> 	imul	eax, dword ptr [ebp+edi*4]
   283 000028D6 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   284 000028DB 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
   285 000028DF 5A                  <1> 	pop	edx
   286 000028E0 E948FEFFFF          <1> 	jmp	_rex_accumulate
   287                              <1> 
   288                              <1> ; use the platform unsigned multiply
   289                              <1> ; work in positive magnitude
   290                              <1> ; adjust the final sign after offset-adding products
   291                              <1> 
   292 000028E5 E85FFEFFFF          <1> r_m:	call	_rex_chex_126
   293 000028EA 52                  <1> 	push	edx
   294 000028EB 53                  <1> 	push	ebx			; register stack cursor
   295 000028EC E845DAFFFF          <1> 	call	_operand_read
   296 000028F1 5F                  <1> 	pop	edi			; recover register stack cursor
   297                              <1> 
   298 000028F2 31C9                <1> 	xor	ecx, ecx		; final sign
   299 000028F4 A900008000          <1> 	test	eax, 00800000h		;
   300 000028F9 740D                <1> 	jz	r_msigu?		; negative multiplier?
   301 000028FB F7D1                <1> 	not	ecx			; final sign reverse
   302 000028FD 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   303 00002902 40                  <1> 	inc	eax			; 2s complement
   304 00002903 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   305                              <1> 
   306                              <1> r_msigu?:
   307 00002908 89C3                <1> 	mov	ebx, eax		; multiplier 2b used twice
   308 0000290A 8B44BD00            <1> 	mov	eax, dword ptr [ebp+edi*4]
   309 0000290E A900008000          <1> 	test	eax, 00800000h		; multiply high order part 1st
   310 00002913 7426                <1> 	jz	r_mgoferit_yall
   311                              <1> 
   312 00002915 F7D1                <1> 	not	ecx			; final sign reverse
   313 00002917 8B54BD04            <1> 	mov	edx, dword ptr [ebp+edi*4+4]
   314 0000291B 81F2FFFFFF00        <1> 	xor	edx, 00FFFFFFh
   315 00002921 42                  <1> 	inc	edx			; 2s complement
   316 00002922 C1C208              <1> 	rol	edx, 8
   317 00002925 0FB6F2              <1> 	movzx	esi, dl
   318 00002928 C1EA08              <1> 	shr	edx, 8
   319 0000292B 8954BD04            <1> 	mov	dword ptr [ebp+edi*4+4], edx
   320 0000292F 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh		; ms register long multiplicand
   321 00002934 01F0                <1> 	add	eax, esi
   322 00002936 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   323                              <1> 
   324                              <1> r_mgoferit_yall:
   325 0000293B F7E3                <1> 	mul	ebx			; multiply high order part
   326 0000293D 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax	; save lower half of product
   327 00002941 8B44BD04            <1> 	mov	eax, dword ptr [ebp+edi*4+4]	; multiply low order part
   328 00002945 F7E3                <1> 	mul	ebx
   329 00002947 C1E208              <1> 	shl	edx, 8			; 8 bits of eax must shift up to edx
   330 0000294A C1C008              <1> 	rol	eax, 8
   331 0000294D 88C2                <1> 	mov	dl, al
   332 0000294F C1E808              <1> 	shr	eax, 8			; leaving 8 zeros in eax high end
   333 00002952 0354BD00            <1> 	add	edx, dword ptr [ebp+edi*4]	; add2 lower half of 1st product
   334 00002956 21C9                <1> 	and	ecx, ecx		; final sign?
   335 00002958 7917                <1> 	jns	r_m_writeback
   336                              <1> 
   337 0000295A 81F2FFFFFF00        <1> 	xor	edx, 00FFFFFFh
   338 00002960 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   339 00002965 40                  <1> 	inc	eax			; 2s complement
   340 00002966 C1C008              <1> 	rol	eax, 8			; carried out single bit?
   341 00002969 0FB6F0              <1> 	movzx	esi, al			; must add to edx
   342 0000296C C1E808              <1> 	shr	eax, 8
   343 0000296F 01F2                <1> 	add	edx, esi
   344                              <1> 
   345                              <1> r_m_writeback:
   346 00002971 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   347 00002976 81E2FFFFFF00        <1> 	and	edx, 00FFFFFFh
   348 0000297C 8944BD04            <1> 	mov	dword ptr [ebp+edi*4+4], eax	
   349 00002980 8954BD00            <1> 	mov	dword ptr [ebp+edi*4], edx
   350 00002984 5A                  <1> 	pop	edx
   351 00002985 E9A3FDFFFF          <1> 	jmp	_rex_accumulate
   352                              <1> 
   353 0000298A E8BAFDFFFF          <1> r_d:	call	_rex_chex_126
   354 0000298F 89DF                <1> 	mov	edi, ebx		; register cursor
   355 00002991 E868EDFFFF          <1> 	call	_divide
   356 00002996 895CBD04            <1> 	mov	dword ptr [ebp+edi*4+4], ebx
   357 0000299A 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
   358 0000299E F605[00000000]08    <1> 	test	byte ptr [_psr], FP_R
   359 000029A5 0F8482FDFFFF        <1> 	jz	_rex_accumulate
   360 000029AB 83FF7D              <1> 	cmp	edi, 125
   361 000029AE 0F8779FDFFFF        <1> 	ja	_rex_accumulate
   362 000029B4 894CBD08            <1> 	mov	dword ptr [ebp+edi*4+8], ecx
   363 000029B8 E970FDFFFF          <1> r_dnor:	jmp	_rex_accumulate
   364                              <1> 
   365 000029BD E887FDFFFF          <1> r_sbr:	call	_rex_chex_126
   366 000029C2 43                  <1> 	inc	ebx		; starboard lane
   367 000029C3 EB05                <1> 	jmp	r_lsr
   368 000029C5 E873FDFFFF          <1> r_sar:	call	_rex_chex_127
   369 000029CA 88C1                <1> r_lsr	mov	cl, al
   370 000029CC 8B449D00            <1> 	mov	eax, dword ptr [ebp+ebx*4]
   371 000029D0 D3E8                <1> 	shr	eax, cl
   372 000029D2 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   373 000029D7 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   374 000029DB E94DFDFFFF          <1> 	jmp	_rex_accumulate
   375                              <1> 
   376 000029E0 E864FDFFFF          <1> r_dsr:	call	_rex_chex_126
   377 000029E5 88C1                <1> 	mov	cl, al
   378 000029E7 89DF                <1> 	mov	edi, ebx
   379 000029E9 8B44BD00            <1> 	mov	eax, dword ptr [ebp+edi*4]
   380 000029ED 8B5CBD04            <1> 	mov	ebx, dword ptr [ebp+edi*4+4]
   381 000029F1 E849EEFFFF          <1> 	call	dsr
   382 000029F6 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
   383 000029FA 895CBD04            <1> 	mov	dword ptr [ebp+edi*4+4], ebx
   384 000029FE E92AFDFFFF          <1> 	jmp	_rex_accumulate
   385                              <1> 
   386 00002A03 E841FDFFFF          <1> r_sbl:	call	_rex_chex_126
   387 00002A08 43                  <1> 	inc	ebx		; starboard lane
   388 00002A09 EB05                <1> 	jmp	r_lsl
   389 00002A0B E82DFDFFFF          <1> r_sal:	call	_rex_chex_127
   390 00002A10 88C1                <1> r_lsl:	mov	cl, al
   391 00002A12 8B449D00            <1> 	mov	eax, dword ptr [ebp+ebx*4]
   392 00002A16 D3E0                <1> 	shl	eax, cl
   393 00002A18 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   394 00002A1D 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   395 00002A21 E907FDFFFF          <1> 	jmp	_rex_accumulate
   396                              <1> 
   397 00002A26 E81EFDFFFF          <1> r_dsl:	call	_rex_chex_126
   398 00002A2B 88C1                <1> 	mov	cl, al
   399 00002A2D 89DF                <1> 	mov	edi, ebx
   400 00002A2F 8B44BD00            <1> 	mov	eax, dword ptr [ebp+edi*4]
   401 00002A33 8B5CBD04            <1> 	mov	ebx, dword ptr [ebp+edi*4+4]
   402 00002A37 E838EEFFFF          <1> 	call	dsl
   403 00002A3C 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
   404 00002A40 895CBD04            <1> 	mov	dword ptr [ebp+edi*4+4], ebx
   405 00002A44 E9E4FCFFFF          <1> 	jmp	_rex_accumulate
   406                              <1> 
   407 00002A49 E8FBFCFFFF          <1> r_rbr:	call	_rex_chex_126
   408 00002A4E 43                  <1> 	inc	ebx		; starboard lane
   409 00002A4F EB05                <1> 	jmp	r_rr
   410 00002A51 E8E7FCFFFF          <1> r_rar:	call	_rex_chex_127
   411 00002A56 89DF                <1> r_rr:	mov	edi, ebx
   412 00002A58 8B5CBD00            <1> 	mov	ebx, dword ptr [ebp+edi*4]
   413 00002A5C E880EEFFFF          <1> 	call	rr
   414 00002A61 895CBD00            <1> 	mov	dword ptr [ebp+edi*4], ebx
   415 00002A65 E9C3FCFFFF          <1> 	jmp	_rex_accumulate
   416                              <1> 
   417 00002A6A E8DAFCFFFF          <1> r_drr:	call	_rex_chex_126
   418 00002A6F 88C1                <1> 	mov	cl, al
   419 00002A71 89DF                <1> 	mov	edi, ebx
   420 00002A73 8B44BD00            <1> 	mov	eax, dword ptr [ebp+edi*4]
   421 00002A77 8B5CBD04            <1> 	mov	ebx, dword ptr [ebp+edi*4+4]
   422 00002A7B E8AFEEFFFF          <1> 	call	drr
   423 00002A80 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
   424 00002A84 895CBD04            <1> 	mov	dword ptr [ebp+edi*4+4], ebx
   425 00002A88 E9A0FCFFFF          <1> 	jmp	_rex_accumulate
   426                              <1> 
   427 00002A8D E8B7FCFFFF          <1> r_rbl:	call	_rex_chex_126
   428 00002A92 43                  <1> 	inc	ebx		; starboard lane
   429 00002A93 EB05                <1> 	jmp	r_rl
   430 00002A95 E8A3FCFFFF          <1> r_ral:	call	_rex_chex_127
   431 00002A9A 89DF                <1> r_rl:	mov	edi, ebx
   432 00002A9C 8B5CBD00            <1> 	mov	ebx, dword ptr [ebp+edi*4]
   433 00002AA0 E862EEFFFF          <1> 	call	rl
   434 00002AA5 895CBD00            <1> 	mov	dword ptr [ebp+edi*4], ebx
   435 00002AA9 E97FFCFFFF          <1> 	jmp	_rex_accumulate
   436                              <1> 
   437 00002AAE E896FCFFFF          <1> r_drl:	call	_rex_chex_126
   438 00002AB3 88C1                <1> 	mov	cl, al
   439 00002AB5 89DF                <1> 	mov	edi, ebx
   440 00002AB7 8B44BD00            <1> 	mov	eax, dword ptr [ebp+edi*4]
   441 00002ABB 8B5CBD04            <1> 	mov	ebx, dword ptr [ebp+edi*4+4]
   442 00002ABF E8C1EEFFFF          <1> 	call	drl
   443 00002AC4 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
   444 00002AC8 895CBD04            <1> 	mov	dword ptr [ebp+edi*4+4], ebx
   445 00002ACC E95CFCFFFF          <1> 	jmp	_rex_accumulate
   446                              <1> 
   447 00002AD1 E873FCFFFF          <1> r_sba:	call	_rex_chex_126
   448 00002AD6 43                  <1> 	inc	ebx		; starboard lane
   449 00002AD7 EB05                <1> 	jmp	r_asr
   450 00002AD9 E85FFCFFFF          <1> r_saa:	call	_rex_chex_127
   451 00002ADE 88C1                <1> r_asr:	mov	cl, al
   452 00002AE0 8B449D00            <1> 	mov	eax, dword ptr [ebp+ebx*4]
   453 00002AE4 C1E008              <1> 	shl	eax, 8
   454 00002AE7 D3F8                <1> 	sar	eax, cl
   455 00002AE9 C1E808              <1> 	shr	eax, 8
   456 00002AEC 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   457 00002AF0 E938FCFFFF          <1> 	jmp	_rex_accumulate
   458                              <1> 
   459 00002AF5 E84FFCFFFF          <1> r_dsa:	call	_rex_chex_126
   460 00002AFA 88C1                <1> 	mov	cl, al
   461 00002AFC 89DF                <1> 	mov	edi, ebx
   462 00002AFE 8B44BD00            <1> 	mov	eax, dword ptr [ebp+edi*4]
   463 00002B02 8B5CBD04            <1> 	mov	ebx, dword ptr [ebp+edi*4+4]
   464 00002B06 E8A0EDFFFF          <1> 	call	dsa
   465 00002B0B 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
   466 00002B0F 895CBD04            <1> 	mov	dword ptr [ebp+edi*4+4], ebx
   467 00002B13 E915FCFFFF          <1> 	jmp	_rex_accumulate
   468                              <1> 
   469 00002B18 E838FCFFFF          <1> r_qs:	call	_rex_chex_124
   470 00002B1D E838D9FFFF          <1> 	call	_burst_write4	; eax -> ea / ebx -> register cursor
   471 00002B22 E906FCFFFF          <1> 	jmp	_rex_accumulate
   472                              <1> 
   473 00002B27 E829FCFFFF          <1> r_ql:	call	_rex_chex_124
   474 00002B2C E8C9D7FFFF          <1> 	call	_burst_read4	; eax -> ea / ebx -> register cursor
   475 00002B31 E9F7FBFFFF          <1> 	jmp	_rex_accumulate
   476                              <1> 
   477 00002B36 E8C6FBFFFF          <1> r_dte:	call	_rex_prime_final_count
   478 00002B3B E89ED7FFFF          <1> 	call	_burst_read2
   479 00002B40 334510              <1> 	xor	eax, dword ptr [ebp+A]
   480 00002B43 7524                <1> 	jnz	r_mtax
   481 00002B45 335D14              <1> 	xor	ebx, dword ptr [ebp+B]
   482 00002B48 751F                <1> 	jnz	r_mtax
   483 00002B4A EB14                <1> 	jmp	r_skipout		; stop search repeat
   484                              <1> 
   485 00002B4C E8B0FBFFFF          <1> r_mta:	call	_rex_prime_final_count
   486 00002B51 B100                <1> 	mov	cl, 0		; operand size 1 word
   487 00002B53 E8DED7FFFF          <1> 	call	_operand_read
   488 00002B58 334510              <1> 	xor	eax, dword ptr [ebp+A]
   489 00002B5B 234504              <1> 	and	eax, dword ptr [ebp+K]
   490 00002B5E 7509                <1> 	jnz	r_mtax
   491                              <1> 
   492                              <1> r_skipout:				; stop search repeat
   493 00002B60 83C204              <1> 	add	edx, 4
   494 00002B63 8BA57C040000        <1> 	mov	esp, dword ptr [ebp+287*4]
   495 00002B69 C3                  <1> r_mtax:	ret
   496                              <1> 
   497 00002B6A E8DAFBFFFF          <1> r_ds:	call	_rex_chex_126
   498 00002B6F E83AD9FFFF          <1> 	call	_burst_write2	; eax -> ea / ebx -> register cursor
   499 00002B74 E9B4FBFFFF          <1> 	jmp	_rex_accumulate
   500                              <1> 
   501 00002B79 E8CBFBFFFF          <1> r_dl:	call	 _rex_chex_126
   502 00002B7E 53                  <1> 	push	ebx
   503 00002B7F E85AD7FFFF          <1> 	call	_burst_read2
   504 00002B84 5F                  <1> 	pop	edi
   505 00002B85 895CBD04            <1> 	mov	dword ptr [ebp+edi*4+4], ebx
   506 00002B89 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
   507 00002B8D E99BFBFFFF          <1> 	jmp	_rex_accumulate
   508                              <1> 
   509 00002B92 E8B2FBFFFF          <1> r_dan:	call	 _rex_chex_126
   510 00002B97 53                  <1> 	push	ebx
   511 00002B98 E841D7FFFF          <1> 	call	_burst_read2
   512 00002B9D 5F                  <1> 	pop	edi
   513 00002B9E 81F3FFFFFF00        <1> 	xor	ebx, 00FFFFFFh
   514 00002BA4 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   515 00002BA9 43                  <1> 	inc	ebx
   516 00002BAA EB0C                <1> 	jmp	r_danad
   517                              <1> 
   518 00002BAC E898FBFFFF          <1> r_da:	call	 _rex_chex_126
   519 00002BB1 53                  <1> 	push	ebx
   520 00002BB2 E827D7FFFF          <1> 	call	_burst_read2
   521 00002BB7 5F                  <1> 	pop	edi
   522                              <1> 
   523                              <1> r_danad:
   524 00002BB8 035CBD04            <1> 	add	ebx, dword ptr [ebp+edi*4+4]
   525 00002BBC C1E308              <1> 	shl	ebx, 8
   526 00002BBF 83D000              <1> 	adc	eax, 0
   527 00002BC2 C1EB08              <1> 	shr	ebx, 8
   528 00002BC5 895CBD04            <1> 	mov	dword ptr [ebp+edi*4+4], ebx
   529 00002BC9 0344BD00            <1> 	add	eax, dword ptr [ebp+edi*4]
   530                              <1> 
   531                              <1> r_store_carry:
   532 00002BCD E81BEFFFFF          <1> 	call	_alu_carry
   533 00002BD2 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
   534 00002BD6 E952FBFFFF          <1> 	jmp	_rex_accumulate
   535                              <1> 	
    42                                  					; data follows here
    43                                  					; if it is in this assembly
    44                                  	%if	RTA_MBANKS
    45                                  
    46                                  	section		.data
    47                                  	%include	"rta_data.msm"
    48                                  
    49                                  	section		.bss
    50                                  _memory	resd	MEMORY
    51                                  
    52                                  	%endif
    53                                  
    54                                  	end
    54          ******************       warning: label alone on a line without a colon might be in error [-w+orphan-labels]
    55                                  
