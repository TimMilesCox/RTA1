     1                                  
     2                                  	%include	"rta_x86n.def"
     1                              <1> 
     2                              <1> __SMP		equ	8
     3                              <1> 
     4                              <1> TIME_UPDATE	equ     1
     5                              <1> LOCKSTEP	equ	2
     6                              <1> BREAKPOINT	equ	4
     7                              <1> CHILLDOWN	equ	8
     8                              <1> TOUCHPOINT	equ	16
     9                              <1> 
    10                              <1> EXTERNAL_INTERRUPT 	equ	00FF00h
    11                              <1> ATTENTION		equ	128
    12                              <1> INCREMENTER_CARRY	equ	64
    13                              <1> TPULSE			equ	32
    14                              <1> 
    15                              <1> 		%if	DRANG & 2
    16                              <1> INDICATIONS	equ	CHILLDOWN|TIME_UPDATE|LOCKSTEP
    17                              <1> 		%else
    18                              <1> INDICATIONS	equ	CHILLDOWN|TIME_UPDATE|LOCKSTEP|BREAKPOINT
    19                              <1> 		%endif
    20                              <1> 
    21                              <1> EXTERNAL_INDICATIONS equ EXTERNAL_INTERRUPT|ATTENTION|INCREMENTER_CARRY|TPULSE
    22                              <1> 
    23                              <1> IO_PORTS	equ	192
    24                              <1> 
    25                              <1> 	%if	RTA_MBANKS
    26                              <1> global	_metric
    27                              <1> global	_indication
    28                              <1> global	_iselect
    29                              <1> global	_iselectu
    30                              <1> global	_readout
    31                              <1> global	_readoutx
    32                              <1> global	_readoutp
    33                              <1> global	_psr
    34                              <1> global	_apc
    35                              <1> global	_apcz
    36                              <1> global	_breakpoint
    37                              <1> global	_b0_name
    38                              <1> global	_b0p
    39                              <1> global	_devices
    40                              <1> global	_base
    41                              <1> global	_register_set
    42                              <1> global	__register
    43                              <1> global	_memory
    44                              <1> 
    45                              <1> 	%if	RTA_MBANKS<1
    46                              <1> RTA_MPAGES	equ	32
    47                              <1> 	%else
    48                              <1> RTA_MPAGES	equ	RTA_MBANKS*64
    49                              <1> 	%endif
    50                              <1> 
    51                              <1> 	%else
    52                              <1> ;	extern	_metric
    53                              <1> extern	_general_indication
    54                              <1> ;	extern	_iselect
    55                              <1> ;	extern	_iselectu
    56                              <1> ;	extern	_psr
    57                              <1> ;	extern	_apc
    58                              <1> ;	extern	_apcu
    59                              <1> ;	extern	_apcz
    60                              <1> 
    61                              <1> extern	_breakpoint
    62                              <1> extern	_touchpoint
    63                              <1> extern	_touchpoint2
    64                              <1> 
    65                              <1> ;	extern	_b0_name
    66                              <1> ;	extern	_b0p
    67                              <1> extern	_devices
    68                              <1> ;	extern	_base
    69                              <1> ;	extern	_register_set
    70                              <1> ;	extern	__register
    71                              <1> extern	_memory
    72                              <1> 
    73                              <1> _output equ     272
    74                              <1> _inputr equ     264
    75                              <1> _input2 equ     256
    76                              <1> 
    77                              <1> _OUTPUT	equ	_output*4
    78                              <1> _INPUTR	equ	_inputr*4
    79                              <1> _INPUT2 equ	_input2*4
    80                              <1> _BIAS	equ	_OUTPUT
    81                              <1> 
    82                              <1> 	%endif
    83                              <1> 
    84                              <1> 	extern	_flag
    85                              <1> 	extern	_uflag
    86                              <1> 
    87                              <1> HALF_W	equ	128
    88                              <1> FP_R	equ	8
    89                              <1> B_STREAMZR  equ 64
    90                              <1> B_STREAM16R equ 32
    91                              <1> B_STREAM16W equ 16
    92                              <1> 
    93                              <1> r	equ	0
    94                              <1> k	equ	1
    95                              <1> x	equ	2
    96                              <1> y	equ	3
    97                              <1> a	equ	4
    98                              <1> b	equ	5
    99                              <1> mantissa2 equ	6
   100                              <1> mantissa3 equ	7
   101                              <1> residue	equ	8
   102                              <1> p	equ	12
   103                              <1> q	equ	13
   104                              <1> fp	equ	14
   105                              <1> s_p	equ	15
   106                              <1> 
   107                              <1> rdatac	equ	20
   108                              <1> rdata	equ	21
   109                              <1> wdatac	equ	22
   110                              <1> wdata	equ	23
   111                              <1> 
   112                              <1> 
   113                              <1> fp_guard equ	128+19
   114                              <1> 
   115                              <1> rt_clock equ	128+20
   116                              <1> priority equ	128+21
   117                              <1> dayclock_u equ	128+22
   118                              <1> dayclock equ	128+23
   119                              <1> 
   120                              <1> R	equ	r*4
   121                              <1> K	equ	k*4
   122                              <1> X	equ	x*4
   123                              <1> Y	equ	y*4
   124                              <1> A	equ	a*4
   125                              <1> B	equ	b*4
   126                              <1> MANTISSA2 equ	mantissa2*4
   127                              <1> MANTISSA3 equ	mantissa3*4
   128                              <1> RESIDUE	equ	residue*4
   129                              <1> 
   130                              <1> P	equ	p*4
   131                              <1> Q	equ	q*4
   132                              <1> FP	equ	fp*4
   133                              <1> S_P	equ	s_p*4
   134                              <1> 
   135                              <1> RDATAC	equ	rdatac*4
   136                              <1> RDATA	equ	rdata*4
   137                              <1> WDATAC	equ	wdatac*4
   138                              <1> WDATA	equ	wdata*4
   139                              <1> 
   140                              <1> FP_GUARD equ	fp_guard*4
   141                              <1> 
   142                              <1> RT_CLOCK equ	rt_clock*4
   143                              <1> PRIORITY equ	priority*4
   144                              <1> DAYCLOCK_U equ	dayclock_u*4
   145                              <1> DAYCLOCK equ	dayclock*4
   146                              <1> 
   147                              <1> I	equ	4
   148                              <1> XI	equ	5
   149                              <1> 
   150                              <1> DEVICE  equ	32768
   151                              <1> SYSMEM  equ	16384
   152                              <1> DATA16  equ	1
   153                              <1> FSYS24  equ	2
   154                              <1> 
   155                              <1> II_GUARD equ	64+31
   156                              <1> II_EXIT	equ	64+6
   157                              <1> II_YIELD equ	64+1
   158                              <1> II_SPAWN equ	64+2
   159                              <1> II_BANK equ	64+3
   160                              <1> II_ARRAY equ	64+4
   161                              <1> II_BANK_FREE equ 64+5
   162                              <1> II_TWAIT equ	64+27
   163                              <1> II_EVENT_WAIT equ 64+28
   164                              <1> II_FPXPO equ	0+3
   165                              <1> 
   166                              <1> II_XINT		equ	0+2
   167                              <1> II_MSECOND	equ	0+4
   168                              <1> II_ATTENTION	equ	0+5
   169                              <1> 
   170                              <1> LP_AUTHORITY	equ	1		; latent parameters GUARD$
   171                              <1> LP_ADDRESS	equ	14
   172                              <1> 
   173                              <1> LP_TIMESLICE	equ	10		; latent parameter timeslice -> yield
   174                              <1> LP_RANGE	equ	12		; latent parameter FP$XPO
   175                              <1> LP_AUTOEXIT	equ	11		; latent parameter return -> EXIT$
     3                                  	%include	"rta_smp.def"
     1                              <1> __POINTER	equ	4
     2                              <1> 
     3                              <1> REGISTER	equ	0			; /*	288	int	*/
     4                              <1> 
     5                              <1> APC		equ	REGISTER+288*4		; /*	1	->	*/
     6                              <1> APCZ		equ	APC+__POINTER		; /*	1	->	*/
     7                              <1> B0P		equ	APCZ+__POINTER		; /*	1	->	*/
     8                              <1> REGISTER_SET	equ	B0P+__POINTER 
     9                              <1> 
    10                              <1> RESTART_VECTOR	equ	REGISTER_SET+__POINTER	; /*	1	int	*/
    11                              <1> INDICATION	equ	RESTART_VECTOR+4	; /*	1	int	*/	
    12                              <1> LATENT_PARAMETER equ	INDICATION+4		; /*	1	int	*/
    13                              <1> ISELECT		equ	LATENT_PARAMETER+4	; /*	1	int	*/	
    14                              <1> 
    15                              <1> PSR		equ	ISELECT+4		; /*	1	int	*/
    16                              <1> B0_NAME		equ	PSR+4			; /*	1	int	*/
    17                              <1> B0_SCOPE	equ	B0_NAME+4		; /*	1	int	*/
    18                              <1> 
    19                              <1> spare		equ	B0_SCOPE+4		; align with C structure
    20                              <1> 						; and align  metric block 
    21                              <1> 
    22                              <1> DELTA		equ	spare+4			; /*	1	int	*/
    23                              <1> __METRIC	equ	DELTA+4			; /*	1	int	*/
    24                              <1> 
    25                              <1> DELTA_BASE	equ	__METRIC+4		; /*	1	long	*/
    26                              <1> TOTAL_DELTA	equ	DELTA_BASE+8		; /*	1	long	*/
    27                              <1> TOTAL_METRIC	equ	TOTAL_DELTA+8		; /*	1	long	*/
    28                              <1> 
    29                              <1> IO_PORT		equ	TOTAL_METRIC+8		; /*	192	int	*/
    30                              <1> DATAFRAME	equ	IO_PORT+192*4		; /*	nothing		*/
    31                              <1> 
    32                              <1> CORE_SIZE	equ	DATAFRAME+0
    33                              <1> 
    34                              <1> 		%if	0
    35                              <1> CORE_INDEX2	equ	4*280
    36                              <1> CORE_INDEX1	equ	4*(280-128)
    37                              <1> 		%endif
     4                                  	%include	"io.def"
     1                              <1> 
     2                              <1> ;	_NAMES of ports as referenced in implementation or emulation 
     3                              <1> 
     4                              <1> _CORE_PIN		equ	73*4	; read-only port 1 */ _CORE_SOCKET
     5                              <1> 
     6                              <1> _XI_PENDING		equ	74*4	; mask of external interrupt sources
     7                              <1> _XI_ACK			equ	75*4	; writeable ack to quench pending signals
     8                              <1> _INCREMENTER_RESTART	equ	76*4
     9                              <1> _CORE_SOCKET		equ	77*4	; socket index this core read only
    10                              <1> 
    11                              <1> _MCAST_PENDING		equ	78*4	; mask of cores which have multicast to here
    12                              <1> _MCAST_TO		equ	79*4	; -> latent parameter
    13                              <1> 					; destinations mask in register k
    14                              <1> _TZONE			equ	101*4
    15                              <1> 
    16                              <1> _APP_THRESHOLD		equ	72*4	; lowest application code page / limit ISRs
    17                              <1> _INDICATE		equ	102*4	; control commands powersave + others
    18                              <1> _CHILLDOWN		equ	103*4	; powersave microseconds
    19                              <1> 
    20                              <1> _SYS_SWITCH		equ	126*4	; if a switch block is connected
    21                              <1> _SYS_LEDS		equ	127*4	; if a LEDs block is connected
    22                              <1> 
    23                              <1> _DEVICE			equ	128*4	; descriptors 64 devices starting executable space
    24                              <1> _RAM_THRESHOLD		equ	124*4	; 1st writeable page executable space
    25                              <1> _IFRAME_U		equ	64*4	; highest page instruction frame B0 + iframe pages - 1
    26                              <1> 
    27                              <1> _I_DATA			equ	80*4	; external data read port
    28                              <1> _O_DATA			equ	88*4	; external daza write port
    29                              <1> 
    30                              <1> _CORES_MASK		equ	125*4	; bit map cores present +(1*/RTA_SMP)-1
     5                                  
     6                                  ;	this is not PIC code
     7                                  ;	but does relative jumps for compactness
     8                                  
     9                                  %define ptr
    10                                  %define include
    11                                  %define .model
    12                                  %define .code
    13                                  
    14                                  SYSMEM_FLAG	equ	00800000h
    15                                  DATA16_FLAG	equ	00400000h
    16                                  FSYS24_FLAG	equ	00C00000h
    17                                  
    18                                  					; instruction code starts here
    19                                  	section		.text
    20                                  	global		_leloup
    21                                  	global		_execute
    22                                  	global		_device_readp
    23                                  	global		_bus_readp
    24                                  	global		_memory_read
    25                                  	global		_bus_read
    26                                  	global		_device_read
    27                                  
    28                                  	%include	"leloup.msm"
     1                              <1> 
     2                              <1> 	extern	_ultra
     3                              <1> 	extern	_ultra1
     4                              <1> 	extern	_ultra2
     5                              <1> 	extern	_ultra3
     6                              <1> 	extern	_ultra4
     7                              <1> 	extern	_ultra5
     8                              <1> 	extern	_ultra6
     9                              <1> 	extern	_ultra7
    10                              <1> 	extern	_core
    11                              <1> 
    12                              <1> _save_ebp	equ	0
    13                              <1> _save_return	equ	4
    14                              <1> _1st_param	equ	8
    15                              <1> 
    16                              <1> _leloup:
    17 00000000 55                  <1> 	push	ebp
    18 00000001 56                  <1> 	push	esi
    19 00000002 57                  <1> 	push	edi
    20                              <1> 
    21                              <1> 	%if	0
    22                              <1> 	add	esp, -8
    23                              <1> 	movq	qword ptr [esp], mm7
    24                              <1> 	%endif
    25                              <1> 
    26                              <1> 	%if	0			; cdecl
    27                              <1> 	push	eax
    28                              <1> 	push	ecx
    29                              <1> 	push	edx
    30                              <1> 	%endif
    31                              <1> 
    32 00000003 53                  <1> 	push	ebx
    33                              <1> 
    34 00000004 8B7508              <1> 	mov	esi, dword ptr [ebp+8]	; structure smp ->
    35 00000007 56                  <1> 	push	esi			; balanced on stack top
    36 00000008 0F6EFE              <1> 	movd	mm7, esi		; refresh from mmx during instruction
    37                              <1> 
    38 0000000B 8B9680040000        <1> 	mov	edx, dword ptr [esi+APC]
    39 00000011 8BAE8C040000        <1> 	mov	ebp, dword ptr [esi+REGISTER_SET]
    40                              <1> 
    41 00000017 3B9684040000        <1> loup:	cmp	edx, dword ptr [esi+APCZ]
    42 0000001D 7740                <1> 	ja	off_limits
    43                              <1> 
    44 0000001F 8B02                <1> 	mov	eax, dword ptr [edx]
    45 00000021 0FC8                <1> 	bswap	eax
    46 00000023 83C204              <1> 	add	edx, 4
    47                              <1> 
    48 00000026 E82A010000          <1> 	call	_execute
    49                              <1> 
    50 0000002B 8B3424              <1> 	mov	esi, dword ptr [esp] 	; core pointer needed all the way round
    51                              <1> 
    52                              <1> 	%if	TSLICE
    53 0000002E F786A0040000000087- <1> 	test	dword ptr [esi+PSR], 00870000h	; not while ISR or interrupt mask
    53 00000037 00                  <1>
    54 00000038 752F                <1> 	jnz	louping
    55 0000003A F78650020000FFFFFF- <1> 	test	dword ptr [esi+RT_CLOCK], 00FFFFFFh
    55 00000043 00                  <1>
    56 00000044 7423                <1> 	jz	louping
    57                              <1> 
    58 00000046 FF8E50020000        <1> 	dec	dword ptr [esi+RT_CLOCK]
    59 0000004C 751B                <1> 	jnz	louping
    60                              <1> 
    61 0000004E B841000000          <1> 	mov	eax, II_YIELD
    62                              <1> 
    63 00000053 B90A000000          <1> 	mov	ecx, LP_TIMESLICE
    64 00000058 E8B90E0000          <1> 	call	_ii
    65                              <1> 
    66                              <1> 	%endif
    67                              <1> 
    68 0000005D EB0A                <1> 	jmp	louping
    69                              <1> 
    70                              <1> off_limits:
    71 0000005F B85F000000          <1> 	mov	eax, II_GUARD
    72 00000064 E8AD0E0000          <1> 	call	_ii
    73                              <1> 
    74                              <1> louping:
    75 00000069 8A0D[00000000]      <1> 	mov	cl, byte ptr [_general_indication]
    76 0000006F F6C104              <1> 	test	cl, BREAKPOINT
    77 00000072 7420                <1> 	jz	loup_count
    78 00000074 A1[00000000]        <1> 	mov	eax, dword ptr [_breakpoint]
    79 00000079 31D0                <1> 	xor	eax, edx
    80 0000007B 7517                <1> 	jnz	loup_count
    81 0000007D 800D[00000000]02    <1> 	or	byte ptr [_general_indication], LOCKSTEP
    82 00000084 808E9404000002      <1> 	or	byte ptr [esi+INDICATION], LOCKSTEP
    83 0000008B 800D[12000000]01    <1> 	or	byte ptr [_flag+'s'-'a'], 1
    84 00000092 EB50                <1> 	jmp	indicated
    85                              <1> 
    86                              <1> loup_count:
    87 00000094 FF8E6C040000        <1> 	dec	dword ptr [esi+283*4]
    88 0000009A 7908                <1> 	jns	loup_away
    89 0000009C 66838E9404000001    <1> 	or	word ptr [esi+INDICATION], TIME_UPDATE
    90                              <1> loup_away:
    91                              <1> 
    92 000000A4 668B8694040000      <1> 	mov	ax, word ptr [esi+INDICATION]
    93 000000AB 8A8EA2040000        <1> 	mov	cl, byte ptr [esi+PSR+2]
    94 000000B1 80E107              <1> 	and	cl, 7				; highest interrupt mask?
    95 000000B4 80F107              <1> 	xor	cl, 7
    96                              <1> 
    97 000000B7 7421                <1> 	jz	internal_indications?		; maskable interrupts are masked
    98                              <1> 
    99 000000B9 66A9EBFF            <1>         test	ax, INDICATIONS|EXTERNAL_INDICATIONS	; 1 or both of internal++external
   100 000000BD 0F8454FFFFFF        <1> 	jz	loup					; indications? No?
   101 000000C3 66A9E0FF            <1> 	test	ax, EXTERNAL_INDICATIONS	; external indications among the yes?
   102                              <1> 
   103 000000C7 741B                <1> 	jz	indicated			; external indications there are not
   104                              <1> 						; therefore internal indications there are
   105                              <1> ;	push	esi	; already on stack top	; therefore raise their interrupts
   106 000000C9 E8400D0000          <1> 	call	_xi
   107 000000CE 8B3424              <1> 	mov	esi, dword ptr [esp]
   108                              <1> 
   109 000000D1 80A6940400007F      <1> 	and	byte ptr [esi+INDICATION], 127
   110 000000D8 EB8F                <1> 	jmp	louping				; keep going intil pending flags are off
   111                              <1> 
   112                              <1> internal_indications?:
   113 000000DA 66A90B00            <1> 	test	ax, INDICATIONS			; just read from esi->INDICATION
   114 000000DE 0F8433FFFFFF        <1> 	jz	loup
   115                              <1> 
   116                              <1> indicated:
   117 000000E4 80A694040000FD      <1> 	and	byte ptr [esi+INDICATION], LOCKSTEP^255
   118 000000EB 89AE8C040000        <1> 	mov	dword ptr [esi+REGISTER_SET], ebp
   119 000000F1 899680040000        <1> 	mov	dword ptr [esi+APC], edx
   120                              <1> 
   121 000000F7 5B                  <1> 	pop	ebx				; core  pointer
   122 000000F8 5B                  <1> 	pop	ebx				; caller values
   123                              <1> 
   124                              <1> 	%if	0				; cdecl
   125                              <1> 	pop	edx
   126                              <1> 	pop	ecx
   127                              <1> 	pop	eax
   128                              <1> 	%endif
   129                              <1> 
   130                              <1> 	%if	0
   131                              <1> 	movq	mm7, qword ptr [esp]
   132                              <1> 	add	esp, 8
   133                              <1> 	%endif
   134                              <1> 
   135 000000F9 5F                  <1> 	pop	edi
   136 000000FA 5E                  <1> 	pop	esi
   137 000000FB 5D                  <1> 	pop	ebp
   138 000000FC C3                  <1> 	ret
   139                              <1> 
    29                                  	%include	"execute.msm"
     1                              <1> ;	include	rta_x86.h
     2                              <1> 	.model	small
     2          ******************  <1>  warning: label alone on a line without a colon might be in error [-w+orphan-labels]
     3                              <1> 	.code
     4                              <1> ;	_execute:
     5                              <1> ;        mov     dword ptr [__register+287*4], esp
     6                              <1> 
     7 000000FD 89C1                <1> __ea:	mov	ecx, eax
     8 000000FF C1E108              <1> 	shl	ecx, 8
     9 00000102 C1E913              <1> 	shr	ecx, 24-5		; instruction index in ch
    10 00000105 C0E905              <1> 	shr	cl, 5			; operand designator in cl
    11                              <1> 
    12 00000108 C1E010              <1> 	shl	eax, 16
    13 0000010B 80F905              <1> 	cmp	cl, XI			; sign extended immediate?
    14 0000010E 7508                <1> 	jnz	derive_ea
    15                              <1> 
    16 00000110 C1F808              <1> 	sar	eax, 8			; different from other EAs
    17 00000113 C1E808              <1> 	shr	eax, 8
    18 00000116 EB3C                <1> 	jmp	ea_derived
    19                              <1> 
    20                              <1> derive_ea:
    21 00000118 C1E810              <1> 	shr	eax, 16			; no sign of it
    22 0000011B 6621C0              <1> 	and	ax, ax			; indexing / indirection ?
    23 0000011E 7934                <1> 	jns	ea_derived		; no
    24                              <1> 
    25 00000120 89C3                <1> 	mov	ebx, eax
    26 00000122 80E47F              <1> 	and	ah, 127			; ie: and ax 32767
    27 00000125 66C1EB0C            <1> 	shr	bx, 12			; position index tag
    28 00000129 F6C306              <1> 	test	bl, 6			; indirect or indexed ?
    29 0000012C 7415                <1> 	jz	indirect
    30                              <1> 					; pe = PF set
    31                              <1> 					; can only be tested on b7..0
    32 0000012E 7A03                <1> 	jpe	indexed_4bit		; indexed fp / sp
    33                              <1> 					; indexed x / y / a / b
    34 00000130 80E307              <1> 	and	bl, 7			; zero bit 3
    35                              <1> 
    36                              <1> indexed_4bit:
    37 00000133 6625FF0F            <1> 	and	ax, 4095		; isolate address offset
    38 00000137 03449D00            <1> 	add	eax, dword ptr [ebp+ebx*4]
    39                              <1> 
    40 0000013B C1E008              <1> 	shl	eax, 8			; truncate any overflow
    41 0000013E C1E808              <1> 	shr	eax, 8
    42                              <1> 
    43 00000141 EB11                <1> 	jmp	ea_derived
    44                              <1> 
    45                              <1> indirect:				; indirect via page B0 / B1
    46 00000143 6689CB              <1> 	mov	bx, cx
    47 00000146 6631C9              <1> 	xor	cx, cx			; cl <- zero to read 1-word indirection pointer
    48 00000149 E803020000          <1> 	call	_operand_read
    49 0000014E 6689D9              <1> 	mov	cx, bx			; retrieve instruction:class into cx
    50                              <1> 
    51                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]	; retrieve smp core ->
    52 00000151 0F7EFE              <1> 	movd	esi, mm7
    53                              <1> ea_derived:
    54 00000154 C3                  <1> 	ret
    55                              <1> 
    56                              <1> _execute:
    57 00000155 89A67C040000        <1> 	mov	dword ptr [esi+REGISTER+287*4], esp
    58 0000015B E89DFFFFFF          <1> 	call	__ea
    59                              <1> 
    60 00000160 0FB6DD              <1> 	movzx	ebx, ch			; instruction index
    61 00000163 80F906              <1> 	cmp	cl, 6
    62 00000166 0F848F000000        <1> 	jz	near shifts_jumps
    63 0000016C 0F8712010000        <1> 	ja	near large_operations
    64                              <1> 
    65                              <1> integer_operations:
    66 00000172 8B1C9D[7B010000]    <1> 	mov	ebx, dword ptr [operations1+ebx*4]
    67 00000179 FFE3                <1> 	jmp	ebx
    68                              <1> 
    69                              <1> operations1:
    70 0000017B [4A120000]          <1>         dd	_sr
    71 0000017F [64120000]          <1>         dd	_sk
    72 00000183 [7E120000]          <1>         dd	_sx
    73 00000187 [98120000]          <1>         dd	_sy
    74 0000018B [B2120000]          <1>         dd	_sa
    75 0000018F [C8120000]          <1>         dd	_sb
    76 00000193 [DA120000]          <1>         dd	_z
    77 00000197 [F3120000]          <1>         dd	_pop
    78                              <1> 
    79 0000019B [0F130000]          <1>         dd	_lr
    80 0000019F [18130000]          <1>         dd	_lk
    81 000001A3 [21130000]          <1>         dd	_lx
    82 000001A7 [2A130000]          <1>         dd	_ly
    83 000001AB [33130000]          <1>         dd	_la
    84 000001AF [3C130000]          <1>         dd	_lb
    85 000001B3 [45130000]          <1>         dd	_tz
    86 000001B7 [6C130000]          <1>         dd	_tp
    87                              <1> 
    88 000001BB [86160000]          <1>         dd	_ax
    89 000001BF [97160000]          <1>         dd	_ay
    90 000001C3 [A8160000]          <1>         dd	_or
    91 000001C7 [B1160000]          <1>         dd	_orB
    92 000001CB [BA160000]          <1>         dd	_and
    93 000001CF [C3160000]          <1>         dd	_andB
    94 000001D3 [CC160000]          <1>         dd	_xor
    95 000001D7 [D5160000]          <1>         dd	_xorB
    96                              <1> 
    97 000001DB [DE160000]          <1>         dd	_aa
    98 000001DF [FE160000]          <1>         dd	_ab
    99 000001E3 [E5160000]          <1>         dd	_ana
   100 000001E7 [05170000]          <1>         dd	_anb
   101 000001EB [1E170000]          <1>         dd	_m
   102 000001EF [4E170000]          <1>         dd	_mf
   103 000001F3 [AA170000]          <1>         dd	_d
   104 000001F7 [8A130000]          <1>         dd	_push
   105                              <1> 
   106                              <1> shifts_jumps:
   107 000001FB 8B1C9D[04020000]    <1> 	mov	ebx, dword ptr [operations6+ebx*4]
   108 00000202 FFE3                <1> 	jmp	ebx
   109                              <1> 
   110                              <1> operations6:
   111 00000204 [4F180000]          <1>         dd	_sar
   112 00000208 [66180000]          <1>         dd	_sbr
   113 0000020C [7D180000]          <1>         dd	_dsr
   114 00000210 [A8130000]          <1>         dd	_jdr
   115 00000214 [91180000]          <1>         dd	_sal
   116 00000218 [A8180000]          <1>         dd	_sbl
   117 0000021C [BF180000]          <1>         dd	_dsl
   118 00000220 [C2130000]          <1>         dd	_lcal
   119                              <1> 
   120 00000224 [D3180000]          <1>         dd	_rar
   121 00000228 [DF180000]          <1>         dd	_rbr
   122 0000022C [EB180000]          <1>         dd	_drr
   123 00000230 [D6130000]          <1>         dd	_jnc
   124 00000234 [871A0000]          <1>         dd	_ral
   125 00000238 [931A0000]          <1>         dd	_rbl
   126 0000023C [9F1A0000]          <1>         dd	_drl
   127 00000240 [E3130000]          <1>         dd	_jc
   128                              <1> 
   129 00000244 [B31A0000]          <1>         dd	_saa
   130 00000248 [C41A0000]          <1>         dd	_sba
   131 0000024C [D51A0000]          <1>         dd	_dsa
   132 00000250 [F0130000]          <1>         dd	_jao
   133 00000254 [FA130000]          <1>         dd	_jpa
   134 00000258 [04140000]          <1>         dd	_jpb
   135 0000025C [0E140000]          <1>         dd	_j
   136 00000260 [30140000]          <1>         dd	_jpo
   137                              <1> 
   138 00000264 [38140000]          <1>         dd	_jza
   139 00000268 [42140000]          <1>         dd	_jzb
   140 0000026C [4C140000]          <1>         dd	_jnza
   141 00000270 [56140000]          <1>         dd	_jnzb
   142 00000274 [60140000]          <1>         dd	_jna
   143 00000278 [6A140000]          <1>         dd	_jnb
   144 0000027C [74140000]          <1>         dd	_jxge
   145 00000280 [83140000]          <1>         dd	_jyge
   146                              <1> 
   147                              <1> 
   148                              <1> large_operations:
   149 00000284 8B1C9D[8F020000]    <1> 	mov	ebx, dword ptr [operations7+ebx*4]
   150 0000028B B100                <1> 	mov	cl, 0		; default size large operand
   151 0000028D FFE3                <1> 	jmp	ebx		; 1 word
   152                              <1> 
   153                              <1> operations7:
   154 0000028F [63150000]          <1>         dd	_ts
   155 00000293 [E91A0000]          <1>         dd	_n
   156 00000297 [F81A0000]          <1>         dd	_inc
   157 0000029B [031B0000]          <1>         dd	_dec
   158 0000029F [79150000]          <1>         dd	_sim
   159 000002A3 [4E1B0000]          <1>         dd	_popA
   160 000002A7 [0E1B0000]          <1>         dd	_src
   161 000002AB [2E1B0000]          <1>         dd	_slc
   162                              <1> 
   163 000002AF [96140000]          <1>         dd	_qs
   164 000002B3 [A0140000]          <1>         dd	_ql
   165 000002B7 [05150000]          <1>         dd	_dte
   166 000002BB [CD140000]          <1>         dd	_dpop
   167 000002BF [C9230000]          <1>         dd	_fa
   168 000002C3 [E4230000]          <1>         dd	_fan
   169 000002C7 [FF230000]          <1>         dd	_fm
   170 000002CB [20240000]          <1>         dd	_fd
   171                              <1> 
   172 000002CF [AA140000]          <1>         dd	_qpop
   173 000002D3 [BA140000]          <1>         dd	_qpush
   174 000002D7 [56150000]          <1>         dd	_ex
   175 000002DB [DD140000]          <1>         dd	_dpush
   176 000002DF [311C0000]          <1>         dd	_lsc
   177 000002E3 [F4140000]          <1>         dd	_mta
   178 000002E7 [18150000]          <1>         dd	_sc
   179 000002EB [26150000]          <1>         dd	_mlb
   180                              <1> 
   181 000002EF [3F150000]          <1>         dd	_ds
   182 000002F3 [49150000]          <1>         dd	_dl
   183 000002F7 [801B0000]          <1>         dd	_da
   184 000002FB [871B0000]          <1>         dd	_dan
   185 000002FF [421C0000]          <1>         dd	_dlsc
   186 00000303 [55150000]          <1>         dd	_spare
   187 00000307 [BC150000]          <1>         dd	_go
   188 0000030B [9F150000]          <1>         dd	_call
   189                              <1> 
    30                                  	%include	"rw.msm"
     1                              <1> 
     2                              <1> 
     3                              <1> ;	include	rta_x86.h
     4                              <1> ;	.model	large
     5                              <1> ;	.code
     6                              <1> 
     7                              <1> ;	this is the operand reader / writer
     8                              <1> ;	for emulated RTA1 on x86
     9                              <1> 
    10                              <1> ;	layout is
    11                              <1> 
    12                              <1> ;	RTA1 24-bit registers are modeled in an array of
    13                              <1> ;	platform-endian integers. In x86 these are 32-bit
    14                              <1> ;	little-endian integers
    15                              <1> 
    16                              <1> ;	platform-endian doesn't affect registers
    17                              <1> ;	because endianness is not at the CPU
    18                              <1> ;	side of the bus, but at the memory side
    19                              <1> 
    20                              <1> ;	when Intel circuitry in the x86 CPU staticises the value
    21                              <1> ;	of an emulated register, that value is big endian
    22                              <1> 
    23                              <1> ;	the stored integers where emulated registers are modeled
    24                              <1> ;	are platform-endian, with identical effect on big and
    25                              <1> ;	little endian emulator platforms
    26                              <1> 
    27                              <1> ;	RTA1 24-bit executable space storage words are modeled in
    28                              <1> ;	another array of platform-endian 32-bit integers. Emulation
    29                              <1> ;	on x86 swaps the byte order of storage words on read and
    30                              <1> ;	before write to conform with RTA1 canonical storage order
    31                              <1> 
    32                              <1> ;       RTA1 architecture has registers in the first 256 locations
    33                              <1> ;       of address space and access differentiates registers from
    34                              <1> ;       from memory according to effective address
    35                              <1> 
    36                              <1> ;	location of registers and storage are handed to read / write
    37                              <1> ;	routines as RTA1 word linear effective addresses
    38                              <1> 
    39                              <1> ;	These routines maintain the RTA1 linear addresses passed
    40                              <1> ;	in x86 registers and apply them with shifted scale plus
    41                              <1> ;	displacement, for example
    42                              <1> 
    43                              <1> ;		mov	eax, dword ptr [edi+esi*4+_memory]
    44                              <1> ;		bswap	eax
    45                              <1> ;		mov	dword_ptr [ebp+ebx*4], eax
    46                              <1> 
    47                              <1> ;	RTA1 register addresses are already absolute in terms of
    48                              <1> ;	the emulated RTA1 machine
    49                              <1> 
    50                              <1> ;	ebp points at the context register frame. There are two
    51                              <1> ;	register frames, application and interrupt. Registers
    52                              <1> ;	addressed as storage operand are in a single list
    53                              <1> 
    54                              <1> ;		mov	eax, dword ptr [esi*4+__register]
    55                              <1> 
    56                              <1> ;	RTA1 storage addresses are translated by RTA1 relocation
    57                              <1> ;	architecture before application. The updated linear addresses
    58                              <1> ;	of the emulated machine are in esi
    59                              <1> 
    60                              <1> ;	The operand routines in this file point edi to the x86 platform
    61                              <1> ;	storage array start of the storage device, most often emulated
    62                              <1> ;	RTA1 executable space
    63                              <1> 
    64                              <1> ;	instructions call these operand routines with RTA1 effective 
    65                              <1> ;	address in eax
    66                              <1> 
    67                              <1> ;	instructions receive load operand values in eax and ebx, or in
    68                              <1> ;	a list of RTA1 emulated register locations pointed by ebp+ebx
    69                              <1> 
    70                              <1> ;	store instructions submit a value in ebx, or values in list of
    71                              <1> ;	RTA1 emulated register locations pointed by ebp+ebx
    72                              <1> 
    73                              <1> ;	to preserve linear address consistency, application instruction
    74                              <1> ;	work areas, where needed in addition to x86 registers, are
    75                              <1> ;	implemented as sub-architectural extra RTA1 registers at the end
    76                              <1> ;	of the 256-longword register stack. x86 register ebp+ebx*4 identify
    77                              <1> ;	these locations by linear RTA1 word quantum as "registers"
    78                              <1> 
    79                              <1> ;	RTA1 registers and storage alike are in 24-bit word address quantum space
    80                              <1> 
    81                              <1> ;	emulated instructions loading or storing multiple hidden extra work
    82                              <1> ;	registers should unconditionally set ebp to the start or application
    83                              <1> ;	frame of the emulated register array, so that [ebp+ebx*4] accesses the
    84                              <1> ;	correct locations at register occurence 256+
    85                              <1> 
    86                              <1> ;               _floating_operand2 equ  256+12
    87                              <1> 
    88                              <1> ;		push	ebp
    89                              <1> ;		mov	ebp, __register	; point to application register frame[0]
    90                              <1> ;		mov	ebx, 256+_floating_operand2
    91                              <1> ;		call	_burst_read4
    92                              <1> 
    93                              <1> ;		pop	ebp		; return to previous register frame[0] application
    94                              <1> 					;                          or frame[1] interrupt
    95                              <1> 
    96                              <1> ;	Both internal stack pointers are also absolute, so for stack operations
    97                              <1> ;	ebp should be momentarily forced to the lower-addressed (application) stack
    98                              <1> ;	frame after being used to point the stack location of reference
    99                              <1> 
   100                              <1> ;		mov	ebx, dword ptr [ebp+S_P]	; read one of the two stack pointers
   101                              <1> ;		cmp	ebx, ebp+STACK_LOWER_LIMIT	; 24*4 within context of either stack
   102                              <1> ;		jl	II_GUARD
   103                              <1> ;		add	ebx, -1				; new stack top
   104                              <1> ;		mov	dword ptr [ebp+S_P], ebx
   105                              <1> ;		push	ebp				; which ever stack pointer it is, it points
   106                              <1> ;		mov	ebp,__register			; relative to all the register stack
   107                              <1> ;		call	_operand_read			; for I am the single-word push instruction
   108                              <1> ;		pop	ebp				;
   109                              <1> 
   110                              <1> ;	register identities supplied from emulated instructions to these routines
   111                              <1> ;	are their lowercase names equated to RTA1 word addresses
   112                              <1> 
   113                              <1> ;	There exist also uppercase spellings which instruction routines may
   114                              <1> ;	access internally. The uppercase names are four times in value the
   115                              <1> ;	equivalent lowercase ordinal names to give x86 platform offset values
   116                              <1> 
   117                              <1> ;       Assembly language equate is like parentheses! What's in a label
   118                              <1> ;       is not an expression but its value. Nothing like C preprocessor.
   119                              <1> ;       Just in case you're developing enhancements in assembly using
   120                              <1> ;       preprocessor and #define
   121                              <1> 
   122                              <1> ;		_floating_operand2 equ	256+12
   123                              <1> ;		FLOATING_OPERAND2 equ	_floating_operand2*4
   124                              <1> 
   125                              <1> 
   126                              <1> ;		a	equ	4
   127                              <1> ;		b	equ	5
   128                              <1> ;		mantissa2 equ	6
   129                              <1> 
   130                              <1> ;		A	equ	a*4
   131                              <1> ;		B	equ	b*4
   132                              <1> ;		MANTISSA2 equ	mantissa2*4
   133                              <1> 
   134                              <1> ;		mov	ebx, dword ptr [bp+MANTISSA2]	; the very same!
   135                              <1> ;		mov	ebx, dword ptr [bp+mantissa2*4]	; the very same
   136                              <1> 
   137                              <1> ;	but to identify an instruction-implied register to these operand routines
   138                              <1> 
   139                              <1> ;		mov	ebx, mantissa2		; bp already says which register set
   140                              <1> 
   141                              <1> ;	instruction evaluation supplies right-hand side operand EA in eax
   142                              <1> ;	Instruction implementation needs not examine EA. Call _operand_read
   143                              <1> ;	or _operand_write. eax must be as supplied to the instruction routine
   144                              <1> ;	on on operand retrieve and store
   145                              <1> 
   146                              <1> ;	simple instructions receive operand mode in cl from instruction
   147                              <1> ;	evaluation
   148                              <1> 
   149                              <1> ;	shifts and jumps use the ea which is already indexed or indirected
   150                              <1> ;	if necessary and make no operand call
   151                              <1> 
   152                              <1> ;	instructions call _burst_read2 or _burst_write2 for two-word operand cycles
   153                              <1> ;	instructions call _burst_read4 or _burst_write4 for four-word operand cycles
   154                              <1> 
   155                              <1> ;	operand reads of 1 or 2 words return values in eax:ebx
   156                              <1> 
   157                              <1> ;		call	_burst_read2
   158                              <1> ;		mov	dword ptr [ebp+A], eax
   159                              <1> ;		mov	dword ptr [ebp+B], ebx
   160                              <1> 
   161                              <1> ;	to store one operand word place it in ebx
   162                              <1> 
   163                              <1> ;	_sc	mov	ebx, dword ptr[_psr]	; I am the store carry instruction sc
   164                              <1> ;		and	ebx, 1			; CARRY
   165                              <1> ;		call	_operand_write
   166                              <1> 
   167                              <1> ;	to store two or four words or to load four words, point bx to register
   168                              <1> 
   169                              <1> ;	_qpop	mov	ebx, dword ptr [ebp+S_P] ; internal stack pointer
   170                              <1> ;						; either application sp or interrupt sp
   171                              <1> ;
   172                              <1> ;		add	dword ptr [ebp+S_P], 4	; internal stack+= 4
   173                              <1> ;		push	ebp			;
   174                              <1> ;		mov	ebp, __register		; in case context is interrupt registers
   175                              <1> ;		call	_burst_write4		; both internal stack pointers are absolute
   176                              <1> ;		pop	ebp			; point epb back to application registers
   177                              <1> ;						;                or interrupt registers
   178                              <1> 
   179                              <1> ;	more complex instructions do something to the registers after
   180                              <1> ;	acquiring operands
   181                              <1> 
   182                              <1> ;		call	_operand_read
   183                              <1> ;		add	eax, dword ptr [ebp+A]
   184                              <1> ;		rol	eax
   185                              <1> ;		and	al, CARRY		; 1
   186                              <1> ;		or	byte ptr [_psr], al	; low-order byte of longword _psr
   187                              <1> ;		shr	eax, 8
   188                              <1> ;		mov	dword ptr [ebp+A], eax
   189                              <1> 
   190                              <1> ;	emulated RTA1 instructions which both read and write (modify)
   191                              <1> ;	storage use the address in [edi+esi*4] to rewrite. edi is
   192                              <1> ;	NULL if it's not a suitable memory for a modify operation
   193                              <1> 
   194                              <1> ;	modify instructions which may have a register operand (not TS)
   195                              <1> ;	call _operand_write to rewrite a register. This guards aganst
   196                              <1> ;	applications writing interrupt registers.
   197                              <1>  
   198                              <1> ;	the effect of storage buses characteristically different
   199                              <1> ;	from RTA1 executable space is emulated in the routines
   200                              <1> ;	device_read and device_write
   201                              <1> 
   202                              <1> ;	Peripheral bus types implemented are
   203                              <1> 
   204                              <1> ;		filestore containing extents of up to 768K octets
   205                              <1> ;		accessible to RTA1 as up to 256K words in each extent.
   206                              <1> ;		The 3-octet words are in canonical order and packed
   207                              <1> 
   208                              <1> ;		network interface buffer store shared with the emulator
   209                              <1> ;		platform and reading out to RTA1 at 16 data bits per word
   210                              <1> ;		with eight high-order zero bits. RTA writes 16 data bits
   211                              <1> ;		to these locations from register low-order bit positions.
   212                              <1> ;		Storage byte order is canonical. These buffers are normal
   213                              <1> ;		and contiguous byte arrays of the emulator platform.
   214                              <1> ;		To RTA1 they are an attached device array of 16-bit words
   215                              <1> 
   216                              <1> ;	Device array types are
   217                              <1> 
   218                              <1> ;		executable space
   219                              <1> ;		24-bit filestore array
   220                              <1> ;		16-bit network interface array
   221                              <1> 
   222                              <1> ;	devices are identified in RTA1 memory relocation pointers and
   223                              <1> ;	tagged with device type. Executable space is device zero
   224                              <1> 
   225                              <1> ;	esi -> core.REGISTER
   226                              <1> 
   227                              <1> _burst_read2:
   228 0000030F 66B90600            <1> 	mov	cx, 6
   229 00000313 A900FFFF00          <1> 	test	eax, 00FFFF00h
   230 00000318 7402                <1> 	jz	read2_registers
   231 0000031A EB4D                <1> 	jmp	_bus_read
   232                              <1> 
   233                              <1> read2_registers:				; load registers from registers
   234 0000031C 8B5C8604            <1> 	mov	ebx, dword ptr [esi+eax*4+4]
   235 00000320 8B0486              <1> 	mov	eax, dword ptr [esi+eax*4]
   236 00000323 C3                  <1> 	ret
   237                              <1> 	
   238                              <1> ;	esi -> core.REGISTER
   239                              <1> 
   240                              <1> _burst_read4:				; buffered read
   241 00000324 66B90700            <1> 	mov	cx, 7			; that will help the caller
   242 00000328 A900FFFF00          <1> 	test	eax, 00FFFF00h		; ebp+ebx contains a register number
   243 0000032D 7402                <1> 	jz	read4_registers		; may also identify extra
   244 0000032F EB38                <1> 	jmp	_bus_read
   245                              <1> 					; workspace registers
   246                              <1> read4_registers:			; at register stack tail
   247 00000331 8B4C860C            <1> 	mov	ecx, dword ptr [esi+eax*4+3*4]
   248 00000335 894C9D0C            <1> 	mov	dword ptr [ebp+ebx*4+3*4], ecx
   249 00000339 8B4C8608            <1> 	mov	ecx, dword ptr [esi+eax*4+2*4]
   250 0000033D 894C9D08            <1> 	mov	dword ptr [ebp+ebx*4+2*4], ecx
   251 00000341 8B4C8604            <1> 	mov	ecx, dword ptr [esi+eax*4+4]
   252 00000345 894C9D04            <1> 	mov	dword ptr [ebp+ebx*4+4], ecx
   253 00000349 8B0C86              <1> 	mov	ecx, dword ptr [esi+eax*4]
   254 0000034C 894C9D00            <1> 	mov	dword ptr [ebp+ebx*4], ecx
   255 00000350 C3                  <1> 	ret
   256                              <1> 
   257                              <1> ;	esi -> core.REGISTER
   258                              <1> 
   259                              <1> _operand_read:			; call here with designator coded in cx
   260 00000351 80E107              <1> 	and	cl, 7		; and ea in eax
   261 00000354 80F904              <1> 	cmp	cl, 4
   262 00000357 740F                <1> 	je	immediate	; EA is operand
   263 00000359 80F905              <1> 	cmp	cl, 5
   264 0000035C 740A                <1> 	je	immediate_xi	; EA is operand
   265                              <1> 
   266 0000035E A900FFFF00          <1> 	test	eax, 00FFFF00h
   267 00000363 7504                <1> 	jnz	_bus_read	; ea does not point to registers
   268 00000365 8B0486              <1> 	mov	eax, dword ptr [esi+eax*4]
   269                              <1> 
   270                              <1> immediate:
   271                              <1> immediate_xi:
   272 00000368 C3                  <1> 	ret 
   273                              <1> 
   274                              <1> _bus_read:				; readout any memory
   275                              <1> 
   276 00000369 E8A2050000          <1> 	call	base_read_pointer	; returns eax <- storage block
   277                              <1> 					; 	  esi <- word offset
   278                              <1> 					;	  edi <- EA
   279                              <1> 
   280 0000036E A900004000          <1> 	test	eax, 00400000h		; big block?
   281 00000373 741B                <1> 	je	memory_read_4k_block
   282                              <1> 
   283 00000375 80F906              <1> 	cmp	cl, 6			; multiword operation?
   284 00000378 720D                <1> 	jb	_bus_read_256k_block
   285                              <1> 
   286 0000037A 81FEFCFF0300        <1> 	cmp	esi, 03FFFCh		; near the edge?
   287 00000380 7605                <1> 	jna	_bus_read_256k_block	; no
   288                              <1> 
   289 00000382 E872210000          <1> 	call	read_straddle_18b?
   290                              <1> 
   291                              <1> _bus_read_256k_block:
   292 00000387 A83F                <1> 	test	al, 63
   293 00000389 7429                <1> 	jz	memory_read_page
   294                              <1> 
   295 0000038B E9A4030000          <1> 	jmp	device_read
   296                              <1> 
   297                              <1> memory_read_4k_block:
   298 00000390 F7C600F00300        <1> 	test	esi, 0003F000h		; inside 4k block?
   299 00000396 740A                <1> 	jz	memory_read_thru
   300                              <1> 
   301 00000398 B90E000000          <1> 	mov	ecx, LP_ADDRESS
   302 0000039D E9660B0000          <1> 	jmp	guard_ii_escape		; no
   303                              <1> 
   304                              <1> memory_read_thru:
   305 000003A2 80F906              <1> 	cmp	cl, 6
   306 000003A5 720D                <1> 	jb	memory_read_page
   307                              <1> 
   308 000003A7 81FEFC0F0000        <1> 	cmp	esi, 0FFCh		; near the edge?
   309 000003AD 7605                <1> 	jna	memory_read_page	; no
   310                              <1> 
   311 000003AF E81A210000          <1> 	call	read_straddle_12b?
   312                              <1> 
   313                              <1> memory_read_page:
   314 000003B4 C1E00C              <1> 	shl	eax, 12			; multiply by page and lose bit 00400000
   315 000003B7 01C6                <1> 	add	esi, eax
   316                              <1> ;	mov	ch, byte ptr [edi+PSR]	; field of PSR with byte options
   317 000003B9 BF[00000000]        <1> 	mov	edi, _memory		; byte address
   318                              <1> 
   319                              <1> memory_read_on:
   320 000003BE 8D3CB7              <1> 	lea	edi, [edi+esi*4]
   321                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
   322 000003C1 0F7EFE              <1> 	movd	esi, mm7
   323                              <1> 
   324 000003C4 0FB6C1              <1> 	movzx	eax, cl
   325 000003C7 8B0485[D0030000]    <1> 	mov	eax, dword ptr [read_action+eax*4]
   326 000003CE FFE0                <1> 	jmp	eax
   327                              <1> 
   328                              <1> read_action:
   329 000003D0 [F0030000]          <1> 	dd	memory_read_w0
   330 000003D4 [31040000]          <1> 	dd	memory_t1
   331 000003D8 [38040000]          <1> 	dd	memory_t2	; or h1
   332 000003DC [48040000]          <1> 	dd	memory_t3	; or h2
   333 000003E0 [68030000]          <1> 	dd	immediate	; don't get here
   334 000003E4 [68030000]          <1> 	dd	immediate_xi	; don't get here
   335 000003E8 [F7030000]          <1> 	dd	memory_read2
   336 000003EC [05040000]          <1> 	dd	memory_read4
   337                              <1> 
   338                              <1> memory_read_w0:			; readout system memory 1 word
   339                              <1> ;	mov	dword ptr [esi+REGISTER+154*4], edi
   340                              <1> ;	mov	dword ptr [esi+REGISTER+155*4], esi
   341 000003F0 8B07                <1> 	mov	eax, dword ptr [edi]
   342 000003F2 B000                <1> 	mov	al, 0
   343 000003F4 0FC8                <1> 	bswap	eax
   344                              <1> ; immediate:
   345                              <1> ; immediate_xi:
   346 000003F6 C3                  <1>  	ret
   347                              <1> 
   348                              <1> memory_read2:			; readout system memory 2 words
   349 000003F7 8B5F04              <1> 	mov	ebx, dword ptr [edi+4]
   350 000003FA 8B07                <1> 	mov	eax, dword ptr [edi]
   351                              <1> 
   352 000003FC B000                <1> 	mov	al, 0
   353 000003FE B300                <1> 	mov	bl, 0
   354 00000400 0FC8                <1> 	bswap	eax
   355 00000402 0FCB                <1> 	bswap	ebx
   356 00000404 C3                  <1> 	ret
   357                              <1> 				; readout system memory 4 words
   358                              <1> memory_read4:			; store by pointer
   359                              <1> 				; this will be useful to the caller
   360                              <1> 
   361 00000405 8B07                <1> 	mov	eax, dword ptr [edi]
   362 00000407 B000                <1> 	mov	al, 0
   363 00000409 0FC8                <1> 	bswap	eax
   364 0000040B 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   365 0000040F 8B4704              <1> 	mov	eax, dword ptr [edi+4]
   366 00000412 B000                <1> 	mov	al, 0
   367 00000414 0FC8                <1> 	bswap	eax
   368 00000416 89449D04            <1> 	mov	dword ptr [ebp+ebx*4+4], eax
   369 0000041A 8B4708              <1> 	mov	eax, dword ptr [edi+2*4]
   370 0000041D B000                <1> 	mov	al, 0
   371 0000041F 0FC8                <1> 	bswap	eax
   372 00000421 89449D08            <1> 	mov	dword ptr [ebp+ebx*4+2*4], eax
   373 00000425 8B470C              <1> 	mov	eax, dword ptr [edi+3*4]
   374 00000428 B000                <1> 	mov	al, 0
   375 0000042A 0FC8                <1> 	bswap	eax
   376 0000042C 89449D0C            <1> 	mov	dword ptr [ebp+ebx*4+3*4], eax
   377 00000430 C3                  <1> 	ret
   378                              <1> 
   379                              <1> memory_t1:
   380 00000431 8B07                <1> 	mov	eax, dword ptr [edi]
   381 00000433 C1E010              <1> 	shl	eax, 16		; t1 = 3.2.THIS.zero
   382 00000436 EB1B                <1> 	jmp	memory_tw
   383                              <1> 
   384                              <1> memory_t2:
   385 00000438 8B07                <1> 	mov	eax, dword ptr [edi]
   386 0000043A F686A004000080      <1> 	test	byte ptr [esi+PSR], HALF_W
   387 00000441 7517                <1> 	jnz	memory_h1
   388 00000443 C1E008              <1> 	shl	eax, 8		; t2 = 3.THIS.1.zero
   389 00000446 EB0B                <1> 	jmp	memory_tw
   390                              <1> 
   391                              <1> memory_t3:
   392 00000448 8B07                <1> 	mov	eax, dword ptr [edi]
   393 0000044A F686A004000080      <1> 	test	byte ptr [esi+PSR], HALF_W
   394 00000451 750E                <1> 	jnz	memory_h2
   395                              <1> memory_tw:
   396 00000453 C1F810              <1> 	sar	eax, 16		; t3 = THIS.2.1.zero
   397 00000456 C1E808              <1> 	shr	eax, 8
   398 00000459 C3                  <1> 	ret
   399                              <1> 
   400                              <1> memory_h1:
   401 0000045A 0FC8                <1> 	bswap	eax		; already loaded but not swapped
   402 0000045C C1E008              <1> 	shl	eax, 8		; h1 = zero.HERE.2.3
   403 0000045F EB05                <1> 	jmp	memory_hw
   404                              <1> 
   405                              <1> memory_h2:
   406 00000461 0FC8                <1> 	bswap	eax		; already loaded but not swapped
   407 00000463 C1E014              <1> 	shl	eax, 8+12
   408                              <1> memory_hw:
   409 00000466 C1F80C              <1> 	sar	eax, 12
   410 00000469 C1E808              <1> 	shr	eax, 8
   411 0000046C C3                  <1> 	ret
   412                              <1> 
   413                              <1> ;	esi -> core.REGISTER
   414                              <1> 				; store system memory
   415                              <1> _burst_write4:
   416 0000046D 66B90700            <1> 	mov	cx, 7
   417 00000471 A900FFFF00          <1> 	test	eax, 00FFFF00h
   418 00000476 0F858A000000        <1> 	jnz	NEAR bus_write
   419                              <1> 
   420                              <1> 	; store emulated registers to emulated registers
   421                              <1> 
   422 0000047C F786A0040000000080- <1> 	test	dword ptr [esi+PSR], 0800000h	; ISR ?
   422 00000485 00                  <1>
   423 00000486 750A                <1> 	jnz	write4_registers	; ISRs may write some spare registers
   424 00000488 83F87C              <1> 	cmp	eax, 124
   425 0000048B 7605                <1> 	jna	write4_registers
   426 0000048D E9710A0000          <1> 	jmp	guard_ii_authority	; but applications may not write
   427                              <1> 					; any interrupt registers
   428                              <1> 
   429                              <1> write4_registers:
   430                              <1> ;	mov	edi, eax		; eax can be freed
   431                              <1> 
   432 00000492 8B4C9D00            <1> 	mov	ecx, dword ptr [ebp+ebx*4]	; data for store
   433                              <1> 					; ebp+ebx is a register number
   434                              <1> 					; which can be extra register locations
   435                              <1> 					; serving as workspace at the tail of
   436                              <1> 					; the register stack
   437                              <1> 
   438 00000496 890C86              <1> 	mov	dword ptr [esi+eax*4], ecx
   439 00000499 8B4C9D04            <1> 	mov	ecx, dword ptr [ebp+ebx*4+4]
   440 0000049D 894C8604            <1> 	mov	dword ptr [esi+eax*4+4], ecx
   441                              <1> 
   442 000004A1 8B4C9D08            <1> 	mov	ecx, dword ptr [ebp+ebx*4+2*4]
   443 000004A5 894C8608            <1> 	mov	dword ptr [esi+eax*4+2*4], ecx
   444 000004A9 8B4C9D0C            <1> 	mov	ecx, dword ptr [ebp+ebx*4+3*4]
   445 000004AD 894C860C            <1> 	mov	dword ptr [esi+eax*4+3*4], ecx
   446 000004B1 C3                  <1> 	ret
   447                              <1> 
   448                              <1> ;	esi -> core.REGISTER
   449                              <1> 
   450                              <1> _burst_write2:
   451 000004B2 66B90600            <1> 	mov	cx, 6
   452 000004B6 A900FFFF00          <1> 	test	eax, 00FFFF00h
   453 000004BB 7549                <1> 	jnz	bus_write
   454                              <1> 
   455                              <1> 	; store to emulated registers
   456                              <1> 
   457 000004BD F786A0040000000080- <1> 	test	dword ptr [esi+PSR], 0800000h	; ISR ?
   457 000004C6 00                  <1>
   458 000004C7 750A                <1> 	jnz	write2_registers	; there are spare registers at the end
   459 000004C9 83F87E              <1> 	cmp	eax, 126		; but applications may not write
   460 000004CC 7605                <1> 	jna	write2_registers	; any interrupt registers
   461 000004CE E9300A0000          <1> 	jmp	guard_ii_authority
   462                              <1> 
   463                              <1> write2_registers:
   464                              <1> ;	mov	edi, eax			; time to free eax
   465 000004D3 8B4C9D00            <1> 	mov	ecx, dword ptr [ebp+ebx*4]
   466 000004D7 890C86              <1> 	mov	dword ptr [esi+eax*4], ecx
   467 000004DA 8B4C9D04            <1> 	mov	ecx, dword ptr [ebp+ebx*4+4]
   468 000004DE 894C8604            <1> 	mov	dword ptr [esi+eax*4++4], ecx
   469 000004E2 C3                  <1> 	ret
   470                              <1> 
   471                              <1> ;	esi -> core.REGISTER
   472                              <1> 
   473                              <1> _operand_write:
   474 000004E3 A900FFFF00          <1> 	test	eax, 00FFFF00h
   475 000004E8 751C                <1> 	jnz	bus_write
   476                              <1> 
   477                              <1> _operand_write_register:
   478 000004EA A980000000          <1> 	test	eax, 80h		; in the interrupt registers?
   479 000004EF 7411                <1> 	jz	write1_register
   480 000004F1 F786A0040000000080- <1> 	test	dword ptr [esi+PSR], 0800000h
   480 000004FA 00                  <1>
   481 000004FB 7505                <1> 	jnz	write1_register
   482 000004FD E9010A0000          <1> 	jmp	guard_ii_authority
   483                              <1> 
   484                              <1> write1_register:
   485 00000502 891C86              <1> 	mov	dword ptr [esi+eax*4], ebx
   486 00000505 C3                  <1> 	ret
   487                              <1> 
   488                              <1> bus_write:				; write any memory
   489                              <1> 					;	eax <- EA
   490                              <1> 					;	ebx <- data | [ ebp + ebx * 4] -> 1st data word
   491                              <1> 					;	cl  <- encoding [ word * 1 / 2 / 4 ] / byte
   492                              <1> 					;	esi <- core
   493                              <1> 
   494                              <1> 
   495 00000506 E899040000          <1> 	call	base_write_pointer	; returns eax <- block
   496                              <1> 					;         edi <- EA
   497                              <1> 					;	  esi <- word offset
   498                              <1> 
   499 0000050B A900004000          <1> 	test	eax, 00400000h		; big block?
   500 00000510 741E                <1> 	jz	memory_write_4k_block	; no
   501 00000512 80F906              <1> 	cmp	cl, 6			; multiword operation?
   502 00000515 720D                <1> 	jb	bus_write_256k_block	; no
   503                              <1> 
   504 00000517 81FEFCFF0300        <1> 	cmp	esi, 03FFFCh		; near the edge?
   505 0000051D 7605                <1> 	jna	bus_write_256k_block	; no
   506                              <1> 
   507 0000051F E844200000          <1> 	call	write_straddle_18b?
   508                              <1> 
   509                              <1> bus_write_256k_block:
   510 00000524 A93F000000          <1> 	test	eax, 63			; a device array?
   511 00000529 7429                <1> 	jz	memory_write_page	; no. scaling shift will scrub bit 400000
   512 0000052B E907030000          <1> 	jmp	_device_write		; yes a device array
   513                              <1> 
   514                              <1> memory_write_4k_block:
   515 00000530 F7C600F00300        <1> 	test	esi, 0003F000h		; inside a 4k page?
   516 00000536 740A                <1> 	jz	memory_write_thru
   517 00000538 B90E000000          <1> 	mov	ecx, LP_ADDRESS
   518 0000053D E9C6090000          <1> 	jmp	guard_ii_escape		; no
   519                              <1> 
   520                              <1> memory_write_thru:
   521 00000542 80F906              <1> 	cmp	cl, 6			; multiword operation?
   522 00000545 720D                <1> 	jb	memory_write_page	; no
   523                              <1> 
   524 00000547 81FEFC0F0000        <1> 	cmp	esi, 0FFCh		; near the edge?
   525 0000054D 7605                <1> 	jna	memory_write_page	; no
   526                              <1> 
   527 0000054F E8E41F0000          <1> 	call	write_straddle_12b?
   528                              <1> 
   529                              <1> memory_write_page:
   530                              <1> ;	mov	edi, dword ptr [ebp+CORE_INDEX1]
   531 00000554 0F7EFF              <1> 	movd	edi, mm7
   532                              <1> 
   533 00000557 3B87C0060000        <1> 	cmp	eax, dword ptr [edi+IO_PORT+_RAM_THRESHOLD] ; edi -> core registers
   534 0000055D 0F88A0090000        <1> 	js	near guard_ii_authority	; guard the NVRAM whether real or emulated
   535                              <1> 
   536 00000563 C1E00C              <1> 	shl	eax, 12			; multiply by page and lose bit 00400000
   537                              <1> 
   538 00000566 01C6                <1> 	add	esi, eax		; add offset
   539                              <1> 
   540 00000568 BF[00000000]        <1> 	mov	edi, _memory
   541                              <1> 
   542                              <1> memory_write_on:
   543 0000056D 8D3CB7              <1> 	lea	edi, [edi+esi*4]
   544                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
   545 00000570 0F7EFE              <1> 	movd	esi, mm7
   546                              <1> 
   547 00000573 F705[00000000]1000- <1> 	test	dword ptr [_general_indication], TOUCHPOINT
   547 0000057B 0000                <1>
   548 0000057D 7415                <1> 	jz	memory_write_on_go
   549                              <1> 
   550 0000057F 3B3D[00000000]      <1> 	cmp	edi, dword ptr [_touchpoint]
   551 00000585 780D                <1> 	js	memory_write_on_go
   552 00000587 3B3D[00000000]      <1> 	cmp	edi, dword ptr [_touchpoint2]
   553 0000058D 7905                <1> 	jns	memory_write_on_go
   554 0000058F E96F090000          <1> 	jmp	guard_ii_authority
   555                              <1> 
   556                              <1> memory_write_on_go:
   557 00000594 0FB6C1              <1> 	movzx	eax, cl
   558 00000597 8B0485[A0050000]    <1> 	mov	eax, dword ptr [write_action+eax*4]
   559 0000059E FFE0                <1> 	jmp	eax
   560                              <1> 
   561                              <1> write_action:
   562 000005A0 [C0050000]          <1> 	dd	memory_write
   563 000005A4 [C5050000]          <1> 	dd	write_t1
   564 000005A8 [C9050000]          <1> 	dd	write_t2	; or h1
   565 000005AC [D6050000]          <1> 	dd	write_t3	; or h2
   566 000005B0 [C4050000]          <1> 	dd	just_dont
   567 000005B4 [C4050000]          <1> 	dd	just_dont
   568 000005B8 [10060000]          <1> 	dd	memory_write2
   569 000005BC [22060000]          <1> 	dd	memory_write4
   570                              <1> 
   571                              <1> memory_write:					; store system memory 1 word
   572 000005C0 0FCB                <1> 	bswap	ebx
   573 000005C2 891F                <1> 	mov	dword ptr [edi], ebx
   574                              <1> 
   575                              <1> just_dont:
   576 000005C4 C3                  <1> 	ret
   577                              <1> 
   578                              <1> write_t1:
   579 000005C5 885F01              <1> 	mov	byte ptr [edi+1], bl
   580 000005C8 C3                  <1> 	ret
   581                              <1> 
   582                              <1> write_t2:
   583 000005C9 F686A004000080      <1> 	test	byte ptr [esi+PSR], HALF_W
   584 000005D0 7511                <1> 	jnz	write_h1
   585 000005D2 885F02              <1> 	mov	byte ptr [edi+2], bl
   586 000005D5 C3                  <1> 	ret
   587                              <1> 
   588                              <1> write_t3:
   589 000005D6 F686A004000080      <1> 	test	byte ptr [esi+PSR], HALF_W
   590 000005DD 751A                <1> 	jnz	write_h2
   591 000005DF 885F03              <1> 	mov	byte ptr [edi+3], bl
   592 000005E2 C3                  <1> 	ret
   593                              <1> 
   594                              <1> write_h1:
   595 000005E3 8B07                <1> 	mov	eax, dword ptr [edi]
   596 000005E5 0FC8                <1> 	bswap	eax
   597 000005E7 81E3FF0F0000        <1> 	and	ebx, 4095
   598 000005ED C1E30C              <1> 	shl	ebx, 12
   599 000005F0 25FF0F0000          <1> 	and	eax, 4095
   600 000005F5 09D8                <1> 	or	eax, ebx
   601 000005F7 EB12                <1> 	jmp	write_hw
   602                              <1> 
   603                              <1> write_h2:
   604 000005F9 8B07                <1> 	mov	eax, dword ptr [edi]
   605 000005FB 0FC8                <1> 	bswap	eax
   606 000005FD C1E80C              <1> 	shr	eax, 12
   607 00000600 C1E00C              <1> 	shl	eax, 12
   608 00000603 81E3FF0F0000        <1> 	and	ebx, 4095
   609 00000609 09D8                <1> 	or	eax, ebx
   610                              <1> 
   611                              <1> write_hw:
   612 0000060B 0FC8                <1> 	bswap	eax
   613 0000060D 8907                <1> 	mov	dword ptr [edi], eax
   614 0000060F C3                  <1> 	ret
   615                              <1> 					; store system memory 2 words
   616                              <1> memory_write2:				; eax is already free
   617 00000610 8B449D00            <1> 	mov	eax, dword ptr [ebp+ebx*4]
   618 00000614 0FC8                <1> 	bswap	eax
   619 00000616 8907                <1> 	mov	dword ptr [edi], eax
   620                              <1> 
   621 00000618 8B449D04            <1> 	mov	eax, dword ptr [ebp+ebx*4+4]
   622 0000061C 0FC8                <1> 	bswap	eax
   623 0000061E 894704              <1> 	mov	dword ptr [edi+4], eax
   624 00000621 C3                  <1> 	ret
   625                              <1> 
   626                              <1> memory_write4:					; store system memory 4 words
   627 00000622 8B449D00            <1> 	mov	eax, dword ptr [ebp+ebx*4]	; bx is a register number and may
   628                              <1> 						; identify extra workspace registers
   629                              <1> 						; at register stack tail
   630 00000626 0FC8                <1> 	bswap	eax
   631 00000628 8907                <1> 	mov	dword ptr [edi], eax
   632 0000062A 8B449D04            <1> 	mov	eax, dword ptr [ebp+ebx*4+4]
   633 0000062E 0FC8                <1> 	bswap	eax
   634 00000630 894704              <1> 	mov	dword ptr [edi+4], eax
   635 00000633 8B449D08            <1> 	mov	eax, dword ptr [ebp+ebx*4+8]
   636 00000637 0FC8                <1> 	bswap	eax
   637 00000639 894708              <1> 	mov	dword ptr [edi+2*4], eax
   638 0000063C 8B449D0C            <1> 	mov	eax, dword ptr [ebp+ebx*4+12]
   639 00000640 0FC8                <1> 	bswap	eax
   640 00000642 89470C              <1> 	mov	dword ptr [edi+3*4], eax
   641 00000645 C3                  <1> 	ret
   642                              <1> 
   643                              <1> ;	modify instructions n inc dec src slc sim popA
   644                              <1> ;	rewrite here
   645                              <1> 
   646                              <1> 
   647                              <1> memoreg_writeback:
   648                              <1> 	%if	1
   649 00000646 21FF                <1> 	and	edi, edi
   650 00000648 7509                <1> 	jnz	memory_direct
   651 0000064A 25FFFFFF00          <1> 	and	eax, 00FFFFFFh			; unchanged esi -> core.REGISTER	
   652 0000064F 89049E              <1> 	mov	[esi+ebx*4+REGISTER], eax	; platform endian
   653                              <1> 						; register writeback index ebx ->
   654 00000652 C3                  <1> 	ret
   655                              <1> 	%else
   656                              <1> 
   657                              <1> 
   658                              <1> 	test	ebx, -256			; save EA is ?
   659                              <1> 	jnz	memory_direct			; a memory device
   660                              <1> 	xchg	eax, ebx			; a register
   661                              <1> 	and	ebx, 00FFFFFFh
   662                              <1> 	jmp	_operand_write_register		; esi -> core.REGISTER
   663                              <1> 
   664                              <1> ;	if not a register rewrite
   665                              <1> ;	n inc dec src slc sim popA
   666                              <1> ;	write RTA memory at its saved platform address
   667                              <1> 	%endif
   668                              <1> 
   669                              <1> memory_direct:					; esi <- memory_offset
   670 00000653 0FC8                <1> 	bswap	eax				; write components edi esi kept from base_read
   671 00000655 30C0                <1> 	xor	al, al				
   672 00000657 8904B7              <1> 	mov	dword ptr [edi+esi*4], eax
   673 0000065A C3                  <1> 	ret
   674                              <1> 
   675                              <1> 
   676                              <1> ;	execute calls memory read
   677                              <1> ;	ea < 256 is not for execute a register
   678                              <1> ;	operand is at a readable address in system memory or array
   679                              <1> 
   680                              <1> memory_read:					; for execute and modify instructions:
   681 0000065B E867000000          <1> 	call	memory_point			; read only executable space
   682 00000660 8B04B7              <1> 	mov	eax, dword ptr [edi+esi*4]	; and similar memory types
   683 00000663 0FC8                <1> 	bswap	eax
   684 00000665 C3                  <1> 	ret
   685                              <1> 
   686                              <1> ;	modify instructions n inc dec src slc sim popA call here
   687                              <1> ;	ea < 256 is a register
   688                              <1> 
   689                              <1> memoreg:					; read-modify-write registers / system memory
   690 00000666 A900FFFFFF          <1> 	test	eax, -256			; but nothing marked as a peripheral bus
   691 0000066B 751A                <1> 	jnz	memory_read_lock
   692 0000066D A880                <1> 	test	al, 128				; interrupt register?
   693 0000066F 740E                <1> 	jz	register_read_for_write		; no, clear to update
   694 00000671 F686A204000080      <1> 	test	byte ptr [esi+PSR+2], 128	; ISR ?
   695 00000678 7505                <1> 	jnz	register_read_for_write
   696 0000067A E984080000          <1> 	jmp	guard_ii_authority
   697                              <1> 
   698                              <1> register_read_for_write:			; unchanged esi -> core.REGISTER
   699 0000067F 89C3                <1>         mov     ebx, eax                        ; copy of ea -> registers to memoreg_writeback
   700 00000681 31FF                <1>         xor     edi, edi                        ; tell memoreg->writeback that's how it is, no device
   701 00000683 8B0486              <1>         mov     eax, dword ptr [esi+REGISTER+eax*4]
   702 00000686 C3                  <1>         ret					; register writeback index ebx ->
   703                              <1> 
   704                              <1> 
   705                              <1> ;	RAM boundary in port 124 defines the upper page limit
   706                              <1> ;	of a real or emulated NVRAM containing the fixed system image
   707                              <1> 
   708                              <1> ;	fixed system image may be kernel + loader in a dozen pages
   709                              <1> ;	or it may be the entire application
   710                              <1> 
   711                              <1> ;	emulated machine applies the update limit
   712                              <1> ;	whether NVRAM is emulated or real
   713                              <1> 
   714                              <1> ;	if not a register
   715                              <1> ;	n inc dec src slc sim popA read a memory word which is legal to write
   716                              <1> ;	and keep the platform address to write the modified value
   717                              <1> ;	modify instructions do not lock memory between read and rewrite
   718                              <1> 
   719                              <1> memory_read_lock:
   720 00000687 E806000000          <1> 	call	memory_lock
   721 0000068C 8B04B7              <1> 	mov	eax, dword ptr [edi+esi*4]
   722 0000068F 0FC8                <1> 	bswap	eax
   723 00000691 C3                  <1> 	ret
   724                              <1> 
   725                              <1> ;	memory_read_lock calls here for modify instructions if ea > registers
   726                              <1> ;	ts calls here with ea whatever range always -> memory
   727                              <1> 
   728                              <1> ;	ea must be a legally writable memory word
   729                              <1> ;	memory_lock does not lock but identifies a platform write address  
   730                              <1> ;	ts reads / unconditionally replaces word.t1
   731                              <1> ;	under platform locking protocol, xchg platform instruction
   732                              <1> 
   733                              <1> memory_lock:					; point for update
   734                              <1> 						; barred below RAM boundary as write is
   735 00000692 E80D030000          <1> 	call	base_write_pointer		; resolve device:block:offset from EA
   736                              <1> 						; edi <- core.REGISTERS <- esi
   737                              <1> 						; eax <- memory block index
   738                              <1> 						; esi <- memory word offset
   739                              <1> 
   740                              <1> ;	mov	edi, dword ptr [ebp+CORE_INDEX1]
   741 00000697 0F7EFF              <1> 	movd	edi, mm7
   742                              <1> 
   743 0000069A A900004000          <1> 	test	eax, 00400000h			; update block name is a big bank ?
   744 0000069F 7419                <1> 	jz	memory_lock_page		; no
   745 000006A1 A93F000000          <1> 	test	eax, 63				; a device outside executable space ?
   746 000006A6 754D                <1> 	jnz	_yspace_read			; yes
   747 000006A8 25FFFF3F00          <1> 	and	eax, 003FFFFFh			; bit 0400000 is gets stripped later anyway
   748 000006AD 3B87C0060000        <1> 	cmp	eax, dword ptr [edi+IO_PORT+_RAM_THRESHOLD]	; below RAM boundary?
   749 000006B3 7339                <1> 	jnb	_xspace_read			; no, go ahead
   750 000006B5 E949080000          <1> 	jmp	guard_ii_authority
   751                              <1> 
   752                              <1> memory_lock_page:
   753 000006BA 3B87C0060000        <1> 	cmp	eax, dword ptr [edi+IO_PORT+_RAM_THRESHOLD]	; below RAM boundary?
   754 000006C0 731A                <1> 	jnb	_xspace_read4K			; no, go head if offset < 1000 hex
   755 000006C2 E93C080000          <1> 	jmp	guard_ii_authority
   756                              <1> 
   757                              <1> 
   758                              <1> ;	memory_read calls here for execute
   759                              <1> ;	identify a platform read address of an RTA memory word
   760                              <1> 
   761                              <1> memory_point:
   762 000006C7 E844020000          <1> 	call	base_read_pointer		; edi <- core.REGISTERS <- esi
   763                              <1> 						; esi <- word offset in memory block
   764 000006CC A900004000          <1> 	test	eax, 00400000h			; eax <- page index
   765 000006D1 7409                <1> 	jz	_xspace_read4K
   766                              <1> 
   767 000006D3 A93F000000          <1> 	test	eax, 63
   768 000006D8 7414                <1> 	jz	_xspace_read
   769 000006DA EB19                <1> 	jmp	_yspace_read			; ie a device either appropriate or not
   770                              <1> 
   771                              <1> _xspace_read4K:
   772 000006DC F7C600F00300        <1> 	test	esi, 003F000h
   773 000006E2 740A                <1> 	jz	_xspace_read
   774 000006E4 B90E000000          <1> 	mov	ecx, LP_ADDRESS
   775 000006E9 E91A080000          <1> 	jmp	guard_ii_escape
   776                              <1> 
   777                              <1> _xspace_read:
   778 000006EE BF[00000000]        <1> 	mov	edi, _memory
   779 000006F3 EB34                <1> 	jmp	_memory_deliver			; device array zero
   780                              <1> 
   781                              <1> _yspace_read:
   782 000006F5 A900008000          <1> 	test	eax, 00800000h			; a tripsy non-space?
   783 000006FA 7533                <1> 	jnz	_zspace_read			; not allowed
   784                              <1> 
   785 000006FC 89C7                <1> 	mov	edi, eax
   786 000006FE 83E73F              <1> 	and	edi, 63
   787 00000701 8BBCBED0060000      <1> 	mov	edi, dword ptr [esi+IO_PORT+_DEVICE+edi*4]
   788 00000708 F7C700008000        <1> 	test	edi, SYSMEM_FLAG
   789 0000070E 741F                <1> 	jz	_zspace_read
   790 00000710 F7C700004000        <1> 	test	edi, DATA16_FLAG
   791 00000716 7517                <1> 	jnz	_zspace_read
   792                              <1> 
   793 00000718 C1E002              <1> 	shl	eax, 2				; al = 4 * device index
   794 0000071B 0FB6F8              <1> 	movzx	edi, al
   795                              <1> 
   796 0000071E 8BBF[00000000]      <1> 	mov	edi, dword ptr [_devices+edi]	; and platform pointers are also 32-bit
   797 00000724 30C0                <1> 	xor	al, al				; necessary to lose the device bits now
   798 00000726 C1E802              <1> 	shr	eax, 2
   799                              <1> 
   800                              <1> _memory_deliver:
   801 00000729 C1E00C              <1> 	shl	eax, 12		; multiply by page and lose bit 00400000
   802 0000072C 01C6                <1> 	add	esi, eax
   803                              <1> 
   804                              <1> 	%if	__SMP
   805                              <1> 	%else
   806                              <1> 	mov	eax, dword ptr [edi+esi*4]
   807                              <1> 	bswap	eax
   808                              <1> 	%endif
   809 0000072E C3                  <1> 	ret
   810                              <1> 
   811                              <1> _zspace_read:
   812 0000072F E9CF070000          <1> 	jmp	guard_ii_authority
   813                              <1> 
   814                              <1> ;	esi -> core
   815                              <1> 
   816                              <1> ;	sub-architectural measure on sabr and reload instructions
   817                              <1> 
   818                              <1> ;	check the target memory block is in range and the bus characteristic
   819                              <1> ;	of the memory device when selecting blocks of memory, not when
   820                              <1> ;	accessing them. Use 8 spare bits in the word containing _base[]
   821                              <1> ;	for a quick recall of the emulated bus attribute on reference
   822                              <1> 
   823                              <1> ;	because this software emulation needs to act differently for
   824                              <1> 
   825                              <1> ;		executable space	rta1 24-bit words canonical memory
   826                              <1> ;					modeled in platform 32-bit words
   827                              <1> 
   828                              <1> ;		shared network buffers	16-bit words canonical in memory
   829                              <1> ;					and zero extend on readout to RTA1
   830                              <1> 
   831                              <1> ;		24-bit filestore array	3-octet words stored big-endian
   832                              <1> ;					in packed array
   833                              <1> 
   834                              <1> ;	concept RTA1 device arrays with bus behaviour differences are completely
   835                              <1> ;	emulated on PC emulations because device arrays are modeled in PC RAM.
   836                              <1> 
   837                              <1> ;	Various bus behaviours are emulated transparently to RTA1 target software
   838                              <1> ;	in anticipation	that different memories for different uses may be attached
   839                              <1> ;	on product boards, making core-emulated RTA1s much more efficient for not
   840                              <1> ;	needing this part of emulation
   841                              <1> 
   842                              <1> ;	devices
   843                              <1> 
   844                              <1> ;	device 0 is always executable space, but there may be more devices
   845                              <1> ;	with bus characteristics like device 0. The device descriptors are
   846                              <1> 
   847                              <1> ;		_________________________________________________________________
   848                              <1> ;		| 16 bits flags	| 16 bits banks	|       32 bits pointer		|
   849                              <1> ;		|_______________|____high index_|_______________________________|
   850                              <1> 
   851                              <1> 
   852                              <1> ;	[out]	sabr	[go]	[call]	reload instructions call here
   853                              <1> ;	go and call can probably check quicker themself
   854                              <1> ;	out can be trusted because applications don't out memory _base[] ports
   855                              <1> 
   856                              <1> ;	a big block in an RTA1 address window is 262144 words.
   857                              <1> ;	this checking concerns address windows tagged 2..63
   858                              <1> ;	a device is an array up to 65536 big blocks or banks
   859                              <1> 
   860                              <1> ;	you get here with the relocation handle in ebx
   861                              <1> ;	and the target window tag in eax, because that is the EA of a sabr instruction
   862                              <1> 
   863                              <1> device_read:				; readout device arrays
   864 00000734 A900008000          <1>         test    eax, 0800000h           ; the vilainous bank index?
   865 00000739 7537                <1>         jnz     device_read_escape
   866                              <1> 
   867                              <1> 					; edi -> core.REGISTER
   868 0000073B C1E002              <1> 	shl	eax, 2			; al is device index * 4
   869 0000073E 50                  <1> 	push	eax			; rest of eax is block index * 4
   870 0000073F 0FB6C0              <1> 	movzx	eax, al			; extend device number
   871                              <1> 					; sense device descriptor
   872                              <1> 
   873                              <1> ;	mov	edi, dword ptr [ebp+CORE_INDEX1]
   874 00000742 0F7EFF              <1> 	movd	edi, mm7
   875                              <1> 
   876 00000745 F68438D2060000C0    <1> 	test	byte ptr [edi+eax+IO_PORT+_DEVICE+2], 192
   877                              <1> 
   878 0000074D 58                  <1> 	pop	eax			; recover storage block index
   879                              <1> 
   880 0000074E 7422                <1> 	jz	device_read_escape	; neither type flag set
   881                              <1> 
   882 00000750 9C                  <1> 	pushfd				; sign is set for descriptor bit 23	
   883                              <1> 					; parity is set if both bits are
   884                              <1> 
   885 00000751 8AAFA0040000        <1> 	mov	ch, byte ptr [edi+PSR]	; flag field with byte options for memory read
   886 00000757 0FB6F8              <1> 	movzx	edi, al			; device select
   887                              <1> 
   888 0000075A 30C0                <1> 	xor	al, al			; add storage block to offset
   889 0000075C C1E00A              <1> 	shl	eax, 10			; block index * 64 * 4 now times 262144
   890 0000075F 01C6                <1> 	add	esi, eax		; offset += <-
   891                              <1> 
   892 00000761 8BBF[00000000]      <1> 	mov	edi,  dword ptr [_devices+edi]
   893                              <1> 
   894                              <1> 					; known that one or two bits is set
   895 00000767 58                  <1> 	pop	eax			; flags from test of device	
   896                              <1> 
   897 00000768 A804                <1> 	test	al, 4			; parity?
   898 0000076A 755C                <1> 	jnz	device_read_array24	; parity -> 2 bits set -> FSYS24 bus
   899                              <1> 
   900 0000076C A880                <1> 	test	al, 128			; sign -> descriptor bit 23 -> SYSMEM
   901 0000076E 7411                <1> 	jz	device_read_data16	; otherwise NET16 trunk
   902 00000770 EB0A                <1> 	jmp	device_read_sysmem	; system memory type if yes				
   903                              <1> 
   904                              <1> device_read_escape:
   905 00000772 B90E000000          <1> 	mov	ecx, LP_ADDRESS
   906 00000777 E98C070000          <1> 	jmp	guard_ii_escape
   907                              <1> 
   908                              <1> 
   909                              <1> device_read_sysmem:			; readout system memory array
   910 0000077C E93DFCFFFF          <1> 	jmp	memory_read_on		; allow all variations partial word / multiword
   911                              <1> 
   912                              <1> device_read_data16:			; readout 16-bit array
   913                              <1> 
   914 00000781 80F907              <1> 	cmp	cl, 7
   915 00000784 741A                <1> 	jz	device_read_data16_4
   916 00000786 80F906              <1> 	cmp	cl, 6
   917 00000789 7409                <1> 	jz	device_read_data16_2
   918 0000078B EB00                <1> 	jmp	device_read_data16_1
   919                              <1> 
   920                              <1> device_read_data16_1:			; readout 1 word of 16-bit array
   921 0000078D 0FB70477            <1> 	movzx	eax, word ptr [edi+esi*2]
   922 00000791 86E0                <1> 	xchg	ah, al
   923 00000793 C3                  <1> 	ret
   924                              <1> 
   925                              <1> device_read_data16_2:			; readout 2 words of 16-bit array
   926 00000794 8B0477              <1> 	mov	eax, dword ptr [edi+esi*2]	; 4.3.2.1
   927 00000797 0FC8                <1> 	bswap	eax				; 1.2.3.4
   928 00000799 0FB7D8              <1> 	movzx	ebx, ax				; 0.0.3.4
   929 0000079C C1E810              <1> 	shr	eax, 16				; 0.0.1.2
   930 0000079F C3                  <1> 	ret
   931                              <1> 
   932                              <1> device_read_data16_4:			; readout 4 words of 16-bit array
   933 000007A0 8B0477              <1> 	mov	eax, dword ptr [edi+esi*2]
   934 000007A3 0FC8                <1> 	bswap	eax				; 1.2.3.4
   935 000007A5 0FB7C8              <1> 	movzx	ecx, ax
   936 000007A8 C1E810              <1> 	shr	eax, 16
   937 000007AB 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   938 000007AF 894C9D04            <1> 	mov	dword ptr [ebp+ebx*4+4], ecx
   939                              <1> 
   940 000007B3 8B447704            <1> 	mov     eax, dword ptr [edi+esi*2+4]
   941 000007B7 0FC8                <1> 	bswap	eax				; 5.6.7.8
   942 000007B9 0FB7C8              <1> 	movzx	ecx, ax
   943 000007BC C1E810              <1> 	shr	eax, 16
   944 000007BF 89449D08            <1> 	mov	dword ptr [ebp+ebx*4+8], eax
   945 000007C3 894C9D0C            <1> 	mov	dword ptr [ebp+ebx*4+12], ecx
   946 000007C7 C3                  <1> 	ret
   947                              <1> 
   948                              <1> device_read_array24:			; readout from packed 24-bit array
   949 000007C8 E83C010000          <1> 	call	device_array24_setpointer
   950                              <1> 
   951 000007CD 80F907              <1> 	cmp	cl, 7
   952 000007D0 7440                <1> 	jz	device_read_array24_4
   953 000007D2 80F906              <1> 	cmp	cl, 6
   954 000007D5 7430                <1> 	jz	device_read_array24_2
   955 000007D7 EB00                <1> 	jmp	device_read_array24_1
   956                              <1> 
   957                              <1> device_read_array24_1:			; readout a word of packed 24-bit array
   958 000007D9 660FB60437          <1> 	movzx	ax, byte ptr [edi+esi]
   959 000007DE C1E008              <1> 	shl	eax, 8
   960 000007E1 8A443701            <1> 	mov	al, byte ptr [edi+esi+1]
   961 000007E5 C1E008              <1> 	shl	eax, 8
   962 000007E8 8A443702            <1> 	mov	al, byte ptr [edi+esi+2]
   963 000007EC 83C603              <1> 	add	esi, 3
   964 000007EF C3                  <1> 	ret
   965                              <1> 
   966                              <1> device_read_array24_1R:
   967 000007F0 660FB61C37          <1> 	movzx	bx, byte ptr [edi+esi]
   968 000007F5 C1E308              <1> 	shl	ebx, 8
   969 000007F8 8A5C3701            <1> 	mov	bl, byte ptr [edi+esi+1]
   970 000007FC C1E308              <1> 	shl	ebx, 8
   971 000007FF 8A5C3702            <1> 	mov	bl, byte ptr [edi+esi+2]
   972 00000803 83C603              <1> 	add	esi, 3
   973 00000806 C3                  <1> 	ret
   974                              <1> 
   975                              <1> device_read_array24_2:			; readout 2 words of packed 24-bit array
   976 00000807 E8CDFFFFFF          <1> 	call	device_read_array24_1
   977 0000080C E8DFFFFFFF          <1> 	call	device_read_array24_1R
   978 00000811 C3                  <1> 	ret
   979                              <1> 
   980                              <1> device_read_array24_4:			; readout 4 words of packed 24-bit array
   981 00000812 E8C2FFFFFF          <1> 	call	device_read_array24_1
   982 00000817 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   983 0000081B E8B9FFFFFF          <1> 	call	device_read_array24_1
   984 00000820 89449D04            <1> 	mov	dword ptr [ebp+ebx*4+4], eax
   985 00000824 E8B0FFFFFF          <1> 	call	device_read_array24_1
   986 00000829 89449D08            <1> 	mov	dword ptr [ebp+ebx*4+8], eax
   987 0000082D E8A7FFFFFF          <1> 	call	device_read_array24_1
   988 00000832 89449D0C            <1> 	mov	dword ptr [ebp+ebx*4+12], eax
   989 00000836 C3                  <1> 	ret
   990                              <1> 
   991                              <1> _device_write:				; store device arrays
   992 00000837 A900008000          <1> 	test	eax, 0800000h		; the vilainous bank index?
   993 0000083C 7537                <1> 	jnz	device_write_escape
   994                              <1> 
   995                              <1>                                         ; edi -> core.REGISTER
   996 0000083E C1E002              <1>         shl     eax, 2                  ; al is device index * 4
   997 00000841 50                  <1>         push    eax                     ; rest of eax is block index * 4
   998 00000842 0FB6C0              <1>         movzx   eax, al                 ; extend device number
   999                              <1>                                         ; sense device descriptor
  1000                              <1> 
  1001                              <1> ;	mov	edi, dword ptr [ebp+CORE_INDEX1]
  1002 00000845 0F7EFF              <1> 	movd	edi, mm7
  1003                              <1> 
  1004 00000848 F68438D2060000C0    <1>         test    byte ptr [edi+eax+IO_PORT+_DEVICE+2], 192
  1005                              <1> 
  1006 00000850 58                  <1>         pop     eax                     ; recover storage block index
  1007                              <1> 
  1008 00000851 7422                <1>         jz      device_write_escape      ; neither type flag set
  1009                              <1> 
  1010 00000853 9C                  <1>         pushfd                          ; sign is set for descriptor bit 23     
  1011                              <1>                                         ; parity is set if both bits are
  1012                              <1> 
  1013 00000854 8AAFA0040000        <1>         mov     ch, byte ptr [edi+PSR]  ; flag field with byte options for memory read
  1014 0000085A 0FB6F8              <1>         movzx   edi, al                 ; device select
  1015                              <1> 
  1016 0000085D 30C0                <1>         xor     al, al                  ; add storage block to offset
  1017 0000085F C1E00A              <1>         shl     eax, 10                 ; block index * 64 * 4 now times 262144
  1018 00000862 01C6                <1>         add     esi, eax                ; offset += <-
  1019                              <1> 
  1020 00000864 8BBF[00000000]      <1>         mov     edi,  dword ptr [_devices+edi]
  1021                              <1> 
  1022                              <1>                                         ; known that one or two bits is set
  1023 0000086A 58                  <1>         pop     eax                     ; flags from test of device     
  1024                              <1> 
  1025 0000086B A804                <1>         test    al, 4                   ; parity?
  1026 0000086D 754E                <1>         jnz     device_write_array24    ; parity -> 2 bits set -> FSYS24 bus
  1027 0000086F A880                <1>         test    al, 128                 ; sign -> descriptor bit 23 -> SYSMEM
  1028 00000871 7411                <1>         jz      device_write_data16     ; otherwise NET16 trunk
  1029 00000873 EB0A                <1>         jmp     device_write_sysmem     ; system memory type if yes                     
  1030                              <1> 
  1031                              <1> device_write_escape:
  1032 00000875 B90E000000          <1> 	mov	ecx, LP_ADDRESS
  1033 0000087A E989060000          <1> 	jmp	guard_ii_escape
  1034                              <1> 
  1035                              <1> 
  1036                              <1> device_write_sysmem:
  1037 0000087F E9E9FCFFFF          <1> 	jmp	memory_write_on		; allow all variations partial word / multiword
  1038                              <1> 
  1039                              <1> device_write_data16:
  1040                              <1> 
  1041 00000884 80F907              <1> 	cmp	cl, 7
  1042 00000887 740E                <1> 	jz	device_write_data16_4
  1043 00000889 80F906              <1> 	cmp	cl, 6
  1044 0000088C 741C                <1> 	jz	device_write_data16_2
  1045 0000088E EB00                <1> 	jmp	device_write_data16_1
  1046                              <1> 
  1047                              <1> device_write_data16_1:			; store 16-bit array
  1048 00000890 86FB                <1> 	xchg	bh, bl
  1049 00000892 66891C77            <1> 	mov	word ptr [edi+esi*2], bx
  1050 00000896 C3                  <1> 	ret
  1051                              <1> 
  1052                              <1> 
  1053                              <1> device_write_data16_4:			; store 4 words in 16-bit array
  1054                              <1> 					; low-order half is swapped on bus read
  1055                              <1> 					; and canonical in eax
  1056 00000897 668B449D08          <1> 	mov	ax, word ptr [ebp+ebx*4+8]	; get low-order half 3rd register
  1057 0000089C C1E010              <1> 	shl	eax, 16				; 5.6.0.0
  1058 0000089F 668B449D0C          <1> 	mov	ax, word ptr [ebp+ebx*4+12]	; 5.6.7.8
  1059 000008A4 0FC8                <1> 	bswap	eax				; it's correct so swap for bus write
  1060 000008A6 89447704            <1> 	mov	dword ptr [edi+esi*2+4], eax
  1061                              <1> 
  1062                              <1> 
  1063                              <1> device_write_data16_2:			; store 2 words in 16-bit array
  1064                              <1> 					; registers are modeled in storage
  1065                              <1> 					; so each bus read corrects an octet pair
  1066                              <1> 
  1067 000008AA 668B449D00          <1> 	mov	ax, word ptr [ebp+ebx*4]	; get low-order half 1st register
  1068 000008AF C1E010              <1> 	shl	eax, 16				; 1.2.0.0
  1069 000008B2 668B449D04          <1> 	mov	ax, word ptr [ebp+ebx*4+4]	; 1.2.3.4
  1070 000008B7 0FC8                <1> 	bswap	eax				; it's correct, so swap for bus write
  1071 000008B9 890477              <1> 	mov	dword ptr [edi+esi*2], eax
  1072 000008BC C3                  <1> 	ret
  1073                              <1> 
  1074                              <1> device_write_array24:			; store 24-bit packed array
  1075 000008BD E847000000          <1> 	call	device_array24_setpointer
  1076                              <1> 
  1077 000008C2 80F907              <1> 	cmp	cl, 7
  1078 000008C5 7434                <1> 	jz	device_write_array24_4
  1079 000008C7 80F906              <1> 	cmp	cl, 6
  1080 000008CA 741C                <1> 	jz	device_write_array24_2
  1081 000008CC EB00                <1> 	jmp	device_write_array24_1
  1082                              <1> 
  1083                              <1> device_write_array24_1:			; store 1 word in packed 24-bit array
  1084 000008CE 89D8                <1> 	mov	eax, ebx
  1085                              <1> device_write_array24_x:
  1086 000008D0 C1C010              <1> 	rol	eax, 16
  1087 000008D3 880437              <1> 	mov	byte ptr [edi+esi], al
  1088 000008D6 C1C008              <1> 	rol	eax, 8
  1089 000008D9 88443701            <1> 	mov	byte ptr [edi+esi+1], al
  1090 000008DD C1C008              <1> 	rol	eax, 8
  1091 000008E0 88443702            <1> 	mov	byte ptr [edi+esi+2], al
  1092 000008E4 83C603              <1> 	add	esi, 3
  1093 000008E7 C3                  <1> 	ret
  1094                              <1> 
  1095                              <1> device_write_array24_2:			; store 2 words in packed 24-bit array
  1096 000008E8 8B449D00            <1> 	mov	eax, [ebp+ebx*4]
  1097 000008EC E8DFFFFFFF          <1> 	call	device_write_array24_x
  1098 000008F1 8B449D04            <1> 	mov	eax, [ebp+ebx*4+4]
  1099 000008F5 E8D6FFFFFF          <1> 	call	device_write_array24_x
  1100                              <1> ;	add	ebx, 2
  1101 000008FA C3                  <1> 	ret
  1102                              <1> 
  1103                              <1> device_write_array24_4:			; store 4 words in packed 24-bit array
  1104 000008FB E8E8FFFFFF          <1> 	call	device_write_array24_2
  1105 00000900 83C302              <1> 	add	ebx, 2
  1106 00000903 E8E0FFFFFF          <1> 	call	device_write_array24_2
  1107 00000908 C3                  <1> 	ret
  1108                              <1> 
  1109                              <1> device_array24_setpointer:
  1110 00000909 89F0                <1> 	mov	eax, esi			; think of a number
  1111 0000090B D1E0                <1> 	shl	eax, 1				; double it
  1112 0000090D 01C6                <1> 	add	esi, eax			; add it to the number you first thought of...
  1113 0000090F C3                  <1> 	ret
  1114                              <1> 
    31                                  	%include	"base_map.msm"
     1                              <1> base_read_pointer:
     2 00000910 89C7                <1> 	mov	edi, eax		; keep EA for +words reads
     3                              <1> 					; straddling storage blocks
     4 00000912 C1C910              <1> 	ror	ecx, 16			; conserve designator / word counts
     5                              <1> 
     6 00000915 C1C812              <1> 	ror	eax, 18
     7 00000918 A83F                <1> 	test	al, 63
     8 0000091A 750C                <1> 	jnz	read_address18
     9 0000091C C1C006              <1> 	rol	eax, 6
    10 0000091F 660FB6C8            <1> 	movzx	cx, al
    11 00000923 C1E814              <1> 	shr	eax, 32-12
    12                              <1> 					; advise caller address 6.12
    13 00000926 EB07                <1> 	jmp	resolve_read_tag	; this path is  most storage reads
    14                              <1> 	
    15                              <1> read_address18:
    16 00000928 660FB6C8            <1> 	movzx	cx, al
    17 0000092C C1E80E              <1> 	shr	eax, 32-18
    18                              <1> 
    19                              <1> resolve_read_tag:
    20                              <1> 
    21 0000092F 80E13F              <1> 	and	cl, 63
    22 00000932 7418                <1> 	jz	read_window_clear	; everyone may read B0
    23 00000934 F6C138              <1> 	test	cl, 56
    24 00000937 7513                <1> 	jnz	read_window_clear
    25 00000939 80F10F              <1> 	xor	cl, 15			; [ 1 2 3 4 5 6 7 ] -> 8 + [ 6 5 4 3 2 1 0]
    26 0000093C 660FA38EA0040000    <1> 	bt	word ptr [esi+PSR], cx	; in memory bytes ffff f00c 0xxx xxxx
    27 00000944 7303                <1> 	jnc	read_application_window	; x86 bus read -> 0xxx xxxx ffff f00c
    28 00000946 80C940              <1> 	or	cl, 64
    29                              <1> 
    30                              <1> read_application_window:
    31 00000949 80F10F              <1> 	xor	cl, 15			; [ 1 2 3 4 5 6 7 ] <- 8 + [ 6 5 4 3 2 1 0]
    32                              <1> 
    33                              <1> read_window_clear:
    34 0000094C 50                  <1> 	push	eax
    35 0000094D 0FB6C1              <1> 	movzx	eax, cl
    36 00000950 8B8486D0040000      <1> 	mov	eax, dword ptr [esi+eax*4+IO_PORT]
    37 00000957 5E                  <1> 	pop	esi
    38                              <1> 
    39 00000958 C1C910              <1> 	ror	ecx, 16
    40 0000095B C3                  <1> 	ret
    41                              <1> 
    42 0000095C FF00800000000000    <1> write_rule	db	255, 0, 128, 0, 0, 0, 0, 0
    43 00000964 0000000000000000    <1> 		db	0, 0, 0, 0, 0, 0, 0, 0
    44 0000096C 0000000000000000    <1> 		db	0, 0, 0, 0, 0, 0, 0, 0
    45 00000974 0000000000000000    <1> 		db	0, 0, 0, 0, 0, 0, 0, 0
    46 0000097C 0000000000000000    <1> 		db	0, 0, 0, 0, 0, 0, 0, 0
    47 00000984 0000000000000000    <1> 		db	0, 0, 0, 0, 0, 0, 0, 0
    48 0000098C 0000000000000000    <1> 		db	0, 0, 0, 0, 0, 0, 0, 0
    49 00000994 0000000000000000    <1> 		db	0, 0, 0, 0, 0, 0, 0, 0
    50 0000099C FF80808080808080    <1> 		db	255, 128, 128, 128, 128, 128, 128, 128
    51                              <1> 
    52                              <1> base_write_pointer:
    53                              <1> 
    54 000009A4 89C7                <1> 	mov	edi, eax		; keep EA for +words writes
    55 000009A6 C1C910              <1> 	ror	ecx, 16			; straddling storage blocks
    56                              <1> 					; protect designators in ecx
    57 000009A9 C1C812              <1> 	ror	eax, 18			
    58                              <1> 
    59 000009AC A83F                <1> 	test	al, 63
    60 000009AE 750C                <1> 	jnz	write_address18
    61 000009B0 C1C006              <1> 	rol	eax, 6
    62 000009B3 660FB6C8            <1> 	movzx	cx, al
    63 000009B7 C1E814              <1> 	shr	eax, 32-12
    64 000009BA EB07                <1> 	jmp	resolve_write_tag	; this path is
    65                              <1> 					; most storge writes
    66                              <1> write_address18:
    67 000009BC 660FB6C8            <1> 	movzx	cx, al
    68 000009C0 C1E80E              <1> 	shr	eax, 32-18
    69                              <1> 	
    70                              <1> resolve_write_tag:
    71                              <1> 
    72 000009C3 80E13F              <1> 	and	cl, 63
    73 000009C6 0F8437050000        <1> 	jz	near guard_ii_authority	; no-one may write B0
    74 000009CC F6C138              <1> 	test	cl, 56
    75 000009CF 7513                <1> 	jnz	write_window_known
    76 000009D1 80F10F              <1> 	xor	cl, 15			; [ 1 2 3 4 5 6 7 ] -> 8 + [ 6 5 4 3 2 1 0]
    77 000009D4 660FA38EA0040000    <1> 	bt	word ptr [esi+PSR], cx		; in memory bytes ffff f00c 0xxx xxxx
    78 000009DC 7303                <1> 	jnc	write_application_window	; x86 bus read -> 0xxx xxxx ffff f00c
    79 000009DE 80C940              <1> 	or	cl, 64
    80                              <1> 
    81                              <1> write_application_window:
    82 000009E1 80F10F              <1> 	xor	cl, 15			; [ 1 2 3 4 5 6 7 ] <- 8 + [ 6 5 4 3 2 1 0]
    83                              <1> 
    84                              <1> write_window_known:
    85 000009E4 50                  <1> 	push	eax
    86 000009E5 0FB6C1              <1> 	movzx	eax, cl
    87 000009E8 F680[5C090000]80    <1> 	test	byte ptr [eax+write_rule], 128
    88 000009EF 740D                <1> 	jz	write_window_free
    89 000009F1 F686A204000080      <1> 	test	byte ptr [esi+PSR+2], 128	; ISR ?
    90 000009F8 0F8405050000        <1> 	jz	near guard_ii_authority		; the unbalanced push is harmless
    91                              <1> 						; stack is reset on faults
    92                              <1> write_window_free:
    93 000009FE 8B8486D0040000      <1> 	mov	eax, dword ptr [esi+eax*4+IO_PORT]
    94 00000A05 5E                  <1> 	pop	esi
    95                              <1> 
    96 00000A06 C1C910              <1> 	ror	ecx, 16		; restore designator information
    97 00000A09 C3                  <1> 	ret
    32                                  	%include	"sr.msm"
     1                              <1> 
     2                              <1> ;	read staging register
     3                              <1> ;	read bits from a stream of bits
     4                              <1> 
     5 00000A0A 8B4E50              <1> _rsr:	mov	ecx, dword ptr [esi+RDATAC]
     6 00000A0D 88CD                <1> 	mov	ch, cl
     7 00000A0F 88C1                <1> 	mov	cl, al
     8                              <1> 
     9 00000A11 31C0                <1> 	xor	eax, eax
    10 00000A13 F786A0040000400000- <1> 	test	dword ptr [esi+PSR], B_STREAMZR
    10 00000A1C 00                  <1>
    11 00000A1D 7503                <1> 	jnz	_rsr_zadd
    12 00000A1F 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
    13                              <1> _rsr_zadd:
    14 00000A22 20C9                <1> 	and	cl, cl
    15 00000A24 7450                <1> 	jz	_rsr_x
    16 00000A26 8B5E54              <1> 	mov	ebx, dword ptr [esi+RDATA]
    17                              <1> 
    18 00000A29 20ED                <1> 	and	ch, ch			; any data loaded yet?
    19 00000A2B 740F                <1> 	jz	_rsr_read		; if not read first no question 
    20 00000A2D 38CD                <1> 	cmp	ch, cl			; otherwise, already enough for request?
    21 00000A2F 7330                <1> 	jnb	_rsr_draw		; if so deliver data
    22 00000A31 28E9                <1> 	sub	cl, ch			; if not trim the oustanding count
    23 00000A33 86CD                <1> 	xchg	cl, ch			
    24 00000A35 E8FA0E0000          <1> 	call	dsl			; and deliver available data
    25 00000A3A 86E9                <1> 	xchg	ch, cl			; before reading some more
    26                              <1> _rsr_read:
    27 00000A3C E894000000          <1> 	call	stream_read
    28                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]	; after call to operand_read
    29 00000A41 0F7EFE              <1> 	movd	esi, mm7
    30                              <1> 
    31 00000A44 C7465018000000      <1> 	mov	dword ptr [esi+RDATAC], 24
    32 00000A4B F786A0040000200000- <1> 	test	dword ptr [esi+PSR], B_STREAM16R
    32 00000A54 00                  <1>
    33 00000A55 740A                <1> 	jz	_rsr_draw
    34 00000A57 C7465010000000      <1> 	mov	dword ptr [esi+RDATAC], 16
    35 00000A5E C1E308              <1> 	shl	ebx, 8
    36                              <1> _rsr_draw:
    37 00000A61 6651                <1> 	push	cx
    38 00000A63 E8CC0E0000          <1> 	call	dsl
    39 00000A68 6659                <1> 	pop	cx
    40 00000A6A 81E1FF000000        <1> 	and	ecx, 255
    41 00000A70 294E50              <1> 	sub	dword ptr [esi+RDATAC], ecx
    42 00000A73 895E54              <1> 	mov	dword ptr [esi+RDATA], ebx
    43                              <1> _rsr_x:
    44 00000A76 894510              <1> 	mov	dword ptr [ebp+A], eax
    45 00000A79 C3                  <1> 	ret
    46                              <1> 
    47                              <1> 
    48                              <1> ;	write staging register
    49                              <1> ;	write bits to a stream of bits
    50                              <1> 
    51 00000A7A 8B4E58              <1> _wsr:	mov	ecx, dword ptr [esi+WDATAC]
    52 00000A7D 88CD                <1> 	mov	ch, cl					; accumulated count
    53 00000A7F 88C1                <1> 	mov	cl, al					; new request
    54                              <1> 
    55 00000A81 8B465C              <1> 	mov	eax, dword ptr [esi+WDATA]	; accumulated data
    56 00000A84 8B5D10              <1> 	mov	ebx, dword ptr [ebp+A]		; source new data
    57                              <1> 
    58 00000A87 80C5E8              <1> 	add	ch, -24				; space for new data expressed negative
    59 00000A8A F786A0040000100000- <1> 	test	dword ptr [esi+PSR], B_STREAM16W	; 16 bits / word flag
    59 00000A93 00                  <1>
    60 00000A94 7403                <1> 	jz	_wsr24
    61 00000A96 80C508              <1> 	add	ch, 8
    62                              <1> 
    63 00000A99 00CD                <1> _wsr24:	add	ch, cl			; increment towards zero
    64 00000A9B 7404                <1> 	jz	_wsr_write		; accumulated word exactly full
    65 00000A9D 731D                <1> 	jnc	_wsr_add		; not yet full
    66                              <1> 
    67 00000A9F 28E9                <1> 	sub	cl, ch			; full + some more
    68                              <1> 
    69                              <1> _wsr_write:
    70 00000AA1 E88E0E0000          <1> 	call	dsl			; fill output word
    71 00000AA6 88E9                <1> 	mov	cl, ch			; position outstanding count
    72 00000AA8 E83D000000          <1> 	call	stream_write
    73                              <1> 
    74                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]	; after call to operand_write
    75 00000AAD 0F7EFE              <1> 	movd	esi, mm7
    76                              <1> 
    77 00000AB0 B800000000          <1> 	mov	eax, 0
    78 00000AB5 C7465800000000      <1> 	mov	dword ptr [esi+REGISTER+WDATAC], 0
    79                              <1> 
    80                              <1> _wsr_add:
    81 00000ABC 6651                <1> 	push	cx
    82 00000ABE E8710E0000          <1> 	call	dsl			; add to output word
    83 00000AC3 6659                <1> 	pop	cx
    84 00000AC5 81E1FF000000        <1> 	and	ecx, 255		; format ecx for add to accumulated count 
    85 00000ACB 014E58              <1> 	add	dword ptr [esi+REGISTER+WDATAC], ecx
    86 00000ACE 89465C              <1> 	mov	dword ptr [esi+REGISTER+WDATA], eax
    87 00000AD1 895D10              <1> 	mov	dword ptr [ebp+A], ebx
    88 00000AD4 C3                  <1> 	ret
    89                              <1> 
    90                              <1> stream_read:
    91 00000AD5 51                  <1> 	push	ecx
    92 00000AD6 50                  <1> 	push	eax
    93 00000AD7 8B4534              <1> 	mov	eax, dword ptr [ebp+Q]
    94 00000ADA 83453401            <1> 	add	dword ptr [ebp+Q], 1
    95 00000ADE 30C9                <1> 	xor	cl, cl
    96 00000AE0 E86CF8FFFF          <1> 	call	_operand_read
    97 00000AE5 89C3                <1> 	mov	ebx, eax
    98 00000AE7 58                  <1> 	pop	eax
    99 00000AE8 59                  <1> 	pop	ecx
   100 00000AE9 C3                  <1> 	ret
   101                              <1> 
   102                              <1> stream_write:
   103 00000AEA 51                  <1> 	push	ecx
   104 00000AEB 53                  <1> 	push	ebx
   105 00000AEC 89C3                <1> 	mov	ebx, eax
   106 00000AEE 8B4530              <1> 	mov	eax, dword ptr [ebp+P]
   107 00000AF1 83453001            <1> 	add	dword ptr [ebp+P], 1
   108 00000AF5 30C9                <1> 	xor	cl, cl
   109 00000AF7 E8E7F9FFFF          <1> 	call	_operand_write
   110 00000AFC 5B                  <1> 	pop	ebx
   111 00000AFD 59                  <1> 	pop	ecx
   112 00000AFE C3                  <1> 	ret
   113                              <1> 
    33                                  	%include	"io.msm"
     1 00000AFF 8B9C86D0040000      <1> _inA:	mov	ebx, dword ptr [esi+IO_PORT+eax*4]
     2 00000B06 895D10              <1> 	mov	dword ptr [ebp+A], ebx
     3 00000B09 C3                  <1> _inA_:	ret
     4                              <1> 
     5 00000B0A 8B9C86D0040000      <1> _inB:	mov	ebx, dword ptr [esi+IO_PORT+eax*4]
     6 00000B11 895D14              <1> 	mov	dword ptr [ebp+B], ebx
     7 00000B14 C3                  <1> _inB_:	ret
     8                              <1> 
     9 00000B15 8B5D10              <1> _outA:	mov	ebx, dword ptr [ebp+A]
    10 00000B18 E9A7010000          <1> 	jmp	oport
    11                              <1> 
    12 00000B1D 8B5D14              <1> _outB:	mov	ebx, dword ptr [ebp+B]
    13 00000B20 E99F010000          <1> 	jmp	oport
    14                              <1> 
    15                              <1> 
    16                              <1> ISR_ONLY equ	8
    17                              <1> MEMTYPE	equ	1
    18                              <1> MEMZERONLY equ	2
    19                              <1> EXTERNAL_IO equ	4
    20                              <1> BROADCAST equ	16
    21                              <1> 
    22                              <1> B_1	equ	MEMTYPE
    23                              <1> B_TCB	equ	MEMTYPE+ISR_ONLY
    24                              <1> B_KERN	equ	MEMTYPE+ISR_ONLY
    25                              <1> A_THREP	equ	MEMZERONLY+ISR_ONLY
    26                              <1> I_PORT	equ	EXTERNAL_IO
    27                              <1> O_PORT	equ	EXTERNAL_IO
    28                              <1> O_INDICA equ	EXTERNAL_IO
    29                              <1> O_CHILL	equ	EXTERNAL_IO
    30                              <1> I_TZONE	equ	EXTERNAL_IO
    31                              <1> RAM_THRESH equ	ISR_ONLY+MEMZERONLY
    32                              <1> XI_ACK	equ	ISR_ONLY+EXTERNAL_IO
    33                              <1> O_LEDS	equ	EXTERNAL_IO
    34                              <1> O_INC	equ	ISR_ONLY+EXTERNAL_IO
    35                              <1> O_MCAST	equ	ISR_ONLY+BROADCAST
    36                              <1> 
    37                              <1> 
    38                              <1> mask_port_outAB:
    39 00000B25 000100000000000000- <1> 	db	0, B_1, 0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    39 00000B2E 00000000000000      <1>
    40 00000B35 000000000000000000- <1> 	db	    0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    40 00000B3E 00000000000000      <1>
    41                              <1> 
    42 00000B45 000000000000000000- <1> 	db	    0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    42 00000B4E 00000000000000      <1>
    43 00000B55 000000000000000000- <1> 	db	    0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    43 00000B5E 00000000000000      <1>
    44                              <1> 
    45 00000B65 0009090909090909    <1> 	db	0,  B_TCB,B_KERN,B_KERN,B_KERN,B_KERN,B_KERN,B_KERN
    46 00000B6D 0A00000C0C000018    <1> 	db	A_THREP, 0, 0, XI_ACK,  O_INC, 0,0, O_MCAST
    47                              <1> 
    48 00000B75 0404040404040404    <1> 	db	I_PORT,I_PORT,I_PORT,I_PORT,I_PORT,I_PORT,I_PORT,I_PORT
    49 00000B7D 0404040404040404    <1> 	db	O_PORT,O_PORT,O_PORT,O_PORT,O_PORT,O_PORT,O_PORT,O_PORT
    50                              <1> 
    51 00000B85 0000000000040404    <1> 	db	0,0,0,0, 0, I_TZONE, O_INDICA, O_CHILL
    52 00000B8D 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  RAM_THRESH, 0,0, O_LEDS
    52 00000B96 0000000A000004      <1>
    53                              <1> 
    54 00000B9D 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    54 00000BA6 00000000000000      <1>
    55 00000BAD 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    55 00000BB6 00000000000000      <1>
    56 00000BBD 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    56 00000BC6 00000000000000      <1>
    57 00000BCD 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    57 00000BD6 00000000000000      <1>
    58                              <1> 
    59                              <1> 					; outA|B rules flags per I/O port
    60                              <1> 
    61                              <1> _reload:
    62 00000BDD 50                  <1> 	push	eax
    63 00000BDE 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
    64 00000BE1 83451002            <1> 	add	dword ptr [ebp+A], 2
    65 00000BE5 E825F7FFFF          <1> 	call	_burst_read2
    66 00000BEA 5F                  <1> 	pop	edi
    67 00000BEB 8984BED0040000      <1> 	mov	dword ptr [esi+IO_PORT+edi*4], eax
    68 00000BF2 899CBED4040000      <1> 	mov	dword ptr [esi+IO_PORT+edi*4+4], ebx
    69 00000BF9 C3                  <1> 	ret
    34                                  	%include	"sabr.msm"
     1                              <1> ;	check and write to I/O port <- storage base index in range [ 2..63 ]
     2                              <1> ;	write a copy to reload base table in thread control block
     3                              <1> ;	values out of memory range are replaced with trap device C00001
     4                              <1> ;	which causes GUARD$ exception if the sindow is accessed
     5                              <1> 
     6                              <1> ;	anauthorised actions
     7                              <1> ;
     8                              <1> ;		attempt to write window base < 2 or > 63
     9                              <1> ;		application selecting ISR space
    10                              <1> ;		application selecting NVRAM
    11                              <1> ;
    12                              <1> ;	are not carried out and a GUARD$ exception is raised
    13                              <1> ;	ISRs write the trap device C00001 to close memory windows
    14                              <1> 
    15                              <1> _sabr_guard:
    16 00000BFA E904030000          <1> 	jmp	guard_ii_authority
    17                              <1> 
    18 00000BFF A93E000000          <1> _sabr:	test	eax, 03Eh		; ea not < 2
    19 00000C04 74F4                <1> 	jz	_sabr_guard
    20 00000C06 A9C0FFFF00          <1> 	test	eax, 0FFFFC0h		; ea not > 63
    21 00000C0B 75ED                <1> 	jnz	_sabr_guard
    22                              <1> 
    23 00000C0D 8B4D10              <1> 	mov	ecx, dword ptr [ebp+A]
    24                              <1> 
    25 00000C10 F7C100004000        <1> 	test	ecx, 00400000h
    26 00000C16 7463                <1> 	jz	memory_page
    27 00000C18 F7C13F000000        <1> 	test	ecx, 63
    28 00000C1E 7455                <1> 	jz	large_memory_page
    29                              <1> 
    30 00000C20 F7C100008000        <1> 	test	ecx, 00800000h
    31 00000C26 740B                <1> 	jz	array_attribute
    32                              <1> 
    33 00000C28 F686A204000080      <1> 	test	byte ptr [esi+PSR+2], 128
    34 00000C2F 74C9                <1> 	jz	_sabr_guard
    35 00000C31 EB70                <1> 	jmp	unthru			; ISR write illegal device thru
    36                              <1> 					; closes the address space window
    37                              <1> 
    38                              <1> 					; application may not write device
    39                              <1> 					; but may zero -> sabr  with same effect
    40                              <1> array_attribute:
    41                              <1> 
    42 00000C33 C1E102              <1> 	shl	ecx, 2
    43 00000C36 0FB6D9              <1> 	movzx	ebx, cl			; cl = device * 4
    44                              <1> 
    45                              <1> 	%if	0
    46                              <1> 	mov	edi, dword ptr [_devices+ebx]
    47                              <1> 	%endif
    48                              <1> 
    49 00000C39 8B9C33D0060000      <1> 	mov	ebx, dword ptr [esi+ebx+IO_PORT+_DEVICE]
    50                              <1> 					; platform address + device descriptor
    51                              <1> 
    52                              <1> 
    53                              <1> 	%if	0
    54                              <1> 	mov	dword ptr [esi+eax*8+DATAFRAME], ebx	; rapid recall
    55                              <1> 	mov	dword ptr [esi+eax*8+DATAFRAME+4], edi	; device information
    56                              <1> 	%endif						; via window tag
    57                              <1> 
    58 00000C40 C1E908              <1> 	shr	ecx, 6+2		; lose previous shift + device code
    59 00000C43 F7C300004000        <1> 	test	ebx, 00400000h
    60 00000C49 750A                <1> 	jnz	peripheral_array
    61 00000C4B F7C300008000        <1> 	test	ebx, 00800000h
    62 00000C51 751D                <1> 	jnz	memory_array
    63                              <1> 
    64 00000C53 EBA5                <1> 	jmp	_sabr_guard		; no device code
    65                              <1> 
    66                              <1> peripheral_array:			; device types 00C00000 00400000
    67 00000C55 F686A204000080      <1> 	test	byte ptr [esi+PSR+2], 128
    68 00000C5C 749C                <1> 	jz	_sabr_guard
    69                              <1> 
    70 00000C5E 81E1FFFF0000        <1> 	and	ecx, 0000FFFFh		; have # large blocks in low 16 bits
    71 00000C64 81E3FFFF0000        <1> 	and	ebx, 0000FFFFh
    72 00000C6A 29CB                <1> 	sub	ebx, ecx
    73 00000C6C 7932                <1> 	jns	thru
    74 00000C6E EB29                <1> 	jmp	_sabr_safeguard
    75                              <1> 
    76                              <1> memory_array:
    77 00000C70 C1E106              <1> 	shl	ecx, 6			; block * 64
    78 00000C73 EB14                <1> 	jmp	memory_array_bound?
    79                              <1> 
    80                              <1> large_memory_page:
    81 00000C75 81E1FFFFBF00        <1> 	and	ecx, 00BFFFFFh		; remove 00400000 bit for lower bound check
    82                              <1> 
    83                              <1> memory_page:
    84 00000C7B 8B9ED0060000        <1> 	mov	ebx, dword ptr [esi+IO_PORT+_DEVICE]	; device zero memory attribute
    85 00000C81 3B8EF0050000        <1> 	cmp	ecx, dword ptr [esi+IO_PORT+_APP_THRESHOLD]	; ISR / application boundary
    86 00000C87 7210                <1> 	jb	_sabr_safeguard
    87                              <1> 
    88                              <1> memory_array_bound?:
    89 00000C89 81E1FFFFBF00        <1> 	and	ecx, 00BFFFFFh		; bit 00800000 is a bad accident
    90 00000C8F 81E3FFFF3F00        <1> 	and	ebx, 003FFFFFh		; stop it here
    91 00000C95 29CB                <1> 	sub	ebx, ecx
    92 00000C97 7907                <1> 	jns	thru
    93                              <1> 
    94                              <1> _sabr_safeguard:
    95 00000C99 B90100C000          <1> 	mov	ecx, 00C00001h
    96 00000C9E EB03                <1> 	jmp	unthru
    97                              <1> 
    98 00000CA0 8B4D10              <1> thru:	mov	ecx, dword ptr [ebp+A]		; i.e. correct as supplied
    99 00000CA3 898C86D0040000      <1> unthru:	mov	dword ptr [esi+eax*4+IO_PORT], ecx
   100                              <1> 
   101 00000CAA BF[00000000]        <1> 	mov	edi, _memory
   102 00000CAF 8B9ED4050000        <1> 	mov	ebx, dword ptr [esi+IO_PORT+65*4] ; thread control block
   103                              <1> 
   104 00000CB5 C1E30C              <1> 	shl	ebx, 12			; multiply to TCB size
   105 00000CB8 01C3                <1> 	add	ebx, eax		; ea is target base index
   106 00000CBA 0FC9                <1> 	bswap	ecx			; for this is a big endian memory write
   107 00000CBC 898C9F00010000      <1> 	mov	dword ptr [edi+ebx*4+64*4], ecx
   108 00000CC3 C3                  <1> 	ret				; save TCB reload copy of loaded pointer
    35                                  	%include	"oport.msm"
     1                              <1> 
     2                              <1> OOO_TRACE	equ	0
     3                              <1> 
     4                              <1> 							; static void oport(int ea, int value, smp *xcore)
     5                              <1> 							; {
     6                              <1> oport:		; write I / O port			;    int		 rule,
     7                              <1> 		; RTA instructions outA outB		;			 device;
     8                              <1> 							; 
     9                              <1> 		; ports which are memory pointers	;    int		 mask,
    10                              <1> 		; must have a block that exists		;			 from,
    11                              <1> 		; ISRs can write trap value C00001 	;                 	 index;
    12                              <1> 		; = device 400001 | illegal 800000	; 
    13                              <1> 		; port # = effective address = eax	;    int		 device_index = 0;
    14                              <1> 		; write value in ebx			; 
    15                              <1> 		; multicast bits in RTA register k	;    smp		*ascor;
    16                              <1> 		 					;    unsigned	*register_set = xcore->register_set;
    17 00000CC4 3DC0000000          <1> 	cmp	eax, IO_PORTS				; 
    18 00000CC9 0F8393000000        <1> 	jnb	near no_port				;    if (ea < IO_PORTS)
    19                              <1> 							;    {
    20 00000CCF 8A88[250B0000]      <1> 	mov	cl, byte ptr [eax+mask_port_outAB]	;       rule = mask_port_outAB[ea];
    21 00000CD5 20C9                <1> 	and	cl, cl					; 
    22 00000CD7 0F8485000000        <1> 	jz	near no_rule				;       if (rule)
    23 00000CDD F6C108              <1> 	test	cl, ISR_ONLY				;       {
    24 00000CE0 740D                <1> 	jz	application_plus_isr_rule		;          if (((rule & ISR_ONLY) == 0) || (psr & 0x00800000))
    25 00000CE2 F686A204000080      <1> 	test	byte ptr [esi+PSR+2], 128		;          {
    26 00000CE9 0F8473000000        <1> 	jz	near no_authority				;
    27                              <1> 							;
    28                              <1> application_plus_isr_rule:				;
    29 00000CEF F6C104              <1> 	test	cl, EXTERNAL_IO				;             if (rule & EXTERNAL_IO)
    30 00000CF2 7423                <1> 	jz	broadcast_rule?				;             {
    31 00000CF4 899C86D0040000      <1> 	mov	dword ptr [esi+IO_PORT+eax*4], ebx	;                base[ea] = value;
    32 00000CFB 83F866              <1> 	cmp	eax, 102	; INDICATION$		;                if (ea == 102) indication |= value;
    33 00000CFE 7506                <1> 	jne	xi_ack?		 			;
    34 00000D00 099E94040000        <1> 	or	dword ptr [esi+INDICATION], ebx		;
    35                              <1>  							;
    36                              <1> xi_ack?:							;
    37 00000D06 83F84B              <1> 	cmp	eax, 75					;                if (ea == 75)
    38 00000D09 750B                <1> 	jne	xi_no_ack				;                {
    39 00000D0B F6D3                <1> 	not	bl					;                    base[74] &= (value & 255) ^ 255;
    40 00000D0D 0FB6DB              <1> 	movzx	ebx, bl					;                    // indication |= (value & 255) << 8;
    41                              <1> 							;                }
    42 00000D10 219EF8050000        <1> 	and	dword ptr [esi+IO_PORT+_XI_PENDING], ebx	; 
    43                              <1> xi_no_ack:						; //               if ((ea == 79) && (value & 1)) indication |= ATTENTION;
    44 00000D16 C3                  <1> 	ret						;                return;
    45                              <1> 							;             }
    46                              <1> 							; 
    47                              <1> broadcast_rule?:					;             if (rule & BROADCAST)
    48 00000D17 F6C110              <1> 	test	cl, BROADCAST				;             {
    49 00000D1A 744B                <1> 	jz	memory_rule?				;                mask = k;
    50                              <1> 
    51                              <1> 	%if	OOO_TRACE
    52                              <1> 	inc	dword ptr [esi+REGISTER+282*4]
    53                              <1> 	%endif
    54                              <1> 
    55 00000D1C 52                  <1> 	push	edx	; borrow the program counter	;
    56                              <1> 
    57                              <1> 	%if	1
    58 00000D1D 8B96F4050000        <1> 	mov	edx, dword ptr [esi+IO_PORT+_CORE_PIN]	;
    59                              <1> 	%else
    60                              <1> 	mov	ecx, dword ptr [esi+IO_PORT+_CORE_SOCKET] ;
    61                              <1> 	mov	edx, 1					;
    62                              <1> 	shl	edx, cl		; source identifier bit	;
    63                              <1> 	%endif
    64                              <1> 							;
    65 00000D23 BF[00000000]        <1> 	mov	edi, _core				;
    66 00000D28 8B4D04              <1> 	mov	ecx, dword ptr [ebp+REGISTER+K]		;
    67 00000D2B 238EC4060000        <1> 	and	ecx, dword ptr [esi+IO_PORT+_CORES_MASK] ;
    68                              <1> 							;
    69                              <1> multicast_select:					;
    70 00000D31 D1E9                <1> 	shr	ecx, 1					;                from = base[77];
    71 00000D33 7321                <1> 	jnc	multicast_next				; 
    72                              <1> 
    73 00000D35 21DB                <1> 	and	ebx, ebx	; if all of it is zero
    74 00000D37 7416                <1> 	jz	multicast_time
    75                              <1> 
    76                              <1> ;	write the port unless this is a dayclock update	;  
    77                              <1> 
    78 00000D39 899C86D0040000      <1> 	mov	dword ptr [esi+IO_PORT+eax*4], ebx	;                for (index = 0; index < RTA_SMP; index++)
    79 00000D40 099708060000        <1>         or      dword ptr [edi+IO_PORT+_MCAST_PENDING], edx ;            {
    80 00000D46 808F9404000080      <1>         or      byte ptr [edi+INDICATION], ATTENTION    ;                   if (mask & 1)
    81 00000D4D EB07                <1> 	jmp	multicast_next
    82                              <1> 
    83                              <1> multicast_time:
    84 00000D4F 808F9404000020      <1> 	or	byte ptr [edi+INDICATION], TPULSE
    85                              <1> 							;                   {
    86                              <1> multicast_next:						;                      ascor = core + index;
    87 00000D56 81C7D0070000        <1> 	add	edi, CORE_SIZE				;                      ascor->BASE[78] |= 1 << from;
    88                              <1> ;	shr	ecx, 1					;                      ascor->INDICATION |= ATTENTION;
    89 00000D5C 21C9                <1> 	and	ecx, ecx				;                   }
    90 00000D5E 75D1                <1> 	jnz	multicast_select			; 
    91 00000D60 5A                  <1> 	pop	edx	; give back the program counter	;
    92 00000D61 C3                  <1> 	ret						;                   mask >>= 1;
    93                              <1> 							;                }
    94                              <1> no_port:						; 
    95                              <1> no_rule:						;                /**************************************************
    96                              <1> no_authority:						; 			keep these on the sending side
    97                              <1> 							; 			until constructing interrupt frame
    98 00000D62 E99C010000          <1> 	jmp	guard_ii_authority			; 			between instructions at target core
    99                              <1> 							;                         to avoid overwrites from other cores
   100                              <1> 							;                **************************************************/
   101                              <1> 							; 
   102                              <1> 							;                base[ea] = value;	/* latent parameter	*/
   103                              <1> 							;                return;
   104                              <1> 							;             }
   105                              <1> 							; 
   106                              <1> memory_rule?:	; system memory type only		;             else if (rule & MEMTYPE)
   107                              <1> 
   108 00000D67 F6C101              <1> 	test	cl, MEMTYPE				;             {
   109 00000D6A 7459                <1> 	jz	page_pointer?				;                if (value & 0x00400000) device_index = value & 63;
   110 00000D6C F7C300004000        <1> 	test	ebx, 0400000h	; bank sized?		; 
   111 00000D72 745E                <1> 	jz	memory_page_pointer			;                if (device_index)
   112                              <1> 							;                {
   113 00000D74 F7C33F000000        <1> 	test	ebx, 63					;                   if (value & 0x00800000)
   114 00000D7A 7419                <1> 	jz	device_is_pointed			;                   {
   115 00000D7C F7C300008000        <1> 	test	ebx, 0800000h	; the trap device?	;                      if (psr & 0x00800000)
   116 00000D82 7411                <1> 	jz	device_is_pointed			;                      {
   117 00000D84 F686A204000080      <1> 	test	byte ptr [esi+PSR+2], 128	; ISR?		;                         base[ea] = value;
   118 00000D8B 74D5                <1> 	jz	no_authority				;                         return;
   119 00000D8D 899C86D0040000      <1> 	mov	[esi+IO_PORT+eax*4], ebx		;                      }
   120 00000D94 C3                  <1> 	ret						; 
   121                              <1> 							;                      GUARD_AUTHORITY
   122                              <1> device_is_pointed:					;                      return;
   123 00000D95 8B8ED0060000        <1> 	mov	ecx, dword ptr [esi+IO_PORT+_DEVICE]	;                   }
   124 00000D9B F7C100008000        <1> 	test	ecx, 00800000h				;                }
   125 00000DA1 74BF                <1> 	jz	no_authority				; 
   126 00000DA3 F7C100004000        <1> 	test	ecx, 00400000h				;                device = base[128+device_index];
   127 00000DA9 75B7                <1> 	jnz	no_authority				;            
   128 00000DAB 81E1FFFF3F00        <1> 	and	ecx, 003FFFFFh				;                if ((device & 0x00C00000) == 0x00800000)
   129 00000DB1 89DF                <1> 	mov	edi, ebx				;                {
   130 00000DB3 81E7FFFF3F00        <1> 	and	edi, 003FFFFFh	; catch any 00800000	;                   if ((value & 0x003FFFC0) > (device & 0x003FFFFF))
   131 00000DB9 39F9                <1> 	cmp	ecx, edi				;                   {
   132 00000DBB 7233                <1> 	jb	outwith		; beyond memory		;                   }
   133 00000DBD 899C86D0040000      <1> 	mov	[esi+IO_PORT+eax*4], ebx		;                   else
   134 00000DC4 C3                  <1> 	ret						;                   {
   135                              <1> 							;                      base[ea] = value;
   136                              <1> 							;                      return;
   137                              <1> 							;                   }
   138                              <1> 							;                }
   139                              <1> 							;             }
   140                              <1> 							;             else
   141                              <1> 							;             {
   142                              <1> 							;                /*******************************************
   143                              <1> ;	only a device zero page index will do		; 			page pointer to system memory
   144                              <1> 							;                *******************************************/
   145                              <1> page_pointer?:						; 
   146 00000DC5 F6C102              <1> 	test	cl, MEMZERONLY				;                if ((value & 0x00400000) == 0)
   147 00000DC8 7498                <1> 	jz	no_rule					;                {
   148 00000DCA F7C30000C000        <1> 	test	ebx, 00C00000h				;                   if (value > (base[128] & 0x003FFFFF))
   149 00000DD0 7590                <1> 	jnz	no_authority				;                   {
   150                              <1> 							;                   }
   151                              <1> memory_page_pointer:					;                   else
   152 00000DD2 8B8ED0060000        <1> 	mov	ecx, dword ptr [esi+IO_PORT+_DEVICE]	;                   {
   153 00000DD8 81E1FFFF3F00        <1> 	and	ecx, 003FFFFFh				;                      base[ea] = value;
   154 00000DDE 81E3FFFFFF00        <1> 	and	ebx, 00FFFFFFh				;                      return;
   155 00000DE4 39D9                <1> 	cmp	ecx, ebx				;                   }
   156 00000DE6 7208                <1> 	jb	outwith					;                }
   157 00000DE8 899C86D0040000      <1> 	mov	dword ptr [esi+IO_PORT+eax*4], ebx		;             }
   158 00000DEF C3                  <1> 	ret						;          }
   159                              <1> 							;       }
   160                              <1> 							;    }
   161                              <1> outwith:							; 
   162 00000DF0 B90E000000          <1> 	mov	ecx, LP_ADDRESS				;    GUARD_AUTHORITY;
   163 00000DF5 E90E010000          <1> 	jmp	guard_ii_escape				; }							; 
    36                                  	%include	"ii.msm"
     1 00000DFA 660986A0040000      <1> _on:	or	word ptr [esi+PSR], ax	; only touch low-order 16 bits
     2 00000E01 C3                  <1> 	ret
     3                              <1> 
     4 00000E02 6683F0FF            <1> _off:	xor	ax, 0000FFFFh
     5 00000E06 662186A0040000      <1> 	and	word ptr [esi+PSR], ax	; only touch low-order 16 bits
     6 00000E0D C3                  <1> 	ret
     7                              <1> 
     8                              <1> RELOAD_SMPP	equ	1
     9                              <1> III_TRACE	equ	0
    10                              <1> 
    11                              <1> _xi:
    12                              <1> 	%if	RELOAD_SMPP
    13                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
    14 00000E0E 0F7EFE              <1> 	movd	esi, mm7
    15                              <1> 	%endif
    16                              <1> 
    17 00000E11 20E4                <1> 	and	ah, ah				; 8 external interrupts?
    18 00000E13 741B                <1> 	jz	_xix_beat?			; nane
    19                              <1> 
    20 00000E15 30C9                <1> 	xor	cl, cl
    21                              <1> 
    22                              <1> _xi_next:					; external interrupt pending signals[8]
    23 00000E17 88A6F8050000        <1> 	mov	byte ptr [esi+IO_PORT+_XI_PENDING], ah	; position for inA|B from port XI_PENDING$	LL.mm.hh.zz
    24 00000E1D C6869504000000      <1> 	mov	byte ptr [esi+INDICATION+1], 0	; clear from platform indications fabric	ll.MM.hh.zz
    25 00000E24 31C9                <1> 	xor	ecx, ecx			; clear latent param
    26 00000E26 B802000000          <1> 	mov	eax, II_XINT			; select external interrupt
    27                              <1> 
    28 00000E2B E902010000          <1> 	jmp	_ii_
    29                              <1> 
    30                              <1> _xix_beat?:
    31 00000E30 A820                <1> 	test	al, TPULSE
    32 00000E32 7438                <1> 	jz	_xix
    33                              <1> 
    34 00000E34 BF[00000000]        <1> 	mov	edi, _core					; always core zero so far
    35                              <1> 
    36                              <1> _xi_atn_dayclock:
    37 00000E39 8B8F58020000        <1>         mov     ecx, dword ptr [edi+REGISTER+DAYCLOCK_U]
    38 00000E3F 8B9F5C020000        <1>         mov     ebx, dword ptr [edi+REGISTER+DAYCLOCK]
    39 00000E45 3B8F58020000        <1>         cmp     ecx, dword ptr [edi+REGISTER+DAYCLOCK_U]
    40 00000E4B 75EC                <1>         jnz     _xi_atn_dayclock
    41 00000E4D 899E5C020000        <1>         mov     dword ptr [esi+REGISTER+DAYCLOCK], ebx
    42 00000E53 898E58020000        <1>         mov     dword ptr [esi+REGISTER+DAYCLOCK_U], ecx
    43                              <1> 
    44 00000E59 8B9F64060000        <1>         mov     ebx, dword ptr [edi+IO_PORT+_TZONE]
    45 00000E5F 899E64060000        <1>         mov     dword ptr [esi+IO_PORT+_TZONE], ebx
    46                              <1> 
    47 00000E65 80A694040000DF      <1> 	and	byte ptr [esi+INDICATION], TPULSE^255
    48                              <1> 	
    49 00000E6C A880                <1> _xix:	test	al, ATTENTION					; core2core interrupt
    50 00000E6E 0F8452000000        <1> 	jz	near _xiy
    51                              <1> 
    52 00000E74 8B9E08060000        <1> 	mov	ebx, [esi+IO_PORT+_MCAST_PENDING]
    53 00000E7A BF[00000000]        <1> 	mov	edi, _core					; test bit progressing
    54 00000E7F 52                  <1> 	push	edx
    55 00000E80 BAFEFFFFFF          <1> 	mov	edx, -2
    56 00000E85 239EC4060000        <1> 	and	ebx, dword ptr [esi+IO_PORT+_CORES_MASK]
    57                              <1> 
    58                              <1> _xi_atn_sources:
    59 00000E8B D1EB                <1> 	shr	ebx, 1						; this source pending?
    60 00000E8D 7317                <1> 	jnc	_xi_atn_source_next				; no
    61                              <1> 
    62 00000E8F 219608060000        <1> 	and	dword ptr [esi+IO_PORT+_MCAST_PENDING], edx	; unpend
    63 00000E95 8B8F0C060000        <1> 	mov	ecx, dword ptr [edi+IO_PORT+_MCAST_TO]		; latent parameter from sending side
    64                              <1> 
    65 00000E9B B805000000          <1> 	mov	eax, II_ATTENTION				; no
    66 00000EA0 5A                  <1> 	pop	edx						; ragged but working ***
    67 00000EA1 E98C000000          <1> 	jmp	_ii_						; _ii_ takes ecx for
    68                              <1> 								; interrupt latent parameter
    69                              <1> _xi_atn_source_next:
    70 00000EA6 81C7D0070000        <1> 	add	edi, CORE_SIZE
    71                              <1> ;	shr	ebx, 1						; MCAST_PENDING in line with edi -> core
    72 00000EAC D1C2                <1> 	rol	edx, 1						; MCAST_PENDING flag-off mask
    73 00000EAE 21DB                <1> 	and	ebx, ebx					; no bits left = no more pending
    74 00000EB0 75D9                <1> 	jnz	_xi_atn_sources					; expect from new interrupts
    75                              <1> 
    76                              <1> _xi_atn_sources_all:
    77                              <1> 
    78 00000EB2 5A                  <1> 	pop	edx						; also popped if jump to _ii_ ***
    79                              <1> 
    80 00000EB3 F78608060000FFFFFF- <1> 	test	dword ptr [esi+IO_PORT+_MCAST_PENDING], 00FFFFFFh
    80 00000EBC 00                  <1>
    81 00000EBD 7507                <1> 	jnz	_xi_atn_new_sources				; new interrupts flagged up, keep ATTENTION
    82 00000EBF 80A6940400007F      <1> 	and	byte ptr [esi+INDICATION], ATTENTION^255
    83                              <1> _xi_atn_new_sources:
    84                              <1> 
    85                              <1> 	%if	III_TRACE
    86                              <1> 	mov	eax, dword ptr [esi+IO_PORT+_MCAST_PENDING]
    87                              <1> 	mov	dword ptr [esi+REGISTER+281*4], eax
    88                              <1> 	%endif
    89                              <1> 
    90                              <1> _xiy:
    91                              <1> 	%if	1
    92                              <1> 
    93 00000EC6 8B8694040000        <1> 	mov	eax, dword ptr [esi+INDICATION]			; case we did _xix in the same sweep
    94 00000ECC F6869404000040      <1> 	test	byte ptr [esi+INDICATION], INCREMENTER_CARRY	; nanosecond or other counter 
    95 00000ED3 7410                <1> 	jz	_xiz						; from minus to carrry on zero
    96                              <1> 								; to feed millisecond dayclock
    97 00000ED5 80A694040000BF      <1> 	and	byte ptr [esi+INDICATION], INCREMENTER_CARRY^255
    98 00000EDC B804000000          <1> 	mov	eax, II_MSECOND
    99 00000EE1 31C9                <1> 	xor	ecx, ecx
   100 00000EE3 EB4D                <1> 	jmp	_ii_
   101                              <1> 
   102                              <1> 	%endif
   103                              <1> 
   104 00000EE5 C3                  <1> _xiz:	ret
   105                              <1> 
   106                              <1> _ii_instruction:
   107 00000EE6 89C3                <1> 	mov	ebx, eax
   108 00000EE8 C1EB06              <1> 	shr	ebx, 6
   109 00000EEB 2B9EF0050000        <1> 	sub	ebx, dword ptr [esi+IO_PORT+_APP_THRESHOLD]	; application threshold
   110 00000EF1 7910                <1> 	jns	guard_ii_authority	; must have executed a character string
   111                              <1> 					; like 757575
   112 00000EF3 A9C0FFFFFF          <1> 	test	eax, -64
   113 00000EF8 751C                <1> 	jnz	_ii			; not in restart page OK
   114 00000EFA F686A204000080      <1> 	test	byte ptr [esi+PSR+2], 128	; psr + 1 in BE-speak LE:L_M_H_Z
   115 00000F01 7513                <1> 	jnz	_ii			; ISR may interrupt to restart page
   116                              <1> 
   117                              <1> 		; service call application to restart page not allowed
   118                              <1> 		; most likely to be an accident
   119                              <1> 		; drop thru and be quelled
   120                              <1> 
   121                              <1> guard_ii_authority:
   122 00000F03 B901000000          <1> 	mov	ecx, LP_AUTHORITY
   123                              <1> guard_ii_escape:
   124 00000F08 B85F000000          <1> 	mov	eax, II_GUARD
   125                              <1> _ii_escape:
   126                              <1> 	%if	RELOAD_SMPP
   127                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]		; read register 152 or 280
   128 00000F0D 0F7EFE              <1> 	movd	esi, mm7
   129                              <1> 	%endif						; depending ebp -> application / ISR registers
   130                              <1> 
   131 00000F10 8BA67C040000        <1> 	mov	esp, dword ptr [esi+REGISTER+287*4]	; read esp at start of _execute
   132                              <1> 
   133 00000F16 83F85F              <1> _ii:	cmp	eax, II_GUARD
   134 00000F19 7517                <1> 	jnz	_ii_
   135 00000F1B F605[19000000]01    <1> 	test	byte ptr [_uflag+'Z'-'A'], 1		; break to debug console?
   136 00000F22 740E                <1> 	jz	_ii_					; not if not opted
   137 00000F24 808E9404000002      <1> 	or	byte ptr [esi+INDICATION], LOCKSTEP
   138 00000F2B 800D[00000000]02    <1> 	or	byte ptr [_general_indication], LOCKSTEP
   139                              <1> 	
   140 00000F32 8DAE00020000        <1> _ii_:	lea	ebp, [esi+128*4] 
   141                              <1> 
   142 00000F38 89AE8C040000        <1> 	mov	dword ptr [esi+REGISTER_SET], ebp
   143 00000F3E C7869C040000800000- <1> 	mov	dword ptr [esi+ISELECT], 128
   143 00000F47 00                  <1>
   144                              <1> 
   145 00000F48 8B5D3C              <1> 	mov	ebx, dword ptr [ebp+S_P]
   146 00000F4B 81FB00010000        <1> 	cmp	ebx, 256
   147 00000F51 0F87B9010000        <1> 	ja	near guard_stack
   148 00000F57 83C3FC              <1> 	add	ebx, -4
   149                              <1> 
   150 00000F5A 81FB9A000000        <1> 	cmp	ebx, 128+24+2
   151 00000F60 0F82AA010000        <1> 	jb	near guard_stack
   152 00000F66 895D3C              <1> 	mov	dword ptr [ebp+S_P], ebx
   153                              <1> 
   154 00000F69 2B9688040000        <1> 	sub	edx, dword ptr [esi+B0P]
   155 00000F6F C1EA02              <1> 	shr	edx, 2
   156 00000F72 89549E0C            <1> 	mov	dword ptr [esi+ebx*4+REGISTER+3*4], edx	; save PC offset
   157 00000F76 8B96A4040000        <1> 	mov	edx, dword ptr [esi+B0_NAME]
   158 00000F7C 89549E08            <1> 	mov	dword ptr [esi+ebx*4+REGISTER+2*4], edx	; save bank ID
   159 00000F80 8B96A0040000        <1> 	mov	edx, dword ptr [esi+PSR]
   160 00000F86 89549E04            <1> 	mov	dword ptr [esi+ebx*4+REGISTER+4], edx	; saved PSR
   161 00000F8A 890C9E              <1> 	mov	dword ptr [esi+ebx*4+REGISTER], ecx	; latent parameter
   162 00000F8D F7C200008000        <1> 	test	edx, 00800000h				; nested interrupt ?
   163 00000F93 7503                <1> 	jnz	_ii_ii
   164 00000F95 895D38              <1> 	mov	dword ptr [ebp+FP], ebx			; if not, mark interrupted
   165                              <1> 							; application stack frame
   166                              <1> _ii_ii:
   167 00000F98 81CA00008000        <1> 	or	edx, 00800000h				; ISR active
   168 00000F9E 8996A0040000        <1> 	mov	dword ptr [esi+PSR], edx
   169                              <1> 
   170 00000FA4 89C2                <1> 	mov	edx, eax				; get to the operand
   171 00000FA6 83E23F              <1> 	and	edx, 63					; address from interrupt vector
   172 00000FA9 C1E806              <1> 	shr	eax, 6
   173 00000FAC 25FF030000          <1> 	and	eax, 000003FFh				; eax -> page containing ISR ; edx  -> vector
   174 00000FB1 31DB                <1> 	xor	ebx, ebx				; single page ISR
   175 00000FB3 E94D060000          <1> 	jmp	_go2_frame
   176                              <1> 
   177                              <1> ;	_ir	sign extended ea is in eax
   178                              <1> 
   179 00000FB8 F686A204000080      <1> _ir:	test	byte ptr [esi+PSR+2], 128		; eax = EA = variation on return offset
   180 00000FBF 0F843EFFFFFF        <1> 	jz	guard_ii_authority		; not good to do Interrupt Return from application space
   181 00000FC5 89D7                <1> 	mov	edi, edx			; save in case the operation interrupts itself
   182 00000FC7 89C2                <1> 	mov	edx, eax			; +- displacement operand, offset in stack added later
   183                              <1> 
   184 00000FC9 E879010000          <1> 	call	stack_read4			; [ebp+ebx*4] -> interrupt stack frame
   185                              <1> 						; interrupt stack pointer is already updated ebx+4
   186                              <1> 
   187 00000FCE 8B449E08            <1> 	mov	eax, dword ptr [esi+ebx*4+2*4]		; interrupted b0_name
   188                              <1> 
   189 00000FD2 8B4C9E04            <1> 	mov	ecx, dword ptr [esi+ebx*4+1*4]		; interrupted psr
   190                              <1> 
   191 00000FD6 03549E0C            <1> 	add	edx, dword ptr [esi+ebx*4+3*4]		; add interrupted iframe offset to EA
   192                              <1> 
   193 00000FDA 31DB                <1> 	xor	ebx, ebx				; iframe default page high index  
   194 00000FDC A900008000          <1> 	test	eax, 00800000h
   195 00000FE1 7410                <1> 	jz	ir_4k_iframe				; 1-page iframe return target
   196                              <1> 
   197 00000FE3 89C3                <1> 	mov	ebx, eax				; iframe page high index
   198 00000FE5 C1E30C              <1> 	shl	ebx, 12					; from 6 bits at front of table
   199 00000FE8 0FB61C9D[01010000]  <1> 	movzx	ebx, byte ptr [_memory+ebx*4+64*4+1]	; at iframe + 64 words
   200 00000FF0 C1EB02              <1> 	shr	ebx, 2					; shift 6 bits into 8 bits
   201                              <1> 
   202                              <1> ir_4k_iframe:
   203 00000FF3 898EA0040000        <1> 	mov	dword ptr [esi+PSR], ecx
   204 00000FF9 F7C100008000        <1> 	test	ecx, 00800000h				; returning ISR -> ISR ?
   205 00000FFF 741B                <1> 	jz	ir_application				; no
   206                              <1> 
   207 00001001 8DAE00020000        <1> 	lea	ebp, [esi+REGISTER+128*4]		; for nested interrupts
   208 00001007 89AE8C040000        <1> 	mov	dword ptr [esi+REGISTER_SET], ebp	; interrupt register set
   209 0000100D C7869C040000800000- <1> 	mov	dword ptr [esi+ISELECT], 128		; interrupt register set
   209 00001016 00                  <1>
   210 00001017 E9E9050000          <1> 	jmp	_go2_frame				; yes
   211                              <1> 
   212                              <1> ir_application:
   213 0000101C 89F5                <1> 	mov	ebp, esi				; application register set
   214 0000101E 89AE8C040000        <1> 	mov	dword ptr [esi+REGISTER_SET], ebp
   215 00001024 C7869C040000000000- <1> 	mov	dword ptr [esi+ISELECT], 0
   215 0000102D 00                  <1>
   216 0000102E E9D2050000          <1> 	jmp	_go2_frame
   217                              <1> 
    37                                  	%include	"stack.msm"
     1                              <1> ;	stack operations call these to add or subract stack
     2                              <1> ;	limits are checked here
     3                              <1> ;	these routines always leave epb -> all registers 0..255
     4                              <1> ;	because both  interrupt internal stack pointer register 128 + 15
     5                              <1> ;		and application internal stack pointer register 15
     6                              <1> 
     7                              <1> ;	are absolute pointers to the entire register stack
     8                              <1> 
     9                              <1> ;	therefore instructions calling here must afterwards
    10                              <1> 
    11                              <1> ;		mov	ebp, dword ptr [_register_set]
    12                              <1> 
    13                              <1> ;	to get ebp back to application registers 0..127
    14                              <1> ;			or interrupt registers 128..255
    15                              <1> 
    16                              <1> ;	ebp governs which r k x y a b mantissa2 mantissa3 fp sp is implied in the instruction opcode
    17                              <1> ;	registers addressed as operand are always absolute in the range 0..255
    18                              <1> 
    19                              <1> ;	these don't move any data but leave [ebp+ebx*4] pointing to the required stack frame
    20                              <1> ;	and update the stack pointer
    21                              <1> 
    22                              <1> ;	although applications can and must read interrupt registers with load instructions
    23                              <1> ;	they can't read interrupt registers with runaway pop instructions
    24                              <1> ;	because the problem is easier to find with an interrupt as soon as 128+ gets popped
    25                              <1> 
    26                              <1> 
    27                              <1> 
    28                              <1> stack1:
    29                              <1> 	%if	0
    30                              <1> 	mov	ebx, dword ptr [ebp+S_P]
    31                              <1> 	dec	ebx
    32                              <1> 	mov	dword ptr [ebp+S_P], ebx
    33                              <1> 	ret
    34                              <1> 	%endif
    35                              <1> 
    36                              <1> 
    37 00001033 8B5D3C              <1> 	mov	ebx, dword ptr [ebp+S_P]	; read whichever internal sp
    38 00001036 F686A204000080      <1> 	test	byte ptr [esi+PSR+2], 128	; ISR ?
    39 0000103D 742B                <1> 	jz	stack1_a			; no ?
    40 0000103F 81FB00010000        <1> 	cmp	ebx, 256			; in upper range ?
    41 00001045 0F87C5000000        <1> 	ja	near guard_stack		; no ?
    42 0000104B 4B                  <1> 	dec	ebx				; decrement
    43 0000104C 0F88BE000000        <1> 	js	near guard_stack		; < 0 ?
    44 00001052 81FB98000000        <1> 	cmp	ebx, 128+24	; +2		; in clock registers?
    45 00001058 730C                <1> 	jnb	stack1_j			;
    46 0000105A 81FB80000000        <1> 	cmp	ebx, 128			; in app stack? Allowed for thread switch
    47 00001060 0F83AA000000        <1> 	jnb	near guard_stack		; in working registers page
    48                              <1> stack1_j:
    49 00001066 895D3C              <1> 	mov	dword ptr [ebp+S_P], ebx	; new frame
    50 00001069 C3                  <1> 	ret
    51                              <1> 
    52                              <1> stack1_a:					; this is application
    53 0000106A 81FB80000000        <1> 	cmp	ebx, 128			; > interrupt register range start
    54 00001070 0F879A000000        <1> 	ja	near guard_stack		; not allowed
    55 00001076 4B                  <1> 	dec	ebx				; decrement
    56 00001077 0F8893000000        <1> 	js	near guard_stack		; < 0 ?
    57 0000107D 83FB18              <1> 	cmp	ebx, 24				; in control registers ?
    58 00001080 0F828A000000        <1> 	jb	near guard_stack		; not allowed
    59 00001086 895D3C              <1> 	mov	dword ptr [ebp+S_P], ebx	; new frame
    60 00001089 C3                  <1> 	ret
    61                              <1> 
    62                              <1> stack2:
    63                              <1> 	%if	0
    64                              <1> 	mov	ebx, dword ptr [ebp+S_P]
    65                              <1> 	add	ebx, -2
    66                              <1> 	mov	dword ptr [ebp+S_P], ebx
    67                              <1> 	ret
    68                              <1> 	%endif
    69                              <1> 
    70 0000108A 8B5D3C              <1> 	mov	ebx, dword ptr [ebp+S_P]
    71 0000108D F686A204000080      <1> 	test	byte ptr [esi+PSR+2], 128
    72 00001094 742A                <1> 	jz	stack2_a
    73 00001096 81FB00010000        <1> 	cmp	ebx, 256
    74 0000109C 0F876E000000        <1> 	ja	near guard_stack
    75 000010A2 83C3FE              <1> 	add	ebx, -2
    76 000010A5 0F8865000000        <1> 	js	near guard_stack
    77 000010AB 81FB98000000        <1> 	cmp	ebx, 128+24
    78 000010B1 7309                <1> 	jnb	stack2_j
    79 000010B3 83FB7E              <1> 	cmp	ebx, 128-2
    80 000010B6 0F8754000000        <1> 	ja	near guard_stack
    81                              <1> 
    82                              <1> stack2_j:
    83 000010BC 895D3C              <1> 	mov	dword ptr [ebp+S_P], ebx
    84 000010BF C3                  <1> 	ret
    85                              <1> 
    86                              <1> stack2_a:
    87 000010C0 81FB80000000        <1> 	cmp	ebx, 128			; application push high limit 128,  ISR 256
    88 000010C6 7748                <1> 	ja	guard_stack
    89 000010C8 83C3FE              <1> 	add	ebx, -2
    90 000010CB 7843                <1> 	js	guard_stack
    91 000010CD 83FB18              <1> 	cmp	ebx, 24
    92 000010D0 723E                <1> 	jb	guard_stack			; stack top limit zero ISR and application
    93 000010D2 895D3C              <1> 	mov	dword ptr [ebp+S_P], ebx
    94 000010D5 C3                  <1> 	ret
    95                              <1> 
    96                              <1> stack4:
    97                              <1> 	%if	0
    98                              <1> 	mov	ebx, dword ptr [ebp+S_P]
    99                              <1> 	add	ebx, -4
   100                              <1> 	mov	dword ptr [ebp+S_P], ebx
   101                              <1> 	ret
   102                              <1> 	%endif
   103                              <1> 
   104 000010D6 8B5D3C              <1> 	mov	ebx, dword ptr [ebp+S_P]
   105 000010D9 F686A204000080      <1> 	test	byte ptr [esi+PSR+2], 128	; read psr interrupt bit
   106 000010E0 741B                <1> 	jz	stack4_a			; stack is registers 24..127
   107 000010E2 81FB00010000        <1> 	cmp	ebx, 256			; stack is registers  0..255
   108 000010E8 7726                <1> 	ja	guard_stack
   109 000010EA 83C3FC              <1> 	add	ebx, -4				; proposed frame
   110 000010ED 7821                <1> 	js	guard_stack			; not lower than register zero
   111 000010EF 81FB98000000        <1> 	cmp	ebx, 128+24
   112 000010F5 7305                <1> 	jnb	stack4_j
   113 000010F7 83FB7C              <1> 	cmp	ebx, 128-4			; in working registers page
   114 000010FA 7714                <1> 	ja	guard_stack
   115                              <1> 
   116                              <1> stack4_j:
   117                              <1> ;	mov	dword ptr [ebp+S_P], ebx	; caller does this
   118 000010FC C3                  <1> 	ret					; both sp are absolute pointers
   119                              <1> 
   120                              <1> stack4_a:
   121 000010FD 81FB80000000        <1> 	cmp	ebx, 128			; don't push into a higher register than 127
   122 00001103 770B                <1> 	ja	guard_stack
   123 00001105 83C3FC              <1> 	add	ebx, -4
   124 00001108 7806                <1> 	js	guard_stack
   125 0000110A 83FB18              <1> 	cmp	ebx, 24				; dont push lower than 24
   126 0000110D 7201                <1> 	jb	guard_stack
   127                              <1> ;	mov	dword ptr [ebp+S_P], ebx	; caller does this
   128 0000110F C3                  <1> 	ret					; return new frame
   129                              <1> 
   130                              <1> guard_stack:
   131                              <1> stack_underflow:
   132 00001110 8BAE8C040000        <1> 	mov	ebp, dword ptr [esi+REGISTER_SET] ; esi -> core.REGISTER
   133 00001116 F786A0040000000080- <1> 	test	dword ptr [esi+PSR], 00800000h	; interrupt mode?
   133 0000111F 00                  <1>
   134 00001120 0F84DDFDFFFF        <1> 	jz	guard_ii_authority		; sideline the application
   135 00001126 C7453C00010000      <1> 	mov	dword ptr [ebp+S_P], 256	; restart the interrupt stack
   136 0000112D B801000000          <1> 	mov	eax, 1				; so the interrupt can be interrupted
   137 00001132 F605[19000000]01    <1> 	test	byte ptr [_uflag+'Z'-'A'], 1
   138 00001139 7407                <1> 	jz	gsago
   139 0000113B 808E9404000002      <1> 	or	byte ptr [esi+INDICATION], LOCKSTEP
   140 00001142 E9C6FDFFFF          <1> gsago:	jmp	_ii_escape
   141                              <1> 
   142                              <1> stack_read4:
   143 00001147 BB04000000          <1> 	mov	ebx, 4
   144 0000114C 035D3C              <1> 	add	ebx, dword ptr [ebp+S_P]
   145 0000114F 81FB80000000        <1> 	cmp	ebx, 128			; you can have stack locations up to here
   146 00001155 7611                <1> 	jna	stack_r4			; whoever you are
   147 00001157 F686A204000080      <1> 	test	byte ptr [esi+PSR+2], 128	; any higher you have to be an ISR
   148 0000115E 74B0                <1> 	jz	stack_underflow
   149 00001160 81FB00010000        <1> 	cmp	ebx, 256			; and then not any higher than this
   150 00001166 77A8                <1> 	ja	stack_underflow
   151                              <1> 
   152                              <1> stack_r4:
   153 00001168 875D3C              <1> 	xchg	ebx, dword ptr [ebp+S_P]	; write new stack top
   154 0000116B C3                  <1> 	ret					; return old stack top
   155                              <1> 
   156                              <1> stack_read2:
   157 0000116C BB02000000          <1> 	mov	ebx, 2
   158 00001171 035D3C              <1> 	add	ebx, dword ptr [ebp+S_P]
   159 00001174 81FB80000000        <1> 	cmp	ebx, 128			; you can have stack locations up to here
   160 0000117A 7611                <1> 	jna	stack_r2			; whoever you are
   161 0000117C F686A204000080      <1> 	test	byte ptr [esi+PSR+2], 128	; any higher you have to be an ISR
   162 00001183 748B                <1> 	jz	stack_underflow
   163 00001185 81FB00010000        <1> 	cmp	ebx, 256			; and then not any higher than this
   164 0000118B 7783                <1> 	ja	stack_underflow
   165                              <1> 
   166                              <1> stack_r2:
   167 0000118D 875D3C              <1> 	xchg	ebx, dword ptr [ebp+S_P]	; write new stack top
   168 00001190 C3                  <1> 	ret					; return old stack top
   169                              <1> 
   170                              <1> stack_read1:
   171 00001191 BB01000000          <1> 	mov	ebx, 1				; calculate
   172 00001196 035D3C              <1> 	add	ebx, dword ptr [ebp+S_P]	; new stack top
   173 00001199 81FB80000000        <1> 	cmp	ebx, 128			; you can have stack locations up to here
   174 0000119F 7619                <1> 	jna	stack_r1			; whoever you are
   175 000011A1 F686A204000080      <1> 	test	byte ptr [esi+PSR+2], 128	; any higher you have to be an ISR
   176 000011A8 0F8462FFFFFF        <1> 	jz	stack_underflow
   177 000011AE 81FB00010000        <1> 	cmp	ebx, 256			; and then not any higher than this
   178 000011B4 0F8756FFFFFF        <1> 	ja	stack_underflow
   179                              <1> 
   180                              <1> stack_r1:
   181 000011BA 875D3C              <1> 	xchg	ebx, dword ptr [ebp+S_P]	; write new stack top
   182 000011BD C3                  <1> 	ret					; return old stack top
   183                              <1> 
    38                                  	%include	"return.msm"
     1                              <1> _autoexit:
     2 000011BE B846000000          <1> 	mov	eax, II_EXIT
     3 000011C3 B90B000000          <1> 	mov	ecx, LP_AUTOEXIT
     4 000011C8 E940FDFFFF          <1> 	jmp	_ii_escape
     5                              <1> 
     6 000011CD F786A0040000000080- <1> _lret:	test	dword ptr [esi+PSR], 00800000h
     6 000011D6 00                  <1>
     7 000011D7 7509                <1> 	jnz	_lret_
     8                              <1> 
     9 000011D9 817D3C80000000      <1> 	cmp	dword ptr [ebp+S_P], 128
    10 000011E0 74DC                <1> 	jz	_autoexit
    11                              <1> 
    12 000011E2 E8AAFFFFFF          <1> _lret_:	call	stack_read1
    13 000011E7 03049E              <1> 	add	eax, dword ptr [esi+ebx*4]
    14 000011EA 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
    15 000011EF E91A020000          <1> 	jmp	_j
    16                              <1> 
    17 000011F4 F786A0040000000080- <1> _fret:	test	dword ptr [esi+PSR], 00800000h
    17 000011FD 00                  <1>
    18 000011FE 7509                <1> 	jnz	_fret_
    19                              <1> 
    20 00001200 817D3C80000000      <1> 	cmp	dword ptr [ebp+S_P], 128
    21 00001207 74B5                <1> 	jz	_autoexit
    22                              <1> 
    23 00001209 E85EFFFFFF          <1> _fret_:	call	stack_read2
    24 0000120E 899680040000        <1> 	mov	dword ptr [esi+APC], edx
    25 00001214 89C2                <1> 	mov	edx, eax
    26 00001216 03549E04            <1> 	add	edx, dword ptr [esi+ebx*4+1*4]	; add EA as displacement to offset on stack
    27 0000121A 8B049E              <1> 	mov	eax, dword ptr [esi+ebx*4]
    28 0000121D 31DB                <1> 	xor	ebx, ebx			; 1-page frame?
    29 0000121F A900008000          <1> 	test	eax, 00800000h			; multipages frame?
    30 00001224 7410                <1> 	jz	_fret_1page
    31 00001226 89C3                <1> 	mov	ebx, eax
    32 00001228 C1E30C              <1> 	shl	ebx, 12
    33 0000122B 0FB61C9D[01010000]  <1> 	movzx	ebx, byte ptr [_memory+ebx*4+64*4+1]
    34 00001233 C1EB02              <1> 	shr	ebx, 2
    35                              <1> 
    36                              <1> _fret_1page:
    37 00001236 E9CA030000          <1> 	jmp	_go2_frame
    38                              <1> 
    39 0000123B B803000000          <1> _fpxpo:	mov	eax, II_FPXPO
    40 00001240 B90C000000          <1> 	mov	ecx, LP_RANGE
    41 00001245 E9C3FCFFFF          <1> 	jmp	_ii_escape
    42                              <1> 
    39                                  	%include	"rta.msm"
     1                              <1> 
     2 0000124A 80F904              <1> _sr:	cmp	cl, I
     3 0000124D 0F84ACF8FFFF        <1> 	jz	_inA
     4 00001253 80F905              <1> 	cmp	cl, XI
     5 00001256 0F849EFBFFFF        <1> 	jz	_on
     6                              <1> 
     7 0000125C 8B5D00              <1> 	mov	ebx, dword ptr [ebp+R]
     8 0000125F E97FF2FFFF          <1> 	jmp	_operand_write
     9                              <1> 
    10 00001264 80F904              <1> _sk:	cmp	cl, I
    11 00001267 0F849DF8FFFF        <1> 	jz	_inB
    12 0000126D 80F905              <1> 	cmp	cl, XI
    13 00001270 0F848CFBFFFF        <1> 	jz	_off
    14                              <1> 
    15 00001276 8B5D04              <1> 	mov	ebx, dword ptr [ebp+K]
    16 00001279 E965F2FFFF          <1> 	jmp	_operand_write
    17                              <1> 
    18 0000127E 80F904              <1> _sx:	cmp	cl, I
    19 00001281 0F848EF8FFFF        <1> 	jz	_outA
    20 00001287 80F905              <1> 	cmp	cl, XI
    21 0000128A 0F847AF7FFFF        <1> 	jz	_rsr
    22                              <1> 
    23 00001290 8B5D08              <1> 	mov	ebx, dword ptr [ebp+X]
    24 00001293 E94BF2FFFF          <1> 	jmp	_operand_write
    25                              <1> 
    26 00001298 80F904              <1> _sy:	cmp	cl, I
    27 0000129B 0F847CF8FFFF        <1> 	jz	_outB
    28 000012A1 80F905              <1> 	cmp	cl, XI
    29 000012A4 0F84D0F7FFFF        <1> 	jz	_wsr
    30                              <1> 
    31 000012AA 8B5D0C              <1> 	mov	ebx, dword ptr [ebp+Y]
    32 000012AD E931F2FFFF          <1> 	jmp	_operand_write;
    33                              <1> 
    34 000012B2 80F904              <1> _sa:	cmp	cl, I
    35 000012B5 0F8422F9FFFF        <1> 	jz	_reload
    36 000012BB 80F905              <1> 	cmp	cl, XI
    37 000012BE 744E                <1> 	jz	escape
    38                              <1> 
    39 000012C0 8B5D10              <1> 	mov	ebx, dword ptr [ebp+A]
    40 000012C3 E91BF2FFFF          <1> 	jmp	_operand_write
    41                              <1> 
    42 000012C8 80F904              <1> _sb:	cmp	cl, I
    43 000012CB 7441                <1> 	jz	escape
    44 000012CD 80F905              <1> 	cmp	cl, XI
    45 000012D0 743C                <1> 	jz	escape
    46                              <1> 
    47 000012D2 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]
    48 000012D5 E909F2FFFF          <1> 	jmp	_operand_write
    49                              <1> 
    50 000012DA 80F904              <1> _z:	cmp	cl, I
    51 000012DD 0F841CF9FFFF        <1> 	jz	_sabr
    52 000012E3 80F905              <1> 	cmp	cl, XI
    53 000012E6 0F84E1FEFFFF        <1> 	jz	_lret
    54 000012EC 31DB                <1> 	xor	ebx, ebx
    55 000012EE E9F0F1FFFF          <1> 	jmp	_operand_write
    56                              <1> 
    57 000012F3 80F904              <1> _pop:	cmp	cl, I
    58 000012F6 7416                <1> 	jz	escape
    59 000012F8 80F905              <1> 	cmp	cl, XI
    60 000012FB 0F84F3FEFFFF        <1> 	jz	_fret
    61                              <1> 
    62 00001301 E88BFEFFFF          <1> 	call	stack_read1
    63 00001306 8B1C9E              <1> 	mov	ebx, dword ptr [esi+ebx*4]
    64 00001309 E9D5F1FFFF          <1> 	jmp	_operand_write
    65                              <1> 
    66 0000130E C3                  <1> escape	ret
    67                              <1> 
    68 0000130F E83DF0FFFF          <1> _lr:	call	_operand_read
    69 00001314 894500              <1> 	mov	dword ptr [ebp+R], eax
    70 00001317 C3                  <1> 	ret
    71                              <1> 
    72 00001318 E834F0FFFF          <1> _lk:	call	_operand_read
    73 0000131D 894504              <1> 	mov	dword ptr [ebp+K], eax
    74 00001320 C3                  <1> 	ret
    75 00001321 E82BF0FFFF          <1> _lx:	call	_operand_read
    76 00001326 894508              <1> 	mov	dword ptr [ebp+X], eax
    77 00001329 C3                  <1> 	ret
    78                              <1> 
    79 0000132A E822F0FFFF          <1> _ly:	call	_operand_read
    80 0000132F 89450C              <1> 	mov	dword ptr [ebp+Y], eax
    81 00001332 C3                  <1> 	ret
    82                              <1> 
    83 00001333 E819F0FFFF          <1> _la:	call	_operand_read
    84 00001338 894510              <1> 	mov	dword ptr [ebp+A], eax
    85 0000133B C3                  <1> 	ret
    86                              <1> 
    87 0000133C E810F0FFFF          <1> _lb:	call	_operand_read
    88 00001341 894514              <1> 	mov	dword ptr [ebp+B], eax
    89 00001344 C3                  <1> 	ret
    90                              <1> 
    91 00001345 80F904              <1> _tz:	cmp	cl, I
    92 00001348 0F84CE130000        <1> 	jz	near _rex
    93 0000134E 80F905              <1> 	cmp	cl, XI
    94 00001351 B900000000          <1> 	mov	ecx, 0
    95 00001356 0F848AFBFFFF        <1> 	jz	_ii_instruction
    96                              <1> 
    97 0000135C E8F0EFFFFF          <1> 	call	_operand_read
    98 00001361 A9FFFFFF00          <1> 	test	eax, 00FFFFFFh
    99 00001366 7503                <1> 	jnz	_tz_
   100 00001368 83C204              <1> 	add	edx, 4
   101 0000136B C3                  <1> _tz_:	ret
   102                              <1> 
   103 0000136C 80F904              <1> _tp:	cmp	cl, I
   104 0000136F 742A                <1> 	jz	_jdz
   105 00001371 80F905              <1> 	cmp	cl, XI
   106 00001374 0F843EFCFFFF        <1> 	jz	_ir
   107                              <1> 
   108 0000137A E8D2EFFFFF          <1> 	call	_operand_read
   109 0000137F A900008000          <1> 	test	eax, 00800000h
   110 00001384 7503                <1> 	jnz	_tp_
   111 00001386 83C204              <1> 	add	edx, 4
   112 00001389 C3                  <1> _tp_:	ret
   113                              <1> 
   114 0000138A E8C2EFFFFF          <1> _push:	call	_operand_read
   115                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
   116 0000138F 0F7EFE              <1> 	movd	esi, mm7
   117                              <1> 
   118 00001392 E89CFCFFFF          <1> 	call	stack1
   119 00001397 89049E              <1> 	mov	dword ptr [esi+ebx*4], eax
   120 0000139A C3                  <1> 	ret
   121                              <1> 
   122 0000139B 8B5D14              <1> _jdz:	mov	ebx, dword ptr [ebp+B]
   123 0000139E 0B5D10              <1> 	or	ebx, dword ptr [ebp+A]
   124 000013A1 0F8467000000        <1> 	jz	near _j
   125 000013A7 C3                  <1> 	ret
   126                              <1> 
   127 000013A8 8B5D00              <1> _jdr:	mov	ebx, dword ptr [ebp+R]	; dec r and jump if it passed from zero to -1
   128 000013AB 81C3FFFFFF00        <1> 	add	ebx, 00FFFFFFh
   129 000013B1 C1C308              <1> 	rol	ebx, 8
   130 000013B4 88D9                <1> 	mov	cl, bl
   131 000013B6 C1EB08              <1> 	shr	ebx, 8			; write back to registers only 00000000 thru 00FFFFFF
   132 000013B9 895D00              <1> 	mov	dword ptr [ebp+R], ebx
   133 000013BC F6C101              <1> 	test	cl, 1
   134 000013BF 754D                <1> 	jnz	_j
   135 000013C1 C3                  <1> 	ret
   136                              <1> 
   137 000013C2 E86CFCFFFF          <1> _lcal:	call	stack1
   138 000013C7 2B9688040000        <1> 	sub	edx, dword ptr [esi+B0P]
   139 000013CD C1EA02              <1> 	shr	edx, 2
   140 000013D0 89149E              <1> 	mov	dword ptr [esi+ebx*4], edx
   141 000013D3 EB39                <1> 	jmp	_j			; EA is in eax
   142 000013D5 C3                  <1> 	ret
   143                              <1> 
   144 000013D6 F786A0040000010000- <1> _jnc:	test	dword ptr [esi+PSR], 1
   144 000013DF 00                  <1>
   145 000013E0 742C                <1> 	jz	_j
   146 000013E2 C3                  <1> 	ret
   147                              <1> 
   148 000013E3 F786A0040000010000- <1> _jc:	test	dword ptr [esi+PSR], 1
   148 000013EC 00                  <1>
   149 000013ED 751F                <1> 	jnz	_j
   150 000013EF C3                  <1> 	ret
   151                              <1> 
   152 000013F0 F7451001000000      <1> _jao:	test	dword ptr [ebp+A], 1
   153 000013F7 7515                <1> 	jnz	_j
   154 000013F9 C3                  <1> 	ret
   155                              <1> 
   156 000013FA F7451000008000      <1> _jpa:	test	dword ptr [ebp+A], 00800000h
   157 00001401 740B                <1> 	jz	_j
   158 00001403 C3                  <1> 	ret
   159                              <1> 
   160 00001404 F7451400008000      <1> _jpb:	test	dword ptr [ebp+B], 00800000h
   161 0000140B 7401                <1> 	jz	_j
   162 0000140D C3                  <1> 	ret
   163                              <1> 
   164 0000140E 89D7                <1> _j:	mov	edi, edx			; save position for error handling
   165 00001410 8B9688040000        <1> 	mov	edx, dword ptr [esi+B0P]
   166                              <1> 
   167 00001416 C1E002              <1> 	shl	eax, 2
   168 00001419 01C2                <1> 	add	edx, eax
   169 0000141B 3B9684040000        <1> 	cmp	edx, dword ptr [esi+APCZ]
   170 00001421 7701                <1> 	ja	_j_check
   171 00001423 C3                  <1> 	ret
   172                              <1> 
   173                              <1> _j_check:
   174 00001424 89FA                <1> 	mov	edx, edi			; restore updated apc
   175 00001426 B90E000000          <1> 	mov	ecx, LP_ADDRESS
   176 0000142B E9D8FAFFFF          <1> 	jmp	guard_ii_escape			; for interrupt come-from
   177                              <1> 
   178 00001430 E88B100000          <1> _jpo:	call	NEAR _get_parity
   179 00001435 7BD7                <1> 	jpo	_j
   180 00001437 C3                  <1> 	ret
   181                              <1> 
   182 00001438 816510FFFFFF00      <1> _jza:	and	dword ptr [ebp+A], 00FFFFFFh
   183 0000143F 74CD                <1> 	jz	_j
   184 00001441 C3                  <1> 	ret
   185                              <1> 
   186 00001442 816514FFFFFF00      <1> _jzb:	and	dword ptr [ebp+B], 00FFFFFFh
   187 00001449 74C3                <1> 	jz	_j
   188 0000144B C3                  <1> 	ret
   189                              <1> 
   190 0000144C 816510FFFFFF00      <1> _jnza:	and	dword ptr [ebp+A], 00FFFFFFh
   191 00001453 75B9                <1> 	jnz	_j
   192 00001455 C3                  <1> 	ret
   193                              <1> 
   194 00001456 816514FFFFFF00      <1> _jnzb:	and	dword ptr [ebp+B], 00FFFFFFh
   195 0000145D 75AF                <1> 	jnz	_j
   196 0000145F C3                  <1> 	ret
   197                              <1> 
   198 00001460 F7451000008000      <1> _jna:	test	dword ptr [ebp+A], 00800000h
   199 00001467 75A5                <1> 	jnz	_j
   200 00001469 C3                  <1> 	ret
   201                              <1> 
   202 0000146A F7451400008000      <1> _jnb:	test	dword ptr [ebp+B], 00800000h
   203 00001471 759B                <1> 	jnz	_j
   204 00001473 C3                  <1> 	ret
   205                              <1> 
   206 00001474 8B5D08              <1> _jxge:	mov	ebx, dword ptr [ebp+X]
   207 00001477 2B5D00              <1> 	sub	ebx, dword ptr [ebp+R]
   208 0000147A F7C300000001        <1> 	test	ebx, 01000000h		; microcarry?
   209 00001480 748C                <1> 	jz	_j			; no:  x <  r,    jump
   210 00001482 C3                  <1> 	ret				; yes: x >= r, no jump
   211                              <1> 
   212 00001483 8B5D0C              <1> _jyge:	mov	ebx, dword ptr [ebp+Y]
   213 00001486 2B5D00              <1> 	sub	ebx, dword ptr [ebp+R]
   214 00001489 F7C300000001        <1> 	test	ebx, 01000000h		; microcarry?
   215 0000148F 0F8479FFFFFF        <1> 	jz	_j			; no:  y <  r,    jump
   216 00001495 C3                  <1> 	ret				; yes: y >= r, no jump
   217                              <1> 
   218 00001496 BB04000000          <1> _qs:	mov	ebx, a
   219 0000149B E9CDEFFFFF          <1> 	jmp	_burst_write4
   220                              <1> 
   221 000014A0 BB04000000          <1> _ql:	mov	ebx, a
   222 000014A5 E97AEEFFFF          <1> 	jmp	_burst_read4
   223                              <1> 
   224 000014AA E898FCFFFF          <1> _qpop:	call	stack_read4			; places 4 stack registers in the scope of burst write
   225 000014AF 55                  <1> 	push	ebp
   226                              <1> ;	mov	ebp, dword ptr [ebp+CORE_INDEX1] 
   227 000014B0 0F7EFD              <1> 	movd	ebp, mm7
   228                              <1> 
   229 000014B3 E8B5EFFFFF          <1> 	call	_burst_write4
   230 000014B8 5D                  <1> 	pop	ebp
   231 000014B9 C3                  <1> 	ret					; stack pointers are absolute
   232                              <1> 
   233 000014BA E817FCFFFF          <1> _qpush: call	stack4
   234 000014BF 55                  <1> 	push	ebp
   235                              <1> ;	mov	ebp, dword ptr [ebp+CORE_INDEX1]
   236 000014C0 0F7EFD              <1> 	movd	ebp, mm7
   237                              <1> 
   238 000014C3 E85CEEFFFF          <1> 	call	_burst_read4
   239 000014C8 5D                  <1> 	pop	ebp
   240 000014C9 895D3C              <1> 	mov	dword ptr [ebp+S_P], ebx	; update RTA1 sp after writing stack frame
   241 000014CC C3                  <1> 	ret					; not done until this point
   242                              <1> 
   243 000014CD E89AFCFFFF          <1> _dpop:	call	stack_read2
   244 000014D2 55                  <1> 	push	ebp
   245                              <1> ;	mov	ebp, dword ptr [ebp+CORE_INDEX1]
   246 000014D3 0F7EFD              <1> 	movd	ebp, mm7
   247                              <1> 
   248 000014D6 E8D7EFFFFF          <1> 	call	_burst_write2
   249 000014DB 5D                  <1> 	pop	ebp
   250 000014DC C3                  <1> 	ret
   251                              <1> 
   252 000014DD E82DEEFFFF          <1> _dpush:	call	_burst_read2
   253                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
   254 000014E2 0F7EFE              <1> 	movd	esi, mm7
   255                              <1> 
   256 000014E5 89D9                <1> 	mov	ecx, ebx
   257 000014E7 E89EFBFFFF          <1> 	call	stack2				; RTA1 sp updated at this point
   258 000014EC 894C9E04            <1> 	mov	dword ptr [esi+ebx*4+4], ecx
   259 000014F0 89049E              <1> 	mov	dword ptr [esi+ebx*4], eax
   260 000014F3 C3                  <1> 	ret
   261                              <1> 
   262 000014F4 E858EEFFFF          <1> _mta:	call	_operand_read
   263 000014F9 334510              <1> 	xor	eax, dword ptr [ebp+A]
   264 000014FC 234504              <1> 	and	eax, dword ptr [ebp+K]
   265 000014FF 7503                <1> 	jnz	_mta_
   266 00001501 83C204              <1> 	add	edx, 4		; k AND (a XOR operand) = 0, skip 1 instruction
   267 00001504 C3                  <1> _mta_:	ret
   268                              <1> 
   269 00001505 E805EEFFFF          <1> _dte:	call	_burst_read2
   270 0000150A 334510              <1> 	xor	eax, dword ptr [ebp+A]
   271 0000150D 7508                <1> 	jnz	_dte_
   272 0000150F 335D14              <1> 	xor	ebx, dword ptr [ebp+B]
   273 00001512 7503                <1> 	jnz	_dte_
   274 00001514 83C204              <1> 	add	edx, 4
   275 00001517 C3                  <1> _dte_:	ret	
   276                              <1> 
   277 00001518 8B9EA0040000        <1> _sc:	mov	ebx, dword ptr [esi+PSR]
   278 0000151E 83E301              <1> 	and	ebx, 1		; store carry 
   279 00001521 E9BDEFFFFF          <1> 	jmp	_operand_write
   280                              <1> 
   281 00001526 E826EEFFFF          <1> _mlb:	call	_operand_read
   282 0000152B 8B5D04              <1> 	mov	ebx, dword ptr [ebp+K]
   283 0000152E 21D8                <1> 	and	eax, ebx
   284 00001530 81F3FFFFFF00        <1> 	xor	ebx, 00FFFFFFh
   285 00001536 235D14              <1> 	and	ebx, dword ptr [ebp+B]
   286 00001539 09C3                <1> 	or	ebx, eax
   287 0000153B 895D14              <1> 	mov	dword ptr [ebp+B], ebx	; b = (b AND (NOT k)) OR (operand AND k)
   288 0000153E C3                  <1> 	ret
   289                              <1> 
   290 0000153F BB04000000          <1> _ds:	mov	ebx, a
   291 00001544 E969EFFFFF          <1> 	jmp	_burst_write2
   292                              <1> 
   293 00001549 E8C1EDFFFF          <1> _dl:	call	_burst_read2
   294 0000154E 895D14              <1> 	mov	dword ptr [ebp+B], ebx
   295 00001551 894510              <1> 	mov	dword ptr [ebp+A], eax
   296 00001554 C3                  <1> 	ret
   297                              <1> 
   298 00001555 C3                  <1> _spare:	ret
   299                              <1> 
   300 00001556 E800F1FFFF          <1> _ex:	call	memory_read
   301                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
   302 0000155B 0F7EFE              <1> 	movd	esi, mm7
   303                              <1> 
   304 0000155E E9F2EBFFFF          <1> 	jmp	_execute
   305                              <1> 
   306 00001563 E82AF1FFFF          <1> _ts:	call	memory_lock			; edi + esi -> memory word
   307 00001568 66B80080            <1> 	mov	ax, 08000h
   308 0000156C 668704B7            <1> 	xchg	ax, word ptr [edi+esi*4]	; swap -> t1 for 080 under lock
   309 00001570 6621C0              <1> 	and	ax, ax
   310 00001573 7803                <1> 	js	_ts___				; no action if already locked
   311                              <1> 
   312 00001575 83C204              <1> 	add	edx, 4				; skip if ms bit was clear before
   313                              <1> 
   314 00001578 C3                  <1> _ts___:	ret
   315                              <1> 
   316                              <1> 
   317 00001579 E8E8F0FFFF          <1> _sim:	call	memoreg				; edi -> device		edi <- NULL
   318                              <1> 						; esi -> word	OR	ebx -> register
   319                              <1> 						; eax <- data
   320                              <1> ;	mov	ecx, dword ptr [ebp+CORE_INDEX1]
   321 0000157E 0F7EF9              <1> 	movd	ecx, mm7
   322                              <1> 
   323 00001581 66C1E008            <1> 	shl	ax, 8
   324 00001585 8A81A2040000        <1> 	mov	al, byte ptr [ecx+PSR+2]
   325 0000158B C1C803              <1> 	ror	eax, 3
   326 0000158E C0C003              <1> 	rol	al, 3
   327 00001591 8881A2040000        <1> 	mov	byte ptr [ecx+PSR+2], al
   328 00001597 C1E81D              <1> 	shr	eax, 32-3
   329                              <1> 
   330 0000159A E9A7F0FFFF          <1> 	jmp	memoreg_writeback
   331                              <1> 
   332 0000159F 52                  <1> _call:	push	edx
   333 000015A0 E8E5FAFFFF          <1> 	call	stack2
   334 000015A5 2B9688040000        <1> 	sub	edx, dword ptr [esi+B0P]
   335 000015AB C1EA02              <1> 	shr	edx, 2
   336 000015AE 89549E04            <1> 	mov	dword ptr [esi+ebx*4+1*4], edx
   337 000015B2 8B96A4040000        <1> 	mov	edx, dword ptr [esi+B0_NAME]
   338 000015B8 89149E              <1> 	mov	dword ptr [esi+ebx*4], edx
   339 000015BB 5A                  <1> 	pop	edx		; in case the jump goes wrong
   340                              <1> 				; and an interrupt frame needs constructed
   341                              <1> 
   342 000015BC 899680040000        <1> _go:	mov	dword ptr [esi+APC], edx
   343 000015C2 E88AEDFFFF          <1> 	call	_operand_read	; may be memory or register
   344                              <1> 
   345                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
   346 000015C7 0F7EFE              <1> 	movd	esi, mm7
   347                              <1> 
   348 000015CA 89C2                <1> 	mov	edx, eax	; lookaside to calculate the vector
   349 000015CC A900008000          <1> 	test	eax, 00800000h	; gate?
   350 000015D1 7425                <1> 	jz	_go2_4k_frame
   351                              <1> 
   352 000015D3 25FFFF7F00          <1> 	and	eax, 007FFFFFh	; read the gate constant
   353 000015D8 E832EDFFFF          <1> 	call	_burst_read2	;
   354                              <1> 
   355                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
   356 000015DD 0F7EFE              <1> 	movd	esi, mm7
   357                              <1> 
   358 000015E0 89C2                <1> 	mov	edx, eax	; page high index ++ word offset
   359 000015E2 89D8                <1> 	mov	eax, ebx	; storage block base page index
   360 000015E4 C1C20E              <1> 	rol	edx, 6+8
   361 000015E7 89D3                <1> 	mov	ebx, edx	; instruction frame page high index
   362 000015E9 83E33F              <1> 	and	ebx, 63
   363 000015EC 7405                <1> 	jz	_go_gate	; one page iframe
   364 000015EE 0D00008000          <1> 	or	eax, 00800000h	; two+ page iframe
   365                              <1> 
   366                              <1> _go_gate:
   367 000015F3 C1EA0E              <1> 	shr	edx, 6+8	; net word offset
   368                              <1> 
   369 000015F6 EB0D                <1> 	jmp	_go2_frame
   370                              <1> 	
   371                              <1> _go2_4k_frame:
   372 000015F8 83E23F              <1> 	and	edx, 63		; target is in 4k block, 64 vectors
   373 000015FB C1E806              <1> 	shr	eax, 6		; new b0_name
   374 000015FE 25FFFF0000          <1> 	and	eax, 0000FFFFh	; bit 22 of GO / CALL word reserved
   375 00001603 31DB                <1> 	xor	ebx, ebx	; frame high page index
   376                              <1> 
   377                              <1> _go2_frame:
   378 00001605 F686A204000080      <1> 	test	byte ptr [esi+PSR+2], 128	; already in interrupt code?
   379 0000160C 751B                <1> 	jnz	_go2_base_frame	; 	; may branch into interrupt code
   380                              <1> 					; because he is interrupt code
   381 0000160E 89C1                <1> 	mov	ecx, eax
   382 00001610 81E1FFFF3F00        <1> 	and	ecx, 03FFFFFh
   383 00001616 2B8EF0050000        <1> 	sub	ecx, dword ptr [esi+IO_PORT+_APP_THRESHOLD]	; applications lower limit
   384 0000161C 7D0B                <1> 	jnl	_go2_base_frame
   385                              <1> 
   386 0000161E 8B9680040000        <1> 	mov	edx, dword ptr [esi+APC]
   387 00001624 E9DAF8FFFF          <1> 	jmp	guard_ii_authority
   388                              <1> 
   389                              <1> _go2_base_frame:
   390                              <1> 
   391 00001629 8986A4040000        <1> 	mov	dword ptr [esi+B0_NAME], eax	; with flags
   392 0000162F 25FFFF3F00          <1> 	and	eax, 003FFFFFh			; base page index only
   393 00001634 01C3                <1> 	add	ebx, eax
   394 00001636 899ED0050000        <1> 	mov	dword ptr [esi+IO_PORT+_IFRAME_U], ebx
   395                              <1> 
   396                              <1> 	%if	1
   397 0000163C 8B8ED0060000        <1> 	mov	ecx, dword ptr [esi+IO_PORT+_DEVICE]	; memory page high index
   398 00001642 81E1FFFF3F00        <1> 	and	ecx, 003FFFFFh			; strip memory type bits
   399 00001648 29D9                <1> 	sub	ecx, ebx			; iframe high page may be = not >
   400 0000164A 7910                <1> 	jns	_go2_frame_in_range
   401                              <1> 
   402 0000164C B90E000000          <1> 	mov	ecx, LP_ADDRESS
   403 00001651 8B9680040000        <1> 	mov	edx, dword ptr [esi+APC]
   404 00001657 E9ACF8FFFF          <1> 	jmp	guard_ii_escape
   405                              <1> 
   406                              <1> _go2_frame_in_range:
   407                              <1> 
   408                              <1> 	%else
   409                              <1> 	PATH NOT IN USE
   410                              <1> 	mov	ecx, dword ptr [esi+IO_PORT+_DEVICE]	; have we the highest frame page?
   411                              <1> 	and	ecx, 003FFFFFh			; read highest page index
   412                              <1> ; NO!	mov	esi, LP_ADDRESS			; trim off flags
   413                              <1> 	sub	ecx, ebx			; compare
   414                              <1> 	xchg	edx, dword ptr [esi+APC]
   415                              <1> 	js	guard_ii_escape			; if negative that should catch it
   416                              <1> 	xchg	edx, dword ptr [esi+APC]
   417                              <1> 	%endif
   418                              <1> 
   419 0000165C C1E30C              <1> 	shl	ebx, 12
   420 0000165F 8D1C9D[FC3F0000]    <1> 	lea	ebx, [_memory+ebx*4+4095*4]	; last instruction word in iframe
   421                              <1> 						; higher = wrong
   422 00001666 899E84040000        <1> 	mov	dword ptr [esi+APCZ], ebx	; set execution limit pointer
   423                              <1> 
   424 0000166C 8986D0040000        <1> 	mov	dword ptr [esi+IO_PORT], eax
   425 00001672 C1E00E              <1> 	shl	eax, 12+2	; 4kword block multiplied by 4 for word
   426 00001675 05[00000000]        <1> 	add	eax, _memory	; add the platform location of executable space
   427 0000167A 898688040000        <1> 	mov	dword ptr [esi+B0P], eax
   428 00001680 C1E202              <1> 	shl	edx, 2		; add the vector offset * 4 for word
   429 00001683 01C2                <1> 	add	edx, eax
   430 00001685 C3                  <1> _go_:	ret
   431                              <1> 
    40                                  	%include	"alu.msm"
     1                              <1> 
     2                              <1> 
     3 00001686 E8C6ECFFFF          <1> _ax:	call	_operand_read
     4 0000168B 034508              <1> 	add	eax, dword ptr [ebp+X]
     5 0000168E 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
     6 00001693 894508              <1> 	mov	dword ptr [ebp+X], eax
     7 00001696 C3                  <1> 	ret
     8                              <1> 
     9 00001697 E8B5ECFFFF          <1> _ay:	call	_operand_read
    10 0000169C 03450C              <1> 	add	eax, dword ptr [ebp+Y]
    11 0000169F 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
    12 000016A4 89450C              <1> 	mov	dword ptr [ebp+Y], eax
    13 000016A7 C3                  <1> 	ret
    14                              <1> 
    15 000016A8 E8A4ECFFFF          <1> _or:	call	_operand_read
    16 000016AD 094510              <1> 	or	dword ptr [ebp+A], eax
    17 000016B0 C3                  <1> 	ret
    18                              <1> 
    19 000016B1 E89BECFFFF          <1> _orB:	call	_operand_read
    20 000016B6 094514              <1> 	or	dword ptr [ebp+B], eax
    21 000016B9 C3                  <1> 	ret
    22                              <1> 
    23 000016BA E892ECFFFF          <1> _and:	call	_operand_read
    24 000016BF 214510              <1> 	and	dword ptr [ebp+A], eax
    25 000016C2 C3                  <1> 	ret
    26                              <1> 
    27 000016C3 E889ECFFFF          <1> _andB:	call	_operand_read
    28 000016C8 214514              <1> 	and	dword ptr [ebp+B], eax
    29 000016CB C3                  <1> 	ret
    30                              <1> 
    31 000016CC E880ECFFFF          <1> _xor:	call	_operand_read
    32 000016D1 314510              <1> 	xor	dword ptr [ebp+A], eax
    33 000016D4 C3                  <1> 	ret
    34                              <1> 
    35 000016D5 E877ECFFFF          <1> _xorB:	call	_operand_read
    36 000016DA 314514              <1> 	xor	dword ptr [ebp+B], eax
    37 000016DD C3                  <1> 	ret
    38                              <1> 
    39 000016DE E86EECFFFF          <1> _aa:	call	_operand_read
    40 000016E3 EB0D                <1> 	jmp	_aa_
    41                              <1> 
    42 000016E5 E867ECFFFF          <1> _ana:	call	_operand_read
    43 000016EA 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
    44 000016EF 83C001              <1> 	add	eax, 1
    45                              <1> 
    46 000016F2 034510              <1> _aa_:	add	eax, dword ptr [ebp+A]
    47 000016F5 E8B9040000          <1> 	call	_alu_carry
    48                              <1> 
    49 000016FA 894510              <1> 	mov	dword ptr [ebp+A], eax
    50 000016FD C3                  <1> 	ret
    51                              <1> 
    52 000016FE E84EECFFFF          <1> _ab:	call	_operand_read
    53 00001703 EB0D                <1> 	jmp	_ab_
    54                              <1> 
    55 00001705 E847ECFFFF          <1> _anb:	call	_operand_read
    56 0000170A 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
    57 0000170F 83C001              <1> 	add	eax, 1
    58                              <1> 
    59 00001712 034514              <1> _ab_:	add	eax, dword ptr [ebp+B]
    60 00001715 E899040000          <1> 	call	_alu_carry
    61                              <1> 
    62 0000171A 894514              <1> 	mov	dword ptr [ebp+B], eax
    63 0000171D C3                  <1> 	ret
    64                              <1> 
    65 0000171E 52                  <1> _m:	push	edx			; 80386 platform has it ready made, so
    66 0000171F E82DECFFFF          <1> 	call	_operand_read
    67 00001724 C1E008              <1> 	shl	eax, 8			; prepare multiplier to be multiplicand 
    68 00001727 C1F808              <1> 	sar	eax, 8			; sign it in eax
    69 0000172A 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]	; this is register side multiplicand but
    70                              <1> 					; it makes no difference which is which
    71 0000172D C1E308              <1> 	shl	ebx, 8			; so use it as multiplier if that is OK
    72 00001730 C1FB08              <1> 	sar	ebx, 8			; sign it first
    73                              <1> 
    74 00001733 F7EB                <1> 	imul	ebx
    75                              <1> 
    76 00001735 C1C008              <1> 	rol	eax, 8			; move 8 bits up from eax to edx
    77 00001738 C1E208              <1> 	shl	edx, 8
    78 0000173B 88C2                <1> 	mov	dl, al
    79 0000173D C1E808              <1> 	shr	eax, 8
    80 00001740 894514              <1> 	mov	dword ptr [ebp+B], eax	; product bits 23..0
    81 00001743 C1E208              <1> 	shl	edx, 8
    82 00001746 C1EA08              <1> 	shr	edx, 8
    83 00001749 895510              <1> 	mov	dword ptr [ebp+A], edx	; product high order bits
    84 0000174C 5A                  <1> 	pop	edx
    85 0000174D C3                  <1> 	ret
    86                              <1> 
    87 0000174E 52                  <1> _mf:	push	edx		; the multiplier is signed the multiplicand unsigned
    88 0000174F E8FDEBFFFF          <1> 	call	_operand_read
    89 00001754 89C1                <1> 	mov	ecx, eax	; just to remember the multiplier sign
    90 00001756 A900008000          <1> 	test	eax, 00800000h
    91 0000175B 7408                <1> 	jz	_mfplusplus
    92 0000175D 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
    93 00001762 83C001              <1> 	add	eax, 1
    94                              <1> _mfplusplus:
    95 00001765 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]	; this is the multiplicand, unsigned
    96 00001768 F7E3                <1> 	mul	ebx		; two 24-bit unsigned values should be OK here
    97 0000176A C1C008              <1> 	rol	eax, 8
    98 0000176D C1E208              <1> 	shl	edx, 8
    99 00001770 88C2                <1> 	mov	dl, al
   100 00001772 C1E808              <1> 	shr	eax, 8
   101 00001775 C1E208              <1> 	shl	edx, 8
   102 00001778 C1EA08              <1> 	shr	edx, 8
   103 0000177B F7C100008000        <1> 	test	ecx, 00800000h	; was the multiplier signed?
   104 00001781 741F                <1> 	jz	_mfstore
   105 00001783 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   106 00001788 81F2FFFFFF00        <1> 	xor	edx, 00FFFFFFh
   107 0000178E 83C001              <1> 	add	eax, 1
   108 00001791 C1C008              <1> 	rol	eax, 8
   109 00001794 0FB6C8              <1> 	movzx	ecx, al
   110 00001797 C1E808              <1> 	shr	eax, 8
   111 0000179A 01CA                <1> 	add	edx, ecx
   112 0000179C 81E2FFFFFF00        <1> 	and	edx, 00FFFFFFh
   113                              <1> _mfstore:
   114 000017A2 894514              <1> 	mov	dword ptr [ebp+B], eax
   115 000017A5 895510              <1> 	mov	dword ptr [ebp+A], edx
   116 000017A8 5A                  <1> 	pop	edx
   117 000017A9 C3                  <1> 	ret
   118                              <1> 
   119 000017AA BF04000000          <1> _d:	mov	edi, a
   120 000017AF E80A000000          <1> 	call	_divide
   121 000017B4 895D10              <1> 	mov	dword ptr [ebp+A], ebx
   122 000017B7 894518              <1> 	mov	dword ptr [ebp+MANTISSA2], eax
   123 000017BA 894D14              <1> 	mov	dword ptr [ebp+B], ecx
   124 000017BD C3                  <1> 	ret
   125                              <1> 
   126                              <1> 	%if	1
   127                              <1> 
   128                              <1> ;	this divide made from 2 Intel divides should be a better method
   129                              <1> ;	than the procession of 1-bit shifts and test subtracts
   130                              <1> ;	which is the %else which it replaces. That also works
   131                              <1> 
   132                              <1> ;	this converts to and from positive magnitude
   133                              <1> ;	because zoning the 2nd divide with a zero 1st remainder
   134                              <1> ;	can't tell +0 from -0 in platform 2s complement
   135                              <1> 
   136                              <1> ;	polarity conversions before and after need no explanation
   137                              <1> 
   138                              <1> ;	1st dividend is 48 zero bits and high order 16 data bits
   139                              <1> ;	of the the 48-bit RTA1 dividend
   140                              <1> 
   141                              <1> ;	2nd dividend is 1st remainder and the remaining 32 bits
   142                              <1> ;	the the RTA1 dividend
   143                              <1> 
   144                              <1> ;	input is compressed from 24-bit words and output unpacked
   145                              <1> ;	to 24-bit words
   146                              <1> 
   147                              <1> ;	64-bit dividend in 386 mode is high order bits in edx, low in eax
   148                              <1> ;	platform faults if quotient carries from eax. Remainder in edx
   149                              <1> 
   150                              <1> ;	RTA1 quotient is 48 bits so it takes 2 divides in 32-bit mode
   151                              <1> 
   152                              <1> _divide:
   153 000017BE 52                  <1> 	push	edx
   154 000017BF 57                  <1> 	push	edi
   155 000017C0 E88CEBFFFF          <1> 	call	_operand_read	; read divisor
   156 000017C5 5F                  <1> 	pop	edi
   157 000017C6 31C9                <1> 	xor	ecx, ecx	; final sign
   158 000017C8 A900008000          <1> 	test	eax, 00800000h
   159 000017CD 7408                <1> 	jz	_dsig?
   160 000017CF 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   161 000017D4 F7D1                <1> 	not	ecx		; reverse final sign
   162 000017D6 40                  <1> 	inc	eax
   163 000017D7 25FFFFFF00          <1> _dsig?:	and	eax, 00FFFFFFh	; check zerodiv here mebbes
   164 000017DC 89C3                <1> 	mov	ebx, eax	; eax will be used twice as divisor LS word
   165 000017DE 746D                <1> 	jz	_d_ont		; zero results in eax ebx already
   166                              <1> 
   167 000017E0 8B44BD04            <1> 	mov	eax, dword ptr [ebp+edi*4+4]
   168 000017E4 8B54BD00            <1> 	mov	edx, dword ptr [ebp+edi*4]
   169 000017E8 C1E008              <1> 	shl	eax, 8		; pack two 24-bit words to 64 bits 
   170 000017EB 88D0                <1> 	mov	al, dl
   171 000017ED C1C808              <1> 	ror	eax, 8
   172 000017F0 C1E208              <1> 	shl	edx, 8
   173 000017F3 C1EA10              <1> 	shr	edx, 16
   174 000017F6 6689D1              <1> 	mov	cx, dx		; save dividend sign
   175 000017F9 6621D2              <1> 	and	dx, dx		; bit 47 on?
   176 000017FC 7912                <1> 	jns	_dive_in
   177                              <1> 
   178 000017FE 81F10000FFFF        <1> 	xor	ecx, 0FFFF0000h	; reverse final sign
   179 00001804 F7D0                <1> 	not	eax
   180 00001806 66F7D2              <1> 	not	dx
   181 00001809 83C001              <1> 	add	eax, 1
   182 0000180C 6683D200            <1> 	adc	dx, 0
   183                              <1> 
   184                              <1> _dive_in:
   185 00001810 89C6                <1> 	mov	esi, eax	; reserve 2nd dividend
   186 00001812 89D0                <1> 	mov	eax, edx	; position 1st dividend
   187 00001814 31D2                <1> 	xor	edx, edx	; with leading zero
   188 00001816 F7F3                <1> 	div	ebx
   189 00001818 96                  <1> 	xchg	eax, esi	; save 1st quotient
   190 00001819 F7F3                <1> 	div	ebx		; generate 2nd quotient
   191                              <1> 
   192 0000181B 6621C9              <1> 	and	cx, cx		; dividend negative?
   193 0000181E 7903                <1> 	jns	_d_remainder_plus
   194 00001820 F7D2                <1> 	not	edx
   195 00001822 42                  <1> 	inc	edx
   196                              <1> 
   197                              <1> _d_remainder_plus:
   198 00001823 81E2FFFFFF00        <1> 	and	edx, 00FFFFFFh
   199 00001829 87D1                <1> 	xchg	edx, ecx	; remainder -> ecx / final sign -> edx
   200                              <1> 
   201 0000182B 89C3                <1> 	mov	ebx, eax	; low order quotient
   202 0000182D 89F0                <1> 	mov	eax, esi	; high order quotient
   203                              <1> 
   204 0000182F 21D2                <1> 	and	edx, edx	; final sign?
   205 00001831 790C                <1> 	jns	_d_quotient_plus
   206                              <1> 
   207 00001833 F7D3                <1> 	not	ebx		; invert + increment quotient
   208 00001835 66F7D0              <1> 	not	ax		; RTA1 integer is also 2s complement
   209 00001838 83C301              <1> 	add	ebx, 1
   210 0000183B 6683D000            <1> 	adc	ax, 0
   211                              <1> 
   212                              <1> _d_quotient_plus:
   213 0000183F 0FB7C0              <1> 	movzx	eax, ax		; unpack from 32-bit words to 24-bit words
   214 00001842 C1E008              <1> 	shl	eax, 8		; move 8 bits up
   215 00001845 C1C308              <1> 	rol	ebx, 8
   216 00001848 88D8                <1> 	mov	al, bl
   217 0000184A C1EB08              <1> 	shr	ebx, 8		; quotient in eax:ebx
   218                              <1> 
   219 0000184D 5A                  <1> _d_ont:	pop	edx		; give back the emulated program counter
   220 0000184E C3                  <1> 	ret
   221                              <1> 
   222                              <1> 	%else
   223                              <1> 
   224                              <1> _divide:
   225                              <1> 	xor	ebx, ebx
   226                              <1> 	push	ebx		;
   227                              <1> 	push	ebx		; quotient
   228                              <1> 	push	ebx		; dividend[b]
   229                              <1> 	push	ebx		; dividend[a]
   230                              <1> 	push	ebx		; trailing divisor
   231                              <1> 	push	ebx		; divisor
   232                              <1> 	push	ebx		; signs2 
   233                              <1> 	push	ebx		; signs1
   234                              <1> 	mov	ebx, 24
   235                              <1> 	push	ebx		; beats
   236                              <1> 
   237                              <1> 
   238                              <1> _D_BEATS	equ	0
   239                              <1> _D_SIGNS1	equ	1*4
   240                              <1> _D_SIGNS2	equ	2*4
   241                              <1> _D_DIVISORU	equ	3*4
   242                              <1> _D_DIVISORL	equ	4*4
   243                              <1> _D_DIVIDENDU	equ	5*4
   244                              <1> _D_DIVIDENDL	equ	6*4
   245                              <1> _D_QUOTIENTU	equ	7*4
   246                              <1> _D_QUOTIENTL	equ	8*4
   247                              <1> 
   248                              <1> 	push	edi
   249                              <1> 	call	_operand_read
   250                              <1> 	pop	edi
   251                              <1> 
   252                              <1> 	test	eax, 00800000h
   253                              <1> 	jnz	_d_nmagnitude1			; must be stored negative
   254                              <1> 	xor	eax, 00FFFFFFh
   255                              <1> 	jmp	_d_nmagnitude2
   256                              <1> _d_nmagnitude1:
   257                              <1> 	add	eax, -1				; if it's already negative
   258                              <1> 	mov	dword ptr [esp+_D_SIGNS2], 0FFFFFFFFh
   259                              <1> _d_nmagnitude2:
   260                              <1> 	call	qscale
   261                              <1> 	cmp	bl, 24
   262                              <1> 	jz	_d_allsigns
   263                              <1> 	add	dword ptr [esp+_D_BEATS], ebx
   264                              <1> _d_allsigns:
   265                              <1> 	mov	ebx, 00FFFFFF00h ; make the divisor 48 bits contiguous	
   266                              <1> 	mov	bl, al
   267                              <1> 	ror	ebx, 8
   268                              <1> 	shl	eax, 8
   269                              <1> 	mov	ax, 65535
   270                              <1> 	ror	eax, 16
   271                              <1> 
   272                              <1> 	mov	dword ptr [esp+_D_DIVISORL], ebx
   273                              <1> 	mov	dword ptr [esp+_D_DIVISORU], eax
   274                              <1> 
   275                              <1> 	mov	ecx, 1				; precarry
   276                              <1> 
   277                              <1> ;	mov	ebx, dword ptr [ebp+B]	; dividend
   278                              <1> ;	mov	eax, dword ptr [ebp+A]
   279                              <1> 
   280                              <1> 	mov	ebx, dword ptr [ebp+edi*4+4]
   281                              <1> 	mov	eax, dword ptr [ebp+edi*4] 
   282                              <1> 
   283                              <1> 	test	eax, 00800000h
   284                              <1> 	jz	_d_pmagnitude			; must be stored positive
   285                              <1> 	mov	dword ptr [esp+_D_SIGNS1], 00FFFFFFFFh
   286                              <1> 	xor	ebx, 00FFFFFFh
   287                              <1> 	xor	eax, 00FFFFFFh
   288                              <1> 	add	ecx, ebx
   289                              <1> 	mov	ebx, ecx
   290                              <1> 	and	ebx, 00FFFFFFh
   291                              <1> 	shr	ecx, 24
   292                              <1> 	add	eax, ecx
   293                              <1> 	and	eax, 00FFFFFFh
   294                              <1> 
   295                              <1> _d_pmagnitude:
   296                              <1> 	shl	ebx, 8
   297                              <1> 	mov	bl, al
   298                              <1> 	ror	ebx, 8
   299                              <1> 	shl	eax, 8
   300                              <1> 	shr	eax, 16
   301                              <1> 	mov	dword ptr [esp+_D_DIVIDENDL], ebx
   302                              <1> 	mov	dword ptr [esp+_D_DIVIDENDU], eax
   303                              <1> 
   304                              <1> 	mov	ecx, dword ptr [esp+_D_BEATS]
   305                              <1> 
   306                              <1> 	add	ecx, -1
   307                              <1> _d_beat:			; iterative part as quick as possible
   308                              <1> 				; could study doing a pair of Intel divides here
   309                              <1> 	stc
   310                              <1> 	rcr	dword ptr [esp+_D_DIVISORU], 1
   311                              <1> 	rcr	dword ptr [esp+_D_DIVISORL], 1
   312                              <1> 
   313                              <1> 	stc
   314                              <1> 	adc	ebx, dword ptr [esp+_D_DIVISORL]
   315                              <1> 	adc	eax, dword ptr [esp+_D_DIVISORU]
   316                              <1> 
   317                              <1> 	jc	_d_carried
   318                              <1> 	mov	ebx, dword ptr [esp+_D_DIVIDENDL]
   319                              <1> 	mov	eax, dword ptr [esp+_D_DIVIDENDU]
   320                              <1> 	jmp	_d_carried_or_not
   321                              <1> 
   322                              <1> _d_carried:
   323                              <1> 	mov	dword ptr [esp+_D_DIVIDENDL], ebx
   324                              <1> 	mov	dword ptr [esp+_D_DIVIDENDU], eax
   325                              <1> 
   326                              <1> _d_carried_or_not:
   327                              <1> 	rcl	dword ptr [esp+_D_QUOTIENTL], 1
   328                              <1> 	rcl	dword ptr [esp+_D_QUOTIENTU], 1
   329                              <1> 	
   330                              <1> 	add	ecx, -1
   331                              <1> 	jc	_d_beat
   332                              <1> 
   333                              <1> 	pop	ecx		; BEATS
   334                              <1> 	pop	ecx		; SIGNS1
   335                              <1> 	pop	eax		; SIGNS2
   336                              <1> 	pop	ebx		; DIVISORU
   337                              <1> 	pop	ebx		; DIVISORL
   338                              <1> 	pop	ebx		; DIVIDENDU
   339                              <1> 	pop	ebx		; DIVIDENDL
   340                              <1> 
   341                              <1> 	xor	ebx, ecx	; set remainder to sign of dividend
   342                              <1> 	jns	_d_remplus
   343                              <1> 	inc	ebx		; set -remainder 2s complement
   344                              <1> 
   345                              <1> _d_remplus:
   346                              <1> 	and	ebx, 00FFFFFFh	; store remainder
   347                              <1> ;	mov	dword ptr [ebp+B], ebx
   348                              <1> 
   349                              <1> 	xor	ecx, eax	; set sign of quotient to difference of signs
   350                              <1> 	mov	ecx, ebx	; remainder for return
   351                              <1> 	pop	eax		; QUOTIENTU
   352                              <1> 	pop	ebx		; QUOTIENTL
   353                              <1> 
   354                              <1> 	jns	_d_quotient_plus		; cc set from xor of signy
   355                              <1> 
   356                              <1> 	not	eax
   357                              <1> 	not	ebx
   358                              <1> 	add	ebx, 1
   359                              <1> 	adc	eax, 0
   360                              <1> 
   361                              <1> _d_quotient_plus:
   362                              <1> 	shl	eax, 8
   363                              <1> 	rol	ebx, 8
   364                              <1> 	mov	al, bl
   365                              <1> 	shr	ebx, 8
   366                              <1> 	shl	eax, 8
   367                              <1> 	shr	eax, 8
   368                              <1> 
   369                              <1> ;	mov	dword ptr [ebp+A], ebx
   370                              <1> ;	mov	dword ptr [ebp+MANTISSA2], eax
   371                              <1> 	ret
   372                              <1> 
   373                              <1> 	%endif
   374                              <1> 
   375                              <1> 
   376 0000184F 88C1                <1> _sar:	mov	cl, al			; eax shift radix is 31
   377 00001851 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
   378 00001854 F6C1E0              <1> 	test	cl, -32
   379 00001857 7402                <1> 	jz	_sardo
   380 00001859 31C0                <1> 	xor	eax, eax		; shift 32+ clears same as 24+
   381 0000185B D3E8                <1> _sardo:	shr	eax, cl
   382 0000185D 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   383 00001862 894510              <1> 	mov	dword ptr [ebp+A], eax
   384 00001865 C3                  <1> 	ret
   385                              <1> 
   386 00001866 88C1                <1> _sbr:	mov	cl, al
   387 00001868 8B4514              <1> 	mov	eax, dword ptr [ebp+B]
   388 0000186B F6C1E0              <1> 	test	cl, -32
   389 0000186E 7402                <1> 	jz	_sbrdo
   390 00001870 31C0                <1> 	xor	eax, eax		; shift 32+ clears same as 24+
   391 00001872 D3E8                <1> _sbrdo:	shr	eax, cl
   392 00001874 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   393 00001879 894514              <1> 	mov	dword ptr [ebp+B], eax
   394 0000187C C3                  <1> 	ret
   395                              <1> 
   396                              <1> 
   397 0000187D 88C1                <1> _dsr:	mov	cl, al
   398 0000187F 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]
   399 00001882 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
   400 00001885 E875000000          <1> 	call	dsr
   401 0000188A 895D14              <1> 	mov	dword ptr [ebp+B], ebx
   402 0000188D 894510              <1> 	mov	dword ptr [ebp+A], eax
   403 00001890 C3                  <1> 	ret
   404                              <1> 
   405 00001891 88C1                <1> _sal:	mov	cl, al			; shift radix eax is 31
   406 00001893 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
   407 00001896 F6C1E0              <1> 	test	cl, -32
   408 00001899 7402                <1> 	jz	_saldo
   409 0000189B 31C0                <1> 	xor	eax, eax		; shift 32+ clears same as 24+
   410 0000189D D3E0                <1> _saldo:	shl	eax, cl
   411 0000189F 25FFFFFF00          <1> 	and	eax, 00FFFFFFh		; write back to registers only 00000000 thru 00FFFFFF
   412 000018A4 894510              <1> 	mov	dword ptr [ebp+A], eax
   413 000018A7 C3                  <1> 	ret
   414                              <1> 
   415 000018A8 88C1                <1> _sbl:	mov	cl, al
   416 000018AA 8B4514              <1> 	mov	eax, dword ptr [ebp+B]
   417 000018AD F6C1E0              <1> 	test	cl,-32
   418 000018B0 7402                <1> 	jz	_sbldo
   419 000018B2 31C0                <1> 	xor	eax, eax		; shift 32+ clears same as 24+
   420 000018B4 D3E0                <1> _sbldo:	shl	eax, cl
   421 000018B6 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   422 000018BB 894514              <1> 	mov	dword ptr [ebp+B], eax
   423 000018BE C3                  <1> 	ret
   424                              <1> 
   425 000018BF 88C1                <1> _dsl	mov	cl, al
   426 000018C1 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]
   427 000018C4 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
   428 000018C7 E868000000          <1> 	call	dsl
   429 000018CC 895D14              <1> 	mov	dword ptr [ebp+B], ebx
   430 000018CF 894510              <1> 	mov	dword ptr [ebp+A], eax
   431 000018D2 C3                  <1> 	ret
   432                              <1> 
   433 000018D3 8B5D10              <1> _rar:	mov	ebx, dword ptr [ebp+A]
   434 000018D6 E8C6000000          <1> 	call	rr
   435 000018DB 895D10              <1> 	mov	dword ptr [ebp+A], ebx
   436 000018DE C3                  <1> 	ret
   437                              <1> 
   438 000018DF 8B5D14              <1> _rbr:	mov	ebx, dword ptr [ebp+B]
   439 000018E2 E8BA000000          <1> 	call	rr
   440 000018E7 895D14              <1> 	mov	dword ptr [ebp+B], ebx
   441 000018EA C3                  <1> 	ret
   442                              <1> 
   443 000018EB 88C1                <1> _drr:	mov	cl, al
   444 000018ED 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]
   445 000018F0 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
   446 000018F3 E8F7000000          <1> 	call	drr
   447 000018F8 895D14              <1> 	mov	dword ptr [ebp+B], ebx
   448 000018FB 894510              <1> 	mov	dword ptr [ebp+A], eax
   449 000018FE C3                  <1> 	ret
   450                              <1> 
   451                              <1> 
   452 000018FF C1E008              <1> dsr:	shl	eax, 8
   453 00001902 C1E308              <1> 	shl	ebx, 8
   454 00001905 80C1E8              <1> dsru:	add	cl, -24
   455 00001908 7306                <1> 	jnc	dsrl
   456 0000190A 89C3                <1> 	mov	ebx, eax
   457 0000190C 31C0                <1> 	xor	eax, eax
   458 0000190E EBF5                <1> 	jmp	dsru
   459 00001910 80C110              <1> dsrl:	add	cl, 16
   460 00001913 730D                <1> 	jnc	dsr7
   461 00001915 C1E808              <1> dsr8:	shr	eax, 8
   462 00001918 88C3                <1> 	mov	bl, al
   463 0000191A C1CB08              <1> 	ror	ebx, 8
   464 0000191D 80C1F8              <1> 	add	cl,-8
   465 00001920 72F3                <1> 	jc	dsr8
   466 00001922 80E107              <1> dsr7:	and	cl, 7
   467 00001925 D3E8                <1> 	shr	eax, cl
   468 00001927 88C3                <1> 	mov	bl, al		; bits from al in high-order positions bl
   469 00001929 D2C3                <1> 	rol	bl, cl		; roll them to low-order positions
   470 0000192B D3CB                <1> 	ror	ebx, cl
   471 0000192D C1EB08              <1> 	shr	ebx, 8
   472 00001930 C1E808              <1> 	shr	eax, 8
   473 00001933 C3                  <1> 	ret
   474                              <1> 
   475 00001934 C1E008              <1> dsl:	shl	eax, 8
   476 00001937 C1E308              <1> 	shl	ebx, 8
   477 0000193A 80C1E8              <1> dslu:	add	cl, -24
   478 0000193D 7306                <1> 	jnc	dsll
   479 0000193F 89D8                <1> 	mov	eax, ebx
   480 00001941 31DB                <1> 	xor	ebx, ebx
   481 00001943 EBF5                <1> 	jmp	dslu
   482 00001945 80C110              <1> dsll:	add	cl, 16
   483 00001948 730F                <1> 	jnc	dsl7
   484 0000194A C1C308              <1> dsl8:	rol	ebx, 8
   485 0000194D 88D8                <1> 	mov	al, bl
   486 0000194F 30DB                <1> 	xor	bl, bl
   487 00001951 C1E008              <1> 	shl	eax, 8
   488 00001954 80C1F8              <1> 	add	cl, -8
   489 00001957 72F1                <1> 	jc	dsl8
   490 00001959 80E107              <1> dsl7:	and	cl, 7
   491 0000195C D3C3                <1> 	rol	ebx, cl
   492 0000195E 88D8                <1> 	mov	al, bl		; bits from bl in low-order positions al
   493 00001960 D2C8                <1> 	ror	al, cl		; roll them to high-order positions
   494 00001962 D3E0                <1> 	shl	eax, cl
   495 00001964 C1EB08              <1> 	shr	ebx, 8
   496 00001967 C1E808              <1> 	shr	eax, 8
   497 0000196A C3                  <1> 	ret
   498                              <1> 
   499 0000196B C1E008              <1> dsa:	shl	eax, 8
   500 0000196E C1E308              <1> 	shl	ebx, 8
   501 00001971 80C1E8              <1> dsa24:	add	cl, -24
   502 00001974 7307                <1> 	jnc	dsa16
   503 00001976 89C3                <1> 	mov	ebx, eax
   504 00001978 C1F818              <1> 	sar	eax, 24
   505 0000197B EBF4                <1> 	jmp	dsa24
   506 0000197D 80C110              <1> dsa16:	add	cl, 16
   507 00001980 730D                <1> 	jnc	dsa7
   508 00001982 C1F808              <1> dsa8:	sar	eax, 8
   509 00001985 88C3                <1> 	mov	bl, al
   510 00001987 C1CB08              <1> 	ror	ebx, 8
   511 0000198A 80C1F8              <1> 	add	cl, -8
   512 0000198D 72F3                <1> 	jc	dsa8
   513 0000198F 80E107              <1> dsa7:	and	cl, 7
   514 00001992 D3F8                <1> 	sar	eax, cl
   515 00001994 88C3                <1> 	mov	bl, al		; bits from al in high-order positions bl
   516 00001996 D2C3                <1> 	rol	bl, cl		; roll them to low-order positions
   517 00001998 D3CB                <1> 	ror	ebx, cl
   518 0000199A C1E808              <1> 	shr	eax, 8
   519 0000199D C1EB08              <1> 	shr	ebx, 8
   520 000019A0 C3                  <1> 	ret	
   521                              <1> 
   522                              <1> 
   523 000019A1 88C1                <1> rr:	mov	cl, al
   524 000019A3 C1E308              <1> 	shl	ebx, 8
   525 000019A6 F6C118              <1> 	test	cl, 24		; bits 16:8 are self-cancelling
   526 000019A9 7A11                <1> 	jpe	rr7
   527 000019AB F6C110              <1> 	test	cl, 16
   528 000019AE 7407                <1> 	jz	rr8		; 16 is off so 8 is on
   529 000019B0 C1C308              <1> 	rol	ebx, 8		; 8 left in 24-bit ring = 16 right
   530 000019B3 88DF                <1> 	mov	bh, bl		; compress 32-bit ring to 24-bit
   531 000019B5 EB05                <1> 	jmp	short rr7
   532 000019B7 88FB                <1> rr8:	mov	bl, bh		; extend 24-bit ring to 32-bit
   533 000019B9 C1CB08              <1> 	ror	ebx, 8
   534 000019BC 80E107              <1> rr7:	and	cl, 7		; isolate remaining count bits
   535 000019BF 88FB                <1> 	mov	bl, bh		; don't ask, just do it
   536 000019C1 D3CB                <1> 	ror	ebx, cl
   537 000019C3 C1EB08              <1> 	shr	ebx, 8
   538 000019C6 C3                  <1> 	ret
   539                              <1> 
   540 000019C7 88C1                <1> rl:	mov	cl, al
   541 000019C9 C1E308              <1> 	shl	ebx, 8
   542 000019CC F6C118              <1> 	test	cl, 24		; bits 16:8 are self-cancelling
   543 000019CF 7A11                <1> 	jpe	rl7
   544 000019D1 F6C110              <1> 	test	cl, 16
   545 000019D4 7407                <1> 	jz	rl8		; 16 is off so 8 is on
   546 000019D6 88FB                <1> 	mov	bl, bh		; extend 24-bit ring to 32-bit
   547 000019D8 C1CB08              <1> 	ror	ebx, 8		; 8 right in 24-bit ring = 16 left
   548 000019DB EB05                <1> 	jmp	short rl7
   549 000019DD C1C308              <1> rl8:	rol	ebx, 8
   550 000019E0 88DF                <1> 	mov	bh, bl		; compress 32-bit ring to 24-bit	
   551 000019E2 80E107              <1> rl7:	and	cl, 7
   552 000019E5 30DB                <1> 	xor	bl, bl
   553 000019E7 D3C3                <1> 	rol	ebx, cl
   554 000019E9 08DF                <1> 	or	bh, bl
   555 000019EB C1EB08              <1> 	shr	ebx, 8
   556 000019EE C3                  <1> 	ret
   557                              <1> 
   558 000019EF C1E008              <1> drr:	shl	eax, 8
   559 000019F2 C1E308              <1> 	shl	ebx, 8
   560                              <1> 
   561 000019F5 F6C130              <1> 	test	cl, 48		; bits 32:16 are self-cancelling
   562 000019F8 7B07                <1> 	jpo	drr24		; rotate 48 = zero or 56 = 8 positions
   563 000019FA F6C108              <1> 	test	cl, 8		; parity = pe dans le pays d'Intel
   564 000019FD 741C                <1> 	jz	drr7
   565 000019FF EB15                <1> 	jmp	drr_cdrr8
   566                              <1> 
   567 00001A01 93                  <1> drr24:	xchg	eax, ebx	; rotate 24 right or left as you wish
   568 00001A02 F6C118              <1> 	test	cl, 24
   569 00001A05 7A0D                <1> 	jpe	drr24_32	; pattern is 100xxx or 011xxx
   570 00001A07 F6C108              <1> 	test	cl, 8		; pattern is 010xxx or 101xxx
   571 00001A0A 7401                <1> 	jz	drrl8		; pattern is 010
   572 00001A0C 93                  <1> 	xchg	eax, ebx	; swap back, pattern 101 = 40 right = 8 left 
   573 00001A0D E828000000          <1> drrl8:	call	near drl8	; pattern is 010
   574 00001A12 EB07                <1> 	jmp	short drr7 	; already rotated 24 right, now 8 left
   575                              <1> 
   576                              <1> drr24_32:
   577 00001A14 7505                <1> 	jnz	drr7		; pattern is 011 = rotate 24. We did
   578                              <1> drr_cdrr8:
   579 00001A16 E814000000          <1> 	call	near drr8	; pattern is 100 = rotate 32
   580 00001A1B 80E107              <1> drr7:	and	cl, 7
   581 00001A1E 7408                <1> 	jz	drrx
   582 00001A20 88E3                <1> 	mov	bl, ah		; rotate low bits ebx 31:8 to eax high positions
   583 00001A22 88F8                <1> 	mov	al, bh		; rotate low bits eax 31:8 to ebx high positions
   584 00001A24 D3C8                <1> 	ror	eax, cl		; bits from bh in low order positions al
   585 00001A26 D3CB                <1> 	ror	ebx, cl		; bits from ah in low order positions bl
   586 00001A28 C1E808              <1> drrx:	shr	eax, 8
   587 00001A2B C1EB08              <1> 	shr	ebx, 8
   588 00001A2E C3                  <1> 	ret
   589                              <1> 
   590 00001A2F 88E3                <1> drr8:   mov     bl, ah          ; cross 8 bits from one 32-bit ring to another
   591 00001A31 88F8                <1>         mov     al, bh		
   592 00001A33 C1C808              <1>         ror     eax, 8
   593 00001A36 C1CB08              <1>         ror     ebx, 8
   594 00001A39 C3                  <1>         ret
   595                              <1> 
   596 00001A3A C1C008              <1> drl8:   rol     eax, 8
   597 00001A3D C1C308              <1>         rol     ebx, 8
   598 00001A40 88DC                <1>         mov     ah, bl          ; cross 8 bits from one 32-bit ring to another
   599 00001A42 88C7                <1>         mov     bh, al
   600 00001A44 C3                  <1>         ret
   601                              <1> 
   602 00001A45 C1E008              <1> drl:	shl	eax, 8
   603 00001A48 C1E308              <1> 	shl	ebx, 8
   604 00001A4B F6C130              <1> 	test	cl, 48		; values 32:16 cancel each other
   605 00001A4E 7B07                <1> 	jpo	drl24
   606 00001A50 F6C108              <1> 	test	cl, 8
   607 00001A53 741C                <1> 	jz	drl7
   608 00001A55 EB15                <1> 	jmp	short drl_cdrl8
   609                              <1> 
   610 00001A57 93                  <1> drl24:	xchg	eax, ebx
   611 00001A58 F6C118              <1> 	test	cl, 24
   612 00001A5B 7A0D                <1> 	jpe	drl24_32	; pattern is 011xxx or 100xxx
   613 00001A5D F6C108              <1> 	test	cl, 8		; pattern is 010xxx or 101xxx
   614 00001A60 7401                <1> 	jz	drlr8		; pattern is 010 = 16 left = 8 right
   615 00001A62 93                  <1> 	xchg	eax, ebx	; swap back, pattern = 101 = 40 left = 8 right
   616 00001A63 E8C7FFFFFF          <1> drlr8:	call	drr8
   617 00001A68 EB07                <1> 	jmp	short drl7
   618                              <1> 
   619                              <1> drl24_32:
   620 00001A6A 7505                <1> 	jnz	drl7		; pattern is 011 = rotate24. We did
   621                              <1> drl_cdrl8:			; pattern = 100xxx or 001xxx, rotate 8 more
   622 00001A6C E8C9FFFFFF          <1> 	call	drl8
   623 00001A71 80E107              <1> drl7:	and	cl, 7		; rotate positions 0..7
   624 00001A74 30C0                <1> 	xor	al, al
   625 00001A76 30DB                <1> 	xor	bl, bl
   626 00001A78 D3C0                <1> 	rol	eax, cl
   627 00001A7A D3C3                <1> 	rol	ebx, cl
   628 00001A7C 08DC                <1> 	or	ah, bl
   629 00001A7E 08C7                <1> 	or	bh, al
   630 00001A80 C1E808              <1> 	shr	eax, 8
   631 00001A83 C1EB08              <1> 	shr	ebx, 8
   632 00001A86 C3                  <1> 	ret
   633                              <1> 
   634 00001A87 8B5D10              <1> _ral:	mov	ebx, dword ptr [ebp+A]
   635 00001A8A E838FFFFFF          <1> 	call	rl
   636 00001A8F 895D10              <1> 	mov	dword ptr [ebp+A], ebx
   637 00001A92 C3                  <1> 	ret
   638                              <1> 
   639 00001A93 8B5D14              <1> _rbl:	mov	ebx, dword ptr [ebp+B]
   640 00001A96 E82CFFFFFF          <1> 	call	rl
   641 00001A9B 895D14              <1> 	mov	dword ptr [ebp+B], ebx
   642 00001A9E C3                  <1> 	ret	
   643                              <1> 
   644 00001A9F 88C1                <1> _drl:	mov	cl, al
   645 00001AA1 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
   646 00001AA4 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]
   647 00001AA7 E899FFFFFF          <1> 	call	drl
   648 00001AAC 895D14              <1> 	mov	dword ptr [ebp+B], ebx
   649 00001AAF 894510              <1> 	mov	dword ptr [ebp+A], eax
   650 00001AB2 C3                  <1> 	ret
   651                              <1> 
   652 00001AB3 88C1                <1> _saa:	mov	cl, al
   653 00001AB5 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
   654 00001AB8 C1E008              <1> 	shl	eax, 8
   655 00001ABB D3F8                <1> 	sar	eax, cl
   656 00001ABD C1E808              <1> 	shr	eax, 8
   657 00001AC0 894510              <1> 	mov	dword ptr [ebp+A], eax
   658 00001AC3 C3                  <1> 	ret
   659                              <1> 
   660 00001AC4 88C1                <1> _sba:	mov	cl, al
   661 00001AC6 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]
   662 00001AC9 C1E308              <1> 	shl	ebx, 8
   663 00001ACC D3FB                <1> 	sar	ebx, cl
   664 00001ACE C1EB08              <1> 	shr	ebx, 8
   665 00001AD1 895D14              <1> 	mov	dword ptr [ebp+B], ebx
   666 00001AD4 C3                  <1> 	ret
   667                              <1> 
   668 00001AD5 88C1                <1> _dsa:	mov	cl, al
   669 00001AD7 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]
   670 00001ADA 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
   671 00001ADD E889FEFFFF          <1> 	call	dsa
   672 00001AE2 895D14              <1> 	mov	dword ptr [ebp+B], ebx
   673 00001AE5 894510              <1> 	mov	dword ptr [ebp+A], eax
   674 00001AE8 C3                  <1> 	ret
   675                              <1> 
   676 00001AE9 E878EBFFFF          <1> _n:	call	memoreg
   677 00001AEE 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   678 00001AF3 E94EEBFFFF          <1> 	jmp	memoreg_writeback
   679                              <1> 
   680 00001AF8 E869EBFFFF          <1> _inc:	call	memoreg
   681 00001AFD 40                  <1> 	inc	eax
   682 00001AFE E943EBFFFF          <1> 	jmp	memoreg_writeback
   683                              <1> 
   684 00001B03 E85EEBFFFF          <1> _dec:	call	memoreg
   685 00001B08 48                  <1> 	dec	eax
   686 00001B09 E938EBFFFF          <1> 	jmp	memoreg_writeback
   687                              <1> 
   688 00001B0E E853EBFFFF          <1> _src:	call	memoreg
   689 00001B13 C1E008              <1> 	shl	eax, 8
   690 00001B16 8A86A0040000        <1> 	mov	al, byte ptr [esi+PSR]
   691 00001B1C D1C8                <1> 	ror	eax, 1
   692 00001B1E D0C0                <1> 	rol	al, 1
   693 00001B20 8886A0040000        <1> 	mov	byte ptr [esi+PSR], al
   694 00001B26 C1E808              <1> 	shr	eax, 8
   695 00001B29 E918EBFFFF          <1> 	jmp	memoreg_writeback
   696                              <1> 
   697 00001B2E E833EBFFFF          <1> _slc:	call	memoreg
   698 00001B33 C1E008              <1> 	shl	eax, 8
   699 00001B36 8A86A0040000        <1> 	mov	al, byte ptr [esi+PSR]
   700 00001B3C D0C8                <1> 	ror	al, 1
   701 00001B3E D1C0                <1> 	rol	eax, 1
   702 00001B40 8886A0040000        <1> 	mov	byte ptr [esi+PSR], al
   703 00001B46 C1E808              <1> 	shr	eax, 8
   704 00001B49 E9F8EAFFFF          <1> 	jmp	memoreg_writeback
   705                              <1> 
   706                              <1> 	%if	0
   707                              <1> _popA:	call	stack_read1				; ebx <- stack pointer
   708                              <1> 	mov	ebx, dword ptr [esi+ebx*4+REGISTER]	; stack word
   709                              <1> 
   710                              <1> 	mov	ecx, esi				; keep core.REGISTER *
   711                              <1> 	push	ebx
   712                              <1> 	call	memoreg					; reply is memory edi + esi ->
   713                              <1> 							;     or register esi + ebx ->
   714                              <1> 	add	eax, dword ptr [esp]
   715                              <1> 	add	esp, 4
   716                              <1> 
   717                              <1> 	rol	eax, 8					; carry -> LS bit
   718                              <1> 	and	al, 1
   719                              <1> 
   720                              <1> 	and	byte ptr [ecx+PSR], 254
   721                              <1> 	or	byte ptr [ecx+PSR], al
   722                              <1> 	shr	eax, 8					; resulting value without carry
   723                              <1> 	jmp	memoreg_writeback			; eax -> target
   724                              <1> 							; [ edi ] + esi -> memory / register
   725                              <1> 	%else
   726                              <1> 
   727 00001B4E E813EBFFFF          <1> _popA:	call	memoreg					; eax <- addend for update
   728 00001B53 53                  <1> 	push	ebx					; ebx -> writeback register
   729 00001B54 56                  <1> 	push	esi					; or [ edi esi ] -> writeback memory word
   730                              <1> 
   731 00001B55 0F7EFE              <1> 	movd	esi, mm7
   732                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]	; get back the smp core for PSR and...
   733                              <1> 							; total register array and...
   734                              <1> 							; whichever of [ 2 * RTA1 sp ] is in ebx *
   735                              <1> 							; that is simple position in register list
   736                              <1> 							; not application / ISR relative as in ebp
   737                              <1> 							; although each (RTA1 sp) MOSTLY operates
   738                              <1> 							; its own portions of the register array
   739                              <1> 							; CORE_INDEX is in both scopes of ebp :-)
   740                              <1> 
   741 00001B58 E834F6FFFF          <1> 	call	stack_read1				; ebx -> old (RTA1 internal stack) sp
   742 00001B5D 03049E              <1> 	add	eax, dword ptr [esi+ebx*4+REGISTER]	; add word from internal stack
   743                              <1> 
   744 00001B60 C1C008              <1> 	rol	eax, 8					; isolate carry out of bit 23
   745 00001B63 2401                <1> 	and	al, 1
   746 00001B65 8B9EA0040000        <1> 	mov	ebx, dword ptr [esi+PSR]		; platform memory read then write MIGHT
   747 00001B6B 80E3FE              <1> 	and	bl, 254					; be better than 2 * read : write cycle
   748 00001B6E 08C3                <1> 	or	bl, al
   749 00001B70 899EA0040000        <1> 	mov	dword ptr [esi+PSR], ebx		; write PSR back
   750                              <1> 
   751 00001B76 C1E808              <1> 	shr	eax, 8					; reposition and clean result
   752                              <1> 
   753 00001B79 5E                  <1> 	pop	esi					; retrieve possible storage offset
   754 00001B7A 5B                  <1> 	pop	ebx					; retrieve possible register writeback
   755 00001B7B E9C6EAFFFF          <1> 	jmp	memoreg_writeback
   756                              <1> 
   757                              <1> 	%endif
   758                              <1> 	
   759 00001B80 E88AE7FFFF          <1> _da:	call	_burst_read2
   760 00001B85 EB11                <1> 	jmp	_da_
   761                              <1> 
   762 00001B87 E883E7FFFF          <1> _dan:	call	_burst_read2
   763 00001B8C 81F3FFFFFF00        <1> 	xor	ebx, 00FFFFFFh
   764 00001B92 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   765 00001B97 43                  <1> 	inc	ebx			; carry from bit 23 
   766                              <1> 					; remains in bit 24 for now
   767                              <1> 
   768 00001B98 035D14              <1> _da_:	add	ebx, [ebp+B]
   769 00001B9B C1E308              <1> 	shl	ebx, 8
   770 00001B9E 83D000              <1> 	adc	eax, 0
   771 00001BA1 C1EB08              <1> 	shr	ebx, 8
   772 00001BA4 895D14              <1> 	mov	[ebp+B], ebx
   773 00001BA7 034510              <1> 	add	eax, [ebp+A]
   774 00001BAA E804000000          <1> 	call	_alu_carry
   775 00001BAF 894510              <1> 	mov	[ebp+A], eax
   776 00001BB2 C3                  <1> 	ret
   777                              <1> 
   778                              <1> _alu_carry:
   779                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
   780 00001BB3 0F7EFE              <1> 	movd	esi, mm7
   781                              <1> 
   782 00001BB6 C1C008              <1> 	rol	eax, 8
   783 00001BB9 2401                <1> 	and	al, 1
   784 00001BBB 80A6A0040000FE      <1> 	and	byte ptr [esi+PSR], 254
   785 00001BC2 0886A0040000        <1> 	or	byte ptr [esi+PSR], al
   786 00001BC8 C1E808              <1> 	shr	eax, 8
   787 00001BCB C3                  <1> 	ret
   788                              <1> 
   789 00001BCC 040302020101010100- <1> scalex	db	4,3,2,2, 1,1,1,1, 0,0,0,0, 0,0,0,0
   789 00001BD5 00000000000000      <1>
   790                              <1> 
   791                              <1> field_scale:			; examine 24-bit integer in 8-position steps
   792 00001BDC C1C008              <1> 	rol	eax, 8		; until high-order 8 bits are not all signs
   793 00001BDF 88C4                <1> 	mov	ah, al
   794 00001BE1 30E8                <1> 	xor	al, ch
   795 00001BE3 7509                <1> 	jnz	not8signs
   796 00001BE5 80C108              <1> 	add	cl, 8
   797 00001BE8 80F918              <1> 	cmp	cl, 24
   798 00001BEB 72EF                <1> 	jb	field_scale
   799 00001BED C3                  <1> 	ret			; 24 signs = the RTA1 computer word
   800                              <1> not8signs:			; al = 0 indicates it
   801 00001BEE A8F0                <1> 	test	al, 240		; move back some positions but keep counting up
   802 00001BF0 7506                <1> 	jnz	scale_u
   803 00001BF2 80C104              <1> 	add	cl, 4
   804 00001BF5 C0C004              <1> 	rol	al, 4
   805                              <1> scale_u:
   806 00001BF8 C0E804              <1> 	shr	al, 4
   807 00001BFB 0FB6F0              <1> 	movzx	esi, al		; add to count-up 1..7
   808 00001BFE 2E028E[CC1B0000]    <1> 	add	cl, [cs:esi+scalex]
   809 00001C05 6651                <1> 	push	cx		; roll back 7..1 positions
   810 00001C07 80E107              <1> 	and	cl, 7
   811 00001C0A 80F107              <1> 	xor	cl, 7
   812 00001C0D 80C101              <1> 	add	cl, 1
   813 00001C10 88E0                <1> 	mov	al, ah
   814 00001C12 D3C8                <1> 	ror	eax, cl
   815 00001C14 6659                <1> 	pop	cx
   816 00001C16 C3                  <1> 	ret
   817                              <1> 
   818 00001C17 C1E008              <1> qscale:	shl	eax, 8		; 1.2.3
   819 00001C1A C1F808              <1> 	sar	eax, 8		; s.1.2.3
   820 00001C1D C1C008              <1> 	rol	eax, 8		; 1.2.3.s
   821 00001C20 6631C9              <1> 	xor	cx, cx
   822 00001C23 88C5                <1> 	mov	ch, al		; keep 8 sign bits
   823 00001C25 E8B2FFFFFF          <1> 	call	field_scale
   824                              <1> 
   825 00001C2A 0FB6D9              <1> 	movzx	ebx, cl
   826                              <1> 
   827 00001C2D C1E808              <1> 	shr	eax, 8
   828 00001C30 C3                  <1> 	ret
   829                              <1> 
   830 00001C31 E81BE7FFFF          <1> _lsc:	call	_operand_read
   831 00001C36 E8DCFFFFFF          <1> 	call	qscale
   832 00001C3B 895D14              <1> 	mov	dword ptr [ebp+B], ebx	; store the scale
   833 00001C3E 894510              <1> 	mov	dword ptr [ebp+A], eax	; store the rotated value
   834 00001C41 C3                  <1> 	ret
   835                              <1> 
   836 00001C42 E8C8E6FFFF          <1> _dlsc:	call	_burst_read2
   837 00001C47 894510              <1> 	mov	dword ptr [ebp+A], eax		; keep original 1st word
   838 00001C4A C1E008              <1> 	shl	eax, 8
   839 00001C4D C1F808              <1> 	sar	eax, 8
   840 00001C50 C1C008              <1> 	rol	eax, 8
   841 00001C53 6631C9              <1> 	xor	cx, cx
   842 00001C56 88C5                <1> 	mov	ch, al				; keep 8 sign bits
   843 00001C58 E87FFFFFFF          <1> 	call	field_scale
   844 00001C5D 20C0                <1> 	and	al, al
   845 00001C5F 7415                <1> 	jz	_dlsc24				; if the first word is all signs
   846                              <1> 
   847 00001C61 0FB6C1              <1> 	movzx	eax, cl
   848 00001C64 894518              <1> 	mov	dword ptr [ebp+MANTISSA2], eax	; store the scale
   849 00001C67 8B4510              <1> 	mov	eax, dword ptr [ebp+A]		; retrieve the input high order word
   850 00001C6A E8D6FDFFFF          <1> 	call	drl				; scale the two input words per cl
   851 00001C6F 895D14              <1> 	mov	dword ptr [ebp+B], ebx
   852 00001C72 894510              <1> 	mov	dword ptr [ebp+A], eax  	; store the rotated value
   853 00001C75 C3                  <1> 	ret
   854                              <1> 
   855                              <1> _dlsc24:				; different when high order word is all signs
   856 00001C76 C1E808              <1> 	shr	eax, 8			; one result word of signs
   857 00001C79 894514              <1> 	mov	dword ptr [ebp+B], eax	; into the low-order result word
   858 00001C7C 89D8                <1> 	mov	eax, ebx		; scale the low-order input
   859 00001C7E C1E008              <1> 	shl	eax, 8
   860 00001C81 30C9                <1> 	xor	cl, cl			; restart the scale count-up
   861 00001C83 E854FFFFFF          <1> 	call	field_scale
   862 00001C88 80C118              <1> 	add	cl, 24			; restore the early part of the count-up
   863                              <1> 
   864 00001C8B 0FB6D9              <1> 	movzx	ebx, cl
   865 00001C8E 895D18              <1> 	mov	dword ptr [ebp+MANTISSA2], ebx	; store the scale
   866                              <1> 
   867 00001C91 C1E808              <1> 	shr	eax, 8
   868 00001C94 894510              <1> 	mov	dword ptr [ebp+A], eax	; store the rotated value
   869 00001C97 C3                  <1> 	ret
   870                              <1> 
   871                              <1> 	%if	0
   872                              <1> 
   873                              <1> _fpx:	call	_burst_read2		; data read in eax ebx
   874                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
   875                              <1> 	movd	esi, mm7
   876                              <1> 
   877                              <1> 	push	ebx			; ebx is used in RTA1 stack frame
   878                              <1> 	call	stack4			; construct RTA1 stack frame
   879                              <1> 
   880                              <1> 	shl	eax, 4			; move 12 mantissa bits out of eax
   881                              <1> 	movsx	ecx, ax			; and extend the normalising bit
   882                              <1> 
   883                              <1> 	rol	eax, 4+1		; shelter sign in eax bit 0
   884                              <1> 	shl	ax, 12			; better still in eax bit 12
   885                              <1> 	sar	eax, 12			; propagate the value at midpoint position
   886                              <1> 	ror	eax, 1			; have the sign back
   887                              <1> 	shr	eax, 8			; clear eax 31..24
   888                              <1> 	xor	eax, 003ffc00h		; reverse the 12 copies of midpoint bit
   889                              <1> 					; yon's ra complicated bit done
   890                              <1> 	mov	dword ptr [ebp+ebx*4], eax
   891                              <1> 
   892                              <1> 	xor	eax, ecx		; is the normalising bit opposite to signs ?
   893                              <1> 	test	eax, 00800000h
   894                              <1> 	jz	_fpx_allsigns		; no so unnormalised = zero
   895                              <1> 
   896                              <1> 	pop	eax			; the 2nd operand word, ya remember?
   897                              <1> 	shl	eax, 4			; get them 2 halves over the centre
   898                              <1> 
   899                              <1> 	shr	cx, 4			; zero quartets at high order of 16 bits
   900                              <1> 	shr	ax, 4
   901                              <1> 
   902                              <1> 	xchg	ax, cx			; low-order mantissa bits with unsigns in ecx
   903                              <1> 					; high-order mantissa bits with middle part in eax
   904                              <1> 
   905                              <1> 	shl	eax, 4			; LLLz | HHHz
   906                              <1> 	shr	ax, 4			; LLLz | zHHH
   907                              <1> 	rol	eax, 12			; zzHH | HLLL
   908                              <1> 
   909                              <1> 	mov	dword ptr [ebp+ebx*4+1*4], eax
   910                              <1> 	rol	ecx, 12
   911                              <1> 	xor	ecx, 0FFFh		; 12 normalising bits = 12 inverted signs
   912                              <1> 	mov	dword ptr [ebp+ebx*4+2*4], ecx
   913                              <1> 	not	ecx			; convert high order quartet to signs
   914                              <1> 	sar	ecx, 20			; 24 of them
   915                              <1> 	shr	ecx, 8
   916                              <1> 	mov	dword ptr [ebp+ebx*4+3*4], ecx
   917                              <1> ;	mov	ebp, dword ptr [esi+REGISTER_SET]
   918                              <1> 	mov	dword ptr [ebp+S_P], ebx	; update whichever sp that is
   919                              <1> 	ret
   920                              <1> 
   921                              <1> _fpx_allsigns:
   922                              <1> 	add	esp, 4			; take saved operand word back from stack
   923                              <1> 	sar	ecx, 8			; 16 unnormalised normalising bits
   924                              <1> 	shr	ecx, 8			; = 24 sign bits
   925                              <1> 
   926                              <1> 	mov	dword ptr [ebp+ebx*4], ecx
   927                              <1> 	mov	dword ptr [ebp+ebx*4+1*4], ecx
   928                              <1> 	mov	dword ptr [ebp+ebx*4+2*4], ecx
   929                              <1> 	mov	dword ptr [ebp+ebx*4+3*4], ecx
   930                              <1> 
   931                              <1> ;	mov	ebp, dword ptr [_register_set]
   932                              <1> 	mov	dword ptr [ebp+S_P], ebx	; update whichever sp that is
   933                              <1> 	ret
   934                              <1> 
   935                              <1> _fpp:	call	stack_read4
   936                              <1> 	push	eax				; thats EA
   937                              <1> 
   938                              <1> 	mov	eax, dword ptr [ebp+ebx*4]	; s + 23 exponent bits
   939                              <1> 	rol	eax, 8+2			; save sign and midpoint
   940                              <1> 	shl	eax, 12				; squeeze out 12 exponent bits
   941                              <1> 	shr	ax, 12				; bring sign + midpoint back
   942                              <1> 	ror	eax, 2				; and roll them back in
   943                              <1> 	shr	eax, 4				; position 12 bits low in 16 bits
   944                              <1> 	mov	ecx, dword ptr [ebp+ebx*4+1*4]	; take 1st mantissa word from the stack
   945                              <1> 	ror	ecx, 12				; rotate 12 bits down
   946                              <1> 	shl	cx, 4				; position 12 bits high in 16 bits
   947                              <1> 	mov	ax, cx				; merge
   948                              <1> 	shr	eax, 4				; position 24 bits low in 32 bits
   949                              <1> 	mov	dword ptr [ebp+ebx*4], eax	; place back in RTA1 stack frame
   950                              <1> 						; next 12 mantissa bits in ecx 31..20
   951                              <1> 
   952                              <1> 	mov	eax, dword ptr [ebp+ebx*4+2*4]	; read 24 more
   953                              <1> 	shr	eax, 12-4			; position 12 bits at ax 15..4
   954                              <1> 	shr	ecx, 4				;				
   955                              <1> 	mov	cx, ax				; juxtapose with mantissa 23..12
   956                              <1> 	shr	ecx, 4				; wirraff
   957                              <1> 
   958                              <1> 	mov	dword ptr [ebp+ebx*4+1*4], ecx	; making 2nd and final output word
   959                              <1> 
   960                              <1> 	pop	eax				; recover EA
   961                              <1> 	jmp	_burst_write2
   962                              <1> 
   963                              <1> 	%endif
    41                                  	%include	"fpu.msm"
     1                              <1> compress4to8:			; readout floating operand
     2                              <1> 				; and pack to 32-bit words
     3                              <1> 				; for 1 bit-distance shifting
     4                              <1> 				; acquired operand is in 1st half of 
     5                              <1> 				; 8-register block [edi]
     6                              <1> 
     7 00001C98 8B07                <1> 	mov	eax, dword ptr [edi]	; 1s-complement scale field
     8 00001C9A C1E008              <1> 	shl	eax, 8			; 1st data bit reveals sign
     9 00001C9D C1F808              <1> 	sar	eax, 8			; propagate that sign some
    10 00001CA0 89C3                <1> 	mov	ebx, eax
    11 00001CA2 C1F818              <1> 	sar	eax, 24			; propagate signs to 32 bits
    12 00001CA5 31C3                <1> 	xor	ebx, eax		; change scale to unsigned magnitude
    13 00001CA7 891F                <1> 	mov	dword ptr [edi], ebx	; position scale magnitude in 1st register
    14 00001CA9 89471C              <1> 	mov	dword ptr [edi+7*4], eax	; 96 trailing signs
    15 00001CAC 894718              <1> 	mov	dword ptr [edi+6*4], eax
    16 00001CAF 894714              <1> 	mov	dword ptr [edi+5*4], eax
    17 00001CB2 8B5F0C              <1> 	mov	ebx, dword ptr [edi+3*4]	; read low-order mantissa word
    18 00001CB5 88D8                <1> 	mov	al, bl				; low-order octet
    19 00001CB7 C1C808              <1> 	ror	eax, 8				; is followed by 24 signs
    20 00001CBA 894710              <1> 	mov	dword ptr [edi+4*4], eax	; ebx also contains mantissa 23..8
    21                              <1> 						; in positions 23..8
    22                              <1> 
    23 00001CBD 8B4708              <1> 	mov	eax, dword ptr [edi+2*4]	; eax now contains mantissa 47..24
    24 00001CC0 C1E308              <1> 	shl	ebx, 8
    25 00001CC3 6689C3              <1> 	mov	bx, ax				; mantissa 39..24 -> ebx
    26 00001CC6 C1C310              <1> 	rol	ebx, 16				; ebx now contains mantissa 40..8
    27 00001CC9 895F0C              <1> 	mov	dword ptr [edi+3*4], ebx
    28 00001CCC 8B5F04              <1> 	mov	ebx, dword ptr [edi+1*4]	; mantissa 71..48
    29 00001CCF C1E308              <1> 	shl	ebx, 8
    30 00001CD2 C1E810              <1> 	shr	eax, 16				; mantissa 47..40
    31 00001CD5 88C3                <1> 	mov	bl, al
    32 00001CD7 895F08              <1> 	mov	dword ptr [edi+2*4], ebx	; mantissa 71..40
    33 00001CDA 8B4714              <1> 	mov	eax, dword ptr [edi+5*4]	; copy 32 signs
    34 00001CDD 894704              <1> 	mov	dword ptr [edi+1*4], eax	; to 2nd word of register block
    35 00001CE0 C3                  <1> 	ret
    36                              <1> 
    37                              <1> 
    38                              <1> ;	___________________________________
    39                              <1> ;	| magnitude scale|     32 signs   |
    40                              <1> ;	|________________|________________|
    41                              <1> ;	| platform word 7| platform word 6|
    42                              <1> 
    43                              <1> 
    44                              <1> ;	<------------ 168-bit mantissa 167..72-------------|
    45                              <1> ;	<------------  72-bit mantissa ------>
    46                              <1> ;	_____________|___________|____________|____________________________
    47                              <1> ;	|      24    | 8 |   16  |   16   | 8 |    24 signs|96 more signs for
    48                              <1> ;	|____________|___|______ |________|___|____________|residue calculation
    49                              <1> ;	| platform word 5| platform word 4|   +rounding <--- @  96-bit operation
    50                              <1> 
    51                              <1> ;	                 <---------------------------------[ platform words 2..0
    52                              <1> ;	                 :
    53                              <1> ;	                 [                                                  ]
    54                              <1> 
    55                              <1> ;	                 |--- 168-bit mantissa 71:0   -------->
    56                              <1> ;	                      rounding @ 192-bit operation --->+
    57                              <1> ;      	                 _________________________|____________|_____________
    58                              <1> ;	                 |      24    | 8 |   16  |   16   | 8 |    24 signs|
    59                              <1> ;	                 |____________|___|_______|________|___|____________|
    60                              <1> ;	                 | platform word 2| platform word 1| platform word 0|
    61                              <1> 
    62                              <1> ;	                 |    residue rounding -->+
    63                              <1> ;	                 |--- 144-bit mantissa -->	                                    
    64                              <1> 
    65                              <1> _deliver_:
    66                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
    67 00001CE1 0F7EFE              <1> 	movd	esi, mm7
    68                              <1> 
    69 00001CE4 F786A0040000080000- <1> 	test	dword ptr [esi+PSR], FP_R
    69 00001CED 00                  <1>
    70 00001CEE 0F847E000000        <1> 	jz	near _deliver
    71 00001CF4 53                  <1> 	push	ebx		; save result register index
    72 00001CF5 8B1F                <1> 	mov	ebx, dword ptr [edi]		; read scale unsigned magnitude
    73                              <1> 						; not yet signed
    74                              <1> 
    75                              <1> 				; all results except scale have been polarised
    76                              <1> 				; ebx = positive magnitude of major exponent
    77                              <1> 				; deliver floating residue
    78 00001CF7 83C3B8              <1> 	add	ebx, -72	; calculate exponent of residue
    79 00001CFA B148                <1> 	mov	cl, 72
    80                              <1> 
    81 00001CFC 8B4710              <1> 	mov	eax, dword ptr [edi+4*4]	; mantissa */ 64 bits
    82 00001CFF C1E008              <1> 	shl	eax, 8		; separate residual mantissa
    83 00001D02 C1E808              <1> 	shr	eax, 8
    84 00001D05 50                  <1> 	push	eax
    85 00001D06 8B4714              <1> 	mov	eax, dword ptr [edi+5*4]	; mantissa */ 96 bits
    86 00001D09 50                  <1> 	push	eax
    87 00001D0A 8B4718              <1> 	mov	eax, dword ptr [edi+6*4]	; mantissa */ 128 bits
    88 00001D0D 668B4704            <1> 	mov	ax, word ptr [edi+1*4]		; change low-order half trailing word to signs
    89 00001D11 50                  <1> 	push	eax				; before normalising
    90                              <1> 
    91                              <1> _normalise_residue:
    92 00001D12 8B442408            <1> 	mov	eax, dword ptr [esp+2*4]	; residual mantissa high-order word
    93 00001D16 334704              <1> 	xor	eax, dword ptr [edi+1*4]	; signs
    94 00001D19 2500008000          <1> 	and	eax, 00800000h			; normalising position
    95 00001D1E 751A                <1> 	jnz	_residue_normalised
    96 00001D20 8B4704              <1> 	mov	eax, dword ptr [edi+1*4]	; signs again
    97 00001D23 D1D0                <1> 	rcl	eax, 1				; place a sign in carry				
    98 00001D25 D11424              <1> 	rcl	dword ptr [esp], 1		; rotate 96 bits residual mantissa
    99 00001D28 D1542404            <1> 	rcl	dword ptr [esp+1*4], 1
   100 00001D2C D1542408            <1> 	rcl	dword ptr [esp+2*4], 1		; thirdly the high-order word
   101 00001D30 83C3FF              <1> 	add	ebx, -1
   102 00001D33 80C1FF              <1> 	add	cl, -1
   103 00001D36 72DA                <1> 	jc	_normalise_residue
   104 00001D38 31DB                <1> 	xor	ebx, ebx			; residue all signs zero -> scale
   105                              <1> _residue_normalised:
   106 00001D3A F7C3000080FF        <1> 	test	ebx, 0FF800000h
   107 00001D40 0F85F5F4FFFF        <1> 	jnz	_fpxpo				; nonzero mantissa
   108                              <1> 						; and exponent underflow / overflow
   109                              <1> 						
   110                              <1> ;			residual mantissa on the stack now is
   111                              <1> ;			______________________________________________
   112                              <1> ;	sp------------->| mantissa bits 15..0 | 16 sign bits discard |
   113                              <1> ;			|_____________________|______________________|
   114                              <1> ;			|            mantissa bits 47..16            |
   115                              <1> ;			|____________________________________________| 
   116                              <1> ;			| 0000 0000  mantissa bits 71..48            |
   117                              <1> ;			|____________________________________________|
   118                              <1> ;			|	     result register indication      |
   119                              <1> ;			|____________________________________________|
   120                              <1> 
   121 00001D46 8B4704              <1> 	mov	eax, dword ptr [edi+1*4]	; signs
   122 00001D49 31D8                <1> 	xor	eax, ebx			; sign residue exponent now
   123 00001D4B C1E008              <1> 	shl	eax, 8				; trim characteristic to RTA1 24-bit word
   124 00001D4E C1E808              <1> 	shr	eax, 8
   125 00001D51 894520              <1> 	mov	dword ptr [ebp+8*4], eax	; scale XOR signs -> residue characteristic
   126                              <1> 
   127 00001D54 5B                  <1> 	pop	ebx				; low order mantissa part
   128 00001D55 58                  <1> 	pop	eax				; middle order mantissa part
   129 00001D56 88C3                <1> 	mov	bl, al				; donate 8 bits
   130 00001D58 C1CB08              <1> 	ror	ebx, 8				; distribute as RTA1 24-bit words
   131 00001D5B C1EB08              <1> 	shr	ebx, 8				; mantissa 23..0
   132 00001D5E C1E808              <1> 	shr	eax, 8				; mantissa 47..24
   133 00001D61 895D2C              <1> 	mov	dword ptr [ebp+11*4], ebx
   134 00001D64 894528              <1> 	mov	dword ptr [ebp+10*4], eax
   135 00001D67 58                  <1> 	pop	eax				; high order residual mantissa part
   136 00001D68 5B                  <1> 	pop	ebx				; saved result register index
   137 00001D69 C1E008              <1> 	shl	eax, 8
   138 00001D6C C1E808              <1> 	shr	eax, 8				; normalising position is bit 23
   139 00001D6F 894524              <1> 	mov	dword ptr [ebp+9*4], eax	; mantissa 71..48
   140                              <1> 
   141                              <1> _deliver:					; deliver floating result
   142                              <1> 						; ebx = target register index
   143                              <1> 						; result register index [ebp+]ebx*4
   144 00001D72 8B07                <1> 	mov	eax, dword ptr [edi]		; unsigned scale magnitude
   145 00001D74 A9000080FF          <1> 	test	eax, 0FF800000h
   146 00001D79 0F85BCF4FFFF        <1> 	jnz	_fpxpo				; exponent underflow / overflow
   147 00001D7F 334704              <1> 	xor	eax, dword ptr [edi+1*4]	; sign it
   148 00001D82 C1E008              <1> 	shl	eax, 8
   149 00001D85 C1E808              <1> 	shr	eax, 8
   150                              <1> 
   151                              <1> _store_float:
   152 00001D88 89449D00            <1>         mov     dword ptr [ebp+ebx*4], eax      ; store characteristic = scale XOR signs
   153 00001D8C 8B4708              <1>         mov     eax, dword ptr [edi+2*4]	; read bits 71..40 major mantissa
   154 00001D8F 0FB6C8              <1>         movzx   ecx, al
   155 00001D92 C1E808              <1>         shr     eax, 8
   156 00001D95 89449D04            <1>         mov     dword ptr [ebp+ebx*4+4], eax	; store mantissa bits 71..48
   157 00001D99 8B470C              <1>         mov     eax, dword ptr [edi+3*4]	; read mantissa bits 39..8
   158 00001D9C C1E110              <1>         shl     ecx, 16				; position mantissa bits 47..40
   159 00001D9F C1C810              <1>         ror     eax, 16
   160 00001DA2 6689C1              <1>         mov     cx, ax				; position mantissa bits 39..24
   161 00001DA5 894C9D08            <1>         mov     dword ptr [ebp+ebx*4+8], ecx	; store mantissa bits 47..24
   162 00001DA9 8B4F10              <1>         mov     ecx, dword ptr [edi+4*4]	; read mantissa bits 7..0 plus 24 trailing bits
   163 00001DAC C1E910              <1>         shr     ecx, 16				; position after mantissa 23..8
   164 00001DAF 6689C8              <1>         mov     ax, cx
   165 00001DB2 C1E808              <1>         shr     eax, 8				; store mantissa bits 23..0
   166 00001DB5 89449D0C            <1>         mov     dword ptr [ebp+ebx*4+12], eax
   167 00001DB9 C3                  <1> 	ret
   168                              <1> 
   169                              <1> ;	_output equ	272
   170                              <1> ;	_inputr equ	264
   171                              <1> ;	_input2 equ	256
   172                              <1> 
   173                              <1> ;	_OUTPUT	equ	__register+_output*4
   174                              <1> ;	_INPUTR equ	__register+_inputr*4
   175                              <1> ;	_INPUT2 equ	__register+_input2*4
   176                              <1> ;	_BIAS	equ	_OUTPUT
   177                              <1> 
   178                              <1> zoutput:
   179 00001DBA 31C0                <1> 	xor	eax, eax
   180 00001DBC 8907                <1> 	mov	dword ptr [edi], eax
   181 00001DBE 894704              <1> 	mov	dword ptr [edi+1*4], eax
   182 00001DC1 894708              <1> 	mov	dword ptr [edi+2*4], eax
   183 00001DC4 89470C              <1> 	mov	dword ptr [edi+3*4], eax
   184 00001DC7 894710              <1> 	mov	dword ptr [edi+4*4], eax
   185 00001DCA 894714              <1> 	mov	dword ptr [edi+5*4], eax
   186 00001DCD 894718              <1> 	mov	dword ptr [edi+6*4], eax
   187 00001DD0 89471C              <1> 	mov	dword ptr [edi+7*4], eax
   188 00001DD3 C3                  <1> 	ret
   189                              <1> 
   190                              <1> 
   191                              <1> ;	round before add or divide
   192                              <1> ;	XOR rounding pattern to guard field
   193                              <1> 
   194 00001DD4 0FB6DD              <1> round1:	movzx	ebx, ch
   195                              <1> ;	mov	eax, dword ptr [ebp+CORE_INDEX1]
   196 00001DD7 0F7EF8              <1> 	movd	eax, mm7
   197                              <1> 
   198 00001DDA 8B804C020000        <1> 	mov	eax, dword ptr [eax+REGISTER+FP_GUARD]
   199 00001DE0 D3E8                <1> 	shr	eax, cl
   200 00001DE2 C1E008              <1> 	shl	eax, 8
   201 00001DE5 31449F08            <1> 	xor	dword ptr [edi+ebx*4+2*4], eax
   202                              <1> 
   203 00001DE9 C3                  <1> 	ret
   204                              <1> 
   205 00001DEA 0FB6DD              <1> round2:	movzx	ebx, ch
   206                              <1> ;	mov	eax, dword ptr [ebp+CORE_INDEX1]	; ? can't have mattered
   207 00001DED 0F7EFE              <1> 	movd	esi, mm7			; 
   208                              <1> 
   209 00001DF0 8B864C020000        <1> 	mov	eax, dword ptr [esi+REGISTER+FP_GUARD]
   210 00001DF6 D3E8                <1> 	shr	eax, cl
   211 00001DF8 C1E008              <1> 	shl	eax, 8
   212 00001DFB 01449F08            <1> 	add	dword ptr [edi+ebx*4+2*4], eax
   213                              <1> round2more:
   214 00001DFF 83549F0400          <1> 	adc	dword ptr [edi+ebx*4+1*4], 0
   215 00001E04 4B                  <1> 	dec	ebx
   216 00001E05 75F8                <1> 	jnz	round2more
   217 00001E07 C3                  <1> 	ret
   218                              <1> 
   219                              <1> end_around_carry:
   220                              <1> 
   221 00001E08 F75608              <1> 	not	dword ptr [esi+2*4]		; seems to vary or be vaguely documented
   222 00001E0B 0FB64604            <1> 	movzx	eax, byte ptr [esi+1*4]		; what size the call return stack frame is
   223                              <1> 						; so we push ei and copy esp to it
   224                              <1> 						; to see stuff near the stack top
   225                              <1> 
   226 00001E0F F6460880            <1> 	test	byte ptr dword ptr [esi+2*4], 128
   227 00001E13 790B                <1> 	jns	end_around_carry_plus		; updated signs +
   228                              <1> 
   229 00001E15 B8FFFFFFFF          <1> 	mov	eax, -1				; 1 -> -1 in 1s complement
   230 00001E1A D3E8                <1> 	shr	eax, cl
   231 00001E1C F7D0                <1> 	not	eax
   232 00001E1E EB06                <1> 	jmp	eoc1
   233                              <1> 
   234                              <1> end_around_carry_plus:
   235 00001E20 21C0                <1> ?	and	eax, eax
   236 00001E22 7415                <1> 	jz	eox1				; ? don't call this if there is no carry
   237 00001E24 D3C8                <1> 	ror	eax, cl
   238                              <1> 
   239 00001E26 0FB6DD              <1> eoc1:	movzx	ebx, ch
   240 00001E29 01449F08            <1> 	add	dword ptr [edi+ebx*4+2*4], eax
   241                              <1> 
   242 00001E2D 9C                  <1> 	pushf
   243 00001E2E C1F81F              <1> 	sar	eax, 31				; shift leave carry alone
   244 00001E31 9D                  <1> 	popfd
   245                              <1> 
   246 00001E32 43                  <1> 	inc	ebx				; but reference displacements - 2
   247                              <1> 
   248 00001E33 11049F              <1> eoc:	adc	dword ptr [edi+ebx*4], eax	; referencing displacements - 2
   249 00001E36 4B                  <1> 	dec	ebx
   250 00001E37 75FA                <1> 	jnz	eoc
   251 00001E39 C3                  <1> eox1:	ret
   252                              <1> 
   253                              <1> restore_trailing_signs:
   254 00001E3A 0FB6DD              <1> 	movzx	ebx, ch
   255 00001E3D 8B4704              <1> 	mov	eax, dword ptr [edi+1*4]
   256                              <1> 
   257 00001E40 89471C              <1> 	mov	dword ptr [edi+7*4], eax
   258                              <1> 
   259 00001E43 21C0                <1> 	and	eax, eax
   260 00001E45 780B                <1> 	js	restore_trailing_ones
   261 00001E47 F7D0                <1> 	not	eax
   262 00001E49 D3E8                <1> 	shr	eax, cl
   263 00001E4B F7D0                <1> 	not	eax
   264 00001E4D 21449F08            <1> 	and	dword ptr [edi+ebx*4+2*4], eax
   265                              <1> 
   266 00001E51 C3                  <1> 	ret
   267                              <1> restore_trailing_ones:
   268 00001E52 D3E8                <1> 	shr	eax, cl
   269 00001E54 09449F08            <1> 	or	dword ptr [edi+ebx*4+2*4], eax
   270                              <1> 
   271 00001E58 C3                  <1> 	ret
   272                              <1> 	
   273                              <1> bias_addend:					; input mantissa [esi] is biased into location _BIAS
   274 00001E59 57                  <1> 	push	edi
   275 00001E5A 89F7                <1> 	mov	edi, esi
   276                              <1> 
   277                              <1> ;	mov	esi, dword ptr[ebp+CORE_INDEX1]
   278 00001E5C 0F7EFE              <1> 	movd	esi, mm7
   279 00001E5F 8DB640040000        <1> 	lea	esi, [esi+_BIAS]
   280                              <1> 
   281 00001E65 56                  <1> 	push	esi
   282 00001E66 E803000000          <1> 	call	biasfp
   283                              <1> 
   284 00001E6B 5E                  <1> 	pop	esi
   285 00001E6C 5F                  <1> 	pop	edi
   286 00001E6D C3                  <1> 	ret
   287                              <1> 
   288 00001E6E 52                  <1> biasfp:	push	edx
   289 00001E6F 51                  <1> 	push	ecx
   290                              <1> 
   291 00001E70 BB01000000          <1> 	mov	ebx, 1				; output index
   292 00001E75 66C1E003            <1> 	shl	ax, 3				; words sign fill
   293 00001E79 C0E803              <1> 	shr	al, 3				; bits sign fill
   294 00001E7C 6689C1              <1> 	mov	cx, ax
   295 00001E7F 83C704              <1> 	add	edi, 4				; input pointer
   296 00001E82 8B07                <1> 	mov	eax, dword ptr [edi]		; there shall be this word of signs at least
   297                              <1> 
   298 00001E84 89049E              <1> bias32:	mov	dword ptr [esi+ebx*4], eax	; write 1 word of signs
   299 00001E87 43                  <1> 	inc	ebx				; consider the next output word
   300 00001E88 FECD                <1> 	dec	ch				; any more words of signs?
   301 00001E8A 79F8                <1> 	jns	bias32
   302                              <1> 
   303 00001E8C 20C9                <1> 	and	cl, cl
   304 00001E8E 7422                <1> 	jz	bias_fast			; there is no 32-bit shift
   305                              <1> 
   306 00001E90 B520                <1> 	mov	ch, 32				; demonstrate the missing advantage
   307 00001E92 28CD                <1> 	sub	ch, cl				; of instruction architectures
   308                              <1> 						; with 2-register shifts
   309                              <1> biasup2:
   310 00001E94 83FB08              <1> 	cmp	ebx, 8
   311 00001E97 742B                <1> 	jz	bias_addx
   312 00001E99 83C704              <1> 	add	edi, 4				; read new mantissa word
   313 00001E9C 8B17                <1> 	mov	edx, dword ptr [edi]		; it becomes word # new in edx
   314 00001E9E 86E9                <1> 	xchg	ch, cl
   315 00001EA0 D3E0                <1> 	shl	eax, cl				; shift buffered word left 32 - bit offset
   316 00001EA2 86E9                <1> 	xchg	ch, cl
   317 00001EA4 D3EA                <1> 	shr	edx, cl				; shift new mantissa word right bit offset
   318 00001EA6 09D0                <1> 	or	eax, edx
   319 00001EA8 89049E              <1> 	mov	dword ptr [esi+ebx*4], eax	; write 1 merged word
   320 00001EAB 8B07                <1> 	mov	eax, dword ptr [edi]		; read the same mantissa word again
   321 00001EAD 83C301              <1> 	add	ebx, 1				; it becomes word # previous in eax
   322 00001EB0 EBE2                <1> 	jmp	biasup2
   323                              <1> 
   324                              <1> bias_fast:
   325 00001EB2 83FB08              <1> 	cmp	ebx, 8
   326 00001EB5 740D                <1> 	jz	bias_addx
   327 00001EB7 83C704              <1> 	add	edi, 4
   328 00001EBA 8B07                <1> 	mov	eax, dword ptr [edi]
   329 00001EBC 89049E              <1> 	mov	dword ptr [esi+ebx*4], eax
   330 00001EBF 83C301              <1> 	add	ebx, 1
   331 00001EC2 EBEE                <1> 	jmp	bias_fast
   332                              <1> 
   333                              <1> bias_addx:
   334 00001EC4 59                  <1> 	pop	ecx
   335 00001EC5 5A                  <1> 	pop	edx				; restore the program counter
   336 00001EC6 C3                  <1> 	ret
   337                              <1> 
   338                              <1> frame_mantissa:
   339                              <1> ;	ror	ecx, 16				; words count is up, beats index down
   340 00001EC7 80C501              <1> 	add	ch, 1				; up the beats index to beats count
   341 00001ECA 66C1E905            <1> 	shr	cx, 5				; positions / 32 in ch
   342 00001ECE C0E903              <1> 	shr	cl, 3				; positions /// 32 in cl
   343 00001ED1 0FB6DD              <1> 	movzx	ebx, ch				; derive platform words rounded down
   344 00001ED4 C3                  <1> 	ret
   345                              <1> 
   346                              <1> renormalise:					; rule 1: restore sign fill in
   347                              <1> 						; low-order containing platform word
   348                              <1> ; done before end-around-carry, and saved
   349                              <1> ;;	call	frame_mantissa			; it was mashed by rounding and adding
   350 00001ED5 E860FFFFFF          <1> 	call	restore_trailing_signs
   351 00001EDA C1C910              <1> 	ror	ecx, 16				; the governing parameter is now
   352                              <1> 						; the containing words count in cx
   353                              <1> renormalise32:
   354 00001EDD 8B4708              <1> 	mov	eax, dword ptr [edi+2*4]	; sample 32 mantissa bits
   355 00001EE0 3B4704              <1> 	cmp	eax, dword ptr [edi+1*4]	; compare it with 32 signs
   356 00001EE3 750C                <1> 	jnz	renormalise8
   357 00001EE5 E83E000000          <1> 	call	rotate32left			; this also discovers if it's ALL signs = 0
   358 00001EEA 21C0                <1> 	and	eax, eax			; and is the only place that needs examined
   359 00001EEC 75EF                <1> 	jnz	renormalise32
   360                              <1> 
   361 00001EEE 8907                <1> 	mov	dword ptr [edi], eax		; mantissa is signed zero, +0 -> scale
   362                              <1> renormalised:
   363 00001EF0 C3                  <1> 	ret
   364                              <1> 
   365                              <1> renormalise8:					; from this point on the value is nonzero
   366 00001EF1 C1C008              <1> 	rol	eax, 8				; are there 8 signs at head of mantissa?
   367 00001EF4 3A4707              <1> 	cmp	al, byte ptr [edi+1*4+3]	; this is Intel and the 4th byte is high-order
   368 00001EF7 750A                <1> 	jnz	renormalise1			; you have found the 8 bits containing the
   369                              <1> 						; normalising bit
   370 00001EF9 E849000000          <1> 	call	rotate8left			; or else you haven't
   371 00001EFE 8B4708              <1> 	mov     eax, dword ptr [edi+2*4]	; sample the moved mantissa
   372 00001F01 EBEE                <1> 	jmp	renormalise8
   373                              <1> 
   374                              <1> renormalise1:
   375                              <1> ;	movzx	ebx, cx	
   376 00001F03 8B4704              <1> 	mov	eax, dword ptr [edi+1*4]		
   377                              <1> ;	mov	dword ptr [edi+ebx*4+1*4], eax	; in case polarity has changed
   378 00001F06 334708              <1> 	xor	eax, dword ptr [edi+2*4]	; normalising bit opposite polarity to sign?
   379 00001F09 78E5                <1> 	js	renormalised			; arrived
   380 00001F0B E802000000          <1> 	call	bitwise_scale			; almost arrived
   381 00001F10 EBF1                <1> 	jmp	renormalise1
   382                              <1> 
   383                              <1> 
   384                              <1> bitwise_scale:
   385 00001F12 D1571C              <1> 	rcl	dword ptr [edi+7*4], 1	; so it doesn't matter whether 0 or 1
   386 00001F15 D15718              <1> 	rcl	dword ptr [edi+6*4], 1	; gets shifted into the 192nd bit
   387 00001F18 D15714              <1> 	rcl	dword ptr [edi+5*4], 1
   388 00001F1B D15710              <1> 	rcl	dword ptr [edi+4*4], 1	; it's quicker to shift 6 words
   389 00001F1E D1570C              <1> 	rcl	dword ptr [edi+3*4], 1	; than a counted loop of 4 or 5 or 6 words
   390 00001F21 D15708              <1> 	rcl	dword ptr [edi+2*4], 1
   391                              <1> 
   392 00001F24 8307FF              <1> 	add	dword ptr [edi], -1	; scale down
   393 00001F27 C3                  <1> 	ret
   394                              <1> 
   395                              <1> rotate32left:				; rotate all containing platform words of mantissa
   396 00001F28 52                  <1> 	push	edx			; 32 bit positions left and report if all signs
   397 00001F29 51                  <1> 	push	ecx
   398 00001F2A 0FB7D9              <1> 	movzx	ebx, cx
   399 00001F2D 31D2                <1> 	xor	edx, edx		; initialise equality = all signs
   400                              <1> 
   401                              <1> rotate32next:				; the word initially loaded in eax is all signs
   402 00001F2F 4B                  <1> 	dec	ebx
   403 00001F30 87449F08            <1> 	xchg	eax, dword ptr [edi+ebx*4+2*4]
   404 00001F34 89C1                <1> 	mov	ecx, eax
   405 00001F36 334F04              <1> 	xor	ecx, dword ptr [edi+1*4] ; difference between this word and signs
   406 00001F39 09CA                <1> 	or	edx, ecx		; sum of differences
   407 00001F3B 21DB                <1> 	and	ebx, ebx
   408 00001F3D 75F0                <1> 	jnz	rotate32next
   409 00001F3F 8307E0              <1> 	add	dword ptr [edi], -32	; scale down
   410 00001F42 89D0                <1> 	mov	eax, edx
   411 00001F44 59                  <1> 	pop	ecx
   412 00001F45 5A                  <1> 	pop	edx
   413 00001F46 C3                  <1> 	ret
   414                              <1> 
   415                              <1> rotate8left:				; rotate all containing platform words of mantissa
   416 00001F47 51                  <1> 	push	ecx			; 8 bit positions left. 1st word is rotated already
   417 00001F48 0FB7D9              <1> 	movzx	ebx, cx			; and contains signs in 8 low-order bit positions
   418                              <1> rotate8next:
   419 00001F4B 8B4C9F08            <1> 	mov	ecx, dword ptr [edi+ebx*4+2*4]
   420 00001F4F C1C108              <1> 	rol	ecx, 8
   421 00001F52 86C1                <1> 	xchg	al, cl
   422 00001F54 894C9F08            <1> 	mov	dword ptr [edi+ebx*4+2*4], ecx
   423 00001F58 83C3FF              <1> 	add	ebx, -1
   424 00001F5B 72EE                <1> 	jc	rotate8next
   425 00001F5D 8307F8              <1> 	add	dword ptr [edi], -8	; scale down
   426 00001F60 59                  <1> 	pop	ecx
   427 00001F61 C3                  <1> 	ret
   428                              <1> 
   429 00001F62 F75708              <1> zover:	not	dword ptr [edi+2*4]
   430 00001F65 F7570C              <1> 	not	dword ptr [edi+3*4]
   431 00001F68 F75710              <1> 	not	dword ptr [edi+4*4]
   432 00001F6B F75714              <1> 	not	dword ptr [edi+5*4]
   433 00001F6E F75718              <1> 	not	dword ptr [edi+6*4]
   434 00001F71 F7571C              <1> 	not	dword ptr [edi+7*4]
   435 00001F74 C3                  <1> 	ret
   436                              <1> 
   437                              <1> _add_low:
   438 00001F75 8B961C040000        <1>         mov     edx, dword ptr [esi+_INPUT2+7*4]
   439 00001F7B 13963C040000        <1>         adc     edx, dword ptr [esi+_INPUTR+7*4]
   440 00001F81 8B9E18040000        <1>         mov     ebx, dword ptr [esi+_INPUT2+6*4]
   441 00001F87 139E38040000        <1>         adc     ebx, dword ptr [esi+_INPUTR+6*4]
   442 00001F8D 8B8614040000        <1>         mov     eax, dword ptr [esi+_INPUT2+5*4]
   443 00001F93 138634040000        <1>         adc     eax, dword ptr [esi+_INPUTR+5*4]
   444 00001F99 C3                  <1>         ret
   445                              <1> 
   446                              <1> _add_high:
   447 00001F9A 8B9610040000        <1>         mov     edx, dword ptr [esi+_INPUT2+4*4]
   448 00001FA0 139630040000        <1>         adc     edx, dword ptr [esi+_INPUTR+4*4]
   449 00001FA6 8B9E0C040000        <1>         mov     ebx, dword ptr [esi+_INPUT2+3*4]
   450 00001FAC 139E2C040000        <1>         adc     ebx, dword ptr [esi+_INPUTR+3*4]
   451 00001FB2 8B8608040000        <1>         mov     eax, dword ptr [esi+_INPUT2+2*4]
   452 00001FB8 138628040000        <1>         adc     eax, dword ptr [esi+_INPUTR+2*4]
   453 00001FBE C3                  <1>         ret
   454                              <1> 
   455 00001FBF 8DBE00040000        <1> fan:	lea	edi, [esi+_INPUT2]
   456 00001FC5 E898FFFFFF          <1> 	call	zover				; mantissa
   457 00001FCA F79604040000        <1> 	not	dword ptr [esi+_INPUT2+1*4]	; 32 signs
   458                              <1> 
   459 00001FD0 8DBE20040000        <1> fa:	lea	edi, [esi+_INPUTR]
   460 00001FD6 8DB600040000        <1> 	lea	esi, [esi+_INPUT2]
   461                              <1> 
   462 00001FDC 8B4604              <1> 	mov	eax, dword ptr [esi+1*4]	; normalised?
   463 00001FDF 334608              <1> 	xor	eax, dword ptr [esi+2*4]	; normalising bit must ^ signs
   464 00001FE2 7801                <1> 	js	fa_addend_normalised		; yes
   465 00001FE4 C3                  <1> fa_nop:	ret					; accumulator block unchanged
   466                              <1> 
   467                              <1> fa_addend_normalised:
   468 00001FE5 8B4704              <1> 	mov	eax, dword ptr [edi+1*4]	; register side operand normalised?
   469 00001FE8 334708              <1> 	xor	eax, dword ptr [edi+2*4]	; normalising bit must ^ signs
   470 00001FEB 7803                <1> 	js	fa_promote_magnitude		; normalised, get on with it
   471 00001FED 89F7                <1> 	mov	edi, esi			; accumulator block is not normalised
   472 00001FEF C3                  <1> 	ret					; storage addend zero-added
   473                              <1> 
   474                              <1> fa_promote_magnitude:
   475 00001FF0 8B07                <1> 	mov	eax, dword ptr [edi]
   476 00001FF2 2B06                <1> 	sub	eax, dword ptr [esi]
   477                              <1> 
   478 00001FF4 7904                <1> 	jns	fa_add				; register-side operand is not lower
   479                              <1> 
   480 00001FF6 87F7                <1> 	xchg	esi, edi			;
   481 00001FF8 F7D8                <1> 	neg	eax
   482                              <1> 
   483                              <1> fa_add:	;	call	frame_mantissa
   484 00001FFA 50                  <1> 	push	eax				; exponent difference
   485 00001FFB E8D4FDFFFF          <1> 	call	round1
   486                              <1> 
   487 00002000 58                  <1> 	pop	eax				; exponent difference
   488 00002001 21C0                <1> 	and	eax, eax			; is + and either zero or not
   489 00002003 740C                <1> 	jz	fa_addfast
   490                              <1> 
   491 00002005 3DBF000000          <1> 	cmp	eax, 191			; do they touch?
   492 0000200A 77D8                <1> 	ja	fa_nop
   493                              <1> 
   494 0000200C E848FEFFFF          <1> 	call	bias_addend
   495                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1] ; done inside bias_addend
   496                              <1> ;	anyway movd	esi, mm7
   497                              <1> ;	lea	esi, [esi+_BIAS]		; shifted added
   498                              <1> 
   499                              <1> fa_addfast:
   500 00002011 8B4704              <1> 	mov	eax, dword ptr [edi+1*4]	; before look signs
   501 00002014 50                  <1> 	push	eax				; near stack top until fa_normalised
   502                              <1> 
   503 00002015 C1C910              <1> 	ror	ecx, 16				; get containing compute words
   504 00002018 0FB7D9              <1> 	movzx	ebx, cx				; index / count
   505 0000201B C1C910              <1> 	ror	ecx, 16
   506                              <1> 
   507 0000201E F8                  <1> 	clc
   508                              <1> 
   509                              <1> fa_action:
   510 0000201F 8B049E              <1> 	mov	eax, dword ptr [esi+ebx*4]
   511 00002022 11049F              <1> 	adc	dword ptr [edi+ebx*4], eax
   512 00002025 4B                  <1> 	dec	ebx				; process word 1
   513 00002026 75F7                <1> 	jnz	fa_action			; leave word 0 alone
   514                              <1> 
   515 00002028 0F92C3              <1> 	setc	bl				; boolean instructions following
   516 0000202B 53                  <1> 	push	ebx				; should not change carry but
   517                              <1> 
   518                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
   519 0000202C 0F7EFE              <1> 	movd	esi, mm7
   520                              <1> 	
   521 0000202F 8B4704              <1> 	mov	eax, dword ptr [edi+1*4]	; has sign switched ?
   522 00002032 33442404            <1> 	xor	eax, dword ptr [esp+1*4]
   523                              <1> 	
   524 00002036 7918                <1> 	jns	fa_testcarry
   525                              <1> 
   526                              <1> ;	not	dword ptr [esi+7*4]
   527                              <1> 
   528 00002038 F686A004000008      <1> 	test	byte ptr [esi+PSR], FP_R	; flag 8 = store residue
   529 0000203F 7506                <1> 	jnz	switch_long
   530                              <1> 
   531 00002041 F75718              <1> 	not	dword ptr [edi+6*4]		; if double size (+ residue)
   532 00002044 F75714              <1> 	not	dword ptr [edi+5*4]		; these are written in the add loop
   533                              <1> switch_long:
   534                              <1> 
   535                              <1> ;	not	dword ptr [edi+7*4]		; thru zero
   536                              <1> 
   537 00002047 56                  <1> 	push	esi				; have a clear expectation
   538 00002048 89E6                <1> 	mov	esi, esp			; where the first stack words are
   539 0000204A E8B9FDFFFF          <1> 	call	end_around_carry
   540 0000204F 5E                  <1> 	pop	esi
   541                              <1> 
   542                              <1> fa_testcarry:
   543                              <1> 
   544 00002050 8B442404            <1> 	mov	eax, dword ptr [esp+1*4]		; [ esp + 1L ] -> updated signs
   545 00002054 334704              <1> 	xor	eax, dword ptr [edi+1*4]		; carry from normalising position?
   546                              <1> 
   547 00002057 2401                <1> 	and	al, 1
   548 00002059 7422                <1> 	jz	fa_normalise
   549                              <1> 
   550 0000205B FF07                <1> 	inc	dword ptr [edi]				; exponent magnitude++
   551                              <1> 
   552 0000205D 8B442404            <1> 	mov	eax, dword ptr [esp+1*4]	 	; read 32 signs
   553 00002061 D1C8                <1> 	ror	eax, 1					; move a sign to carry	
   554                              <1> 
   555 00002063 D15F04              <1> 	rcr	dword ptr [edi+1*4], 1			; shift from signs word
   556 00002066 D15F08              <1> 	rcr	dword ptr [edi+2*4], 1			; to normalising position
   557 00002069 D15F0C              <1> 	rcr	dword ptr [edi+3*4], 1			; keep going
   558 0000206C D15F10              <1> 	rcr	dword ptr [edi+4*4], 1
   559 0000206F D15F14              <1> 	rcr	dword ptr [edi+5*4], 1
   560 00002072 D15F18              <1> 	rcr	dword ptr [edi+6*4], 1
   561 00002075 D15F1C              <1> 	rcr	dword ptr [edi+7*4], 1
   562                              <1> 
   563 00002078 894704              <1> 	mov	dword ptr [edi+1*4], eax		; write all signs back to signs word
   564                              <1> 
   565 0000207B EB05                <1> 	jmp	fa_normalised
   566                              <1> 
   567                              <1> fa_normalise:
   568 0000207D E853FEFFFF          <1> 	call	renormalise				; in case the sum is plenty positions
   569                              <1> 
   570                              <1> fa_normalised:
   571 00002082 5B                  <1> 	pop	ebx
   572 00002083 58                  <1> 	pop	eax					; below the fractional point
   573 00002084 C3                  <1> 	ret
   574                              <1> 	
   575 00002085 8DBE40040000        <1> fm:	lea	edi, [esi+_OUTPUT]			; initialise final accumulation
   576 0000208B E82AFDFFFF          <1> 	call	zoutput
   577                              <1> 
   578 00002090 8B9E24040000        <1> 	mov	ebx, dword ptr [esi+_INPUTR+1*4]	; read register-side signs
   579 00002096 8B8628040000        <1> 	mov	eax, dword ptr [esi+_INPUTR+2*4]	; and high-end mantissa
   580 0000209C 31D8                <1> 	xor	eax, ebx	 			; cache if-normalised in eax
   581 0000209E 339E04040000        <1> 	xor	ebx, dword ptr [esi+_INPUT2+1*4]	; multiply signs
   582 000020A4 899E44040000        <1> 	mov	dword ptr [esi+_OUTPUT+1*4], ebx	; save the output sign
   583 000020AA 21C0                <1> 	and	eax, eax				; test the cached if-normalised
   584 000020AC 790E                <1> 	jns	fmdont
   585                              <1> 
   586 000020AE 8B8604040000        <1> 	mov	eax, dword ptr [esi+_INPUT2+1*4]	; is the multiplier normalised?
   587 000020B4 338608040000        <1> 	xor	eax, dword ptr [esi+_INPUT2+2*4]	; sign XOR normalising bit?
   588 000020BA 782F                <1> 	js	fmgo					; yes, proceed
   589                              <1> 
   590 000020BC 899E48040000        <1> fmdont:	mov	dword ptr [esi+_OUTPUT+2*4], ebx
   591 000020C2 899E4C040000        <1> 	mov	dword ptr [esi+_OUTPUT+3*4], ebx
   592 000020C8 899E50040000        <1> 	mov	dword ptr [esi+_OUTPUT+4*4], ebx
   593 000020CE 899E54040000        <1> 	mov	dword ptr [esi+_OUTPUT+5*4], ebx
   594 000020D4 899E58040000        <1> 	mov	dword ptr [esi+_OUTPUT+6*4], ebx
   595 000020DA 899E5C040000        <1> 	mov	dword ptr [esi+_OUTPUT+7*4], ebx
   596 000020E0 C78640040000000000- <1> 	mov	dword ptr [esi+_OUTPUT], 0		; mantissa to go
   596 000020E9 00                  <1>
   597                              <1> 
   598 000020EA C3                  <1> 	ret					; no, effective zero multiplier
   599                              <1> 
   600 000020EB 51                  <1> fmgo:	push	ecx
   601 000020EC 8B8624040000        <1> 	mov	eax, dword ptr [esi+_INPUTR+1*4]
   602 000020F2 B148                <1> 	mov	cl, 72				; beats count exactly 72
   603 000020F4 21C0                <1> 	and	eax, eax
   604                              <1> 
   605 000020F6 790B                <1> 	jns	fmp1
   606 000020F8 8DBE20040000        <1> 	lea	edi, [esi+_INPUTR]
   607 000020FE E85FFEFFFF          <1> 	call	zover
   608                              <1> 
   609 00002103 8B8604040000        <1> fmp1:	mov	eax, dword ptr [esi+_INPUT2+1*4]
   610 00002109 21C0                <1> 	and	eax, eax
   611 0000210B 790B                <1> 	jns	fmadd
   612 0000210D 8DBE00040000        <1> 	lea	edi, [esi+_INPUT2]
   613 00002113 E84AFEFFFF          <1> 	call	zover
   614                              <1> 
   615 00002118 F8                  <1> fmadd:	clc
   616                              <1> 
   617 00002119 8DBE20040000        <1> 	lea	edi, [esi+_INPUTR]
   618 0000211F D15F08              <1> 	rcr	dword ptr [edi+2*4], 1		; addend shift right
   619 00002122 D15F0C              <1> 	rcr	dword ptr [edi+3*4], 1
   620 00002125 D15F10              <1> 	rcr	dword ptr [edi+4*4], 1
   621 00002128 D15F14              <1> 	rcr	dword ptr [edi+5*4], 1
   622 0000212B D15F18              <1> 	rcr	dword ptr [edi+6*4], 1
   623 0000212E D15F1C              <1> 	rcr	dword ptr [edi+7*4], 1
   624                              <1> 
   625 00002131 8DBE00040000        <1> 	lea	edi, [esi+_INPUT2]
   626                              <1> ;	rcl	dword ptr [edi+7*4], 1		; multiplier shift left
   627                              <1> ;	rcl	dword ptr [edi+6*4], 1
   628                              <1> ;	rcl	dword ptr [edi+5*4], 1		; multiplier mantissa is only 72 bits
   629 00002137 D15710              <1> 	rcl	dword ptr [edi+4*4], 1
   630 0000213A D1570C              <1> 	rcl	dword ptr [edi+3*4], 1
   631 0000213D D15708              <1> 	rcl	dword ptr [edi+2*4], 1
   632                              <1> 
   633 00002140 8DBE40040000        <1> 	lea	edi, [esi+_OUTPUT]
   634 00002146 7336                <1> 	jnc	fmadx
   635                              <1> 						; 1 shifted from multiplier
   636 00002148 8B863C040000        <1> fmadc:	mov	eax, dword ptr [esi+_INPUTR+7*4]	
   637 0000214E 01471C              <1> 	add	dword ptr [edi+7*4], eax	; do not use carry
   638 00002151 8B8638040000        <1> 	mov	eax, dword ptr [esi+_INPUTR+6*4]
   639 00002157 114718              <1> 	adc	dword ptr [edi+6*4], eax	; start using carry
   640 0000215A 8B8634040000        <1> 	mov	eax, dword ptr [esi+_INPUTR+5*4]
   641 00002160 114714              <1> 	adc	dword ptr [edi+5*4], eax
   642 00002163 8B8630040000        <1> 	mov	eax, dword ptr [esi+_INPUTR+4*4]
   643 00002169 114710              <1> 	adc	dword ptr [edi+4*4], eax
   644 0000216C 8B862C040000        <1> 	mov	eax, dword ptr [esi+_INPUTR+3*4]
   645 00002172 11470C              <1> 	adc	dword ptr [edi+3*4], eax
   646 00002175 8B8628040000        <1> 	mov	eax, dword ptr [esi+_INPUTR+2*4]
   647 0000217B 114708              <1> 	adc	dword ptr [edi+2*4], eax
   648                              <1> 
   649 0000217E FEC9                <1> fmadx:	dec	cl
   650 00002180 7596                <1> 	jnz	fmadd
   651                              <1> 
   652 00002182 59                  <1> fmadz:	pop	ecx
   653                              <1> 
   654 00002183 8B4708              <1> 	mov	eax, dword ptr [edi+2*4] 	; normalised?
   655 00002186 D1D0                <1> 	rcl	eax, 1
   656 00002188 721B                <1> 	jc	fm_normalised
   657                              <1> 
   658 0000218A 838620040000FF      <1> 	add	dword ptr [esi+_INPUTR], -1		; take 1 from scale
   659 00002191 D1571C              <1> 	rcl	dword ptr [edi+7*4], 1
   660 00002194 D15718              <1> 	rcl	dword ptr [edi+6*4], 1
   661 00002197 D15714              <1> 	rcl	dword ptr [edi+5*4], 1
   662 0000219A D15710              <1> 	rcl	dword ptr [edi+4*4], 1
   663 0000219D D1570C              <1> 	rcl	dword ptr [edi+3*4], 1
   664 000021A0 D15708              <1> 	rcl	dword ptr [edi+2*4], 1
   665                              <1> 
   666 000021A3 EB26                <1> 	jmp	fm_inrange
   667                              <1> 
   668                              <1> fm_normalised:
   669 000021A5 8DBE40040000        <1> 	lea	edi, [esi+_OUTPUT]
   670 000021AB E83AFCFFFF          <1> 	call	round2
   671 000021B0 7319                <1> 	jnc	fm_inrange
   672                              <1> 
   673 000021B2 D15F08              <1> 	rcr	dword ptr [edi+2*4], 1
   674 000021B5 D15F0C              <1> 	rcr	dword ptr [edi+3*4], 1
   675 000021B8 D15F10              <1> 	rcr	dword ptr [edi+4*4], 1
   676 000021BB D15F14              <1> 	rcr	dword ptr [edi+5*4], 1
   677 000021BE D15F18              <1> 	rcr	dword ptr [edi+6*4], 1
   678 000021C1 D15F1C              <1> 	rcr	dword ptr [edi+7*4], 1
   679 000021C4 83862004000001      <1> 	add	dword ptr [esi+_INPUTR], 1
   680                              <1> 
   681                              <1> fm_inrange:
   682 000021CB 8B8620040000        <1> 	mov	eax, dword ptr [esi+_INPUTR]
   683 000021D1 038600040000        <1> 	add	eax, dword ptr [esi+_INPUT2]
   684 000021D7 050000C0FF          <1> 	add	eax, -00400000h
   685 000021DC 8907                <1> 	mov	dword ptr [edi], eax		; insert unsigned magnitude product scale
   686 000021DE 8B4704              <1> 	mov	eax, dword ptr [edi+1*4]
   687 000021E1 314708              <1> 	xor	dword ptr [edi+2*4], eax	; the mantissa gets polarised here
   688 000021E4 31470C              <1> 	xor	dword ptr [edi+3*4], eax
   689 000021E7 314710              <1> 	xor	dword ptr [edi+4*4], eax
   690 000021EA 314714              <1> 	xor	dword ptr [edi+5*4], eax
   691 000021ED 314718              <1> 	xor	dword ptr [edi+6*4], eax
   692 000021F0 31471C              <1> 	xor	dword ptr [edi+7*4], eax
   693 000021F3 C3                  <1> 	ret
   694                              <1> 
   695 000021F4 8DBE40040000        <1> fd:	lea	edi, [esi+_OUTPUT]
   696 000021FA E8BBFBFFFF          <1> 	call	zoutput				; result which may stay zero
   697 000021FF 8B8604040000        <1> 	mov	eax, dword ptr [esi+_INPUT2+1*4]	; signs
   698 00002205 89C3                <1> 	mov	ebx, eax
   699 00002207 338608040000        <1> 	xor	eax, dword ptr [esi+_INPUT2+2*4]	; normalising bit 31
   700 0000220D 780C                <1> 	js	fdgo
   701 0000220F F79644040000        <1> 	not	dword ptr [esi+_OUTPUT+1*4]		; divisor 0 or otherwise unnormalised
   702 00002215 E848FDFFFF          <1> 	call	zover				; return -0.0
   703 0000221A C3                  <1> fdnop:	ret					; not normalised = zero divisor
   704                              <1> 
   705 0000221B 8B8624040000        <1> fdgo:	mov     eax, dword ptr [esi+_INPUTR+1*4]	; make sure the dividend is present
   706 00002221 338628040000        <1> 	xor	eax, dword ptr [esi+_INPUTR+2*4]	; normalising bit must be not sign
   707 00002227 783B                <1> 	js	fdop				; go after all
   708                              <1> 						; unnormalised = 0 = unnormalised
   709 00002229 8B8624040000        <1> 	mov	eax, dword ptr [esi+_INPUTR+1*4]	; read the signs I tell you
   710 0000222F C78640040000000000- <1> 	mov	dword ptr [esi+_OUTPUT], 0		; exponent magnitude of nowhere
   710 00002238 00                  <1>
   711 00002239 898644040000        <1> 	mov	dword ptr [esi+_OUTPUT+1*4], eax	; signs
   712 0000223F 898648040000        <1> 	mov	dword ptr [esi+_OUTPUT+2*4], eax	; and as much mantissa as you like
   713 00002245 89864C040000        <1> 	mov	dword ptr [esi+_OUTPUT+3*4], eax
   714 0000224B 898650040000        <1> 	mov	dword ptr [esi+_OUTPUT+4*4], eax
   715 00002251 898654040000        <1> 	mov	dword ptr [esi+_OUTPUT+5*4], eax
   716 00002257 898658040000        <1> 	mov	dword ptr [esi+_OUTPUT+6*4], eax
   717 0000225D 89865C040000        <1> 	mov	dword ptr [esi+_OUTPUT+7*4], eax
   718 00002263 C3                  <1> 	ret
   719                              <1> 
   720 00002264 21DB                <1> fdop:	and	ebx, ebx				; divisor either is negative magnitude
   721 00002266 780B                <1> 	js	fd_comp1	
   722 00002268 8DBE00040000        <1> 	lea	edi, [esi+_INPUT2]			; or shall be
   723 0000226E E8EFFCFFFF          <1> 	call	zover
   724                              <1> fd_comp1:
   725 00002273 F78624040000000000- <1> 	test	dword ptr [esi+_INPUTR+1*4], 080000000h
   725 0000227C 80                  <1>
   726 0000227D 740B                <1> 	jz	fd_upright			; dividend must be positive magnitude
   727 0000227F 8DBE20040000        <1> 	lea	edi, [esi+_INPUTR]
   728 00002285 E8D8FCFFFF          <1> 	call	zover
   729                              <1> fd_upright:
   730 0000228A 8DBE20040000        <1> 	lea	edi, [esi+_INPUTR]
   731                              <1> 
   732 00002290 E83FFBFFFF          <1> 	call	round1				; this also sets counters
   733                              <1> 
   734 00002295 52                  <1> 	push	edx
   735 00002296 51                  <1> 	push	ecx
   736                              <1> 
   737                              <1> ;	add	cx, 01818h		; a divide needs 24 more beats
   738                              <1> 					; than a multiply
   739                              <1> 
   740 00002297 89C8                <1> 	mov	eax, ecx		; save words count in add range
   741 00002299 B15F                <1> 	mov	cl, 95
   742                              <1> 
   743 0000229B C1E810              <1> 	shr	eax, 16			; isolate words count in add range
   744 0000229E 6683C0FA            <1> 	add	ax, -6			; is it big?
   745 000022A2 0F8391000000        <1> 	jnc	near fd_72
   746                              <1> 
   747                              <1> ;	test	ch, 128
   748                              <1> ;	jz	near fd_72
   749                              <1> 
   750 000022A8 89E7                <1> 	mov	edi, esp
   751                              <1> 
   752 000022AA B1BF                <1> 	mov	cl, 191			; maybe
   753                              <1> 
   754 000022AC F9                  <1> fd_144:	stc				; add negative mantissa
   755 000022AD E8C3FCFFFF          <1> 	call	_add_low		; to positive dividend
   756 000022B2 52                  <1> 	push	edx			; save the low half in the stack
   757 000022B3 53                  <1> 	push	ebx
   758 000022B4 50                  <1> 	push	eax
   759 000022B5 E8E0FCFFFF          <1> 	call	_add_high			; add the high half in eax edx ebx
   760                              <1> 
   761 000022BA 7327                <1> 	jnc	fd_144level			; no carry = drop the result
   762                              <1> 
   763 000022BC 898628040000        <1> 	mov	dword ptr [esi+_INPUTR+2*4], eax	; carry = update the dividend
   764 000022C2 899E2C040000        <1> 	mov	dword ptr [esi+_INPUTR+3*4], ebx
   765 000022C8 899630040000        <1> 	mov	dword ptr [esi+_INPUTR+4*4], edx
   766                              <1> 
   767 000022CE 58                  <1> 	pop	eax
   768 000022CF 898634040000        <1> 	mov	dword ptr [esi+_INPUTR+5*4], eax
   769 000022D5 58                  <1> 	pop	eax
   770 000022D6 898638040000        <1> 	mov	dword ptr [esi+_INPUTR+6*4], eax
   771 000022DC 58                  <1> 	pop	eax
   772 000022DD 89863C040000        <1> 	mov	dword ptr [esi+_INPUTR+7*4], eax
   773                              <1> fd_144level:
   774 000022E3 89FC                <1> 	mov	esp, edi	; clear stack whether popped or not
   775 000022E5 D1965C040000        <1> 	rcl	dword ptr [esi+_OUTPUT+7*4], 1	; shift value of carry into quotient
   776 000022EB D19658040000        <1> 	rcl	dword ptr [esi+_OUTPUT+6*4], 1
   777 000022F1 D19654040000        <1> 	rcl	dword ptr [esi+_OUTPUT+5*4], 1
   778 000022F7 D19650040000        <1> 	rcl	dword ptr [esi+_OUTPUT+4*4], 1
   779 000022FD D1964C040000        <1> 	rcl	dword ptr [esi+_OUTPUT+3*4], 1
   780 00002303 D19648040000        <1> 	rcl	dword ptr [esi+_OUTPUT+2*4], 1
   781                              <1> 
   782 00002309 F9                  <1> 	stc
   783 0000230A D19E08040000        <1> 	rcr	dword ptr [esi+_INPUT2+2*4], 1	; shift negative addend
   784 00002310 D19E0C040000        <1> 	rcr	dword ptr [esi+_INPUT2+3*4], 1	; 1 position starboard
   785 00002316 D19E10040000        <1> 	rcr	dword ptr [esi+_INPUT2+4*4], 1
   786 0000231C D19E14040000        <1> 	rcr	dword ptr [esi+_INPUT2+5*4], 1
   787 00002322 D19E18040000        <1> 	rcr	dword ptr [esi+_INPUT2+6*4], 1
   788 00002328 D19E1C040000        <1> 	rcr	dword ptr [esi+_INPUT2+7*4], 1
   789                              <1> 
   790 0000232E 80C1FF              <1> 	add	cl, -1
   791 00002331 0F8275FFFFFF        <1> 	jc	fd_144
   792 00002337 EB44                <1> 	jmp	fd_restore	
   793                              <1> 
   794 00002339 F9                  <1> fd_72:	stc					; add negative mantissa
   795 0000233A E85BFCFFFF          <1> 	call	_add_high			; to positive dividend
   796 0000233F 7312                <1> 	jnc	fd_72level			; no carry = drop the result
   797                              <1> 
   798 00002341 898628040000        <1> 	mov	dword ptr [esi+_INPUTR+2*4], eax	; carry = update the dividend
   799 00002347 899E2C040000        <1> 	mov	dword ptr [esi+_INPUTR+3*4], ebx
   800 0000234D 899630040000        <1> 	mov	dword ptr [esi+_INPUTR+4*4], edx
   801                              <1> fd_72level:
   802 00002353 D19650040000        <1> 	rcl	dword ptr [esi+_OUTPUT+4*4], 1	; shift value of carry into quotient
   803 00002359 D1964C040000        <1> 	rcl	dword ptr [esi+_OUTPUT+3*4], 1
   804 0000235F D19648040000        <1> 	rcl	dword ptr [esi+_OUTPUT+2*4], 1
   805                              <1> 
   806 00002365 F9                  <1> 	stc
   807 00002366 D19E08040000        <1> 	rcr	dword ptr [esi+_INPUT2+2*4], 1	; shift negative addend
   808 0000236C D19E0C040000        <1> 	rcr	dword ptr [esi+_INPUT2+3*4], 1	; 1 position starboard
   809 00002372 D19E10040000        <1> 	rcr	dword ptr [esi+_INPUT2+4*4], 1	;
   810                              <1> 
   811 00002378 80C1FF              <1> 	add	cl, -1
   812 0000237B 72BC                <1> 	jc	fd_72
   813                              <1> 
   814 0000237D 59                  <1> fd_restore:	pop	ecx
   815 0000237E 5A                  <1> 		pop	edx				; hand the program counter back
   816                              <1> 
   817                              <1> 
   818                              <1> ;		mov	esi, dword ptr [ebp+CORE_INDEX1] ; fd kept esi -> core state
   819                              <1> ;	mm7	anyway
   820                              <1> 
   821 0000237F 8B8620040000        <1> 		mov	eax, dword ptr [esi+_INPUTR]	; + magnitude dividend exponent
   822 00002385 2B8600040000        <1> 		sub	eax, dword ptr [esi+_INPUT2]	; + magnitude divisor exponent
   823 0000238B 0501004000          <1> 		add	eax, 00400001h			; midpoint + 1
   824 00002390 898640040000        <1> 		mov	dword ptr [esi+_OUTPUT], eax	; magnitude of quotient scale
   825                              <1> 							; -> front of delivery string
   826 00002396 8DBE40040000        <1> 		lea	edi, [esi+_OUTPUT]
   827                              <1> 
   828 0000239C E834FBFFFF          <1> 		call	renormalise
   829                              <1> 
   830 000023A1 8DBE40040000        <1> 		lea	edi, [esi+_OUTPUT]			; tell rewrite where it is
   831 000023A7 8B8624040000        <1> 		mov	eax, dword ptr [esi+_INPUTR+1*4]	; determine sign of quotient
   832 000023AD 338604040000        <1> 		xor	eax, dword ptr [esi+_INPUT2+1*4]
   833 000023B3 894704              <1> 		mov	[edi+1*4], eax			; output 32 signs
   834                              <1> 							; _deliver_ polarises the quotient scale
   835 000023B6 314708              <1> 		xor	dword ptr [edi+2*4], eax	; switch quotient mantissa
   836 000023B9 31470C              <1> 		xor	dword ptr [edi+3*4], eax
   837 000023BC 314710              <1> 		xor	dword ptr [edi+4*4], eax
   838 000023BF 314714              <1> 		xor	dword ptr [edi+5*4], eax	; switch the long mantissa
   839 000023C2 314718              <1> 		xor	dword ptr [edi+6*4], eax
   840 000023C5 31471C              <1> 		xor	dword ptr [edi+7*4], eax
   841                              <1> 
   842 000023C8 C3                  <1> fd_z:		ret
   843                              <1> 
   844                              <1> 	;	these instructions take the left-side + target as
   845                              <1> 	;	[register_set]->a:b:mantissa2:mantissa3
   846                              <1> 	;	and the right side as [ea]
   847                              <1> 
   848                              <1> 	;	after acquisition and before delivery they call modules
   849                              <1> ;	fa fan fm fd
   850                              <1> ;	which may be used in extended instruction sets
   851                              <1> ;	using source and target registers in the internal stack
   852                              <1> ;	with maximum mantissa size 168 bits
   853                              <1> 
   854                              <1> 
   855                              <1> ;	esi -> core state but must also be used dynamically a lot
   856                              <1> ;	ebp -> always points at either one of two locations
   857                              <1> 
   858                              <1> ;		RTA1 application registers [ 0..127 ] modeled in 128 integers
   859                              <1> ;		RTA1 interrupt registers [ 128..255 ] modeled in 128 integers
   860                              <1> ;
   861                              <1> ;	there is always a copy of esi for retrieval at [ ebp + 152 integers ] ->
   862                              <1> 
   863                              <1> ;	_________________________.------ esi and ebp in application mode
   864                              <1> ;	|  RTA1 register 0	|					|
   865                              <1> ;	|_______________________|					|
   866                              <1> ;									|
   867                              <1> ;	________________________.------- ebp in ISR mode		|
   868                              <1> ;	|  RTA1 register 128	|			|		|
   869                              <1> ;	|_______________________|			|		|
   870                              <1> ;							|		|
   871                              <1> ;							|		|
   872                              <1> ;							|		|
   873                              <1> ;	_________________________.______________________________________|
   874                              <1> ;	| RTA register 152 = esi| offset ebp + 152 integers 
   875                              <1> ;	|_______________________|			|
   876                              <1> ;							|
   877                              <1> ;	.________________________.______________________|
   878                              <1> ;	| RTA register 280 = esi| offset ebp + 152 integers
   879                              <1> ;	|_______________________|
   880                              <1> 
   881 000023C9 BB04000000          <1> _fa:	mov 	ebx, a
   882 000023CE 53                  <1> _far:	push	ebx
   883 000023CF E86D000000          <1> 	call	fp_operands
   884 000023D4 E897000000          <1> 	call	fp_registers_a
   885 000023D9 E8F2FBFFFF          <1> 	call	fa
   886 000023DE 5B                  <1> 	pop	ebx
   887 000023DF E9FDF8FFFF          <1> 	jmp	_deliver_
   888                              <1> 
   889 000023E4 BB04000000          <1> _fan:	mov	ebx, a
   890 000023E9 53                  <1> _fanr:	push	ebx
   891 000023EA E852000000          <1> 	call	fp_operands
   892 000023EF E87C000000          <1> 	call	fp_registers_a
   893 000023F4 E8C6FBFFFF          <1> 	call	fan
   894 000023F9 5B                  <1> 	pop	ebx
   895 000023FA E9E2F8FFFF          <1> 	jmp	_deliver_
   896                              <1> 
   897 000023FF BB04000000          <1> _fm:	mov	ebx, a
   898 00002404 53                  <1> _fmr:	push	ebx
   899 00002405 E837000000          <1> 	call	fp_operands
   900 0000240A E87B000000          <1> 	call	fp_registers_m
   901 0000240F E871FCFFFF          <1> 	call	fm
   902 00002414 5B                  <1> 	pop	ebx
   903 00002415 8DBE40040000        <1> 	lea	edi, [esi+_OUTPUT]
   904 0000241B E9C1F8FFFF          <1> 	jmp	 _deliver_
   905                              <1> 
   906 00002420 BB04000000          <1> _fd:	mov	ebx, a				; default target register
   907 00002425 53                  <1> _fdr:	push	ebx
   908 00002426 E816000000          <1> 	call	fp_operands
   909 0000242B E85A000000          <1> 	call	fp_registers_m
   910 00002430 E8BFFDFFFF          <1> 	call	fd
   911 00002435 5B                  <1> 	pop	ebx
   912 00002436 8DBE40040000        <1> 	lea	edi, [esi+_OUTPUT]
   913 0000243C E9A0F8FFFF          <1> 	jmp	_deliver_
   914                              <1> 
   915                              <1> fp_operands:
   916 00002441 8DBE20040000        <1> 	lea	edi, [esi+_INPUTR]
   917 00002447 50                  <1> 	push	eax				; save effective address
   918 00002448 E857000000          <1> 	call	_load_quad
   919 0000244D E846F8FFFF          <1> 	call	compress4to8
   920 00002452 58                  <1> 	pop	eax				; restore effective address
   921                              <1> 
   922 00002453 55                  <1> 	push	ebp				; ebp must momentarily
   923 00002454 89F5                <1> 	mov	ebp, esi			; -> start of all register list
   924 00002456 BB00010000          <1> 	mov	ebx, _input2			; into starboard buffer
   925 0000245B E8C4DEFFFF          <1> 	call	_burst_read4			; memory or registers @ ea
   926 00002460 5D                  <1> 	pop	ebp				; App / Int register context
   927                              <1> 
   928                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
   929 00002461 0F7EFE              <1> 	movd	esi, mm7
   930                              <1> 
   931 00002464 8DBE00040000        <1> 	lea	edi, [esi+_INPUT2]		; but still in ebp
   932 0000246A E829F8FFFF          <1> 	call	compress4to8
   933 0000246F C3                  <1> 	ret
   934                              <1> 
   935                              <1> fp_registers_a:
   936                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
   937 00002470 0F7EFE              <1> 	movd	esi, mm7
   938                              <1> 
   939 00002473 B908020400          <1> 	mov	ecx, 00040208h
   940 00002478 F786A0040000080000- <1> 	test	dword ptr [esi+PSR], FP_R
   940 00002481 00                  <1>
   941 00002482 7405                <1> 	jz	fp_registers_x
   942 00002484 B910040600          <1> 	mov	ecx, 00060410h
   943                              <1> fp_registers_x:
   944 00002489 C3                  <1> 	ret
   945                              <1> 
   946                              <1> fp_registers_m:
   947                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
   948 0000248A 0F7EFE              <1> 	movd	esi, mm7
   949                              <1> 
   950 0000248D B908020400          <1> 	mov	ecx, 00040208h
   951 00002492 F786A0040000080000- <1> 	test	dword ptr [esi+PSR], FP_R
   951 0000249B 00                  <1>
   952 0000249C 7405                <1> 	jz	fp_registers_z
   953 0000249E B910040600          <1> 	mov	ecx, 00060410h
   954                              <1> fp_registers_z:
   955 000024A3 C3                  <1> 	ret
   956                              <1> 
   957                              <1> _load_quad:
   958 000024A4 8B449D0C            <1> 	mov	eax, dword ptr[ebp+ebx*4+3*4]
   959 000024A8 89470C              <1> 	mov	dword ptr [edi+3*4], eax
   960 000024AB 8B449D08            <1> 	mov	eax, dword ptr  [ebp+ebx*4+2*4]
   961 000024AF 894708              <1> 	mov	dword ptr [edi+2*4], eax
   962 000024B2 8B449D04            <1> 	mov	eax, dword ptr [ebp+ebx*4+1*4]
   963 000024B6 894704              <1> 	mov	dword ptr [edi+1*4], eax
   964 000024B9 8B449D00            <1> 	mov	eax, dword ptr [ebp+ebx*4]
   965 000024BD 8907                <1> 	mov	dword ptr [edi], eax
   966 000024BF C3                  <1> 	ret
   967                              <1> 
   968                              <1> 
   969                              <1> 	%if	0
   970                              <1> ultrate:
   971                              <1> 	mov	eax, dword ptr [edi]
   972                              <1> 	mov	dword ptr [_ultra], eax
   973                              <1>  
   974                              <1> 	mov     eax, dword ptr [edi+1*4]
   975                              <1> 	mov     dword ptr [_ultra1], eax
   976                              <1> 
   977                              <1>         mov     eax, dword ptr [edi+2*4]
   978                              <1>         mov     dword ptr [_ultra2], eax
   979                              <1> 
   980                              <1>         mov     eax, dword ptr [edi+3*4]
   981                              <1>         mov     dword ptr [_ultra3], eax
   982                              <1> 
   983                              <1>         mov     eax, dword ptr [edi+4*4]
   984                              <1>         mov     dword ptr [_ultra4], eax
   985                              <1> 
   986                              <1>         mov     eax, dword ptr [edi+5*4]
   987                              <1>         mov     dword ptr [_ultra5], eax
   988                              <1> 
   989                              <1>         mov     eax, dword ptr [edi+6*4]
   990                              <1>         mov     dword ptr [_ultra6], eax
   991                              <1> 
   992                              <1>         mov     eax, dword ptr [edi+7*4]
   993                              <1>         mov     dword ptr [_ultra7], eax
   994                              <1> 
   995                              <1> 	ret
   996                              <1> 
   997                              <1> zultrate:
   998                              <1> 	push	edi
   999                              <1> 	mov	edi, __ZERO
  1000                              <1> 	call	ultrate
  1001                              <1> 	pop	edi
  1002                              <1> 	ret
  1003                              <1> 
  1004                              <1> __ZERO	dd	0, 0, 0, 0, 0, 0, 0, 0
  1005                              <1> 	%endif
    42                                  	%include	"parity.msm"
     1                              <1> _get_parity:
     2 000024C0 8B5D10              <1>         mov     ebx, dword ptr [ebp+A]
     3 000024C3 235D04              <1>         and     ebx, dword ptr [ebp+K]
     4                              <1> _fold_parity:
     5 000024C6 30DF                <1>         xor     bh, bl
     6 000024C8 C1EB08              <1>         shr     ebx, 8
     7 000024CB 30FB                <1>         xor     bl, bh
     8 000024CD C3                  <1>         ret
     9                              <1> 
    43                                  	%include	"margin.msm"
     1                              <1> read_straddle_12b?:
     2                              <1> 
     3 000024CE F6C101              <1> 	test	cl, 1				; 4 words? You are here because
     4 000024D1 7534                <1> 	jnz	split_read4w			; offset is within last 3 of page
     5                              <1> 						; 2 words then
     6 000024D3 81FEFF0F0000        <1> 	cmp	esi, 0FFFh			; starting @ last word of page?
     7 000024D9 722B                <1> 	jb	readout				; not so, go ahead with burst read
     8                              <1> 
     9                              <1> split_read2w:
    10                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
    11 000024DB 0F7EFE              <1> 	movd	esi, mm7
    12                              <1> 
    13 000024DE 893C24              <1> 	mov	dword ptr [esp], edi		; delete 1st return address + save EA
    14 000024E1 89F8                <1> 	mov	eax, edi			; recover EA
    15 000024E3 30C9                <1> 	xor	cl, cl				; request 1 word
    16 000024E5 E87FDEFFFF          <1> 	call	_bus_read			;
    17 000024EA 870424              <1> 	xchg	eax, dword ptr [esp]		; save 1st word read + load updated EA
    18 000024ED 40                  <1> 	inc	eax				; advance EA onto next page
    19 000024EE 30C9                <1> 	xor	cl, cl				; request 1 word
    20 000024F0 E874DEFFFF          <1> 	call	_bus_read			; read new page or block
    21 000024F5 89C3                <1> 	mov	ebx, eax
    22 000024F7 58                  <1> 	pop	eax				; recover 1st read word
    23 000024F8 C3                  <1> 	ret					; return to caller of operand_read
    24                              <1> 
    25                              <1> read_straddle_18b?:
    26 000024F9 F6C101              <1> 	test	cl, 1				; 4 words? You are here because 
    27 000024FC 7509                <1> 	jnz	split_read4w			; offset is within last 3 of of bank
    28                              <1> 						; 2 words then
    29 000024FE 81FEFFFF0300        <1> 	cmp	esi, 0003FFFFh			; starting @ last word of bank?
    30 00002504 73D5                <1> 	jnb	split_read2w			; otherwise fall thru to burst read
    31                              <1> 
    32                              <1> readout:
    33 00002506 C3                  <1> 	ret					; burst read in order
    34                              <1> 
    35                              <1> split_read4w:					; write EA over stack top return address
    36                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
    37 00002507 0F7EFE              <1> 	movd	esi, mm7
    38                              <1> 
    39 0000250A 893C24              <1> 	mov	dword ptr [esp], edi		; one or other of these 2-word reads
    40 0000250D 89F8                <1> 	mov	eax, edi			; splits down to 1-word reads
    41 0000250F E807000000          <1> 	call	read2				; when offset is [3F]FFD
    42 00002514 E802000000          <1> 	call	read2				;             or [3F]FFF
    43 00002519 58                  <1> 	pop	eax				;   but not when [3F]FFE
    44 0000251A C3                  <1> 	ret					; return to caller of caller
    45                              <1> 	
    46 0000251B 50                  <1> read2:	push	eax				; EA
    47 0000251C 53                  <1> 	push	ebx				; destination index on stack top
    48 0000251D B106                <1> 	mov	cl, 6				; ask bus for 2 words
    49 0000251F E845DEFFFF          <1> 	call	_bus_read			; replaces eax and ebx
    50 00002524 871C24              <1> 	xchg	ebx, dword ptr [esp]		; get destination index up again
    51 00002527 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax	; write 1st result word
    52 0000252B 58                  <1> 	pop	eax				; recover 2nd result word
    53 0000252C 89449D04            <1> 	mov	dword ptr [ebp+ebx*4+1*4], eax	; write 2nd result word
    54 00002530 58                  <1> 	pop	eax				; EA
    55 00002531 83C002              <1> 	add	eax, 2
    56 00002534 83C302              <1> 	add	ebx, 2
    57 00002537 C3                  <1> 	ret	
    58                              <1> 
    44                                  	%include	"margin_w.msm"
     1                              <1> write_straddle_12b?:				; multiword write request
     2                              <1> write_straddle12b?:				; in last 3 words of block
     3 00002538 F6C101              <1> 	test	cl, 1				; 4-word write request?
     4 0000253B 7539                <1> 	jnz	split_write4w			;
     5 0000253D 81FEFF0F0000        <1> 	cmp	esi, 0FFFH			; 2 words then. In last word?
     6 00002543 7230                <1> 	jb	writeout			; no
     7                              <1> 						; yes
     8                              <1> split_write2w:
     9                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
    10 00002545 0F7EFE              <1> 	movd	esi, mm7
    11                              <1> 
    12 00002548 891C24              <1> 	mov	dword ptr [esp], ebx		; not returning to there
    13 0000254B 57                  <1> 	push	edi				; esp -> saved eax [ea], saved ebx
    14 0000254C 89F8                <1> 	mov	eax, edi			; place ea in eax
    15 0000254E 30C9                <1> 	xor	cl, cl				; request 1-word write
    16 00002550 8B5C9D00            <1> 	mov	ebx, dword ptr [ebp+ebx*4]	; data from register array
    17 00002554 E8ADDFFFFF          <1> 	call	bus_write
    18 00002559 58                  <1> 	pop	eax				; retrieve ea from stack
    19 0000255A 5B                  <1> 	pop	ebx				; retrieve register index
    20 0000255B 40                  <1> 	inc	eax				; advance ea to next block
    21 0000255C 8B5C9D04            <1> 	mov	ebx, dword ptr [ebp+ebx*4+4]	; data from register array
    22 00002560 30C9                <1> 	xor	cl, cl				; request 1-word write
    23 00002562 E89FDFFFFF          <1> 	call	bus_write
    24 00002567 C3                  <1> 	ret					; return caller of caller
    25                              <1> 
    26                              <1> write_straddle_18b?:				; multiword write request
    27                              <1> write_straddle18b?:				; in last 3 words of block
    28 00002568 F6C101              <1> 	test	cl, 1				; 4 words?
    29 0000256B 7509                <1> 	jnz	split_write4w
    30 0000256D 81FEFFFF0300        <1> 	cmp	esi, 0003FFFFh			; 2 words then. In last word?
    31 00002573 73D0                <1> 	jnb	split_write2w			; yes
    32                              <1> 						; no
    33                              <1> writeout:
    34 00002575 C3                  <1> 	ret					; return to burst write
    35                              <1> 
    36                              <1> split_write4w:
    37                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
    38 00002576 0F7EFE              <1> 	movd	esi, mm7
    39                              <1> 
    40 00002579 893C24              <1> 	mov	dword ptr [esp], edi		; return address at stack top not used
    41 0000257C 89F8                <1> 	mov	eax, edi			; copy ea
    42 0000257E E807000000          <1> 	call	write2				; request 2 writes word pairs
    43 00002583 E802000000          <1> 	call	write2				; if 1 of them straddles it splits again
    44 00002588 58                  <1> 	pop	eax				; this is ea
    45 00002589 C3                  <1> 	ret					; return to caller of caller
    46                              <1> 
    47                              <1> 
    48 0000258A B106                <1> write2:	mov	cl, 6				; request 2-word bus write
    49 0000258C 50                  <1> 	push	eax				; save ea
    50 0000258D 53                  <1> 	push	ebx				; save register array index
    51 0000258E E873DFFFFF          <1> 	call	bus_write			; send write pair request
    52 00002593 5B                  <1> 	pop	ebx				; retrieve register index
    53 00002594 58                  <1> 	pop	eax				; and ea
    54 00002595 83C302              <1> 	add	ebx, 2				; update register index
    55 00002598 83C002              <1> 	add	eax, 2				; and ea
    56 0000259B C3                  <1> 	ret
    45                                  	%include	"rex.msm"
     1                              <1> 
     2                              <1> _rextable_1
     2          ******************  <1>  warning: label alone on a line without a colon might be in error [-w+orphan-labels]
     3 0000259C 000000000000000000- <1> 	dd	0, 0, 0, 0,		r_sa, r_sb, r_z, 0
     3 000025A5 00000000000000-     <1>
     3 000025AC [D9280000]-         <1>
     3 000025B0 [D1280000]-         <1>
     3 000025B4 [F2280000]00000000  <1>
     4 000025BC 000000000000000000- <1> 	dd	0, 0, 0, 0,		r_la, r_lb, r_tz, r_tp
     4 000025C5 00000000000000-     <1>
     4 000025CC [0C290000]-         <1>
     4 000025D0 [04290000]-         <1>
     4 000025D4 [9A280000]-         <1>
     4 000025D8 [B5280000]          <1>
     5 000025DC 0000000000000000-   <1> 	dd	0, 0, r_or, r_orB,	r_and, r_andB, r_xor, r_xorB
     5 000025E4 [29290000]-         <1>
     5 000025E8 [21290000]-         <1>
     5 000025EC [4A290000]-         <1>
     5 000025F0 [42290000]-         <1>
     5 000025F4 [6B290000]-         <1>
     5 000025F8 [63290000]          <1>
     6 000025FC [8C290000]-         <1> 	dd	r_aa, r_ab, r_ana, r_anb, r_m, r_mf, r_d, 0
     6 00002600 [84290000]-         <1>
     6 00002604 [A9290000]-         <1>
     6 00002608 [A1290000]-         <1>
     6 0000260C [E5290000]-         <1>
     6 00002610 [C4290000]-         <1>
     6 00002614 [8A2A0000]00000000  <1>
     7                              <1> 
     8                              <1> _rextable_6
     8          ******************  <1>  warning: label alone on a line without a colon might be in error [-w+orphan-labels]
     9 0000261C [C82A0000]-         <1> 	dd	r_sar, r_sbr, r_dsr, 0, r_sal, r_sbl, r_dsl, 0
     9 00002620 [C02A0000]-         <1>
     9 00002624 [E32A0000]00000000- <1>
     9 0000262C [0E2B0000]-         <1>
     9 00002630 [062B0000]-         <1>
     9 00002634 [292B0000]00000000  <1>
    10 0000263C [542B0000]-         <1> 	dd	r_rar, r_rbr, r_drr, 0, r_ral, r_rbl, r_drl, 0
    10 00002640 [4C2B0000]-         <1>
    10 00002644 [6D2B0000]00000000- <1>
    10 0000264C [982B0000]-         <1>
    10 00002650 [902B0000]-         <1>
    10 00002654 [B12B0000]00000000  <1>
    11 0000265C [DC2B0000]-         <1> 	dd	r_saa, r_sba, r_dsa, 0, 0, 0, 0, 0
    11 00002660 [D42B0000]-         <1>
    11 00002664 [F82B0000]00000000- <1>
    11 0000266C 000000000000000000- <1>
    11 00002675 00000000000000      <1>
    12 0000267C 000000000000000000- <1> 	dd	0, 0, 0, 0, 		0, 0, 0, 0
    12 00002685 000000000000000000- <1>
    12 0000268E 000000000000000000- <1>
    12 00002697 0000000000          <1>
    13                              <1> 
    14                              <1> _rextable_7
    14          ******************  <1>  warning: label alone on a line without a colon might be in error [-w+orphan-labels]
    15 0000269C 000000000000000000- <1> 	dd	0, 0, 0, 0,		0, 0, 0, 0
    15 000026A5 000000000000000000- <1>
    15 000026AE 000000000000000000- <1>
    15 000026B7 0000000000          <1>
    16 000026BC [1B2C0000]-         <1> 	dd	r_qs, r_ql, r_dte, 0,	r_fa, r_fan, r_fm, r_fd
    16 000026C0 [2A2C0000]-         <1>
    16 000026C4 [392C0000]00000000- <1>
    16 000026CC [6A280000]-         <1>
    16 000026D0 [76280000]-         <1>
    16 000026D4 [82280000]-         <1>
    16 000026D8 [8E280000]          <1>
    17 000026DC 000000000000000000- <1> 	dd	0, 0, 0, 0, 		0, r_mta, 0, 0
    17 000026E5 000000000000000000- <1>
    17 000026EE 0000[4F2C0000]0000- <1>
    17 000026F6 000000000000        <1>
    18 000026FC [6D2C0000]-         <1> 	dd	r_ds, r_dl, r_da, r_dan, 0, 0, 0, 0
    18 00002700 [7C2C0000]-         <1>
    18 00002704 [AF2C0000]-         <1>
    18 00002708 [952C0000]00000000- <1>
    18 00002710 000000000000000000- <1>
    18 00002719 000000              <1>
    19                              <1> 
    20                              <1> 
    21 0000271C F686A204000080      <1> _rex:	test	byte ptr [esi+PSR+2], 128
    22 00002723 0F88D4000000        <1> 	js	near _rex_z				; ISRs can't do this
    23                              <1> 
    24 00002729 E82DDFFFFF          <1> 	call	memory_read				; ea -> instruction for repeat	
    25                              <1> 
    26                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]	; retrieve smp core ->
    27 0000272E 0F7EFE              <1> 	movd	esi, mm7
    28                              <1> 
    29 00002731 898678040000        <1> 	mov	dword ptr [esi+REGISTER+286*4], eax	; save instruction word
    30 00002737 E8C1D9FFFF          <1> 	call	__ea					; get initial ea of repeated  instruction
    31 0000273C 0FB6DD              <1> 	movzx	ebx, ch					; spin-off is opcode index in ch
    32                              <1> 							; and operand type in cl
    33 0000273F 80F906              <1> 	cmp	cl, 6
    34 00002742 7214                <1> 	jb	_rex_itable1
    35 00002744 7709                <1> 	ja	_rex_itable7
    36                              <1> 							; instruction list 6
    37 00002746 8B1C9D[1C260000]    <1> 	mov	ebx, dword ptr [_rextable_6+ebx*4]	; shifts and jumps
    38 0000274D EB10                <1> 	jmp	_rex_evaluate
    39                              <1> 
    40                              <1> _rex_itable7:						; instruction list 7
    41 0000274F 8B1C9D[9C260000]    <1> 	mov	ebx, dword ptr [_rextable_7+ebx*4]	; large arithmetic
    42 00002756 EB07                <1> 	jmp	_rex_evaluate
    43                              <1> 
    44                              <1> _rex_itable1:						; instruction list 1
    45 00002758 8B1C9D[9C250000]    <1> 	mov	ebx, dword ptr [_rextable_1+ebx*4]	; single integer arithmetic
    46                              <1> 
    47                              <1> _rex_evaluate:
    48 0000275F 21DB                <1> 	and	ebx, ebx				; instruction for repeat execute?
    49 00002761 0F8496000000        <1> 	jz	near _rex_z				; no
    50 00002767 899E74040000        <1> 	mov	dword ptr [esi+REGISTER+285*4], ebx	; yes: save execution logic pointer
    51                              <1> 
    52                              <1> 							; if repeat instruction is indexed:
    53                              <1> 							; quick lookup tag for index increment
    54 0000276D C78670040000000000- <1> 	mov	dword ptr [esi+REGISTER+284*4], 0		; default no index register referenced
    54 00002776 00                  <1>
    55 00002777 8B9E78040000        <1> 	mov	ebx, dword ptr [esi+REGISTER+286*4]	; identify any index register tag
    56 0000277D 6621DB              <1> 	and	bx, bx					; in the instruction word
    57 00002780 791A                <1> 	jns	_rex_ready				; by testing bit 15
    58 00002782 66C1EB0C            <1> 	shr	bx, 12
    59                              <1> 							; must be > indirection tags *B0+ *B1+
    60 00002786 80FB0A              <1> 	cmp	bl, 10					; pointers in storage not incremented
    61 00002789 7211                <1> 	jb	_rex_ready				; index registers may increment
    62 0000278B 80FB0E              <1> 	cmp	bl, 14
    63 0000278E 7303                <1> 	jnb	_rex_indexed				; [   fp sp ]  registers   [ 14 15 ]
    64 00002790 80E307              <1> 	and	bl, 7					; [ x y a b ]  registers [ 2 3 4 5 ]
    65                              <1> 
    66                              <1> _rex_indexed:
    67 00002793 83E30F              <1> 	and	ebx, 15					; make 32-bit index value
    68 00002796 899E70040000        <1> 	mov	dword ptr [esi+REGISTER+284*4], ebx	; write quick lookup
    69                              <1> 
    70                              <1> _rex_ready:
    71 0000279C 8B5E34              <1> 	mov	ebx, dword ptr [esi+REGISTER+Q]		; default target register [ q ] ->	
    72 0000279F FF9674040000        <1> 	call	dword ptr [esi+REGISTER+285*4]		; execute logic ->
    73                              <1> 
    74 000027A5 8B8670040000        <1> 	mov	eax, dword ptr [esi+REGISTER+284*4]	; index register tag?
    75 000027AB 6621C0              <1> 	and	ax, ax
    76 000027AE 7417                <1> 	jz	_rex_count				; no
    77                              <1> 
    78 000027B0 8B4E5C              <1> 	mov	ecx, dword ptr [esi+REGISTER+WDATA]
    79 000027B3 81E1FFFFFF00        <1> 	and	ecx, 00FFFFFFh				; index register increment configured?
    80 000027B9 740C                <1> 	jz	_rex_count				; no
    81                              <1> 
    82 000027BB 030C86              <1> 	add	ecx, dword ptr [esi+REGISTER+eax*4]	; calculate index + increment
    83 000027BE 81E1FFFFFF00        <1> 	and	ecx, 00FFFFFFh				; 
    84 000027C4 890C86              <1> 	mov	dword ptr [esi+REGISTER+eax*4], ecx	; write back to tagged index register
    85                              <1> 
    86                              <1> _rex_count:
    87 000027C7 8B4650              <1> 	mov	eax, dword ptr [esi+REGISTER+RDATAC]
    88 000027CA 48                  <1> 	dec	eax
    89 000027CB 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
    90                              <1> 
    91 000027D0 894650              <1> 	mov	dword ptr [esi+REGISTER+RDATAC], eax
    92 000027D3 A900008000          <1> 	test	eax, 00800000h
    93 000027D8 7523                <1> 	jnz	_rex_z					; reached -1 end
    94                              <1> 
    95 000027DA 66F78694040000E0FF  <1> 	test	word ptr [esi+INDICATION], EXTERNAL_INDICATIONS
    96 000027E3 7405                <1> 	jz	_rex_along
    97                              <1> 
    98 000027E5 83C2FC              <1> 	add	edx, -4					; restart after
    99 000027E8 EB13                <1> 	jmp	_rex_z					; yielding to interrupt
   100                              <1> 
   101                              <1> _rex_along:
   102 000027EA 8B8678040000        <1> 	mov	eax, [esi+REGISTER+286*4]			; instruction encoding
   103 000027F0 E808D9FFFF          <1> 	call	__ea
   104 000027F5 8B9E74040000        <1> 	mov	ebx, [esi+REGISTER+285*4]			; command pointer
   105 000027FB EB9F                <1> 	jmp	_rex_ready
   106 000027FD C3                  <1> _rex_z:	ret
   107                              <1> 
   108                              <1> _rex_prime_final_count:
   109 000027FE F7455000008000      <1> 	test	dword ptr [ebp+RDATAC], 00800000h
   110 00002805 7422                <1> 	jz	_rex_primed
   111 00002807 8B5D58              <1> 	mov	ebx, dword ptr [ebp+WDATAC]
   112 0000280A 895D50              <1> 	mov	dword ptr [ebp+RDATAC], ebx
   113 0000280D C3                  <1> 	ret
   114                              <1> 
   115                              <1> _rex_prime:
   116 0000280E F7455000008000      <1> 	test	dword ptr [ebp+RDATAC], 00800000h
   117 00002815 7412                <1> 	jz	_rex_primed
   118 00002817 8B5D58              <1> 	mov	ebx, dword ptr [ebp+WDATAC]
   119 0000281A 895D50              <1> 	mov	dword ptr [ebp+RDATAC], ebx
   120 0000281D 8B5D3C              <1> 	mov	ebx, dword ptr [ebp+S_P]
   121 00002820 81E3FFFFFF00        <1> 	and	ebx, 00FFFFFFh
   122 00002826 895D34              <1> 	mov	dword ptr [ebp+Q], ebx
   123                              <1> _rex_primed:
   124 00002829 C3                  <1> 	ret
   125                              <1> 
   126                              <1> _rex_accumulate:
   127                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
   128 0000282A 0F7EFE              <1> 	movd	esi, mm7
   129                              <1> 
   130 0000282D 8B5E54              <1> 	mov	ebx, dword ptr [esi+RDATA]
   131 00002830 035D34              <1> 	add	ebx, dword ptr [ebp+Q]
   132 00002833 81E3FFFFFF00        <1> 	and	ebx, 00FFFFFFh
   133 00002839 895D34              <1> 	mov	dword ptr [ebp+Q], ebx
   134 0000283C C3                  <1> 	ret
   135                              <1> 
   136                              <1> _rex_chex_127:
   137 0000283D E8CCFFFFFF          <1> 	call	_rex_prime
   138 00002842 83FB7F              <1> 	cmp	ebx, 127
   139 00002845 7618                <1> 	jna	_rex_chex_low
   140 00002847 EB1C                <1> 	jmp	_rex_chexit
   141                              <1> 
   142                              <1> _rex_chex_126:
   143 00002849 E8C0FFFFFF          <1> 	call	_rex_prime
   144 0000284E 83FB7E              <1> 	cmp	ebx, 126
   145 00002851 760C                <1> 	jna	_rex_chex_low
   146 00002853 EB10                <1> 	jmp	_rex_chexit
   147                              <1> 
   148                              <1> _rex_chex_124:
   149 00002855 E8B4FFFFFF          <1> 	call	_rex_prime
   150 0000285A 83FB7C              <1> 	cmp	ebx, 124
   151 0000285D 7706                <1> 	ja	_rex_chexit
   152                              <1> _rex_chex_low:
   153 0000285F 83FB18              <1> 	cmp	ebx, 24
   154 00002862 7201                <1> 	jb	_rex_chexit
   155 00002864 C3                  <1> 	ret
   156                              <1> 
   157                              <1> _rex_chexit:
   158 00002865 E999E6FFFF          <1> 	jmp	guard_ii_authority
   159                              <1> 
   160                              <1> ;	eax = EA
   161                              <1> ;	q -> target register selected
   162                              <1> 
   163 0000286A E8E6FFFFFF          <1> r_fa:	call	_rex_chex_124
   164 0000286F E85AFBFFFF          <1> 	call	_far
   165 00002874 EBB4                <1> 	jmp	_rex_accumulate
   166                              <1> 
   167 00002876 E8DAFFFFFF          <1> r_fan:	call	_rex_chex_124
   168 0000287B E869FBFFFF          <1> 	call	_fanr
   169 00002880 EBA8                <1> 	jmp	_rex_accumulate
   170                              <1> 
   171 00002882 E8CEFFFFFF          <1> r_fm:	call	_rex_chex_124
   172 00002887 E878FBFFFF          <1> 	call	_fmr
   173 0000288C EB9C                <1> 	jmp	_rex_accumulate
   174                              <1> 
   175 0000288E E8C2FFFFFF          <1> r_fd:	call	_rex_chex_124
   176 00002893 E88DFBFFFF          <1> 	call	_fdr
   177 00002898 EB90                <1> 	jmp	_rex_accumulate
   178                              <1> 
   179 0000289A E85FFFFFFF          <1> r_tz:	call	_rex_prime_final_count
   180 0000289F 80F904              <1> 	cmp	cl, 4			; may not be [ i xi ]
   181 000028A2 732C                <1> 	jnb	r_noskip		; but pointers are updated on no_op
   182 000028A4 E8A8DAFFFF          <1> 	call	_operand_read
   183 000028A9 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   184 000028AE 7520                <1> 	jnz	r_noskip
   185                              <1> 
   186 000028B0 E9AE030000          <1> 	jmp	r_skipout		; stop search repeat
   187                              <1> 
   188 000028B5 E844FFFFFF          <1> r_tp:	call	_rex_prime_final_count
   189 000028BA 80F904              <1> 	cmp	cl, 4			; may not be [ i xi ]
   190 000028BD 7311                <1> 	jnb	r_noskip		; but pointers are updated on no_op
   191 000028BF E88DDAFFFF          <1> 	call	_operand_read
   192 000028C4 A900008000          <1> 	test	eax, 00800000h
   193 000028C9 7505                <1> 	jnz	r_noskip
   194                              <1> 
   195 000028CB E993030000          <1> 	jmp	r_skipout		; stop search repeat
   196                              <1> 
   197 000028D0 C3                  <1> r_noskip:	ret
   198                              <1> 
   199 000028D1 E873FFFFFF          <1> r_sb:	call	_rex_chex_126
   200 000028D6 43                  <1> 	inc	ebx			; starboard lane
   201 000028D7 EB05                <1> 	jmp	r_s
   202 000028D9 E85FFFFFFF          <1> r_sa:	call	_rex_chex_127
   203 000028DE 80F904              <1> r_s:	cmp	cl, 4			; may not be [ i xi ]
   204 000028E1 7309                <1> 	jnb	r_no_op_s		; but pointers are updated 
   205 000028E3 8B5C9D00            <1> 	mov	ebx, dword ptr [ebp+ebx*4]
   206 000028E7 E8F7DBFFFF          <1> 	call	_operand_write
   207                              <1> r_no_op_s:
   208 000028EC E939FFFFFF          <1> 	jmp	_rex_accumulate
   209 000028F1 C3                  <1> 	ret
   210                              <1> 
   211 000028F2 E807FFFFFF          <1> r_z:	call	_rex_prime_final_count
   212 000028F7 80F904              <1> 	cmp	cl, 4			; may not be [ i xi ]
   213 000028FA 7307                <1> 	jnb	r_no_op_z		; but pointers are updated
   214 000028FC 31DB                <1> 	xor	ebx, ebx
   215 000028FE E9E0DBFFFF          <1> 	jmp	_operand_write
   216                              <1> r_no_op_z:
   217 00002903 C3                  <1> 	ret
   218                              <1> 
   219 00002904 E840FFFFFF          <1> r_lb:	call	_rex_chex_126
   220 00002909 43                  <1> 	inc	ebx			; starboard lane
   221 0000290A EB05                <1> 	jmp	r_l
   222 0000290C E82CFFFFFF          <1> r_la:	call	_rex_chex_127
   223 00002911 53                  <1> r_l:	push	ebx
   224 00002912 E83ADAFFFF          <1> 	call	_operand_read
   225 00002917 5B                  <1> 	pop	ebx
   226 00002918 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   227 0000291C E909FFFFFF          <1> 	jmp	_rex_accumulate
   228                              <1> 
   229 00002921 E823FFFFFF          <1> r_orB:	call	_rex_chex_126
   230 00002926 43                  <1> 	inc	ebx			; starboard lane
   231 00002927 EB05                <1> 	jmp	r_OR
   232 00002929 E80FFFFFFF          <1> r_or:	call	_rex_chex_127
   233 0000292E 53                  <1> r_OR:	push	ebx
   234 0000292F E81DDAFFFF          <1> 	call	_operand_read
   235 00002934 5B                  <1> 	pop	ebx
   236 00002935 0B449D00            <1> 	or	eax, dword ptr [ebp+ebx*4]
   237 00002939 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   238 0000293D E9E8FEFFFF          <1> 	jmp	_rex_accumulate
   239                              <1> 
   240 00002942 E802FFFFFF          <1> r_andB:	call	_rex_chex_126
   241 00002947 43                  <1> 	inc	ebx		; starboard lane
   242 00002948 EB05                <1> 	jmp	r_AND
   243 0000294A E8EEFEFFFF          <1> r_and:	call	_rex_chex_127
   244 0000294F 53                  <1> r_AND:	push	ebx
   245 00002950 E8FCD9FFFF          <1> 	call	_operand_read
   246 00002955 5B                  <1> 	pop	ebx
   247 00002956 23449D00            <1> 	and	eax, dword ptr [ebp+ebx*4]
   248 0000295A 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   249 0000295E E9C7FEFFFF          <1> 	jmp	_rex_accumulate
   250                              <1> 
   251 00002963 E8E1FEFFFF          <1> r_xorB:	call	_rex_chex_126
   252 00002968 43                  <1> 	inc	ebx		; starboard lane
   253 00002969 EB05                <1> 	jmp	r_XOR
   254 0000296B E8CDFEFFFF          <1> r_xor:	call	_rex_chex_127
   255 00002970 53                  <1> r_XOR:	push	ebx
   256 00002971 E8DBD9FFFF          <1> 	call	_operand_read
   257 00002976 5B                  <1> 	pop	ebx
   258 00002977 33449D00            <1> 	xor	eax, dword ptr [ebp+ebx*4]
   259 0000297B 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   260 0000297F E9A6FEFFFF          <1> 	jmp	_rex_accumulate
   261                              <1> 
   262 00002984 E8C0FEFFFF          <1> r_ab:	call	_rex_chex_126
   263 00002989 43                  <1> 	inc	ebx		; starboard lane
   264 0000298A EB05                <1> 	jmp	r_a
   265 0000298C E8ACFEFFFF          <1> r_aa:	call	_rex_chex_127
   266 00002991 53                  <1> r_a:	push	ebx
   267 00002992 E8BAD9FFFF          <1> 	call	_operand_read
   268 00002997 5F                  <1> 	pop	edi
   269 00002998 0344BD00            <1> 	add	eax, dword ptr [ebp+edi*4]
   270 0000299C E92F030000          <1> 	jmp	r_store_carry
   271                              <1> 
   272 000029A1 E8A3FEFFFF          <1> r_anb:	call	_rex_chex_126
   273 000029A6 43                  <1> 	inc	ebx		; starboard lane
   274 000029A7 EB05                <1> 	jmp	r_an
   275 000029A9 E88FFEFFFF          <1> r_ana:	call	_rex_chex_127
   276 000029AE 53                  <1> r_an:	push	ebx
   277 000029AF E89DD9FFFF          <1> 	call	_operand_read
   278 000029B4 5F                  <1> 	pop	edi
   279 000029B5 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   280 000029BA 40                  <1> 	inc	eax
   281 000029BB 0344BD00            <1> 	add	eax, dword ptr [ebp+edi*4]
   282 000029BF E90C030000          <1> 	jmp	r_store_carry
   283                              <1> 
   284 000029C4 E874FEFFFF          <1> r_mf:	call    _rex_chex_127
   285 000029C9 52                  <1> 	push	edx
   286 000029CA 53                  <1> 	push	ebx
   287 000029CB E881D9FFFF          <1> 	call	_operand_read
   288 000029D0 5F                  <1> 	pop	edi
   289 000029D1 0FAF44BD00          <1> 	imul	eax, dword ptr [ebp+edi*4]
   290 000029D6 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   291 000029DB 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
   292 000029DF 5A                  <1> 	pop	edx
   293 000029E0 E945FEFFFF          <1> 	jmp	_rex_accumulate
   294                              <1> 
   295                              <1> ; use the platform unsigned multiply
   296                              <1> ; work in positive magnitude
   297                              <1> ; adjust the final sign after offset-adding products
   298                              <1> 
   299 000029E5 E85FFEFFFF          <1> r_m:	call	_rex_chex_126
   300 000029EA 52                  <1> 	push	edx
   301 000029EB 53                  <1> 	push	ebx			; register stack cursor
   302 000029EC E860D9FFFF          <1> 	call	_operand_read
   303 000029F1 5F                  <1> 	pop	edi			; recover register stack cursor
   304                              <1> 
   305 000029F2 31C9                <1> 	xor	ecx, ecx		; final sign
   306 000029F4 A900008000          <1> 	test	eax, 00800000h		;
   307 000029F9 740D                <1> 	jz	r_msigu?		; negative multiplier?
   308 000029FB F7D1                <1> 	not	ecx			; final sign reverse
   309 000029FD 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   310 00002A02 40                  <1> 	inc	eax			; 2s complement
   311 00002A03 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   312                              <1> 
   313                              <1> r_msigu?:
   314 00002A08 89C3                <1> 	mov	ebx, eax		; multiplier 2b used twice
   315 00002A0A 8B44BD00            <1> 	mov	eax, dword ptr [ebp+edi*4]
   316 00002A0E A900008000          <1> 	test	eax, 00800000h		; multiply high order part 1st
   317 00002A13 7426                <1> 	jz	r_mgoferit_yall
   318                              <1> 
   319 00002A15 F7D1                <1> 	not	ecx			; final sign reverse
   320 00002A17 8B54BD04            <1> 	mov	edx, dword ptr [ebp+edi*4+4]
   321 00002A1B 81F2FFFFFF00        <1> 	xor	edx, 00FFFFFFh
   322 00002A21 42                  <1> 	inc	edx			; 2s complement
   323 00002A22 C1C208              <1> 	rol	edx, 8
   324 00002A25 0FB6F2              <1> 	movzx	esi, dl
   325 00002A28 C1EA08              <1> 	shr	edx, 8
   326 00002A2B 8954BD04            <1> 	mov	dword ptr [ebp+edi*4+4], edx
   327 00002A2F 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh		; ms register long multiplicand
   328 00002A34 01F0                <1> 	add	eax, esi
   329 00002A36 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   330                              <1> 
   331                              <1> r_mgoferit_yall:
   332 00002A3B F7E3                <1> 	mul	ebx			; multiply high order part
   333 00002A3D 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax	; save lower half of product
   334 00002A41 8B44BD04            <1> 	mov	eax, dword ptr [ebp+edi*4+4]	; multiply low order part
   335 00002A45 F7E3                <1> 	mul	ebx
   336 00002A47 C1E208              <1> 	shl	edx, 8			; 8 bits of eax must shift up to edx
   337 00002A4A C1C008              <1> 	rol	eax, 8
   338 00002A4D 88C2                <1> 	mov	dl, al
   339 00002A4F C1E808              <1> 	shr	eax, 8			; leaving 8 zeros in eax high end
   340 00002A52 0354BD00            <1> 	add	edx, dword ptr [ebp+edi*4]	; add2 lower half of 1st product
   341 00002A56 21C9                <1> 	and	ecx, ecx		; final sign?
   342 00002A58 7917                <1> 	jns	r_m_writeback
   343                              <1> 
   344 00002A5A 81F2FFFFFF00        <1> 	xor	edx, 00FFFFFFh
   345 00002A60 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   346 00002A65 40                  <1> 	inc	eax			; 2s complement
   347 00002A66 C1C008              <1> 	rol	eax, 8			; carried out single bit?
   348 00002A69 0FB6F0              <1> 	movzx	esi, al			; must add to edx
   349 00002A6C C1E808              <1> 	shr	eax, 8
   350 00002A6F 01F2                <1> 	add	edx, esi
   351                              <1> 
   352                              <1> r_m_writeback:
   353 00002A71 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   354 00002A76 81E2FFFFFF00        <1> 	and	edx, 00FFFFFFh
   355 00002A7C 8944BD04            <1> 	mov	dword ptr [ebp+edi*4+4], eax	
   356 00002A80 8954BD00            <1> 	mov	dword ptr [ebp+edi*4], edx
   357 00002A84 5A                  <1> 	pop	edx
   358 00002A85 E9A0FDFFFF          <1> 	jmp	_rex_accumulate
   359                              <1> 
   360 00002A8A E8BAFDFFFF          <1> r_d:	call	_rex_chex_126
   361 00002A8F 89DF                <1> 	mov	edi, ebx		; register cursor
   362 00002A91 E828EDFFFF          <1> 	call	_divide
   363 00002A96 895CBD04            <1> 	mov	dword ptr [ebp+edi*4+4], ebx
   364 00002A9A 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
   365                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
   366 00002A9E 0F7EFE              <1> 	movd	esi, mm7
   367                              <1> 
   368 00002AA1 F686A004000008      <1> 	test	byte ptr [esi+PSR], FP_R
   369 00002AA8 0F847CFDFFFF        <1> 	jz	_rex_accumulate
   370 00002AAE 83FF7D              <1> 	cmp	edi, 125
   371 00002AB1 0F8773FDFFFF        <1> 	ja	_rex_accumulate
   372 00002AB7 894CBD08            <1> 	mov	dword ptr [ebp+edi*4+8], ecx
   373 00002ABB E96AFDFFFF          <1> r_dnor:	jmp	_rex_accumulate
   374                              <1> 
   375 00002AC0 E884FDFFFF          <1> r_sbr:	call	_rex_chex_126
   376 00002AC5 43                  <1> 	inc	ebx		; starboard lane
   377 00002AC6 EB05                <1> 	jmp	r_lsr
   378 00002AC8 E870FDFFFF          <1> r_sar:	call	_rex_chex_127
   379 00002ACD 88C1                <1> r_lsr	mov	cl, al
   380 00002ACF 8B449D00            <1> 	mov	eax, dword ptr [ebp+ebx*4]
   381 00002AD3 D3E8                <1> 	shr	eax, cl
   382 00002AD5 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   383 00002ADA 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   384 00002ADE E947FDFFFF          <1> 	jmp	_rex_accumulate
   385                              <1> 
   386 00002AE3 E861FDFFFF          <1> r_dsr:	call	_rex_chex_126
   387 00002AE8 88C1                <1> 	mov	cl, al
   388 00002AEA 89DF                <1> 	mov	edi, ebx
   389 00002AEC 8B44BD00            <1> 	mov	eax, dword ptr [ebp+edi*4]
   390 00002AF0 8B5CBD04            <1> 	mov	ebx, dword ptr [ebp+edi*4+4]
   391 00002AF4 E806EEFFFF          <1> 	call	dsr
   392 00002AF9 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
   393 00002AFD 895CBD04            <1> 	mov	dword ptr [ebp+edi*4+4], ebx
   394 00002B01 E924FDFFFF          <1> 	jmp	_rex_accumulate
   395                              <1> 
   396 00002B06 E83EFDFFFF          <1> r_sbl:	call	_rex_chex_126
   397 00002B0B 43                  <1> 	inc	ebx		; starboard lane
   398 00002B0C EB05                <1> 	jmp	r_lsl
   399 00002B0E E82AFDFFFF          <1> r_sal:	call	_rex_chex_127
   400 00002B13 88C1                <1> r_lsl:	mov	cl, al
   401 00002B15 8B449D00            <1> 	mov	eax, dword ptr [ebp+ebx*4]
   402 00002B19 D3E0                <1> 	shl	eax, cl
   403 00002B1B 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   404 00002B20 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   405 00002B24 E901FDFFFF          <1> 	jmp	_rex_accumulate
   406                              <1> 
   407 00002B29 E81BFDFFFF          <1> r_dsl:	call	_rex_chex_126
   408 00002B2E 88C1                <1> 	mov	cl, al
   409 00002B30 89DF                <1> 	mov	edi, ebx
   410 00002B32 8B44BD00            <1> 	mov	eax, dword ptr [ebp+edi*4]
   411 00002B36 8B5CBD04            <1> 	mov	ebx, dword ptr [ebp+edi*4+4]
   412 00002B3A E8F5EDFFFF          <1> 	call	dsl
   413 00002B3F 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
   414 00002B43 895CBD04            <1> 	mov	dword ptr [ebp+edi*4+4], ebx
   415 00002B47 E9DEFCFFFF          <1> 	jmp	_rex_accumulate
   416                              <1> 
   417 00002B4C E8F8FCFFFF          <1> r_rbr:	call	_rex_chex_126
   418 00002B51 43                  <1> 	inc	ebx		; starboard lane
   419 00002B52 EB05                <1> 	jmp	r_rr
   420 00002B54 E8E4FCFFFF          <1> r_rar:	call	_rex_chex_127
   421 00002B59 89DF                <1> r_rr:	mov	edi, ebx
   422 00002B5B 8B5CBD00            <1> 	mov	ebx, dword ptr [ebp+edi*4]
   423 00002B5F E83DEEFFFF          <1> 	call	rr
   424 00002B64 895CBD00            <1> 	mov	dword ptr [ebp+edi*4], ebx
   425 00002B68 E9BDFCFFFF          <1> 	jmp	_rex_accumulate
   426                              <1> 
   427 00002B6D E8D7FCFFFF          <1> r_drr:	call	_rex_chex_126
   428 00002B72 88C1                <1> 	mov	cl, al
   429 00002B74 89DF                <1> 	mov	edi, ebx
   430 00002B76 8B44BD00            <1> 	mov	eax, dword ptr [ebp+edi*4]
   431 00002B7A 8B5CBD04            <1> 	mov	ebx, dword ptr [ebp+edi*4+4]
   432 00002B7E E86CEEFFFF          <1> 	call	drr
   433 00002B83 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
   434 00002B87 895CBD04            <1> 	mov	dword ptr [ebp+edi*4+4], ebx
   435 00002B8B E99AFCFFFF          <1> 	jmp	_rex_accumulate
   436                              <1> 
   437 00002B90 E8B4FCFFFF          <1> r_rbl:	call	_rex_chex_126
   438 00002B95 43                  <1> 	inc	ebx		; starboard lane
   439 00002B96 EB05                <1> 	jmp	r_rl
   440 00002B98 E8A0FCFFFF          <1> r_ral:	call	_rex_chex_127
   441 00002B9D 89DF                <1> r_rl:	mov	edi, ebx
   442 00002B9F 8B5CBD00            <1> 	mov	ebx, dword ptr [ebp+edi*4]
   443 00002BA3 E81FEEFFFF          <1> 	call	rl
   444 00002BA8 895CBD00            <1> 	mov	dword ptr [ebp+edi*4], ebx
   445 00002BAC E979FCFFFF          <1> 	jmp	_rex_accumulate
   446                              <1> 
   447 00002BB1 E893FCFFFF          <1> r_drl:	call	_rex_chex_126
   448 00002BB6 88C1                <1> 	mov	cl, al
   449 00002BB8 89DF                <1> 	mov	edi, ebx
   450 00002BBA 8B44BD00            <1> 	mov	eax, dword ptr [ebp+edi*4]
   451 00002BBE 8B5CBD04            <1> 	mov	ebx, dword ptr [ebp+edi*4+4]
   452 00002BC2 E87EEEFFFF          <1> 	call	drl
   453 00002BC7 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
   454 00002BCB 895CBD04            <1> 	mov	dword ptr [ebp+edi*4+4], ebx
   455 00002BCF E956FCFFFF          <1> 	jmp	_rex_accumulate
   456                              <1> 
   457 00002BD4 E870FCFFFF          <1> r_sba:	call	_rex_chex_126
   458 00002BD9 43                  <1> 	inc	ebx		; starboard lane
   459 00002BDA EB05                <1> 	jmp	r_asr
   460 00002BDC E85CFCFFFF          <1> r_saa:	call	_rex_chex_127
   461 00002BE1 88C1                <1> r_asr:	mov	cl, al
   462 00002BE3 8B449D00            <1> 	mov	eax, dword ptr [ebp+ebx*4]
   463 00002BE7 C1E008              <1> 	shl	eax, 8
   464 00002BEA D3F8                <1> 	sar	eax, cl
   465 00002BEC C1E808              <1> 	shr	eax, 8
   466 00002BEF 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   467 00002BF3 E932FCFFFF          <1> 	jmp	_rex_accumulate
   468                              <1> 
   469 00002BF8 E84CFCFFFF          <1> r_dsa:	call	_rex_chex_126
   470 00002BFD 88C1                <1> 	mov	cl, al
   471 00002BFF 89DF                <1> 	mov	edi, ebx
   472 00002C01 8B44BD00            <1> 	mov	eax, dword ptr [ebp+edi*4]
   473 00002C05 8B5CBD04            <1> 	mov	ebx, dword ptr [ebp+edi*4+4]
   474 00002C09 E85DEDFFFF          <1> 	call	dsa
   475 00002C0E 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
   476 00002C12 895CBD04            <1> 	mov	dword ptr [ebp+edi*4+4], ebx
   477 00002C16 E90FFCFFFF          <1> 	jmp	_rex_accumulate
   478                              <1> 
   479 00002C1B E835FCFFFF          <1> r_qs:	call	_rex_chex_124
   480 00002C20 E848D8FFFF          <1> 	call	_burst_write4	; eax -> ea / ebx -> register cursor
   481 00002C25 E900FCFFFF          <1> 	jmp	_rex_accumulate
   482                              <1> 
   483 00002C2A E826FCFFFF          <1> r_ql:	call	_rex_chex_124
   484 00002C2F E8F0D6FFFF          <1> 	call	_burst_read4	; eax -> ea / ebx -> register cursor
   485 00002C34 E9F1FBFFFF          <1> 	jmp	_rex_accumulate
   486                              <1> 
   487 00002C39 E8C0FBFFFF          <1> r_dte:	call	_rex_prime_final_count
   488 00002C3E E8CCD6FFFF          <1> 	call	_burst_read2
   489 00002C43 334510              <1> 	xor	eax, dword ptr [ebp+A]
   490 00002C46 7524                <1> 	jnz	r_mtax
   491 00002C48 335D14              <1> 	xor	ebx, dword ptr [ebp+B]
   492 00002C4B 751F                <1> 	jnz	r_mtax
   493 00002C4D EB14                <1> 	jmp	r_skipout		; stop search repeat
   494                              <1> 
   495 00002C4F E8AAFBFFFF          <1> r_mta:	call	_rex_prime_final_count
   496 00002C54 B100                <1> 	mov	cl, 0		; operand size 1 word
   497 00002C56 E8F6D6FFFF          <1> 	call	_operand_read
   498 00002C5B 334510              <1> 	xor	eax, dword ptr [ebp+A]
   499 00002C5E 234504              <1> 	and	eax, dword ptr [ebp+K]
   500 00002C61 7509                <1> 	jnz	r_mtax
   501                              <1> 
   502                              <1> r_skipout:				; stop search repeat
   503 00002C63 83C204              <1> 	add	edx, 4
   504 00002C66 8BA57C040000        <1> 	mov	esp, dword ptr [ebp+287*4]
   505 00002C6C C3                  <1> r_mtax:	ret
   506                              <1> 
   507 00002C6D E8D7FBFFFF          <1> r_ds:	call	_rex_chex_126
   508 00002C72 E83BD8FFFF          <1> 	call	_burst_write2	; eax -> ea / ebx -> register cursor
   509 00002C77 E9AEFBFFFF          <1> 	jmp	_rex_accumulate
   510                              <1> 
   511 00002C7C E8C8FBFFFF          <1> r_dl:	call	 _rex_chex_126
   512 00002C81 53                  <1> 	push	ebx
   513 00002C82 E888D6FFFF          <1> 	call	_burst_read2
   514 00002C87 5F                  <1> 	pop	edi
   515 00002C88 895CBD04            <1> 	mov	dword ptr [ebp+edi*4+4], ebx
   516 00002C8C 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
   517 00002C90 E995FBFFFF          <1> 	jmp	_rex_accumulate
   518                              <1> 
   519 00002C95 E8AFFBFFFF          <1> r_dan:	call	 _rex_chex_126
   520 00002C9A 53                  <1> 	push	ebx
   521 00002C9B E86FD6FFFF          <1> 	call	_burst_read2
   522 00002CA0 5F                  <1> 	pop	edi
   523 00002CA1 81F3FFFFFF00        <1> 	xor	ebx, 00FFFFFFh
   524 00002CA7 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   525 00002CAC 43                  <1> 	inc	ebx
   526 00002CAD EB0C                <1> 	jmp	r_danad
   527                              <1> 
   528 00002CAF E895FBFFFF          <1> r_da:	call	 _rex_chex_126
   529 00002CB4 53                  <1> 	push	ebx
   530 00002CB5 E855D6FFFF          <1> 	call	_burst_read2
   531 00002CBA 5F                  <1> 	pop	edi
   532                              <1> 
   533                              <1> r_danad:
   534 00002CBB 035CBD04            <1> 	add	ebx, dword ptr [ebp+edi*4+4]
   535 00002CBF C1E308              <1> 	shl	ebx, 8
   536 00002CC2 83D000              <1> 	adc	eax, 0
   537 00002CC5 C1EB08              <1> 	shr	ebx, 8
   538 00002CC8 895CBD04            <1> 	mov	dword ptr [ebp+edi*4+4], ebx
   539 00002CCC 0344BD00            <1> 	add	eax, dword ptr [ebp+edi*4]
   540                              <1> 
   541                              <1> r_store_carry:
   542 00002CD0 E8DEEEFFFF          <1> 	call	_alu_carry
   543 00002CD5 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
   544 00002CD9 E94CFBFFFF          <1> 	jmp	_rex_accumulate
   545                              <1> 
    46                                  					; data follows here
    47                                  					; if it is in this assembly
    48                                  	%if	RTA_MBANKS
    49                                  
    50                                  	section		.data
    51                                  	%include	"rta_data.msm"
    52                                  
    53                                  	section		.bss
    54                                  _memory	resd	MEMORY
    55                                  
    56                                  	%endif
    57                                  
    58                                  	end
    58          ******************       warning: label alone on a line without a colon might be in error [-w+orphan-labels]
    59                                  
