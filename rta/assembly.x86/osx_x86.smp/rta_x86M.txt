     1                                  
     2                                  	%include	"rta_x86n.def"
     1                              <1> 
     2                              <1> __SMP		equ	8
     3                              <1> 
     4                              <1> TIME_UPDATE	equ     1
     5                              <1> LOCKSTEP	equ	2
     6                              <1> BREAKPOINT	equ	4
     7                              <1> CHILLDOWN	equ	8
     8                              <1> TOUCHPOINT	equ	16
     9                              <1> 
    10                              <1> EXTERNAL_INTERRUPT 	equ	00FF00h
    11                              <1> ATTENTION		equ	128
    12                              <1> INCREMENTER_CARRY	equ	64
    13                              <1> TPULSE			equ	32
    14                              <1> 
    15                              <1> 		%if	DRANG & 2
    16                              <1> INDICATIONS	equ	CHILLDOWN|TIME_UPDATE|LOCKSTEP
    17                              <1> 		%else
    18                              <1> INDICATIONS	equ	CHILLDOWN|TIME_UPDATE|LOCKSTEP|BREAKPOINT
    19                              <1> 		%endif
    20                              <1> 
    21                              <1> EXTERNAL_INDICATIONS equ EXTERNAL_INTERRUPT|ATTENTION|INCREMENTER_CARRY|TPULSE
    22                              <1> 
    23                              <1> IO_PORTS	equ	192
    24                              <1> 
    25                              <1> 	%if	RTA_MBANKS
    26                              <1> global	_metric
    27                              <1> global	_indication
    28                              <1> global	_iselect
    29                              <1> global	_iselectu
    30                              <1> global	_readout
    31                              <1> global	_readoutx
    32                              <1> global	_readoutp
    33                              <1> global	_psr
    34                              <1> global	_apc
    35                              <1> global	_apcz
    36                              <1> global	_breakpoint
    37                              <1> global	_b0_name
    38                              <1> global	_b0p
    39                              <1> global	_devices
    40                              <1> global	_base
    41                              <1> global	_register_set
    42                              <1> global	__register
    43                              <1> global	_memory
    44                              <1> 
    45                              <1> 	%if	RTA_MBANKS<1
    46                              <1> RTA_MPAGES	equ	32
    47                              <1> 	%else
    48                              <1> RTA_MPAGES	equ	RTA_MBANKS*64
    49                              <1> 	%endif
    50                              <1> 
    51                              <1> 	%else
    52                              <1> ;	extern	_metric
    53                              <1> extern	_general_indication
    54                              <1> ;	extern	_iselect
    55                              <1> ;	extern	_iselectu
    56                              <1> ;	extern	_psr
    57                              <1> ;	extern	_apc
    58                              <1> ;	extern	_apcu
    59                              <1> ;	extern	_apcz
    60                              <1> 
    61                              <1> extern	_breakpoint
    62                              <1> extern	_touchpoint
    63                              <1> extern	_touchpoint2
    64                              <1> 
    65                              <1> ;	extern	_b0_name
    66                              <1> ;	extern	_b0p
    67                              <1> extern	_devices
    68                              <1> ;	extern	_base
    69                              <1> ;	extern	_register_set
    70                              <1> ;	extern	__register
    71                              <1> extern	_memory
    72                              <1> 
    73                              <1> _output equ     272
    74                              <1> _inputr equ     264
    75                              <1> _input2 equ     256
    76                              <1> 
    77                              <1> _OUTPUT	equ	_output*4
    78                              <1> _INPUTR	equ	_inputr*4
    79                              <1> _INPUT2 equ	_input2*4
    80                              <1> _BIAS	equ	_OUTPUT
    81                              <1> 
    82                              <1> 	%endif
    83                              <1> 
    84                              <1> 	extern	_flag
    85                              <1> 	extern	_uflag
    86                              <1> 
    87                              <1> HALF_W	equ	128
    88                              <1> FP_R	equ	8
    89                              <1> B_STREAMZR  equ 64
    90                              <1> B_STREAM16R equ 32
    91                              <1> B_STREAM16W equ 16
    92                              <1> 
    93                              <1> r	equ	0
    94                              <1> k	equ	1
    95                              <1> x	equ	2
    96                              <1> y	equ	3
    97                              <1> a	equ	4
    98                              <1> b	equ	5
    99                              <1> mantissa2 equ	6
   100                              <1> mantissa3 equ	7
   101                              <1> residue	equ	8
   102                              <1> p	equ	12
   103                              <1> q	equ	13
   104                              <1> fp	equ	14
   105                              <1> s_p	equ	15
   106                              <1> 
   107                              <1> rdatac	equ	20
   108                              <1> rdata	equ	21
   109                              <1> wdatac	equ	22
   110                              <1> wdata	equ	23
   111                              <1> 
   112                              <1> 
   113                              <1> fp_guard equ	128+19
   114                              <1> 
   115                              <1> rt_clock equ	128+20
   116                              <1> priority equ	128+21
   117                              <1> dayclock_u equ	128+22
   118                              <1> dayclock equ	128+23
   119                              <1> 
   120                              <1> R	equ	r*4
   121                              <1> K	equ	k*4
   122                              <1> X	equ	x*4
   123                              <1> Y	equ	y*4
   124                              <1> A	equ	a*4
   125                              <1> B	equ	b*4
   126                              <1> MANTISSA2 equ	mantissa2*4
   127                              <1> MANTISSA3 equ	mantissa3*4
   128                              <1> RESIDUE	equ	residue*4
   129                              <1> 
   130                              <1> P	equ	p*4
   131                              <1> Q	equ	q*4
   132                              <1> FP	equ	fp*4
   133                              <1> S_P	equ	s_p*4
   134                              <1> 
   135                              <1> RDATAC	equ	rdatac*4
   136                              <1> RDATA	equ	rdata*4
   137                              <1> WDATAC	equ	wdatac*4
   138                              <1> WDATA	equ	wdata*4
   139                              <1> 
   140                              <1> FP_GUARD equ	fp_guard*4
   141                              <1> 
   142                              <1> RT_CLOCK equ	rt_clock*4
   143                              <1> PRIORITY equ	priority*4
   144                              <1> DAYCLOCK_U equ	dayclock_u*4
   145                              <1> DAYCLOCK equ	dayclock*4
   146                              <1> 
   147                              <1> I	equ	4
   148                              <1> XI	equ	5
   149                              <1> 
   150                              <1> DEVICE  equ	32768
   151                              <1> SYSMEM  equ	16384
   152                              <1> DATA16  equ	1
   153                              <1> FSYS24  equ	2
   154                              <1> 
   155                              <1> II_GUARD equ	64+31
   156                              <1> II_EXIT	equ	64+6
   157                              <1> II_YIELD equ	64+1
   158                              <1> II_SPAWN equ	64+2
   159                              <1> II_BANK equ	64+3
   160                              <1> II_ARRAY equ	64+4
   161                              <1> II_BANK_FREE equ 64+5
   162                              <1> II_TWAIT equ	64+27
   163                              <1> II_EVENT_WAIT equ 64+28
   164                              <1> II_FPXPO equ	0+3
   165                              <1> 
   166                              <1> II_XINT		equ	0+2
   167                              <1> II_MSECOND	equ	0+4
   168                              <1> II_ATTENTION	equ	0+5
   169                              <1> 
   170                              <1> LP_AUTHORITY	equ	1		; latent parameters GUARD$
   171                              <1> LP_ADDRESS	equ	14
   172                              <1> 
   173                              <1> LP_TIMESLICE	equ	10		; latent parameter timeslice -> yield
   174                              <1> LP_RANGE	equ	12		; latent parameter FP$XPO
   175                              <1> LP_AUTOEXIT	equ	11		; latent parameter return -> EXIT$
     3                                  	%include	"rta_smp.def"
     1                              <1> __POINTER	equ	4
     2                              <1> 
     3                              <1> REGISTER	equ	0			; /*	288	int	*/
     4                              <1> 
     5                              <1> APC		equ	REGISTER+288*4		; /*	1	->	*/
     6                              <1> APCZ		equ	APC+__POINTER		; /*	1	->	*/
     7                              <1> B0P		equ	APCZ+__POINTER		; /*	1	->	*/
     8                              <1> REGISTER_SET	equ	B0P+__POINTER 
     9                              <1> 
    10                              <1> RESTART_VECTOR	equ	REGISTER_SET+__POINTER	; /*	1	int	*/
    11                              <1> INDICATION	equ	RESTART_VECTOR+4	; /*	1	int	*/	
    12                              <1> LATENT_PARAMETER equ	INDICATION+4		; /*	1	int	*/
    13                              <1> ISELECT		equ	LATENT_PARAMETER+4	; /*	1	int	*/	
    14                              <1> 
    15                              <1> PSR		equ	ISELECT+4		; /*	1	int	*/
    16                              <1> B0_NAME		equ	PSR+4			; /*	1	int	*/
    17                              <1> B0_SCOPE	equ	B0_NAME+4		; /*	1	int	*/
    18                              <1> 
    19                              <1> spare		equ	B0_SCOPE+4		; align with C structure
    20                              <1> 						; and align  metric block 
    21                              <1> 
    22                              <1> DELTA		equ	spare+4			; /*	1	int	*/
    23                              <1> __METRIC	equ	DELTA+4			; /*	1	int	*/
    24                              <1> 
    25                              <1> DELTA_BASE	equ	__METRIC+4		; /*	1	long	*/
    26                              <1> TOTAL_DELTA	equ	DELTA_BASE+8		; /*	1	long	*/
    27                              <1> TOTAL_METRIC	equ	TOTAL_DELTA+8		; /*	1	long	*/
    28                              <1> 
    29                              <1> IO_PORT		equ	TOTAL_METRIC+8		; /*	192	int	*/
    30                              <1> DATAFRAME	equ	IO_PORT+192*4		; /*	nothing		*/
    31                              <1> 
    32                              <1> CORE_SIZE	equ	DATAFRAME+0
    33                              <1> 
    34                              <1> 		%if	0
    35                              <1> CORE_INDEX2	equ	4*280
    36                              <1> CORE_INDEX1	equ	4*(280-128)
    37                              <1> 		%endif
     4                                  	%include	"io.def"
     1                              <1> 
     2                              <1> ;	_NAMES of ports as referenced in implementation or emulation 
     3                              <1> 
     4                              <1> _CORE_PIN		equ	73*4	; read-only port 1 */ _CORE_SOCKET
     5                              <1> 
     6                              <1> _XI_PENDING		equ	74*4	; mask of external interrupt sources
     7                              <1> _XI_ACK			equ	75*4	; writeable ack to quench pending signals
     8                              <1> _INCREMENTER_RESTART	equ	76*4
     9                              <1> _CORE_SOCKET		equ	77*4	; socket index this core read only
    10                              <1> 
    11                              <1> _MCAST_PENDING		equ	78*4	; mask of cores which have multicast to here
    12                              <1> _MCAST_TO		equ	79*4	; -> latent parameter
    13                              <1> 					; destinations mask in register k
    14                              <1> _STEPPING		equ	100*4
    15                              <1> _TZONE			equ	101*4
    16                              <1> 
    17                              <1> _APP_THRESHOLD		equ	72*4	; lowest application code page / limit ISRs
    18                              <1> _INDICATE		equ	102*4	; control commands powersave + others
    19                              <1> _CHILLDOWN		equ	103*4	; powersave microseconds
    20                              <1> 
    21                              <1> _SYS_SWITCH		equ	126*4	; if a switch block is connected
    22                              <1> _SYS_LEDS		equ	127*4	; if a LEDs block is connected
    23                              <1> 
    24                              <1> _DEVICE			equ	128*4	; descriptors 64 devices starting executable space
    25                              <1> _RAM_THRESHOLD		equ	124*4	; 1st writeable page executable space
    26                              <1> _IFRAME_U		equ	64*4	; highest page instruction frame B0 + iframe pages - 1
    27                              <1> 
    28                              <1> _I_DATA			equ	80*4	; external data read port
    29                              <1> _O_DATA			equ	88*4	; external daza write port
    30                              <1> 
    31                              <1> _CORES_MASK		equ	125*4	; bit map cores present +(1*/RTA_SMP)-1
     5                                  
     6                                  ;	this is not PIC code
     7                                  ;	but does relative jumps for compactness
     8                                  
     9                                  %define ptr
    10                                  %define include
    11                                  %define .model
    12                                  %define .code
    13                                  
    14                                  SYSMEM_FLAG	equ	00800000h
    15                                  DATA16_FLAG	equ	00400000h
    16                                  FSYS24_FLAG	equ	00C00000h
    17                                  
    18                                  					; instruction code starts here
    19                                  	section		.text
    20                                  	global		_leloup
    21                                  	global		_execute
    22                                  	global		_device_readp
    23                                  	global		_bus_readp
    24                                  	global		_memory_read
    25                                  	global		_bus_read
    26                                  	global		_device_read
    27                                  
    28                                  	%include	"leloup.msm"
     1                              <1> 
     2                              <1> 	extern	_ultra
     3                              <1> 	extern	_ultra1
     4                              <1> 	extern	_ultra2
     5                              <1> 	extern	_ultra3
     6                              <1> 	extern	_ultra4
     7                              <1> 	extern	_ultra5
     8                              <1> 	extern	_ultra6
     9                              <1> 	extern	_ultra7
    10                              <1> 	extern	_core
    11                              <1> 
    12                              <1> _save_ebp	equ	0
    13                              <1> _save_return	equ	4
    14                              <1> _1st_param	equ	8
    15                              <1> 
    16                              <1> _leloup:
    17 00000000 55                  <1> 	push	ebp
    18 00000001 56                  <1> 	push	esi
    19 00000002 57                  <1> 	push	edi
    20                              <1> 
    21                              <1> 	%if	0
    22                              <1> 	add	esp, -8
    23                              <1> 	movq	qword ptr [esp], mm7
    24                              <1> 	%endif
    25                              <1> 
    26                              <1> 	%if	0			; cdecl
    27                              <1> 	push	eax
    28                              <1> 	push	ecx
    29                              <1> 	push	edx
    30                              <1> 	%endif
    31                              <1> 
    32 00000003 53                  <1> 	push	ebx
    33                              <1> 
    34 00000004 8B7508              <1> 	mov	esi, dword ptr [ebp+8]	; structure smp ->
    35 00000007 56                  <1> 	push	esi			; balanced on stack top
    36 00000008 0F6EFE              <1> 	movd	mm7, esi		; refresh from mmx during instruction
    37                              <1> 
    38 0000000B 8B9680040000        <1> 	mov	edx, dword ptr [esi+APC]
    39 00000011 8BAE8C040000        <1> 	mov	ebp, dword ptr [esi+REGISTER_SET]
    40                              <1> 
    41 00000017 3B9684040000        <1> loup:	cmp	edx, dword ptr [esi+APCZ]
    42 0000001D 7740                <1> 	ja	off_limits
    43                              <1> 
    44 0000001F 8B02                <1> 	mov	eax, dword ptr [edx]
    45 00000021 0FC8                <1> 	bswap	eax
    46 00000023 83C204              <1> 	add	edx, 4
    47                              <1> 
    48 00000026 E82A010000          <1> 	call	_execute
    49                              <1> 
    50 0000002B 8B3424              <1> 	mov	esi, dword ptr [esp] 	; core pointer needed all the way round
    51                              <1> 
    52                              <1> 	%if	TSLICE
    53 0000002E F786A0040000000087- <1> 	test	dword ptr [esi+PSR], 00870000h	; not while ISR or interrupt mask
    53 00000037 00                  <1>
    54 00000038 752F                <1> 	jnz	louping
    55 0000003A F78650020000FFFFFF- <1> 	test	dword ptr [esi+RT_CLOCK], 00FFFFFFh
    55 00000043 00                  <1>
    56 00000044 7423                <1> 	jz	louping
    57                              <1> 
    58 00000046 FF8E50020000        <1> 	dec	dword ptr [esi+RT_CLOCK]
    59 0000004C 751B                <1> 	jnz	louping
    60                              <1> 
    61 0000004E B841000000          <1> 	mov	eax, II_YIELD
    62                              <1> 
    63 00000053 B90A000000          <1> 	mov	ecx, LP_TIMESLICE
    64 00000058 E8A80E0000          <1> 	call	_ii
    65                              <1> 
    66                              <1> 	%endif
    67                              <1> 
    68 0000005D EB0A                <1> 	jmp	louping
    69                              <1> 
    70                              <1> off_limits:
    71 0000005F B85F000000          <1> 	mov	eax, II_GUARD
    72 00000064 E89C0E0000          <1> 	call	_ii
    73                              <1> 
    74                              <1> louping:
    75 00000069 8A0D[00000000]      <1> 	mov	cl, byte ptr [_general_indication]
    76 0000006F F6C104              <1> 	test	cl, BREAKPOINT
    77 00000072 7420                <1> 	jz	loup_count
    78 00000074 A1[00000000]        <1> 	mov	eax, dword ptr [_breakpoint]
    79 00000079 31D0                <1> 	xor	eax, edx
    80 0000007B 7517                <1> 	jnz	loup_count
    81 0000007D 800D[00000000]02    <1> 	or	byte ptr [_general_indication], LOCKSTEP
    82 00000084 808E9404000002      <1> 	or	byte ptr [esi+INDICATION], LOCKSTEP
    83 0000008B 800D[12000000]01    <1> 	or	byte ptr [_flag+'s'-'a'], 1
    84 00000092 EB50                <1> 	jmp	indicated
    85                              <1> 
    86                              <1> loup_count:
    87 00000094 FF8E6C040000        <1> 	dec	dword ptr [esi+283*4]
    88 0000009A 7908                <1> 	jns	loup_away
    89 0000009C 66838E9404000001    <1> 	or	word ptr [esi+INDICATION], TIME_UPDATE
    90                              <1> loup_away:
    91                              <1> 
    92 000000A4 668B8694040000      <1> 	mov	ax, word ptr [esi+INDICATION]
    93 000000AB 8A8EA2040000        <1> 	mov	cl, byte ptr [esi+PSR+2]
    94 000000B1 80E107              <1> 	and	cl, 7				; highest interrupt mask?
    95 000000B4 80F107              <1> 	xor	cl, 7
    96                              <1> 
    97 000000B7 7421                <1> 	jz	internal_indications?		; maskable interrupts are masked
    98                              <1> 
    99 000000B9 66A9EBFF            <1>         test	ax, INDICATIONS|EXTERNAL_INDICATIONS	; 1 or both of internal++external
   100 000000BD 0F8454FFFFFF        <1> 	jz	loup					; indications? No?
   101 000000C3 66A9E0FF            <1> 	test	ax, EXTERNAL_INDICATIONS	; external indications among the yes?
   102                              <1> 
   103 000000C7 741B                <1> 	jz	indicated			; external indications there are not
   104                              <1> 						; therefore internal indications there are
   105                              <1> ;	push	esi	; already on stack top	; therefore raise their interrupts
   106 000000C9 E82F0D0000          <1> 	call	_xi
   107 000000CE 8B3424              <1> 	mov	esi, dword ptr [esp]
   108                              <1> 
   109 000000D1 80A6940400007F      <1> 	and	byte ptr [esi+INDICATION], 127
   110 000000D8 EB8F                <1> 	jmp	louping				; keep going intil pending flags are off
   111                              <1> 
   112                              <1> internal_indications?:
   113 000000DA 66A90B00            <1> 	test	ax, INDICATIONS			; just read from esi->INDICATION
   114 000000DE 0F8433FFFFFF        <1> 	jz	loup
   115                              <1> 
   116                              <1> indicated:
   117 000000E4 80A694040000FD      <1> 	and	byte ptr [esi+INDICATION], LOCKSTEP^255
   118 000000EB 89AE8C040000        <1> 	mov	dword ptr [esi+REGISTER_SET], ebp
   119 000000F1 899680040000        <1> 	mov	dword ptr [esi+APC], edx
   120                              <1> 
   121 000000F7 5B                  <1> 	pop	ebx				; core  pointer
   122 000000F8 5B                  <1> 	pop	ebx				; caller values
   123                              <1> 
   124                              <1> 	%if	0				; cdecl
   125                              <1> 	pop	edx
   126                              <1> 	pop	ecx
   127                              <1> 	pop	eax
   128                              <1> 	%endif
   129                              <1> 
   130                              <1> 	%if	0
   131                              <1> 	movq	mm7, qword ptr [esp]
   132                              <1> 	add	esp, 8
   133                              <1> 	%endif
   134                              <1> 
   135 000000F9 5F                  <1> 	pop	edi
   136 000000FA 5E                  <1> 	pop	esi
   137 000000FB 5D                  <1> 	pop	ebp
   138 000000FC C3                  <1> 	ret
   139                              <1> 
    29                                  	%include	"execute.msm"
     1                              <1> ;	include	rta_x86.h
     2                              <1> 	.model	small
     2          ******************  <1>  warning: label alone on a line without a colon might be in error [-w+orphan-labels]
     3                              <1> 	.code
     4                              <1> ;	_execute:
     5                              <1> ;        mov     dword ptr [__register+287*4], esp
     6                              <1> 
     7 000000FD 89C1                <1> __ea:	mov	ecx, eax
     8 000000FF C1E108              <1> 	shl	ecx, 8
     9 00000102 C1E913              <1> 	shr	ecx, 24-5		; instruction index in ch
    10 00000105 C0E905              <1> 	shr	cl, 5			; operand designator in cl
    11                              <1> 
    12 00000108 C1E010              <1> 	shl	eax, 16
    13 0000010B 80F905              <1> 	cmp	cl, XI			; sign extended immediate?
    14 0000010E 7508                <1> 	jnz	derive_ea
    15                              <1> 
    16 00000110 C1F808              <1> 	sar	eax, 8			; different from other EAs
    17 00000113 C1E808              <1> 	shr	eax, 8
    18 00000116 EB3C                <1> 	jmp	ea_derived
    19                              <1> 
    20                              <1> derive_ea:
    21 00000118 C1E810              <1> 	shr	eax, 16			; no sign of it
    22 0000011B 6621C0              <1> 	and	ax, ax			; indexing / indirection ?
    23 0000011E 7934                <1> 	jns	ea_derived		; no
    24                              <1> 
    25 00000120 89C3                <1> 	mov	ebx, eax
    26 00000122 80E47F              <1> 	and	ah, 127			; ie: and ax 32767
    27 00000125 66C1EB0C            <1> 	shr	bx, 12			; position index tag
    28 00000129 F6C306              <1> 	test	bl, 6			; indirect or indexed ?
    29 0000012C 7415                <1> 	jz	indirect
    30                              <1> 					; pe = PF set
    31                              <1> 					; can only be tested on b7..0
    32 0000012E 7A03                <1> 	jpe	indexed_4bit		; indexed fp / sp
    33                              <1> 					; indexed x / y / a / b
    34 00000130 80E307              <1> 	and	bl, 7			; zero bit 3
    35                              <1> 
    36                              <1> indexed_4bit:
    37 00000133 6625FF0F            <1> 	and	ax, 4095		; isolate address offset
    38 00000137 03449D00            <1> 	add	eax, dword ptr [ebp+ebx*4]
    39                              <1> 
    40 0000013B C1E008              <1> 	shl	eax, 8			; truncate any overflow
    41 0000013E C1E808              <1> 	shr	eax, 8
    42                              <1> 
    43 00000141 EB11                <1> 	jmp	ea_derived
    44                              <1> 
    45                              <1> indirect:				; indirect via page B0 / B1
    46 00000143 6689CB              <1> 	mov	bx, cx
    47 00000146 6631C9              <1> 	xor	cx, cx			; cl <- zero to read 1-word indirection pointer
    48 00000149 E803020000          <1> 	call	_operand_read
    49 0000014E 6689D9              <1> 	mov	cx, bx			; retrieve instruction:class into cx
    50                              <1> 
    51                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]	; retrieve smp core ->
    52 00000151 0F7EFE              <1> 	movd	esi, mm7
    53                              <1> ea_derived:
    54 00000154 C3                  <1> 	ret
    55                              <1> 
    56                              <1> _execute:
    57 00000155 89A67C040000        <1> 	mov	dword ptr [esi+REGISTER+287*4], esp
    58 0000015B E89DFFFFFF          <1> 	call	__ea
    59                              <1> 
    60 00000160 0FB6DD              <1> 	movzx	ebx, ch			; instruction index
    61 00000163 80F906              <1> 	cmp	cl, 6
    62 00000166 0F848F000000        <1> 	jz	near shifts_jumps
    63 0000016C 0F8712010000        <1> 	ja	near large_operations
    64                              <1> 
    65                              <1> integer_operations:
    66 00000172 8B1C9D[7B010000]    <1> 	mov	ebx, dword ptr [operations1+ebx*4]
    67 00000179 FFE3                <1> 	jmp	ebx
    68                              <1> 
    69                              <1> operations1:
    70 0000017B [40120000]          <1>         dd	_sr
    71 0000017F [5A120000]          <1>         dd	_sk
    72 00000183 [74120000]          <1>         dd	_sx
    73 00000187 [8E120000]          <1>         dd	_sy
    74 0000018B [A8120000]          <1>         dd	_sa
    75 0000018F [BE120000]          <1>         dd	_sb
    76 00000193 [D0120000]          <1>         dd	_z
    77 00000197 [E9120000]          <1>         dd	_pop
    78                              <1> 
    79 0000019B [05130000]          <1>         dd	_lr
    80 0000019F [0E130000]          <1>         dd	_lk
    81 000001A3 [17130000]          <1>         dd	_lx
    82 000001A7 [20130000]          <1>         dd	_ly
    83 000001AB [29130000]          <1>         dd	_la
    84 000001AF [32130000]          <1>         dd	_lb
    85 000001B3 [3B130000]          <1>         dd	_tz
    86 000001B7 [62130000]          <1>         dd	_tp
    87                              <1> 
    88 000001BB [7C160000]          <1>         dd	_ax
    89 000001BF [8D160000]          <1>         dd	_ay
    90 000001C3 [9E160000]          <1>         dd	_or
    91 000001C7 [A7160000]          <1>         dd	_orB
    92 000001CB [B0160000]          <1>         dd	_and
    93 000001CF [B9160000]          <1>         dd	_andB
    94 000001D3 [C2160000]          <1>         dd	_xor
    95 000001D7 [CB160000]          <1>         dd	_xorB
    96                              <1> 
    97 000001DB [D4160000]          <1>         dd	_aa
    98 000001DF [F4160000]          <1>         dd	_ab
    99 000001E3 [DB160000]          <1>         dd	_ana
   100 000001E7 [FB160000]          <1>         dd	_anb
   101 000001EB [14170000]          <1>         dd	_m
   102 000001EF [44170000]          <1>         dd	_mf
   103 000001F3 [A0170000]          <1>         dd	_d
   104 000001F7 [80130000]          <1>         dd	_push
   105                              <1> 
   106                              <1> shifts_jumps:
   107 000001FB 8B1C9D[04020000]    <1> 	mov	ebx, dword ptr [operations6+ebx*4]
   108 00000202 FFE3                <1> 	jmp	ebx
   109                              <1> 
   110                              <1> operations6:
   111 00000204 [45180000]          <1>         dd	_sar
   112 00000208 [5C180000]          <1>         dd	_sbr
   113 0000020C [73180000]          <1>         dd	_dsr
   114 00000210 [9E130000]          <1>         dd	_jdr
   115 00000214 [87180000]          <1>         dd	_sal
   116 00000218 [9E180000]          <1>         dd	_sbl
   117 0000021C [B5180000]          <1>         dd	_dsl
   118 00000220 [B8130000]          <1>         dd	_lcal
   119                              <1> 
   120 00000224 [C9180000]          <1>         dd	_rar
   121 00000228 [D5180000]          <1>         dd	_rbr
   122 0000022C [E1180000]          <1>         dd	_drr
   123 00000230 [CC130000]          <1>         dd	_jnc
   124 00000234 [7D1A0000]          <1>         dd	_ral
   125 00000238 [891A0000]          <1>         dd	_rbl
   126 0000023C [951A0000]          <1>         dd	_drl
   127 00000240 [D9130000]          <1>         dd	_jc
   128                              <1> 
   129 00000244 [A91A0000]          <1>         dd	_saa
   130 00000248 [BA1A0000]          <1>         dd	_sba
   131 0000024C [CB1A0000]          <1>         dd	_dsa
   132 00000250 [E6130000]          <1>         dd	_jao
   133 00000254 [F0130000]          <1>         dd	_jpa
   134 00000258 [FA130000]          <1>         dd	_jpb
   135 0000025C [04140000]          <1>         dd	_j
   136 00000260 [26140000]          <1>         dd	_jpo
   137                              <1> 
   138 00000264 [2E140000]          <1>         dd	_jza
   139 00000268 [38140000]          <1>         dd	_jzb
   140 0000026C [42140000]          <1>         dd	_jnza
   141 00000270 [4C140000]          <1>         dd	_jnzb
   142 00000274 [56140000]          <1>         dd	_jna
   143 00000278 [60140000]          <1>         dd	_jnb
   144 0000027C [6A140000]          <1>         dd	_jxge
   145 00000280 [79140000]          <1>         dd	_jyge
   146                              <1> 
   147                              <1> 
   148                              <1> large_operations:
   149 00000284 8B1C9D[8F020000]    <1> 	mov	ebx, dword ptr [operations7+ebx*4]
   150 0000028B B100                <1> 	mov	cl, 0		; default size large operand
   151 0000028D FFE3                <1> 	jmp	ebx		; 1 word
   152                              <1> 
   153                              <1> operations7:
   154 0000028F [59150000]          <1>         dd	_ts
   155 00000293 [DF1A0000]          <1>         dd	_n
   156 00000297 [EE1A0000]          <1>         dd	_inc
   157 0000029B [F91A0000]          <1>         dd	_dec
   158 0000029F [6F150000]          <1>         dd	_sim
   159 000002A3 [441B0000]          <1>         dd	_popA
   160 000002A7 [041B0000]          <1>         dd	_src
   161 000002AB [241B0000]          <1>         dd	_slc
   162                              <1> 
   163 000002AF [8C140000]          <1>         dd	_qs
   164 000002B3 [96140000]          <1>         dd	_ql
   165 000002B7 [FB140000]          <1>         dd	_dte
   166 000002BB [C3140000]          <1>         dd	_dpop
   167 000002BF [D2230000]          <1>         dd	_fa
   168 000002C3 [ED230000]          <1>         dd	_fan
   169 000002C7 [08240000]          <1>         dd	_fm
   170 000002CB [29240000]          <1>         dd	_fd
   171                              <1> 
   172 000002CF [A0140000]          <1>         dd	_qpop
   173 000002D3 [B0140000]          <1>         dd	_qpush
   174 000002D7 [4C150000]          <1>         dd	_ex
   175 000002DB [D3140000]          <1>         dd	_dpush
   176 000002DF [271C0000]          <1>         dd	_lsc
   177 000002E3 [EA140000]          <1>         dd	_mta
   178 000002E7 [0E150000]          <1>         dd	_sc
   179 000002EB [1C150000]          <1>         dd	_mlb
   180                              <1> 
   181 000002EF [35150000]          <1>         dd	_ds
   182 000002F3 [3F150000]          <1>         dd	_dl
   183 000002F7 [761B0000]          <1>         dd	_da
   184 000002FB [7D1B0000]          <1>         dd	_dan
   185 000002FF [381C0000]          <1>         dd	_dlsc
   186 00000303 [4B150000]          <1>         dd	_spare
   187 00000307 [B2150000]          <1>         dd	_go
   188 0000030B [95150000]          <1>         dd	_call
   189                              <1> 
    30                                  	%include	"rw.msm"
     1                              <1> 
     2                              <1> 
     3                              <1> ;	include	rta_x86.h
     4                              <1> ;	.model	large
     5                              <1> ;	.code
     6                              <1> 
     7                              <1> ;	this is the operand reader / writer
     8                              <1> ;	for emulated RTA1 on x86
     9                              <1> 
    10                              <1> ;	layout is
    11                              <1> 
    12                              <1> ;	RTA1 24-bit registers are modeled in an array of
    13                              <1> ;	platform-endian integers. In x86 these are 32-bit
    14                              <1> ;	little-endian integers
    15                              <1> 
    16                              <1> ;	platform-endian doesn't affect registers
    17                              <1> ;	because endianness is not at the CPU
    18                              <1> ;	side of the bus, but at the memory side
    19                              <1> 
    20                              <1> ;	when Intel circuitry in the x86 CPU staticises the value
    21                              <1> ;	of an emulated register, that value is big endian
    22                              <1> 
    23                              <1> ;	the stored integers where emulated registers are modeled
    24                              <1> ;	are platform-endian, with identical effect on big and
    25                              <1> ;	little endian emulator platforms
    26                              <1> 
    27                              <1> ;	RTA1 24-bit executable space storage words are modeled in
    28                              <1> ;	another array of platform-endian 32-bit integers. Emulation
    29                              <1> ;	on x86 swaps the byte order of storage words on read and
    30                              <1> ;	before write to conform with RTA1 canonical storage order
    31                              <1> 
    32                              <1> ;       RTA1 architecture has registers in the first 256 locations
    33                              <1> ;       of address space and access differentiates registers from
    34                              <1> ;       from memory according to effective address
    35                              <1> 
    36                              <1> ;	location of registers and storage are handed to read / write
    37                              <1> ;	routines as RTA1 word linear effective addresses
    38                              <1> 
    39                              <1> ;	These routines maintain the RTA1 linear addresses passed
    40                              <1> ;	in x86 registers and apply them with shifted scale plus
    41                              <1> ;	displacement, for example
    42                              <1> 
    43                              <1> ;		mov	eax, dword ptr [edi+esi*4+_memory]
    44                              <1> ;		bswap	eax
    45                              <1> ;		mov	dword_ptr [ebp+ebx*4], eax
    46                              <1> 
    47                              <1> ;	RTA1 register addresses are already absolute in terms of
    48                              <1> ;	the emulated RTA1 machine
    49                              <1> 
    50                              <1> ;	ebp points at the context register frame. There are two
    51                              <1> ;	register frames, application and interrupt. Registers
    52                              <1> ;	addressed as storage operand are in a single list
    53                              <1> 
    54                              <1> ;		mov	eax, dword ptr [esi*4+__register]
    55                              <1> 
    56                              <1> ;	RTA1 storage addresses are translated by RTA1 relocation
    57                              <1> ;	architecture before application. The updated linear addresses
    58                              <1> ;	of the emulated machine are in esi
    59                              <1> 
    60                              <1> ;	The operand routines in this file point edi to the x86 platform
    61                              <1> ;	storage array start of the storage device, most often emulated
    62                              <1> ;	RTA1 executable space
    63                              <1> 
    64                              <1> ;	instructions call these operand routines with RTA1 effective 
    65                              <1> ;	address in eax
    66                              <1> 
    67                              <1> ;	instructions receive load operand values in eax and ebx, or in
    68                              <1> ;	a list of RTA1 emulated register locations pointed by ebp+ebx
    69                              <1> 
    70                              <1> ;	store instructions submit a value in ebx, or values in list of
    71                              <1> ;	RTA1 emulated register locations pointed by ebp+ebx
    72                              <1> 
    73                              <1> ;	to preserve linear address consistency, application instruction
    74                              <1> ;	work areas, where needed in addition to x86 registers, are
    75                              <1> ;	implemented as sub-architectural extra RTA1 registers at the end
    76                              <1> ;	of the 256-longword register stack. x86 register ebp+ebx*4 identify
    77                              <1> ;	these locations by linear RTA1 word quantum as "registers"
    78                              <1> 
    79                              <1> ;	RTA1 registers and storage alike are in 24-bit word address quantum space
    80                              <1> 
    81                              <1> ;	emulated instructions loading or storing multiple hidden extra work
    82                              <1> ;	registers should unconditionally set ebp to the start or application
    83                              <1> ;	frame of the emulated register array, so that [ebp+ebx*4] accesses the
    84                              <1> ;	correct locations at register occurence 256+
    85                              <1> 
    86                              <1> ;               _floating_operand2 equ  256+12
    87                              <1> 
    88                              <1> ;		push	ebp
    89                              <1> ;		mov	ebp, __register	; point to application register frame[0]
    90                              <1> ;		mov	ebx, 256+_floating_operand2
    91                              <1> ;		call	_burst_read4
    92                              <1> 
    93                              <1> ;		pop	ebp		; return to previous register frame[0] application
    94                              <1> 					;                          or frame[1] interrupt
    95                              <1> 
    96                              <1> ;	Both internal stack pointers are also absolute, so for stack operations
    97                              <1> ;	ebp should be momentarily forced to the lower-addressed (application) stack
    98                              <1> ;	frame after being used to point the stack location of reference
    99                              <1> 
   100                              <1> ;		mov	ebx, dword ptr [ebp+S_P]	; read one of the two stack pointers
   101                              <1> ;		cmp	ebx, ebp+STACK_LOWER_LIMIT	; 24*4 within context of either stack
   102                              <1> ;		jl	II_GUARD
   103                              <1> ;		add	ebx, -1				; new stack top
   104                              <1> ;		mov	dword ptr [ebp+S_P], ebx
   105                              <1> ;		push	ebp				; which ever stack pointer it is, it points
   106                              <1> ;		mov	ebp,__register			; relative to all the register stack
   107                              <1> ;		call	_operand_read			; for I am the single-word push instruction
   108                              <1> ;		pop	ebp				;
   109                              <1> 
   110                              <1> ;	register identities supplied from emulated instructions to these routines
   111                              <1> ;	are their lowercase names equated to RTA1 word addresses
   112                              <1> 
   113                              <1> ;	There exist also uppercase spellings which instruction routines may
   114                              <1> ;	access internally. The uppercase names are four times in value the
   115                              <1> ;	equivalent lowercase ordinal names to give x86 platform offset values
   116                              <1> 
   117                              <1> ;       Assembly language equate is like parentheses! What's in a label
   118                              <1> ;       is not an expression but its value. Nothing like C preprocessor.
   119                              <1> ;       Just in case you're developing enhancements in assembly using
   120                              <1> ;       preprocessor and #define
   121                              <1> 
   122                              <1> ;		_floating_operand2 equ	256+12
   123                              <1> ;		FLOATING_OPERAND2 equ	_floating_operand2*4
   124                              <1> 
   125                              <1> 
   126                              <1> ;		a	equ	4
   127                              <1> ;		b	equ	5
   128                              <1> ;		mantissa2 equ	6
   129                              <1> 
   130                              <1> ;		A	equ	a*4
   131                              <1> ;		B	equ	b*4
   132                              <1> ;		MANTISSA2 equ	mantissa2*4
   133                              <1> 
   134                              <1> ;		mov	ebx, dword ptr [bp+MANTISSA2]	; the very same!
   135                              <1> ;		mov	ebx, dword ptr [bp+mantissa2*4]	; the very same
   136                              <1> 
   137                              <1> ;	but to identify an instruction-implied register to these operand routines
   138                              <1> 
   139                              <1> ;		mov	ebx, mantissa2		; bp already says which register set
   140                              <1> 
   141                              <1> ;	instruction evaluation supplies right-hand side operand EA in eax
   142                              <1> ;	Instruction implementation needs not examine EA. Call _operand_read
   143                              <1> ;	or _operand_write. eax must be as supplied to the instruction routine
   144                              <1> ;	on on operand retrieve and store
   145                              <1> 
   146                              <1> ;	simple instructions receive operand mode in cl from instruction
   147                              <1> ;	evaluation
   148                              <1> 
   149                              <1> ;	shifts and jumps use the ea which is already indexed or indirected
   150                              <1> ;	if necessary and make no operand call
   151                              <1> 
   152                              <1> ;	instructions call _burst_read2 or _burst_write2 for two-word operand cycles
   153                              <1> ;	instructions call _burst_read4 or _burst_write4 for four-word operand cycles
   154                              <1> 
   155                              <1> ;	operand reads of 1 or 2 words return values in eax:ebx
   156                              <1> 
   157                              <1> ;		call	_burst_read2
   158                              <1> ;		mov	dword ptr [ebp+A], eax
   159                              <1> ;		mov	dword ptr [ebp+B], ebx
   160                              <1> 
   161                              <1> ;	to store one operand word place it in ebx
   162                              <1> 
   163                              <1> ;	_sc	mov	ebx, dword ptr[_psr]	; I am the store carry instruction sc
   164                              <1> ;		and	ebx, 1			; CARRY
   165                              <1> ;		call	_operand_write
   166                              <1> 
   167                              <1> ;	to store two or four words or to load four words, point bx to register
   168                              <1> 
   169                              <1> ;	_qpop	mov	ebx, dword ptr [ebp+S_P] ; internal stack pointer
   170                              <1> ;						; either application sp or interrupt sp
   171                              <1> ;
   172                              <1> ;		add	dword ptr [ebp+S_P], 4	; internal stack+= 4
   173                              <1> ;		push	ebp			;
   174                              <1> ;		mov	ebp, __register		; in case context is interrupt registers
   175                              <1> ;		call	_burst_write4		; both internal stack pointers are absolute
   176                              <1> ;		pop	ebp			; point epb back to application registers
   177                              <1> ;						;                or interrupt registers
   178                              <1> 
   179                              <1> ;	more complex instructions do something to the registers after
   180                              <1> ;	acquiring operands
   181                              <1> 
   182                              <1> ;		call	_operand_read
   183                              <1> ;		add	eax, dword ptr [ebp+A]
   184                              <1> ;		rol	eax
   185                              <1> ;		and	al, CARRY		; 1
   186                              <1> ;		or	byte ptr [_psr], al	; low-order byte of longword _psr
   187                              <1> ;		shr	eax, 8
   188                              <1> ;		mov	dword ptr [ebp+A], eax
   189                              <1> 
   190                              <1> ;	emulated RTA1 instructions which both read and write (modify)
   191                              <1> ;	storage use the address in [edi+esi*4] to rewrite. edi is
   192                              <1> ;	NULL if it's not a suitable memory for a modify operation
   193                              <1> 
   194                              <1> ;	modify instructions which may have a register operand (not TS)
   195                              <1> ;	call _operand_write to rewrite a register. This guards aganst
   196                              <1> ;	applications writing interrupt registers.
   197                              <1>  
   198                              <1> ;	the effect of storage buses characteristically different
   199                              <1> ;	from RTA1 executable space is emulated in the routines
   200                              <1> ;	device_read and device_write
   201                              <1> 
   202                              <1> ;	Peripheral bus types implemented are
   203                              <1> 
   204                              <1> ;		filestore containing extents of up to 768K octets
   205                              <1> ;		accessible to RTA1 as up to 256K words in each extent.
   206                              <1> ;		The 3-octet words are in canonical order and packed
   207                              <1> 
   208                              <1> ;		network interface buffer store shared with the emulator
   209                              <1> ;		platform and reading out to RTA1 at 16 data bits per word
   210                              <1> ;		with eight high-order zero bits. RTA writes 16 data bits
   211                              <1> ;		to these locations from register low-order bit positions.
   212                              <1> ;		Storage byte order is canonical. These buffers are normal
   213                              <1> ;		and contiguous byte arrays of the emulator platform.
   214                              <1> ;		To RTA1 they are an attached device array of 16-bit words
   215                              <1> 
   216                              <1> ;	Device array types are
   217                              <1> 
   218                              <1> ;		executable space
   219                              <1> ;		24-bit filestore array
   220                              <1> ;		16-bit network interface array
   221                              <1> 
   222                              <1> ;	devices are identified in RTA1 memory relocation pointers and
   223                              <1> ;	tagged with device type. Executable space is device zero
   224                              <1> 
   225                              <1> ;	esi -> core.REGISTER
   226                              <1> 
   227                              <1> _burst_read2:
   228 0000030F 66B90600            <1> 	mov	cx, 6
   229 00000313 A900FFFF00          <1> 	test	eax, 00FFFF00h
   230 00000318 7402                <1> 	jz	read2_registers
   231 0000031A EB4D                <1> 	jmp	_bus_read
   232                              <1> 
   233                              <1> read2_registers:				; load registers from registers
   234 0000031C 8B5C8604            <1> 	mov	ebx, dword ptr [esi+eax*4+4]
   235 00000320 8B0486              <1> 	mov	eax, dword ptr [esi+eax*4]
   236 00000323 C3                  <1> 	ret
   237                              <1> 	
   238                              <1> ;	esi -> core.REGISTER
   239                              <1> 
   240                              <1> _burst_read4:				; buffered read
   241 00000324 66B90700            <1> 	mov	cx, 7			; that will help the caller
   242 00000328 A900FFFF00          <1> 	test	eax, 00FFFF00h		; ebp+ebx contains a register number
   243 0000032D 7402                <1> 	jz	read4_registers		; may also identify extra
   244 0000032F EB38                <1> 	jmp	_bus_read
   245                              <1> 					; workspace registers
   246                              <1> read4_registers:			; at register stack tail
   247 00000331 8B4C860C            <1> 	mov	ecx, dword ptr [esi+eax*4+3*4]
   248 00000335 894C9D0C            <1> 	mov	dword ptr [ebp+ebx*4+3*4], ecx
   249 00000339 8B4C8608            <1> 	mov	ecx, dword ptr [esi+eax*4+2*4]
   250 0000033D 894C9D08            <1> 	mov	dword ptr [ebp+ebx*4+2*4], ecx
   251 00000341 8B4C8604            <1> 	mov	ecx, dword ptr [esi+eax*4+4]
   252 00000345 894C9D04            <1> 	mov	dword ptr [ebp+ebx*4+4], ecx
   253 00000349 8B0C86              <1> 	mov	ecx, dword ptr [esi+eax*4]
   254 0000034C 894C9D00            <1> 	mov	dword ptr [ebp+ebx*4], ecx
   255 00000350 C3                  <1> 	ret
   256                              <1> 
   257                              <1> ;	esi -> core.REGISTER
   258                              <1> 
   259                              <1> _operand_read:			; call here with designator coded in cx
   260 00000351 80E107              <1> 	and	cl, 7		; and ea in eax
   261 00000354 80F904              <1> 	cmp	cl, 4
   262 00000357 740F                <1> 	je	immediate	; EA is operand
   263 00000359 80F905              <1> 	cmp	cl, 5
   264 0000035C 740A                <1> 	je	immediate_xi	; EA is operand
   265                              <1> 
   266 0000035E A900FFFF00          <1> 	test	eax, 00FFFF00h
   267 00000363 7504                <1> 	jnz	_bus_read	; ea does not point to registers
   268 00000365 8B0486              <1> 	mov	eax, dword ptr [esi+eax*4]
   269                              <1> 
   270                              <1> immediate:
   271                              <1> immediate_xi:
   272 00000368 C3                  <1> 	ret 
   273                              <1> 
   274                              <1> _bus_read:				; readout any memory
   275                              <1> 
   276 00000369 E889050000          <1> 	call	base_read_pointer	; returns eax <- storage block
   277                              <1> 					; 	  esi <- word offset
   278                              <1> 					;	  edi <- EA
   279                              <1> 
   280 0000036E A900004000          <1> 	test	eax, 00400000h		; big block?
   281 00000373 741B                <1> 	je	memory_read_4k_block
   282                              <1> 
   283 00000375 80F906              <1> 	cmp	cl, 6			; multiword operation?
   284 00000378 720D                <1> 	jb	_bus_read_256k_block
   285                              <1> 
   286 0000037A 81FEFCFF0300        <1> 	cmp	esi, 03FFFCh		; near the edge?
   287 00000380 7605                <1> 	jna	_bus_read_256k_block	; no
   288                              <1> 
   289 00000382 E8E8210000          <1> 	call	read_straddle_18b?
   290                              <1> 
   291                              <1> _bus_read_256k_block:
   292 00000387 A83F                <1> 	test	al, 63
   293 00000389 7429                <1> 	jz	memory_read_page
   294                              <1> 
   295 0000038B E98B030000          <1> 	jmp	device_read
   296                              <1> 
   297                              <1> memory_read_4k_block:
   298 00000390 F7C600F00300        <1> 	test	esi, 0003F000h		; inside 4k block?
   299 00000396 740A                <1> 	jz	memory_read_thru
   300                              <1> 
   301 00000398 B90E000000          <1> 	mov	ecx, LP_ADDRESS
   302 0000039D E9550B0000          <1> 	jmp	guard_ii_escape		; no
   303                              <1> 
   304                              <1> memory_read_thru:
   305 000003A2 80F906              <1> 	cmp	cl, 6
   306 000003A5 720D                <1> 	jb	memory_read_page
   307                              <1> 
   308 000003A7 81FEFC0F0000        <1> 	cmp	esi, 0FFCh		; near the edge?
   309 000003AD 7605                <1> 	jna	memory_read_page	; no
   310                              <1> 
   311 000003AF E890210000          <1> 	call	read_straddle_12b?
   312                              <1> 
   313                              <1> memory_read_page:
   314 000003B4 C1E00C              <1> 	shl	eax, 12			; multiply by page and lose bit 00400000
   315 000003B7 01C6                <1> 	add	esi, eax
   316                              <1> ;	mov	ch, byte ptr [edi+PSR]	; field of PSR with byte options
   317 000003B9 BF[00000000]        <1> 	mov	edi, _memory		; byte address
   318                              <1> 
   319                              <1> memory_read_on:
   320 000003BE 8D3CB7              <1> 	lea	edi, [edi+esi*4]
   321                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
   322 000003C1 0F7EFE              <1> 	movd	esi, mm7
   323                              <1> 
   324 000003C4 0FB6C1              <1> 	movzx	eax, cl
   325 000003C7 8B0485[D0030000]    <1> 	mov	eax, dword ptr [read_action+eax*4]
   326 000003CE FFE0                <1> 	jmp	eax
   327                              <1> 
   328                              <1> read_action:
   329 000003D0 [F0030000]          <1> 	dd	memory_read_w0
   330 000003D4 [31040000]          <1> 	dd	memory_t1
   331 000003D8 [38040000]          <1> 	dd	memory_t2	; or h1
   332 000003DC [48040000]          <1> 	dd	memory_t3	; or h2
   333 000003E0 [68030000]          <1> 	dd	immediate	; don't get here
   334 000003E4 [68030000]          <1> 	dd	immediate_xi	; don't get here
   335 000003E8 [F7030000]          <1> 	dd	memory_read2
   336 000003EC [05040000]          <1> 	dd	memory_read4
   337                              <1> 
   338                              <1> memory_read_w0:			; readout system memory 1 word
   339                              <1> ;	mov	dword ptr [esi+REGISTER+154*4], edi
   340                              <1> ;	mov	dword ptr [esi+REGISTER+155*4], esi
   341 000003F0 8B07                <1> 	mov	eax, dword ptr [edi]
   342 000003F2 B000                <1> 	mov	al, 0
   343 000003F4 0FC8                <1> 	bswap	eax
   344                              <1> ; immediate:
   345                              <1> ; immediate_xi:
   346 000003F6 C3                  <1>  	ret
   347                              <1> 
   348                              <1> memory_read2:			; readout system memory 2 words
   349 000003F7 8B5F04              <1> 	mov	ebx, dword ptr [edi+4]
   350 000003FA 8B07                <1> 	mov	eax, dword ptr [edi]
   351                              <1> 
   352 000003FC B000                <1> 	mov	al, 0
   353 000003FE B300                <1> 	mov	bl, 0
   354 00000400 0FC8                <1> 	bswap	eax
   355 00000402 0FCB                <1> 	bswap	ebx
   356 00000404 C3                  <1> 	ret
   357                              <1> 				; readout system memory 4 words
   358                              <1> memory_read4:			; store by pointer
   359                              <1> 				; this will be useful to the caller
   360                              <1> 
   361 00000405 8B07                <1> 	mov	eax, dword ptr [edi]
   362 00000407 B000                <1> 	mov	al, 0
   363 00000409 0FC8                <1> 	bswap	eax
   364 0000040B 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   365 0000040F 8B4704              <1> 	mov	eax, dword ptr [edi+4]
   366 00000412 B000                <1> 	mov	al, 0
   367 00000414 0FC8                <1> 	bswap	eax
   368 00000416 89449D04            <1> 	mov	dword ptr [ebp+ebx*4+4], eax
   369 0000041A 8B4708              <1> 	mov	eax, dword ptr [edi+2*4]
   370 0000041D B000                <1> 	mov	al, 0
   371 0000041F 0FC8                <1> 	bswap	eax
   372 00000421 89449D08            <1> 	mov	dword ptr [ebp+ebx*4+2*4], eax
   373 00000425 8B470C              <1> 	mov	eax, dword ptr [edi+3*4]
   374 00000428 B000                <1> 	mov	al, 0
   375 0000042A 0FC8                <1> 	bswap	eax
   376 0000042C 89449D0C            <1> 	mov	dword ptr [ebp+ebx*4+3*4], eax
   377 00000430 C3                  <1> 	ret
   378                              <1> 
   379                              <1> memory_t1:
   380 00000431 8B07                <1> 	mov	eax, dword ptr [edi]
   381 00000433 C1E010              <1> 	shl	eax, 16		; t1 = 3.2.THIS.zero
   382 00000436 EB1B                <1> 	jmp	memory_tw
   383                              <1> 
   384                              <1> memory_t2:
   385 00000438 8B07                <1> 	mov	eax, dword ptr [edi]
   386 0000043A F686A004000080      <1> 	test	byte ptr [esi+PSR], HALF_W
   387 00000441 7517                <1> 	jnz	memory_h1
   388 00000443 C1E008              <1> 	shl	eax, 8		; t2 = 3.THIS.1.zero
   389 00000446 EB0B                <1> 	jmp	memory_tw
   390                              <1> 
   391                              <1> memory_t3:
   392 00000448 8B07                <1> 	mov	eax, dword ptr [edi]
   393 0000044A F686A004000080      <1> 	test	byte ptr [esi+PSR], HALF_W
   394 00000451 750E                <1> 	jnz	memory_h2
   395                              <1> memory_tw:
   396 00000453 C1F810              <1> 	sar	eax, 16		; t3 = THIS.2.1.zero
   397 00000456 C1E808              <1> 	shr	eax, 8
   398 00000459 C3                  <1> 	ret
   399                              <1> 
   400                              <1> memory_h1:
   401 0000045A 0FC8                <1> 	bswap	eax		; already loaded but not swapped
   402 0000045C C1E008              <1> 	shl	eax, 8		; h1 = zero.HERE.2.3
   403 0000045F EB05                <1> 	jmp	memory_hw
   404                              <1> 
   405                              <1> memory_h2:
   406 00000461 0FC8                <1> 	bswap	eax		; already loaded but not swapped
   407 00000463 C1E014              <1> 	shl	eax, 8+12
   408                              <1> memory_hw:
   409 00000466 C1F80C              <1> 	sar	eax, 12
   410 00000469 C1E808              <1> 	shr	eax, 8
   411 0000046C C3                  <1> 	ret
   412                              <1> 
   413                              <1> ;	esi -> core.REGISTER
   414                              <1> 				; store system memory
   415                              <1> _burst_write4:
   416 0000046D 66B90700            <1> 	mov	cx, 7
   417 00000471 A900FFFF00          <1> 	test	eax, 00FFFF00h
   418 00000476 0F858A000000        <1> 	jnz	NEAR bus_write
   419                              <1> 
   420                              <1> 	; store emulated registers to emulated registers
   421                              <1> 
   422 0000047C F786A0040000000080- <1> 	test	dword ptr [esi+PSR], 0800000h	; ISR ?
   422 00000485 00                  <1>
   423 00000486 750A                <1> 	jnz	write4_registers	; ISRs may write some spare registers
   424 00000488 83F87C              <1> 	cmp	eax, 124
   425 0000048B 7605                <1> 	jna	write4_registers
   426 0000048D E9600A0000          <1> 	jmp	guard_ii_authority	; but applications may not write
   427                              <1> 					; any interrupt registers
   428                              <1> 
   429                              <1> write4_registers:
   430                              <1> ;	mov	edi, eax		; eax can be freed
   431                              <1> 
   432 00000492 8B4C9D00            <1> 	mov	ecx, dword ptr [ebp+ebx*4]	; data for store
   433                              <1> 					; ebp+ebx is a register number
   434                              <1> 					; which can be extra register locations
   435                              <1> 					; serving as workspace at the tail of
   436                              <1> 					; the register stack
   437                              <1> 
   438 00000496 890C86              <1> 	mov	dword ptr [esi+eax*4], ecx
   439 00000499 8B4C9D04            <1> 	mov	ecx, dword ptr [ebp+ebx*4+4]
   440 0000049D 894C8604            <1> 	mov	dword ptr [esi+eax*4+4], ecx
   441                              <1> 
   442 000004A1 8B4C9D08            <1> 	mov	ecx, dword ptr [ebp+ebx*4+2*4]
   443 000004A5 894C8608            <1> 	mov	dword ptr [esi+eax*4+2*4], ecx
   444 000004A9 8B4C9D0C            <1> 	mov	ecx, dword ptr [ebp+ebx*4+3*4]
   445 000004AD 894C860C            <1> 	mov	dword ptr [esi+eax*4+3*4], ecx
   446 000004B1 C3                  <1> 	ret
   447                              <1> 
   448                              <1> ;	esi -> core.REGISTER
   449                              <1> 
   450                              <1> _burst_write2:
   451 000004B2 66B90600            <1> 	mov	cx, 6
   452 000004B6 A900FFFF00          <1> 	test	eax, 00FFFF00h
   453 000004BB 7549                <1> 	jnz	bus_write
   454                              <1> 
   455                              <1> 	; store to emulated registers
   456                              <1> 
   457 000004BD F786A0040000000080- <1> 	test	dword ptr [esi+PSR], 0800000h	; ISR ?
   457 000004C6 00                  <1>
   458 000004C7 750A                <1> 	jnz	write2_registers	; there are spare registers at the end
   459 000004C9 83F87E              <1> 	cmp	eax, 126		; but applications may not write
   460 000004CC 7605                <1> 	jna	write2_registers	; any interrupt registers
   461 000004CE E91F0A0000          <1> 	jmp	guard_ii_authority
   462                              <1> 
   463                              <1> write2_registers:
   464                              <1> ;	mov	edi, eax			; time to free eax
   465 000004D3 8B4C9D00            <1> 	mov	ecx, dword ptr [ebp+ebx*4]
   466 000004D7 890C86              <1> 	mov	dword ptr [esi+eax*4], ecx
   467 000004DA 8B4C9D04            <1> 	mov	ecx, dword ptr [ebp+ebx*4+4]
   468 000004DE 894C8604            <1> 	mov	dword ptr [esi+eax*4++4], ecx
   469 000004E2 C3                  <1> 	ret
   470                              <1> 
   471                              <1> ;	esi -> core.REGISTER
   472                              <1> 
   473                              <1> _operand_write:
   474 000004E3 A900FFFF00          <1> 	test	eax, 00FFFF00h
   475 000004E8 751C                <1> 	jnz	bus_write
   476                              <1> 
   477                              <1> _operand_write_register:
   478 000004EA A980000000          <1> 	test	eax, 80h		; in the interrupt registers?
   479 000004EF 7411                <1> 	jz	write1_register
   480 000004F1 F786A0040000000080- <1> 	test	dword ptr [esi+PSR], 0800000h
   480 000004FA 00                  <1>
   481 000004FB 7505                <1> 	jnz	write1_register
   482 000004FD E9F0090000          <1> 	jmp	guard_ii_authority
   483                              <1> 
   484                              <1> write1_register:
   485 00000502 891C86              <1> 	mov	dword ptr [esi+eax*4], ebx
   486 00000505 C3                  <1> 	ret
   487                              <1> 
   488                              <1> bus_write:				; write any memory
   489                              <1> 					;	eax <- EA
   490                              <1> 					;	ebx <- data | [ ebp + ebx * 4] -> 1st data word
   491                              <1> 					;	cl  <- encoding [ word * 1 / 2 / 4 ] / byte
   492                              <1> 					;	esi <- core
   493                              <1> 
   494                              <1> 
   495 00000506 E880040000          <1> 	call	base_write_pointer	; returns eax <- block
   496                              <1> 					;         edi <- EA
   497                              <1> 					;	  esi <- word offset
   498                              <1> 
   499 0000050B A900004000          <1> 	test	eax, 00400000h		; big block?
   500 00000510 741E                <1> 	jz	memory_write_4k_block	; no
   501 00000512 80F906              <1> 	cmp	cl, 6			; multiword operation?
   502 00000515 720D                <1> 	jb	bus_write_256k_block	; no
   503                              <1> 
   504 00000517 81FEFCFF0300        <1> 	cmp	esi, 03FFFCh		; near the edge?
   505 0000051D 7605                <1> 	jna	bus_write_256k_block	; no
   506                              <1> 
   507 0000051F E8BA200000          <1> 	call	write_straddle_18b?
   508                              <1> 
   509                              <1> bus_write_256k_block:
   510 00000524 A93F000000          <1> 	test	eax, 63			; a device array?
   511 00000529 7429                <1> 	jz	memory_write_page	; no. scaling shift will scrub bit 400000
   512 0000052B E9EE020000          <1> 	jmp	_device_write		; yes a device array
   513                              <1> 
   514                              <1> memory_write_4k_block:
   515 00000530 F7C600F00300        <1> 	test	esi, 0003F000h		; inside a 4k page?
   516 00000536 740A                <1> 	jz	memory_write_thru
   517 00000538 B90E000000          <1> 	mov	ecx, LP_ADDRESS
   518 0000053D E9B5090000          <1> 	jmp	guard_ii_escape		; no
   519                              <1> 
   520                              <1> memory_write_thru:
   521 00000542 80F906              <1> 	cmp	cl, 6			; multiword operation?
   522 00000545 720D                <1> 	jb	memory_write_page	; no
   523                              <1> 
   524 00000547 81FEFC0F0000        <1> 	cmp	esi, 0FFCh		; near the edge?
   525 0000054D 7605                <1> 	jna	memory_write_page	; no
   526                              <1> 
   527 0000054F E85A200000          <1> 	call	write_straddle_12b?
   528                              <1> 
   529                              <1> memory_write_page:
   530                              <1> ;	mov	edi, dword ptr [ebp+CORE_INDEX1]
   531 00000554 0F7EFF              <1> 	movd	edi, mm7
   532                              <1> 
   533 00000557 3B87C0060000        <1> 	cmp	eax, dword ptr [edi+IO_PORT+_RAM_THRESHOLD] ; edi -> core registers
   534 0000055D 0F888F090000        <1> 	js	near guard_ii_authority	; guard the NVRAM whether real or emulated
   535                              <1> 
   536 00000563 C1E00C              <1> 	shl	eax, 12			; multiply by page and lose bit 00400000
   537                              <1> 
   538 00000566 01C6                <1> 	add	esi, eax		; add offset
   539                              <1> 
   540 00000568 BF[00000000]        <1> 	mov	edi, _memory
   541                              <1> 
   542                              <1> memory_write_on:
   543 0000056D 8D3CB7              <1> 	lea	edi, [edi+esi*4]
   544                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
   545 00000570 0F7EFE              <1> 	movd	esi, mm7
   546                              <1> 
   547                              <1> 	%if	0
   548                              <1> 	test	dword ptr [_general_indication], TOUCHPOINT
   549                              <1> 	jz	memory_write_on_go
   550                              <1> 
   551                              <1> 	cmp	edi, dword ptr [_touchpoint]
   552                              <1> 	js	memory_write_on_go
   553                              <1> 	cmp	edi, dword ptr [_touchpoint2]
   554                              <1> 	jns	memory_write_on_go
   555                              <1> 	jmp	guard_ii_authority
   556                              <1> 	%endif
   557                              <1> 
   558                              <1> memory_write_on_go:
   559 00000573 0FB6C1              <1> 	movzx	eax, cl
   560 00000576 8B0485[7F050000]    <1> 	mov	eax, dword ptr [write_action+eax*4]
   561 0000057D FFE0                <1> 	jmp	eax
   562                              <1> 
   563                              <1> write_action:
   564 0000057F [9F050000]          <1> 	dd	memory_write
   565 00000583 [A4050000]          <1> 	dd	write_t1
   566 00000587 [A8050000]          <1> 	dd	write_t2	; or h1
   567 0000058B [B5050000]          <1> 	dd	write_t3	; or h2
   568 0000058F [A3050000]          <1> 	dd	just_dont
   569 00000593 [A3050000]          <1> 	dd	just_dont
   570 00000597 [EF050000]          <1> 	dd	memory_write2
   571 0000059B [01060000]          <1> 	dd	memory_write4
   572                              <1> 
   573                              <1> memory_write:					; store system memory 1 word
   574 0000059F 0FCB                <1> 	bswap	ebx
   575 000005A1 891F                <1> 	mov	dword ptr [edi], ebx
   576                              <1> 
   577                              <1> just_dont:
   578 000005A3 C3                  <1> 	ret
   579                              <1> 
   580                              <1> write_t1:
   581 000005A4 885F01              <1> 	mov	byte ptr [edi+1], bl
   582 000005A7 C3                  <1> 	ret
   583                              <1> 
   584                              <1> write_t2:
   585 000005A8 F686A004000080      <1> 	test	byte ptr [esi+PSR], HALF_W
   586 000005AF 7511                <1> 	jnz	write_h1
   587 000005B1 885F02              <1> 	mov	byte ptr [edi+2], bl
   588 000005B4 C3                  <1> 	ret
   589                              <1> 
   590                              <1> write_t3:
   591 000005B5 F686A004000080      <1> 	test	byte ptr [esi+PSR], HALF_W
   592 000005BC 751A                <1> 	jnz	write_h2
   593 000005BE 885F03              <1> 	mov	byte ptr [edi+3], bl
   594 000005C1 C3                  <1> 	ret
   595                              <1> 
   596                              <1> write_h1:
   597 000005C2 8B07                <1> 	mov	eax, dword ptr [edi]
   598 000005C4 0FC8                <1> 	bswap	eax
   599 000005C6 81E3FF0F0000        <1> 	and	ebx, 4095
   600 000005CC C1E30C              <1> 	shl	ebx, 12
   601 000005CF 25FF0F0000          <1> 	and	eax, 4095
   602 000005D4 09D8                <1> 	or	eax, ebx
   603 000005D6 EB12                <1> 	jmp	write_hw
   604                              <1> 
   605                              <1> write_h2:
   606 000005D8 8B07                <1> 	mov	eax, dword ptr [edi]
   607 000005DA 0FC8                <1> 	bswap	eax
   608 000005DC C1E80C              <1> 	shr	eax, 12
   609 000005DF C1E00C              <1> 	shl	eax, 12
   610 000005E2 81E3FF0F0000        <1> 	and	ebx, 4095
   611 000005E8 09D8                <1> 	or	eax, ebx
   612                              <1> 
   613                              <1> write_hw:
   614 000005EA 0FC8                <1> 	bswap	eax
   615 000005EC 8907                <1> 	mov	dword ptr [edi], eax
   616 000005EE C3                  <1> 	ret
   617                              <1> 					; store system memory 2 words
   618                              <1> memory_write2:				; eax is already free
   619 000005EF 8B449D00            <1> 	mov	eax, dword ptr [ebp+ebx*4]
   620 000005F3 0FC8                <1> 	bswap	eax
   621 000005F5 8907                <1> 	mov	dword ptr [edi], eax
   622                              <1> 
   623 000005F7 8B449D04            <1> 	mov	eax, dword ptr [ebp+ebx*4+4]
   624 000005FB 0FC8                <1> 	bswap	eax
   625 000005FD 894704              <1> 	mov	dword ptr [edi+4], eax
   626 00000600 C3                  <1> 	ret
   627                              <1> 
   628                              <1> memory_write4:					; store system memory 4 words
   629 00000601 8B449D00            <1> 	mov	eax, dword ptr [ebp+ebx*4]	; bx is a register number and may
   630                              <1> 						; identify extra workspace registers
   631                              <1> 						; at register stack tail
   632 00000605 0FC8                <1> 	bswap	eax
   633 00000607 8907                <1> 	mov	dword ptr [edi], eax
   634 00000609 8B449D04            <1> 	mov	eax, dword ptr [ebp+ebx*4+4]
   635 0000060D 0FC8                <1> 	bswap	eax
   636 0000060F 894704              <1> 	mov	dword ptr [edi+4], eax
   637 00000612 8B449D08            <1> 	mov	eax, dword ptr [ebp+ebx*4+8]
   638 00000616 0FC8                <1> 	bswap	eax
   639 00000618 894708              <1> 	mov	dword ptr [edi+2*4], eax
   640 0000061B 8B449D0C            <1> 	mov	eax, dword ptr [ebp+ebx*4+12]
   641 0000061F 0FC8                <1> 	bswap	eax
   642 00000621 89470C              <1> 	mov	dword ptr [edi+3*4], eax
   643 00000624 C3                  <1> 	ret
   644                              <1> 
   645                              <1> ;	modify instructions n inc dec src slc sim popA
   646                              <1> ;	rewrite here
   647                              <1> 
   648                              <1> 
   649                              <1> memoreg_writeback:
   650                              <1> 	%if	1
   651 00000625 21FF                <1> 	and	edi, edi
   652 00000627 7509                <1> 	jnz	memory_direct
   653 00000629 25FFFFFF00          <1> 	and	eax, 00FFFFFFh			; unchanged esi -> core.REGISTER	
   654 0000062E 89049E              <1> 	mov	[esi+ebx*4+REGISTER], eax	; platform endian
   655                              <1> 						; register writeback index ebx ->
   656 00000631 C3                  <1> 	ret
   657                              <1> 	%else
   658                              <1> 
   659                              <1> 
   660                              <1> 	test	ebx, -256			; save EA is ?
   661                              <1> 	jnz	memory_direct			; a memory device
   662                              <1> 	xchg	eax, ebx			; a register
   663                              <1> 	and	ebx, 00FFFFFFh
   664                              <1> 	jmp	_operand_write_register		; esi -> core.REGISTER
   665                              <1> 
   666                              <1> ;	if not a register rewrite
   667                              <1> ;	n inc dec src slc sim popA
   668                              <1> ;	write RTA memory at its saved platform address
   669                              <1> 	%endif
   670                              <1> 
   671                              <1> memory_direct:					; esi <- memory_offset
   672 00000632 0FC8                <1> 	bswap	eax				; write components edi esi kept from base_read
   673 00000634 30C0                <1> 	xor	al, al				
   674 00000636 8904B7              <1> 	mov	dword ptr [edi+esi*4], eax
   675 00000639 C3                  <1> 	ret
   676                              <1> 
   677                              <1> 
   678                              <1> ;	execute calls memory read
   679                              <1> ;	ea < 256 is not for execute a register
   680                              <1> ;	operand is at a readable address in system memory or array
   681                              <1> 
   682                              <1> memory_read:					; for execute and modify instructions:
   683 0000063A E867000000          <1> 	call	memory_point			; read only executable space
   684 0000063F 8B04B7              <1> 	mov	eax, dword ptr [edi+esi*4]	; and similar memory types
   685 00000642 0FC8                <1> 	bswap	eax
   686 00000644 C3                  <1> 	ret
   687                              <1> 
   688                              <1> ;	modify instructions n inc dec src slc sim popA call here
   689                              <1> ;	ea < 256 is a register
   690                              <1> 
   691                              <1> memoreg:					; read-modify-write registers / system memory
   692 00000645 A900FFFFFF          <1> 	test	eax, -256			; but nothing marked as a peripheral bus
   693 0000064A 751A                <1> 	jnz	memory_read_lock
   694 0000064C A880                <1> 	test	al, 128				; interrupt register?
   695 0000064E 740E                <1> 	jz	register_read_for_write		; no, clear to update
   696 00000650 F686A204000080      <1> 	test	byte ptr [esi+PSR+2], 128	; ISR ?
   697 00000657 7505                <1> 	jnz	register_read_for_write
   698 00000659 E994080000          <1> 	jmp	guard_ii_authority
   699                              <1> 
   700                              <1> register_read_for_write:			; unchanged esi -> core.REGISTER
   701 0000065E 89C3                <1>         mov     ebx, eax                        ; copy of ea -> registers to memoreg_writeback
   702 00000660 31FF                <1>         xor     edi, edi                        ; tell memoreg->writeback that's how it is, no device
   703 00000662 8B0486              <1>         mov     eax, dword ptr [esi+REGISTER+eax*4]
   704 00000665 C3                  <1>         ret					; register writeback index ebx ->
   705                              <1> 
   706                              <1> 
   707                              <1> ;	RAM boundary in port 124 defines the upper page limit
   708                              <1> ;	of a real or emulated NVRAM containing the fixed system image
   709                              <1> 
   710                              <1> ;	fixed system image may be kernel + loader in a dozen pages
   711                              <1> ;	or it may be the entire application
   712                              <1> 
   713                              <1> ;	emulated machine applies the update limit
   714                              <1> ;	whether NVRAM is emulated or real
   715                              <1> 
   716                              <1> ;	if not a register
   717                              <1> ;	n inc dec src slc sim popA read a memory word which is legal to write
   718                              <1> ;	and keep the platform address to write the modified value
   719                              <1> ;	modify instructions do not lock memory between read and rewrite
   720                              <1> 
   721                              <1> memory_read_lock:
   722 00000666 E806000000          <1> 	call	memory_lock
   723 0000066B 8B04B7              <1> 	mov	eax, dword ptr [edi+esi*4]
   724 0000066E 0FC8                <1> 	bswap	eax
   725 00000670 C3                  <1> 	ret
   726                              <1> 
   727                              <1> ;	memory_read_lock calls here for modify instructions if ea > registers
   728                              <1> ;	ts calls here with ea whatever range always -> memory
   729                              <1> 
   730                              <1> ;	ea must be a legally writable memory word
   731                              <1> ;	memory_lock does not lock but identifies a platform write address  
   732                              <1> ;	ts reads / unconditionally replaces word.t1
   733                              <1> ;	under platform locking protocol, xchg platform instruction
   734                              <1> 
   735                              <1> memory_lock:					; point for update
   736                              <1> 						; barred below RAM boundary as write is
   737 00000671 E815030000          <1> 	call	base_write_pointer		; resolve device:block:offset from EA
   738                              <1> 						; edi <- core.REGISTERS <- esi
   739                              <1> 						; eax <- memory block index
   740                              <1> 						; esi <- memory word offset
   741                              <1> 
   742                              <1> ;	mov	edi, dword ptr [ebp+CORE_INDEX1]
   743 00000676 0F7EFF              <1> 	movd	edi, mm7
   744                              <1> 
   745 00000679 A900004000          <1> 	test	eax, 00400000h			; update block name is a big bank ?
   746 0000067E 7419                <1> 	jz	memory_lock_page		; no
   747 00000680 A93F000000          <1> 	test	eax, 63				; a device outside executable space ?
   748 00000685 754D                <1> 	jnz	_yspace_read			; yes
   749 00000687 25FFFF3F00          <1> 	and	eax, 003FFFFFh			; bit 0400000 is gets stripped later anyway
   750 0000068C 3B87C0060000        <1> 	cmp	eax, dword ptr [edi+IO_PORT+_RAM_THRESHOLD]	; below RAM boundary?
   751 00000692 7339                <1> 	jnb	_xspace_read			; no, go ahead
   752 00000694 E959080000          <1> 	jmp	guard_ii_authority
   753                              <1> 
   754                              <1> memory_lock_page:
   755 00000699 3B87C0060000        <1> 	cmp	eax, dword ptr [edi+IO_PORT+_RAM_THRESHOLD]	; below RAM boundary?
   756 0000069F 731A                <1> 	jnb	_xspace_read4K			; no, go head if offset < 1000 hex
   757 000006A1 E94C080000          <1> 	jmp	guard_ii_authority
   758                              <1> 
   759                              <1> 
   760                              <1> ;	memory_read calls here for execute
   761                              <1> ;	identify a platform read address of an RTA memory word
   762                              <1> 
   763                              <1> memory_point:
   764 000006A6 E84C020000          <1> 	call	base_read_pointer		; edi <- core.REGISTERS <- esi
   765                              <1> 						; esi <- word offset in memory block
   766 000006AB A900004000          <1> 	test	eax, 00400000h			; eax <- page index
   767 000006B0 7409                <1> 	jz	_xspace_read4K
   768                              <1> 
   769 000006B2 A93F000000          <1> 	test	eax, 63
   770 000006B7 7414                <1> 	jz	_xspace_read
   771 000006B9 EB19                <1> 	jmp	_yspace_read			; ie a device either appropriate or not
   772                              <1> 
   773                              <1> _xspace_read4K:
   774 000006BB F7C600F00300        <1> 	test	esi, 003F000h
   775 000006C1 740A                <1> 	jz	_xspace_read
   776 000006C3 B90E000000          <1> 	mov	ecx, LP_ADDRESS
   777 000006C8 E92A080000          <1> 	jmp	guard_ii_escape
   778                              <1> 
   779                              <1> _xspace_read:
   780 000006CD BF[00000000]        <1> 	mov	edi, _memory
   781 000006D2 EB37                <1> 	jmp	_memory_deliver			; device array zero
   782                              <1> 
   783                              <1> _yspace_read:
   784 000006D4 A900008000          <1> 	test	eax, 00800000h			; a tripsy non-space?
   785 000006D9 753B                <1> 	jnz	_zspace_read			; not allowed
   786                              <1> 
   787 000006DB 89C3                <1> 	mov	ebx, eax
   788 000006DD 83E33F              <1> 	and	ebx, 63
   789 000006E0 0F7EFF              <1> 	movd	edi, mm7
   790 000006E3 8B9C9FD0060000      <1> 	mov	ebx, dword ptr [edi+IO_PORT+_DEVICE+ebx*4]
   791 000006EA F7C300008000        <1> 	test	ebx, SYSMEM_FLAG
   792 000006F0 7424                <1> 	jz	_zspace_read
   793 000006F2 F7C300004000        <1> 	test	ebx, DATA16_FLAG
   794 000006F8 751C                <1> 	jnz	_zspace_read
   795                              <1> 
   796 000006FA C1E002              <1> 	shl	eax, 2				; al = 4 * device index
   797 000006FD 0FB6F8              <1> 	movzx	edi, al
   798                              <1> 
   799 00000700 8BBF[00000000]      <1> 	mov	edi, dword ptr [_devices+edi]	; and platform pointers are also 32-bit
   800 00000706 30C0                <1> 	xor	al, al				; necessary to lose the device bits now
   801 00000708 C1E802              <1> 	shr	eax, 2
   802                              <1> 
   803                              <1> _memory_deliver:
   804 0000070B C1E00C              <1> 	shl	eax, 12		; multiply by page and lose bit 00400000
   805 0000070E 01C6                <1> 	add	esi, eax
   806                              <1> 
   807                              <1> 	%if	__SMP
   808 00000710 8B04B7              <1> 	mov	eax, dword ptr [edi+esi*4]
   809 00000713 0FC8                <1> 	bswap	eax
   810                              <1> 	%else
   811                              <1> 	mov	eax, dword ptr [edi+esi*4]
   812                              <1> 	bswap	eax
   813                              <1> 	%endif
   814 00000715 C3                  <1> 	ret
   815                              <1> 
   816                              <1> _zspace_read:
   817 00000716 E9D7070000          <1> 	jmp	guard_ii_authority
   818                              <1> 
   819                              <1> ;	esi -> core
   820                              <1> 
   821                              <1> ;	sub-architectural measure on sabr and reload instructions
   822                              <1> 
   823                              <1> ;	check the target memory block is in range and the bus characteristic
   824                              <1> ;	of the memory device when selecting blocks of memory, not when
   825                              <1> ;	accessing them. Use 8 spare bits in the word containing _base[]
   826                              <1> ;	for a quick recall of the emulated bus attribute on reference
   827                              <1> 
   828                              <1> ;	because this software emulation needs to act differently for
   829                              <1> 
   830                              <1> ;		executable space	rta1 24-bit words canonical memory
   831                              <1> ;					modeled in platform 32-bit words
   832                              <1> 
   833                              <1> ;		shared network buffers	16-bit words canonical in memory
   834                              <1> ;					and zero extend on readout to RTA1
   835                              <1> 
   836                              <1> ;		24-bit filestore array	3-octet words stored big-endian
   837                              <1> ;					in packed array
   838                              <1> 
   839                              <1> ;	concept RTA1 device arrays with bus behaviour differences are completely
   840                              <1> ;	emulated on PC emulations because device arrays are modeled in PC RAM.
   841                              <1> 
   842                              <1> ;	Various bus behaviours are emulated transparently to RTA1 target software
   843                              <1> ;	in anticipation	that different memories for different uses may be attached
   844                              <1> ;	on product boards, making core-emulated RTA1s much more efficient for not
   845                              <1> ;	needing this part of emulation
   846                              <1> 
   847                              <1> ;	devices
   848                              <1> 
   849                              <1> ;	device 0 is always executable space, but there may be more devices
   850                              <1> ;	with bus characteristics like device 0. The device descriptors are
   851                              <1> 
   852                              <1> ;		_________________________________________________________________
   853                              <1> ;		| 16 bits flags	| 16 bits banks	|       32 bits pointer		|
   854                              <1> ;		|_______________|____high index_|_______________________________|
   855                              <1> 
   856                              <1> 
   857                              <1> ;	[out]	sabr	[go]	[call]	reload instructions call here
   858                              <1> ;	go and call can probably check quicker themself
   859                              <1> ;	out can be trusted because applications don't out memory _base[] ports
   860                              <1> 
   861                              <1> ;	a big block in an RTA1 address window is 262144 words.
   862                              <1> ;	this checking concerns address windows tagged 2..63
   863                              <1> ;	a device is an array up to 65536 big blocks or banks
   864                              <1> 
   865                              <1> ;	you get here with the relocation handle in ebx
   866                              <1> ;	and the target window tag in eax, because that is the EA of a sabr instruction
   867                              <1> 
   868                              <1> device_read:				; readout device arrays
   869 0000071B A900008000          <1>         test    eax, 0800000h           ; the vilainous bank index?
   870 00000720 7537                <1>         jnz     device_read_escape
   871                              <1> 
   872                              <1> 					; edi -> core.REGISTER
   873 00000722 C1E002              <1> 	shl	eax, 2			; al is device index * 4
   874 00000725 50                  <1> 	push	eax			; rest of eax is block index * 4
   875 00000726 0FB6C0              <1> 	movzx	eax, al			; extend device number
   876                              <1> 					; sense device descriptor
   877                              <1> 
   878                              <1> ;	mov	edi, dword ptr [ebp+CORE_INDEX1]
   879 00000729 0F7EFF              <1> 	movd	edi, mm7
   880                              <1> 
   881 0000072C F68438D2060000C0    <1> 	test	byte ptr [edi+eax+IO_PORT+_DEVICE+2], 192
   882                              <1> 
   883 00000734 58                  <1> 	pop	eax			; recover storage block index
   884                              <1> 
   885 00000735 7422                <1> 	jz	device_read_escape	; neither type flag set
   886                              <1> 
   887 00000737 9C                  <1> 	pushfd				; sign is set for descriptor bit 23	
   888                              <1> 					; parity is set if both bits are
   889                              <1> 
   890 00000738 8AAFA0040000        <1> 	mov	ch, byte ptr [edi+PSR]	; flag field with byte options for memory read
   891 0000073E 0FB6F8              <1> 	movzx	edi, al			; device select
   892                              <1> 
   893 00000741 30C0                <1> 	xor	al, al			; add storage block to offset
   894 00000743 C1E00A              <1> 	shl	eax, 10			; block index * 64 * 4 now times 262144
   895 00000746 01C6                <1> 	add	esi, eax		; offset += <-
   896                              <1> 
   897 00000748 8BBF[00000000]      <1> 	mov	edi,  dword ptr [_devices+edi]
   898                              <1> 
   899                              <1> 					; known that one or two bits is set
   900 0000074E 58                  <1> 	pop	eax			; flags from test of device	
   901                              <1> 
   902 0000074F A804                <1> 	test	al, 4			; parity?
   903 00000751 755C                <1> 	jnz	device_read_array24	; parity -> 2 bits set -> FSYS24 bus
   904                              <1> 
   905 00000753 A880                <1> 	test	al, 128			; sign -> descriptor bit 23 -> SYSMEM
   906 00000755 7411                <1> 	jz	device_read_data16	; otherwise NET16 trunk
   907 00000757 EB0A                <1> 	jmp	device_read_sysmem	; system memory type if yes				
   908                              <1> 
   909                              <1> device_read_escape:
   910 00000759 B90E000000          <1> 	mov	ecx, LP_ADDRESS
   911 0000075E E994070000          <1> 	jmp	guard_ii_escape
   912                              <1> 
   913                              <1> 
   914                              <1> device_read_sysmem:			; readout system memory array
   915 00000763 E956FCFFFF          <1> 	jmp	memory_read_on		; allow all variations partial word / multiword
   916                              <1> 
   917                              <1> device_read_data16:			; readout 16-bit array
   918                              <1> 
   919 00000768 80F907              <1> 	cmp	cl, 7
   920 0000076B 741A                <1> 	jz	device_read_data16_4
   921 0000076D 80F906              <1> 	cmp	cl, 6
   922 00000770 7409                <1> 	jz	device_read_data16_2
   923 00000772 EB00                <1> 	jmp	device_read_data16_1
   924                              <1> 
   925                              <1> device_read_data16_1:			; readout 1 word of 16-bit array
   926 00000774 0FB70477            <1> 	movzx	eax, word ptr [edi+esi*2]
   927 00000778 86E0                <1> 	xchg	ah, al
   928 0000077A C3                  <1> 	ret
   929                              <1> 
   930                              <1> device_read_data16_2:			; readout 2 words of 16-bit array
   931 0000077B 8B0477              <1> 	mov	eax, dword ptr [edi+esi*2]	; 4.3.2.1
   932 0000077E 0FC8                <1> 	bswap	eax				; 1.2.3.4
   933 00000780 0FB7D8              <1> 	movzx	ebx, ax				; 0.0.3.4
   934 00000783 C1E810              <1> 	shr	eax, 16				; 0.0.1.2
   935 00000786 C3                  <1> 	ret
   936                              <1> 
   937                              <1> device_read_data16_4:			; readout 4 words of 16-bit array
   938 00000787 8B0477              <1> 	mov	eax, dword ptr [edi+esi*2]
   939 0000078A 0FC8                <1> 	bswap	eax				; 1.2.3.4
   940 0000078C 0FB7C8              <1> 	movzx	ecx, ax
   941 0000078F C1E810              <1> 	shr	eax, 16
   942 00000792 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   943 00000796 894C9D04            <1> 	mov	dword ptr [ebp+ebx*4+4], ecx
   944                              <1> 
   945 0000079A 8B447704            <1> 	mov     eax, dword ptr [edi+esi*2+4]
   946 0000079E 0FC8                <1> 	bswap	eax				; 5.6.7.8
   947 000007A0 0FB7C8              <1> 	movzx	ecx, ax
   948 000007A3 C1E810              <1> 	shr	eax, 16
   949 000007A6 89449D08            <1> 	mov	dword ptr [ebp+ebx*4+8], eax
   950 000007AA 894C9D0C            <1> 	mov	dword ptr [ebp+ebx*4+12], ecx
   951 000007AE C3                  <1> 	ret
   952                              <1> 
   953                              <1> device_read_array24:			; readout from packed 24-bit array
   954 000007AF E83C010000          <1> 	call	device_array24_setpointer
   955                              <1> 
   956 000007B4 80F907              <1> 	cmp	cl, 7
   957 000007B7 7440                <1> 	jz	device_read_array24_4
   958 000007B9 80F906              <1> 	cmp	cl, 6
   959 000007BC 7430                <1> 	jz	device_read_array24_2
   960 000007BE EB00                <1> 	jmp	device_read_array24_1
   961                              <1> 
   962                              <1> device_read_array24_1:			; readout a word of packed 24-bit array
   963 000007C0 660FB60437          <1> 	movzx	ax, byte ptr [edi+esi]
   964 000007C5 C1E008              <1> 	shl	eax, 8
   965 000007C8 8A443701            <1> 	mov	al, byte ptr [edi+esi+1]
   966 000007CC C1E008              <1> 	shl	eax, 8
   967 000007CF 8A443702            <1> 	mov	al, byte ptr [edi+esi+2]
   968 000007D3 83C603              <1> 	add	esi, 3
   969 000007D6 C3                  <1> 	ret
   970                              <1> 
   971                              <1> device_read_array24_1R:
   972 000007D7 660FB61C37          <1> 	movzx	bx, byte ptr [edi+esi]
   973 000007DC C1E308              <1> 	shl	ebx, 8
   974 000007DF 8A5C3701            <1> 	mov	bl, byte ptr [edi+esi+1]
   975 000007E3 C1E308              <1> 	shl	ebx, 8
   976 000007E6 8A5C3702            <1> 	mov	bl, byte ptr [edi+esi+2]
   977 000007EA 83C603              <1> 	add	esi, 3
   978 000007ED C3                  <1> 	ret
   979                              <1> 
   980                              <1> device_read_array24_2:			; readout 2 words of packed 24-bit array
   981 000007EE E8CDFFFFFF          <1> 	call	device_read_array24_1
   982 000007F3 E8DFFFFFFF          <1> 	call	device_read_array24_1R
   983 000007F8 C3                  <1> 	ret
   984                              <1> 
   985                              <1> device_read_array24_4:			; readout 4 words of packed 24-bit array
   986 000007F9 E8C2FFFFFF          <1> 	call	device_read_array24_1
   987 000007FE 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   988 00000802 E8B9FFFFFF          <1> 	call	device_read_array24_1
   989 00000807 89449D04            <1> 	mov	dword ptr [ebp+ebx*4+4], eax
   990 0000080B E8B0FFFFFF          <1> 	call	device_read_array24_1
   991 00000810 89449D08            <1> 	mov	dword ptr [ebp+ebx*4+8], eax
   992 00000814 E8A7FFFFFF          <1> 	call	device_read_array24_1
   993 00000819 89449D0C            <1> 	mov	dword ptr [ebp+ebx*4+12], eax
   994 0000081D C3                  <1> 	ret
   995                              <1> 
   996                              <1> _device_write:				; store device arrays
   997 0000081E A900008000          <1> 	test	eax, 0800000h		; the vilainous bank index?
   998 00000823 7537                <1> 	jnz	device_write_escape
   999                              <1> 
  1000                              <1>                                         ; edi -> core.REGISTER
  1001 00000825 C1E002              <1>         shl     eax, 2                  ; al is device index * 4
  1002 00000828 50                  <1>         push    eax                     ; rest of eax is block index * 4
  1003 00000829 0FB6C0              <1>         movzx   eax, al                 ; extend device number
  1004                              <1>                                         ; sense device descriptor
  1005                              <1> 
  1006                              <1> ;	mov	edi, dword ptr [ebp+CORE_INDEX1]
  1007 0000082C 0F7EFF              <1> 	movd	edi, mm7
  1008                              <1> 
  1009 0000082F F68438D2060000C0    <1>         test    byte ptr [edi+eax+IO_PORT+_DEVICE+2], 192
  1010                              <1> 
  1011 00000837 58                  <1>         pop     eax                     ; recover storage block index
  1012                              <1> 
  1013 00000838 7422                <1>         jz      device_write_escape      ; neither type flag set
  1014                              <1> 
  1015 0000083A 9C                  <1>         pushfd                          ; sign is set for descriptor bit 23     
  1016                              <1>                                         ; parity is set if both bits are
  1017                              <1> 
  1018 0000083B 8AAFA0040000        <1>         mov     ch, byte ptr [edi+PSR]  ; flag field with byte options for memory read
  1019 00000841 0FB6F8              <1>         movzx   edi, al                 ; device select
  1020                              <1> 
  1021 00000844 30C0                <1>         xor     al, al                  ; add storage block to offset
  1022 00000846 C1E00A              <1>         shl     eax, 10                 ; block index * 64 * 4 now times 262144
  1023 00000849 01C6                <1>         add     esi, eax                ; offset += <-
  1024                              <1> 
  1025 0000084B 8BBF[00000000]      <1>         mov     edi,  dword ptr [_devices+edi]
  1026                              <1> 
  1027                              <1>                                         ; known that one or two bits is set
  1028 00000851 58                  <1>         pop     eax                     ; flags from test of device     
  1029                              <1> 
  1030 00000852 A804                <1>         test    al, 4                   ; parity?
  1031 00000854 754E                <1>         jnz     device_write_array24    ; parity -> 2 bits set -> FSYS24 bus
  1032 00000856 A880                <1>         test    al, 128                 ; sign -> descriptor bit 23 -> SYSMEM
  1033 00000858 7411                <1>         jz      device_write_data16     ; otherwise NET16 trunk
  1034 0000085A EB0A                <1>         jmp     device_write_sysmem     ; system memory type if yes                     
  1035                              <1> 
  1036                              <1> device_write_escape:
  1037 0000085C B90E000000          <1> 	mov	ecx, LP_ADDRESS
  1038 00000861 E991060000          <1> 	jmp	guard_ii_escape
  1039                              <1> 
  1040                              <1> 
  1041                              <1> device_write_sysmem:
  1042 00000866 E902FDFFFF          <1> 	jmp	memory_write_on		; allow all variations partial word / multiword
  1043                              <1> 
  1044                              <1> device_write_data16:
  1045                              <1> 
  1046 0000086B 80F907              <1> 	cmp	cl, 7
  1047 0000086E 740E                <1> 	jz	device_write_data16_4
  1048 00000870 80F906              <1> 	cmp	cl, 6
  1049 00000873 741C                <1> 	jz	device_write_data16_2
  1050 00000875 EB00                <1> 	jmp	device_write_data16_1
  1051                              <1> 
  1052                              <1> device_write_data16_1:			; store 16-bit array
  1053 00000877 86FB                <1> 	xchg	bh, bl
  1054 00000879 66891C77            <1> 	mov	word ptr [edi+esi*2], bx
  1055 0000087D C3                  <1> 	ret
  1056                              <1> 
  1057                              <1> 
  1058                              <1> device_write_data16_4:			; store 4 words in 16-bit array
  1059                              <1> 					; low-order half is swapped on bus read
  1060                              <1> 					; and canonical in eax
  1061 0000087E 668B449D08          <1> 	mov	ax, word ptr [ebp+ebx*4+8]	; get low-order half 3rd register
  1062 00000883 C1E010              <1> 	shl	eax, 16				; 5.6.0.0
  1063 00000886 668B449D0C          <1> 	mov	ax, word ptr [ebp+ebx*4+12]	; 5.6.7.8
  1064 0000088B 0FC8                <1> 	bswap	eax				; it's correct so swap for bus write
  1065 0000088D 89447704            <1> 	mov	dword ptr [edi+esi*2+4], eax
  1066                              <1> 
  1067                              <1> 
  1068                              <1> device_write_data16_2:			; store 2 words in 16-bit array
  1069                              <1> 					; registers are modeled in storage
  1070                              <1> 					; so each bus read corrects an octet pair
  1071                              <1> 
  1072 00000891 668B449D00          <1> 	mov	ax, word ptr [ebp+ebx*4]	; get low-order half 1st register
  1073 00000896 C1E010              <1> 	shl	eax, 16				; 1.2.0.0
  1074 00000899 668B449D04          <1> 	mov	ax, word ptr [ebp+ebx*4+4]	; 1.2.3.4
  1075 0000089E 0FC8                <1> 	bswap	eax				; it's correct, so swap for bus write
  1076 000008A0 890477              <1> 	mov	dword ptr [edi+esi*2], eax
  1077 000008A3 C3                  <1> 	ret
  1078                              <1> 
  1079                              <1> device_write_array24:			; store 24-bit packed array
  1080 000008A4 E847000000          <1> 	call	device_array24_setpointer
  1081                              <1> 
  1082 000008A9 80F907              <1> 	cmp	cl, 7
  1083 000008AC 7434                <1> 	jz	device_write_array24_4
  1084 000008AE 80F906              <1> 	cmp	cl, 6
  1085 000008B1 741C                <1> 	jz	device_write_array24_2
  1086 000008B3 EB00                <1> 	jmp	device_write_array24_1
  1087                              <1> 
  1088                              <1> device_write_array24_1:			; store 1 word in packed 24-bit array
  1089 000008B5 89D8                <1> 	mov	eax, ebx
  1090                              <1> device_write_array24_x:
  1091 000008B7 C1C010              <1> 	rol	eax, 16
  1092 000008BA 880437              <1> 	mov	byte ptr [edi+esi], al
  1093 000008BD C1C008              <1> 	rol	eax, 8
  1094 000008C0 88443701            <1> 	mov	byte ptr [edi+esi+1], al
  1095 000008C4 C1C008              <1> 	rol	eax, 8
  1096 000008C7 88443702            <1> 	mov	byte ptr [edi+esi+2], al
  1097 000008CB 83C603              <1> 	add	esi, 3
  1098 000008CE C3                  <1> 	ret
  1099                              <1> 
  1100                              <1> device_write_array24_2:			; store 2 words in packed 24-bit array
  1101 000008CF 8B449D00            <1> 	mov	eax, [ebp+ebx*4]
  1102 000008D3 E8DFFFFFFF          <1> 	call	device_write_array24_x
  1103 000008D8 8B449D04            <1> 	mov	eax, [ebp+ebx*4+4]
  1104 000008DC E8D6FFFFFF          <1> 	call	device_write_array24_x
  1105                              <1> ;	add	ebx, 2
  1106 000008E1 C3                  <1> 	ret
  1107                              <1> 
  1108                              <1> device_write_array24_4:			; store 4 words in packed 24-bit array
  1109 000008E2 E8E8FFFFFF          <1> 	call	device_write_array24_2
  1110 000008E7 83C302              <1> 	add	ebx, 2
  1111 000008EA E8E0FFFFFF          <1> 	call	device_write_array24_2
  1112 000008EF C3                  <1> 	ret
  1113                              <1> 
  1114                              <1> device_array24_setpointer:
  1115 000008F0 89F0                <1> 	mov	eax, esi			; think of a number
  1116 000008F2 D1E0                <1> 	shl	eax, 1				; double it
  1117 000008F4 01C6                <1> 	add	esi, eax			; add it to the number you first thought of...
  1118 000008F6 C3                  <1> 	ret
  1119                              <1> 
    31                                  	%include	"base_map.msm"
     1                              <1> base_read_pointer:
     2 000008F7 89C7                <1> 	mov	edi, eax		; keep EA for +words reads
     3                              <1> 					; straddling storage blocks
     4 000008F9 C1C910              <1> 	ror	ecx, 16			; conserve designator / word counts
     5                              <1> 
     6 000008FC C1C812              <1> 	ror	eax, 18
     7 000008FF A83F                <1> 	test	al, 63
     8 00000901 750C                <1> 	jnz	read_address18
     9 00000903 C1C006              <1> 	rol	eax, 6
    10 00000906 660FB6C8            <1> 	movzx	cx, al
    11 0000090A C1E814              <1> 	shr	eax, 32-12
    12                              <1> 					; advise caller address 6.12
    13 0000090D EB07                <1> 	jmp	resolve_read_tag	; this path is  most storage reads
    14                              <1> 	
    15                              <1> read_address18:
    16 0000090F 660FB6C8            <1> 	movzx	cx, al
    17 00000913 C1E80E              <1> 	shr	eax, 32-18
    18                              <1> 
    19                              <1> resolve_read_tag:
    20                              <1> 
    21 00000916 80E13F              <1> 	and	cl, 63
    22 00000919 7418                <1> 	jz	read_window_clear	; everyone may read B0
    23 0000091B F6C138              <1> 	test	cl, 56
    24 0000091E 7513                <1> 	jnz	read_window_clear
    25 00000920 80F10F              <1> 	xor	cl, 15			; [ 1 2 3 4 5 6 7 ] -> 8 + [ 6 5 4 3 2 1 0]
    26 00000923 660FA38EA0040000    <1> 	bt	word ptr [esi+PSR], cx	; in memory bytes ffff f00c 0xxx xxxx
    27 0000092B 7303                <1> 	jnc	read_application_window	; x86 bus read -> 0xxx xxxx ffff f00c
    28 0000092D 80C940              <1> 	or	cl, 64
    29                              <1> 
    30                              <1> read_application_window:
    31 00000930 80F10F              <1> 	xor	cl, 15			; [ 1 2 3 4 5 6 7 ] <- 8 + [ 6 5 4 3 2 1 0]
    32                              <1> 
    33                              <1> read_window_clear:
    34 00000933 50                  <1> 	push	eax
    35 00000934 0FB6C1              <1> 	movzx	eax, cl
    36 00000937 8B8486D0040000      <1> 	mov	eax, dword ptr [esi+eax*4+IO_PORT]
    37 0000093E 5E                  <1> 	pop	esi
    38                              <1> 
    39 0000093F C1C910              <1> 	ror	ecx, 16
    40 00000942 C3                  <1> 	ret
    41                              <1> 
    42 00000943 FF00800000000000    <1> write_rule	db	255, 0, 128, 0, 0, 0, 0, 0
    43 0000094B 0000000000000000    <1> 		db	0, 0, 0, 0, 0, 0, 0, 0
    44 00000953 0000000000000000    <1> 		db	0, 0, 0, 0, 0, 0, 0, 0
    45 0000095B 0000000000000000    <1> 		db	0, 0, 0, 0, 0, 0, 0, 0
    46 00000963 0000000000000000    <1> 		db	0, 0, 0, 0, 0, 0, 0, 0
    47 0000096B 0000000000000000    <1> 		db	0, 0, 0, 0, 0, 0, 0, 0
    48 00000973 0000000000000000    <1> 		db	0, 0, 0, 0, 0, 0, 0, 0
    49 0000097B 0000000000000000    <1> 		db	0, 0, 0, 0, 0, 0, 0, 0
    50 00000983 FF80808080808080    <1> 		db	255, 128, 128, 128, 128, 128, 128, 128
    51                              <1> 
    52                              <1> base_write_pointer:
    53                              <1> 
    54 0000098B 89C7                <1> 	mov	edi, eax		; keep EA for +words writes
    55 0000098D C1C910              <1> 	ror	ecx, 16			; straddling storage blocks
    56                              <1> 					; protect designators in ecx
    57 00000990 C1C812              <1> 	ror	eax, 18			
    58                              <1> 
    59 00000993 A83F                <1> 	test	al, 63
    60 00000995 750C                <1> 	jnz	write_address18
    61 00000997 C1C006              <1> 	rol	eax, 6
    62 0000099A 660FB6C8            <1> 	movzx	cx, al
    63 0000099E C1E814              <1> 	shr	eax, 32-12
    64 000009A1 EB07                <1> 	jmp	resolve_write_tag	; this path is
    65                              <1> 					; most storge writes
    66                              <1> write_address18:
    67 000009A3 660FB6C8            <1> 	movzx	cx, al
    68 000009A7 C1E80E              <1> 	shr	eax, 32-18
    69                              <1> 	
    70                              <1> resolve_write_tag:
    71                              <1> 
    72 000009AA 80E13F              <1> 	and	cl, 63
    73 000009AD 0F843F050000        <1> 	jz	near guard_ii_authority	; no-one may write B0
    74 000009B3 F6C138              <1> 	test	cl, 56
    75 000009B6 7513                <1> 	jnz	write_window_known
    76 000009B8 80F10F              <1> 	xor	cl, 15			; [ 1 2 3 4 5 6 7 ] -> 8 + [ 6 5 4 3 2 1 0]
    77 000009BB 660FA38EA0040000    <1> 	bt	word ptr [esi+PSR], cx		; in memory bytes ffff f00c 0xxx xxxx
    78 000009C3 7303                <1> 	jnc	write_application_window	; x86 bus read -> 0xxx xxxx ffff f00c
    79 000009C5 80C940              <1> 	or	cl, 64
    80                              <1> 
    81                              <1> write_application_window:
    82 000009C8 80F10F              <1> 	xor	cl, 15			; [ 1 2 3 4 5 6 7 ] <- 8 + [ 6 5 4 3 2 1 0]
    83                              <1> 
    84                              <1> write_window_known:
    85 000009CB 50                  <1> 	push	eax
    86 000009CC 0FB6C1              <1> 	movzx	eax, cl
    87 000009CF F680[43090000]80    <1> 	test	byte ptr [eax+write_rule], 128
    88 000009D6 740D                <1> 	jz	write_window_free
    89 000009D8 F686A204000080      <1> 	test	byte ptr [esi+PSR+2], 128	; ISR ?
    90 000009DF 0F840D050000        <1> 	jz	near guard_ii_authority		; the unbalanced push is harmless
    91                              <1> 						; stack is reset on faults
    92                              <1> write_window_free:
    93 000009E5 8B8486D0040000      <1> 	mov	eax, dword ptr [esi+eax*4+IO_PORT]
    94 000009EC 5E                  <1> 	pop	esi
    95                              <1> 
    96 000009ED C1C910              <1> 	ror	ecx, 16		; restore designator information
    97 000009F0 C3                  <1> 	ret
    32                                  	%include	"sr.msm"
     1                              <1> 
     2                              <1> ;	read staging register
     3                              <1> ;	read bits from a stream of bits
     4                              <1> 
     5 000009F1 8B4E50              <1> _rsr:	mov	ecx, dword ptr [esi+RDATAC]
     6 000009F4 88CD                <1> 	mov	ch, cl
     7 000009F6 88C1                <1> 	mov	cl, al
     8                              <1> 
     9 000009F8 31C0                <1> 	xor	eax, eax
    10 000009FA F786A0040000400000- <1> 	test	dword ptr [esi+PSR], B_STREAMZR
    10 00000A03 00                  <1>
    11 00000A04 7503                <1> 	jnz	_rsr_zadd
    12 00000A06 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
    13                              <1> _rsr_zadd:
    14 00000A09 20C9                <1> 	and	cl, cl
    15 00000A0B 7450                <1> 	jz	_rsr_x
    16 00000A0D 8B5E54              <1> 	mov	ebx, dword ptr [esi+RDATA]
    17                              <1> 
    18 00000A10 20ED                <1> 	and	ch, ch			; any data loaded yet?
    19 00000A12 740F                <1> 	jz	_rsr_read		; if not read first no question 
    20 00000A14 38CD                <1> 	cmp	ch, cl			; otherwise, already enough for request?
    21 00000A16 7330                <1> 	jnb	_rsr_draw		; if so deliver data
    22 00000A18 28E9                <1> 	sub	cl, ch			; if not trim the oustanding count
    23 00000A1A 86CD                <1> 	xchg	cl, ch			
    24 00000A1C E8090F0000          <1> 	call	dsl			; and deliver available data
    25 00000A21 86E9                <1> 	xchg	ch, cl			; before reading some more
    26                              <1> _rsr_read:
    27 00000A23 E894000000          <1> 	call	stream_read
    28                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]	; after call to operand_read
    29 00000A28 0F7EFE              <1> 	movd	esi, mm7
    30                              <1> 
    31 00000A2B C7465018000000      <1> 	mov	dword ptr [esi+RDATAC], 24
    32 00000A32 F786A0040000200000- <1> 	test	dword ptr [esi+PSR], B_STREAM16R
    32 00000A3B 00                  <1>
    33 00000A3C 740A                <1> 	jz	_rsr_draw
    34 00000A3E C7465010000000      <1> 	mov	dword ptr [esi+RDATAC], 16
    35 00000A45 C1E308              <1> 	shl	ebx, 8
    36                              <1> _rsr_draw:
    37 00000A48 6651                <1> 	push	cx
    38 00000A4A E8DB0E0000          <1> 	call	dsl
    39 00000A4F 6659                <1> 	pop	cx
    40 00000A51 81E1FF000000        <1> 	and	ecx, 255
    41 00000A57 294E50              <1> 	sub	dword ptr [esi+RDATAC], ecx
    42 00000A5A 895E54              <1> 	mov	dword ptr [esi+RDATA], ebx
    43                              <1> _rsr_x:
    44 00000A5D 894510              <1> 	mov	dword ptr [ebp+A], eax
    45 00000A60 C3                  <1> 	ret
    46                              <1> 
    47                              <1> 
    48                              <1> ;	write staging register
    49                              <1> ;	write bits to a stream of bits
    50                              <1> 
    51 00000A61 8B4E58              <1> _wsr:	mov	ecx, dword ptr [esi+WDATAC]
    52 00000A64 88CD                <1> 	mov	ch, cl					; accumulated count
    53 00000A66 88C1                <1> 	mov	cl, al					; new request
    54                              <1> 
    55 00000A68 8B465C              <1> 	mov	eax, dword ptr [esi+WDATA]	; accumulated data
    56 00000A6B 8B5D10              <1> 	mov	ebx, dword ptr [ebp+A]		; source new data
    57                              <1> 
    58 00000A6E 80C5E8              <1> 	add	ch, -24				; space for new data expressed negative
    59 00000A71 F786A0040000100000- <1> 	test	dword ptr [esi+PSR], B_STREAM16W	; 16 bits / word flag
    59 00000A7A 00                  <1>
    60 00000A7B 7403                <1> 	jz	_wsr24
    61 00000A7D 80C508              <1> 	add	ch, 8
    62                              <1> 
    63 00000A80 00CD                <1> _wsr24:	add	ch, cl			; increment towards zero
    64 00000A82 7404                <1> 	jz	_wsr_write		; accumulated word exactly full
    65 00000A84 731D                <1> 	jnc	_wsr_add		; not yet full
    66                              <1> 
    67 00000A86 28E9                <1> 	sub	cl, ch			; full + some more
    68                              <1> 
    69                              <1> _wsr_write:
    70 00000A88 E89D0E0000          <1> 	call	dsl			; fill output word
    71 00000A8D 88E9                <1> 	mov	cl, ch			; position outstanding count
    72 00000A8F E83D000000          <1> 	call	stream_write
    73                              <1> 
    74                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]	; after call to operand_write
    75 00000A94 0F7EFE              <1> 	movd	esi, mm7
    76                              <1> 
    77 00000A97 B800000000          <1> 	mov	eax, 0
    78 00000A9C C7465800000000      <1> 	mov	dword ptr [esi+REGISTER+WDATAC], 0
    79                              <1> 
    80                              <1> _wsr_add:
    81 00000AA3 6651                <1> 	push	cx
    82 00000AA5 E8800E0000          <1> 	call	dsl			; add to output word
    83 00000AAA 6659                <1> 	pop	cx
    84 00000AAC 81E1FF000000        <1> 	and	ecx, 255		; format ecx for add to accumulated count 
    85 00000AB2 014E58              <1> 	add	dword ptr [esi+REGISTER+WDATAC], ecx
    86 00000AB5 89465C              <1> 	mov	dword ptr [esi+REGISTER+WDATA], eax
    87 00000AB8 895D10              <1> 	mov	dword ptr [ebp+A], ebx
    88 00000ABB C3                  <1> 	ret
    89                              <1> 
    90                              <1> stream_read:
    91 00000ABC 51                  <1> 	push	ecx
    92 00000ABD 50                  <1> 	push	eax
    93 00000ABE 8B4534              <1> 	mov	eax, dword ptr [ebp+Q]
    94 00000AC1 83453401            <1> 	add	dword ptr [ebp+Q], 1
    95 00000AC5 30C9                <1> 	xor	cl, cl
    96 00000AC7 E885F8FFFF          <1> 	call	_operand_read
    97 00000ACC 89C3                <1> 	mov	ebx, eax
    98 00000ACE 58                  <1> 	pop	eax
    99 00000ACF 59                  <1> 	pop	ecx
   100 00000AD0 C3                  <1> 	ret
   101                              <1> 
   102                              <1> stream_write:
   103 00000AD1 51                  <1> 	push	ecx
   104 00000AD2 53                  <1> 	push	ebx
   105 00000AD3 89C3                <1> 	mov	ebx, eax
   106 00000AD5 8B4530              <1> 	mov	eax, dword ptr [ebp+P]
   107 00000AD8 83453001            <1> 	add	dword ptr [ebp+P], 1
   108 00000ADC 30C9                <1> 	xor	cl, cl
   109 00000ADE E800FAFFFF          <1> 	call	_operand_write
   110 00000AE3 5B                  <1> 	pop	ebx
   111 00000AE4 59                  <1> 	pop	ecx
   112 00000AE5 C3                  <1> 	ret
   113                              <1> 
    33                                  	%include	"io.msm"
     1 00000AE6 8B9C86D0040000      <1> _inA:	mov	ebx, dword ptr [esi+IO_PORT+eax*4]
     2 00000AED 895D10              <1> 	mov	dword ptr [ebp+A], ebx
     3 00000AF0 C3                  <1> _inA_:	ret
     4                              <1> 
     5 00000AF1 8B9C86D0040000      <1> _inB:	mov	ebx, dword ptr [esi+IO_PORT+eax*4]
     6 00000AF8 895D14              <1> 	mov	dword ptr [ebp+B], ebx
     7 00000AFB C3                  <1> _inB_:	ret
     8                              <1> 
     9 00000AFC 8B5D10              <1> _outA:	mov	ebx, dword ptr [ebp+A]
    10 00000AFF E9AF010000          <1> 	jmp	oport
    11                              <1> 
    12 00000B04 8B5D14              <1> _outB:	mov	ebx, dword ptr [ebp+B]
    13 00000B07 E9A7010000          <1> 	jmp	oport
    14                              <1> 
    15                              <1> 
    16                              <1> ISR_ONLY equ	8
    17                              <1> MEMTYPE	equ	1
    18                              <1> MEMZERONLY equ	2
    19                              <1> EXTERNAL_IO equ	4
    20                              <1> BROADCAST equ	16
    21                              <1> 
    22                              <1> B_1	equ	MEMTYPE
    23                              <1> B_TCB	equ	MEMTYPE+ISR_ONLY
    24                              <1> B_KERN	equ	MEMTYPE+ISR_ONLY
    25                              <1> A_THREP	equ	MEMZERONLY+ISR_ONLY
    26                              <1> I_PORT	equ	EXTERNAL_IO
    27                              <1> O_PORT	equ	EXTERNAL_IO
    28                              <1> O_INDICA equ	EXTERNAL_IO
    29                              <1> O_CHILL	equ	EXTERNAL_IO
    30                              <1> I_TZONE	equ	EXTERNAL_IO
    31                              <1> RAM_THRESH equ	ISR_ONLY+MEMZERONLY
    32                              <1> XI_ACK	equ	ISR_ONLY+EXTERNAL_IO
    33                              <1> O_LEDS	equ	EXTERNAL_IO
    34                              <1> O_SYSSWCH equ	EXTERNAL_IO
    35                              <1> O_INC	equ	ISR_ONLY+EXTERNAL_IO
    36                              <1> O_MCAST	equ	ISR_ONLY+BROADCAST
    37                              <1> 
    38                              <1> 
    39                              <1> mask_port_outAB:
    40 00000B0C 000100000000000000- <1> 	db    0,B_1,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    40 00000B15 00000000000000      <1>
    41 00000B1C 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    41 00000B25 00000000000000      <1>
    42                              <1> 
    43 00000B2C 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    43 00000B35 00000000000000      <1>
    44 00000B3C 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    44 00000B45 00000000000000      <1>
    45                              <1> 
    46 00000B4C 0009090909090909    <1> 	db	0,B_TCB,B_KERN,B_KERN,  B_KERN,B_KERN,B_KERN,B_KERN
    47 00000B54 0A00000C0C000018    <1> 	db	A_THREP,0,0,XI_ACK,     O_INC,0,0,O_MCAST
    48                              <1> 
    49 00000B5C 0404040404040404    <1> 	db	I_PORT,I_PORT,I_PORT,I_PORT,  I_PORT,I_PORT,I_PORT,I_PORT
    50 00000B64 0404040404040404    <1> 	db	O_PORT,O_PORT,O_PORT,O_PORT,  O_PORT,O_PORT,O_PORT,O_PORT
    51                              <1> 
    52 00000B6C 0000000000040404    <1> 	db	0,0,0,0,  0,I_TZONE,O_INDICA,O_CHILL
    53 00000B74 0000000000000000    <1> 	db	0,0,0,0,  0,0,0,0
    54 00000B7C 0000000000000000    <1> 	db	0,0,0,0,  0,0,0,0
    55 00000B84 0000000000000404    <1> 	db	0,0,0,0,  0,0,O_SYSSWCH,O_LEDS
    56                              <1> 
    57 00000B8C 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    57 00000B95 00000000000000      <1>
    58 00000B9C 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    58 00000BA5 00000000000000      <1>
    59 00000BAC 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    59 00000BB5 00000000000000      <1>
    60 00000BBC 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    60 00000BC5 00000000000000      <1>
    61                              <1> 
    62                              <1> 					; outA|B rules flags per I/O port
    63                              <1> 
    64                              <1> _reload:
    65 00000BCC 50                  <1> 	push	eax
    66 00000BCD 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
    67 00000BD0 83451002            <1> 	add	dword ptr [ebp+A], 2
    68 00000BD4 E836F7FFFF          <1> 	call	_burst_read2
    69 00000BD9 5F                  <1> 	pop	edi
    70 00000BDA 8984BED0040000      <1> 	mov	dword ptr [esi+IO_PORT+edi*4], eax
    71 00000BE1 899CBED4040000      <1> 	mov	dword ptr [esi+IO_PORT+edi*4+4], ebx
    72 00000BE8 C3                  <1> 	ret
    34                                  	%include	"sabr.msm"
     1                              <1> ;	check and write to I/O port <- storage base index in range [ 2..63 ]
     2                              <1> ;	write a copy to reload base table in thread control block
     3                              <1> ;	values out of memory range are replaced with trap device C00001
     4                              <1> ;	which causes GUARD$ exception if the sindow is accessed
     5                              <1> 
     6                              <1> ;	anauthorised actions
     7                              <1> ;
     8                              <1> ;		attempt to write window base < 2 or > 63
     9                              <1> ;		application selecting ISR space
    10                              <1> ;		application selecting NVRAM
    11                              <1> ;
    12                              <1> ;	are not carried out and a GUARD$ exception is raised
    13                              <1> ;	ISRs write the trap device C00001 to close memory windows
    14                              <1> 
    15                              <1> _sabr_guard:
    16 00000BE9 E904030000          <1> 	jmp	guard_ii_authority
    17                              <1> 
    18 00000BEE A93E000000          <1> _sabr:	test	eax, 03Eh		; ea not < 2
    19 00000BF3 74F4                <1> 	jz	_sabr_guard
    20 00000BF5 A9C0FFFF00          <1> 	test	eax, 0FFFFC0h		; ea not > 63
    21 00000BFA 75ED                <1> 	jnz	_sabr_guard
    22                              <1> 
    23 00000BFC 8B4D10              <1> 	mov	ecx, dword ptr [ebp+A]
    24                              <1> 
    25 00000BFF F7C100004000        <1> 	test	ecx, 00400000h
    26 00000C05 7463                <1> 	jz	memory_page
    27 00000C07 F7C13F000000        <1> 	test	ecx, 63
    28 00000C0D 7455                <1> 	jz	large_memory_page
    29                              <1> 
    30 00000C0F F7C100008000        <1> 	test	ecx, 00800000h
    31 00000C15 740B                <1> 	jz	array_attribute
    32                              <1> 
    33 00000C17 F686A204000080      <1> 	test	byte ptr [esi+PSR+2], 128
    34 00000C1E 74C9                <1> 	jz	_sabr_guard
    35 00000C20 EB70                <1> 	jmp	unthru			; ISR write illegal device thru
    36                              <1> 					; closes the address space window
    37                              <1> 
    38                              <1> 					; application may not write device
    39                              <1> 					; but may zero -> sabr  with same effect
    40                              <1> array_attribute:
    41                              <1> 
    42 00000C22 C1E102              <1> 	shl	ecx, 2
    43 00000C25 0FB6D9              <1> 	movzx	ebx, cl			; cl = device * 4
    44                              <1> 
    45                              <1> 	%if	0
    46                              <1> 	mov	edi, dword ptr [_devices+ebx]
    47                              <1> 	%endif
    48                              <1> 
    49 00000C28 8B9C33D0060000      <1> 	mov	ebx, dword ptr [esi+ebx+IO_PORT+_DEVICE]
    50                              <1> 					; platform address + device descriptor
    51                              <1> 
    52                              <1> 
    53                              <1> 	%if	0
    54                              <1> 	mov	dword ptr [esi+eax*8+DATAFRAME], ebx	; rapid recall
    55                              <1> 	mov	dword ptr [esi+eax*8+DATAFRAME+4], edi	; device information
    56                              <1> 	%endif						; via window tag
    57                              <1> 
    58 00000C2F C1E908              <1> 	shr	ecx, 6+2		; lose previous shift + device code
    59 00000C32 F7C300004000        <1> 	test	ebx, 00400000h
    60 00000C38 750A                <1> 	jnz	peripheral_array
    61 00000C3A F7C300008000        <1> 	test	ebx, 00800000h
    62 00000C40 751D                <1> 	jnz	memory_array
    63                              <1> 
    64 00000C42 EBA5                <1> 	jmp	_sabr_guard		; no device code
    65                              <1> 
    66                              <1> peripheral_array:			; device types 00C00000 00400000
    67 00000C44 F686A204000080      <1> 	test	byte ptr [esi+PSR+2], 128
    68 00000C4B 749C                <1> 	jz	_sabr_guard
    69                              <1> 
    70 00000C4D 81E1FFFF0000        <1> 	and	ecx, 0000FFFFh		; have # large blocks in low 16 bits
    71 00000C53 81E3FFFF0000        <1> 	and	ebx, 0000FFFFh
    72 00000C59 29CB                <1> 	sub	ebx, ecx
    73 00000C5B 7932                <1> 	jns	thru
    74 00000C5D EB29                <1> 	jmp	_sabr_safeguard
    75                              <1> 
    76                              <1> memory_array:
    77 00000C5F C1E106              <1> 	shl	ecx, 6			; block * 64
    78 00000C62 EB14                <1> 	jmp	memory_array_bound?
    79                              <1> 
    80                              <1> large_memory_page:
    81 00000C64 81E1FFFFBF00        <1> 	and	ecx, 00BFFFFFh		; remove 00400000 bit for lower bound check
    82                              <1> 
    83                              <1> memory_page:
    84 00000C6A 8B9ED0060000        <1> 	mov	ebx, dword ptr [esi+IO_PORT+_DEVICE]	; device zero memory attribute
    85 00000C70 3B8EF0050000        <1> 	cmp	ecx, dword ptr [esi+IO_PORT+_APP_THRESHOLD]	; ISR / application boundary
    86 00000C76 7210                <1> 	jb	_sabr_safeguard
    87                              <1> 
    88                              <1> memory_array_bound?:
    89 00000C78 81E1FFFFBF00        <1> 	and	ecx, 00BFFFFFh		; bit 00800000 is a bad accident
    90 00000C7E 81E3FFFF3F00        <1> 	and	ebx, 003FFFFFh		; stop it here
    91 00000C84 29CB                <1> 	sub	ebx, ecx
    92 00000C86 7907                <1> 	jns	thru
    93                              <1> 
    94                              <1> _sabr_safeguard:
    95 00000C88 B90100C000          <1> 	mov	ecx, 00C00001h
    96 00000C8D EB03                <1> 	jmp	unthru
    97                              <1> 
    98 00000C8F 8B4D10              <1> thru:	mov	ecx, dword ptr [ebp+A]		; i.e. correct as supplied
    99 00000C92 898C86D0040000      <1> unthru:	mov	dword ptr [esi+eax*4+IO_PORT], ecx
   100                              <1> 
   101 00000C99 BF[00000000]        <1> 	mov	edi, _memory
   102 00000C9E 8B9ED4050000        <1> 	mov	ebx, dword ptr [esi+IO_PORT+65*4] ; thread control block
   103                              <1> 
   104 00000CA4 C1E30C              <1> 	shl	ebx, 12			; multiply to TCB size
   105 00000CA7 01C3                <1> 	add	ebx, eax		; ea is target base index
   106 00000CA9 0FC9                <1> 	bswap	ecx			; for this is a big endian memory write
   107 00000CAB 898C9F00010000      <1> 	mov	dword ptr [edi+ebx*4+64*4], ecx
   108 00000CB2 C3                  <1> 	ret				; save TCB reload copy of loaded pointer
    35                                  	%include	"oport.msm"
     1                              <1> 
     2                              <1> OOO_TRACE	equ	0
     3                              <1> 
     4                              <1> 							; static void oport(int ea, int value, smp *xcore)
     5                              <1> 							; {
     6                              <1> oport:		; write I / O port			;    int		 rule,
     7                              <1> 		; RTA instructions outA outB		;			 device;
     8                              <1> 							; 
     9                              <1> 		; ports which are memory pointers	;    int		 mask,
    10                              <1> 		; must have a block that exists		;			 from,
    11                              <1> 		; ISRs can write trap value C00001 	;                 	 index;
    12                              <1> 		; = device 400001 | illegal 800000	; 
    13                              <1> 		; port # = effective address = eax	;    int		 device_index = 0;
    14                              <1> 		; write value in ebx			; 
    15                              <1> 		; multicast bits in RTA register k	;    smp		*ascor;
    16                              <1> 		 					;    unsigned	*register_set = xcore->register_set;
    17 00000CB3 3DC0000000          <1> 	cmp	eax, IO_PORTS				; 
    18 00000CB8 0F8393000000        <1> 	jnb	near no_port				;    if (ea < IO_PORTS)
    19                              <1> 							;    {
    20 00000CBE 8A88[0C0B0000]      <1> 	mov	cl, byte ptr [eax+mask_port_outAB]	;       rule = mask_port_outAB[ea];
    21 00000CC4 20C9                <1> 	and	cl, cl					; 
    22 00000CC6 0F8485000000        <1> 	jz	near no_rule				;       if (rule)
    23 00000CCC F6C108              <1> 	test	cl, ISR_ONLY				;       {
    24 00000CCF 740D                <1> 	jz	application_plus_isr_rule		;          if (((rule & ISR_ONLY) == 0) || (psr & 0x00800000))
    25 00000CD1 F686A204000080      <1> 	test	byte ptr [esi+PSR+2], 128		;          {
    26 00000CD8 0F8473000000        <1> 	jz	near no_authority				;
    27                              <1> 							;
    28                              <1> application_plus_isr_rule:				;
    29 00000CDE F6C104              <1> 	test	cl, EXTERNAL_IO				;             if (rule & EXTERNAL_IO)
    30 00000CE1 7423                <1> 	jz	broadcast_rule?				;             {
    31 00000CE3 899C86D0040000      <1> 	mov	dword ptr [esi+IO_PORT+eax*4], ebx	;                base[ea] = value;
    32 00000CEA 83F866              <1> 	cmp	eax, 102	; INDICATION$		;                if (ea == 102) indication |= value;
    33 00000CED 7506                <1> 	jne	xi_ack?		 			;
    34 00000CEF 099E94040000        <1> 	or	dword ptr [esi+INDICATION], ebx		;
    35                              <1>  							;
    36                              <1> xi_ack?:							;
    37 00000CF5 83F84B              <1> 	cmp	eax, 75					;                if (ea == 75)
    38 00000CF8 750B                <1> 	jne	xi_no_ack				;                {
    39 00000CFA F6D3                <1> 	not	bl					;                    base[74] &= (value & 255) ^ 255;
    40 00000CFC 0FB6DB              <1> 	movzx	ebx, bl					;                    // indication |= (value & 255) << 8;
    41                              <1> 							;                }
    42 00000CFF 219EF8050000        <1> 	and	dword ptr [esi+IO_PORT+_XI_PENDING], ebx	; 
    43                              <1> xi_no_ack:						; //               if ((ea == 79) && (value & 1)) indication |= ATTENTION;
    44 00000D05 C3                  <1> 	ret						;                return;
    45                              <1> 							;             }
    46                              <1> 							; 
    47                              <1> broadcast_rule?:					;             if (rule & BROADCAST)
    48 00000D06 F6C110              <1> 	test	cl, BROADCAST				;             {
    49 00000D09 744B                <1> 	jz	memory_rule?				;                mask = k;
    50                              <1> 
    51                              <1> 	%if	OOO_TRACE
    52                              <1> 	inc	dword ptr [esi+REGISTER+282*4]
    53                              <1> 	%endif
    54                              <1> 
    55 00000D0B 52                  <1> 	push	edx	; borrow the program counter	;
    56                              <1> 
    57                              <1> 	%if	1
    58 00000D0C 8B96F4050000        <1> 	mov	edx, dword ptr [esi+IO_PORT+_CORE_PIN]	;
    59                              <1> 	%else
    60                              <1> 	mov	ecx, dword ptr [esi+IO_PORT+_CORE_SOCKET] ;
    61                              <1> 	mov	edx, 1					;
    62                              <1> 	shl	edx, cl		; source identifier bit	;
    63                              <1> 	%endif
    64                              <1> 							;
    65 00000D12 BF[00000000]        <1> 	mov	edi, _core				;
    66 00000D17 8B4D04              <1> 	mov	ecx, dword ptr [ebp+REGISTER+K]		;
    67 00000D1A 238EC4060000        <1> 	and	ecx, dword ptr [esi+IO_PORT+_CORES_MASK] ;
    68                              <1> 							;
    69                              <1> multicast_select:					;
    70 00000D20 D1E9                <1> 	shr	ecx, 1					;                from = base[77];
    71 00000D22 7321                <1> 	jnc	multicast_next				; 
    72                              <1> 
    73 00000D24 21DB                <1> 	and	ebx, ebx	; if all of it is zero
    74 00000D26 7416                <1> 	jz	multicast_time
    75                              <1> 
    76                              <1> ;	write the port unless this is a dayclock update	;  
    77                              <1> 
    78 00000D28 899C86D0040000      <1> 	mov	dword ptr [esi+IO_PORT+eax*4], ebx	;                for (index = 0; index < RTA_SMP; index++)
    79 00000D2F 099708060000        <1>         or      dword ptr [edi+IO_PORT+_MCAST_PENDING], edx ;            {
    80 00000D35 808F9404000080      <1>         or      byte ptr [edi+INDICATION], ATTENTION    ;                   if (mask & 1)
    81 00000D3C EB07                <1> 	jmp	multicast_next
    82                              <1> 
    83                              <1> multicast_time:
    84 00000D3E 808F9404000020      <1> 	or	byte ptr [edi+INDICATION], TPULSE
    85                              <1> 							;                   {
    86                              <1> multicast_next:						;                      ascor = core + index;
    87 00000D45 81C7D0070000        <1> 	add	edi, CORE_SIZE				;                      ascor->BASE[78] |= 1 << from;
    88                              <1> ;	shr	ecx, 1					;                      ascor->INDICATION |= ATTENTION;
    89 00000D4B 21C9                <1> 	and	ecx, ecx				;                   }
    90 00000D4D 75D1                <1> 	jnz	multicast_select			; 
    91 00000D4F 5A                  <1> 	pop	edx	; give back the program counter	;
    92 00000D50 C3                  <1> 	ret						;                   mask >>= 1;
    93                              <1> 							;                }
    94                              <1> no_port:						; 
    95                              <1> no_rule:						;                /**************************************************
    96                              <1> no_authority:						; 			keep these on the sending side
    97                              <1> 							; 			until constructing interrupt frame
    98 00000D51 E99C010000          <1> 	jmp	guard_ii_authority			; 			between instructions at target core
    99                              <1> 							;                         to avoid overwrites from other cores
   100                              <1> 							;                **************************************************/
   101                              <1> 							; 
   102                              <1> 							;                base[ea] = value;	/* latent parameter	*/
   103                              <1> 							;                return;
   104                              <1> 							;             }
   105                              <1> 							; 
   106                              <1> memory_rule?:	; system memory type only		;             else if (rule & MEMTYPE)
   107                              <1> 
   108 00000D56 F6C101              <1> 	test	cl, MEMTYPE				;             {
   109 00000D59 7459                <1> 	jz	page_pointer?				;                if (value & 0x00400000) device_index = value & 63;
   110 00000D5B F7C300004000        <1> 	test	ebx, 0400000h	; bank sized?		; 
   111 00000D61 745E                <1> 	jz	memory_page_pointer			;                if (device_index)
   112                              <1> 							;                {
   113 00000D63 F7C33F000000        <1> 	test	ebx, 63					;                   if (value & 0x00800000)
   114 00000D69 7419                <1> 	jz	device_is_pointed			;                   {
   115 00000D6B F7C300008000        <1> 	test	ebx, 0800000h	; the trap device?	;                      if (psr & 0x00800000)
   116 00000D71 7411                <1> 	jz	device_is_pointed			;                      {
   117 00000D73 F686A204000080      <1> 	test	byte ptr [esi+PSR+2], 128	; ISR?		;                         base[ea] = value;
   118 00000D7A 74D5                <1> 	jz	no_authority				;                         return;
   119 00000D7C 899C86D0040000      <1> 	mov	[esi+IO_PORT+eax*4], ebx		;                      }
   120 00000D83 C3                  <1> 	ret						; 
   121                              <1> 							;                      GUARD_AUTHORITY
   122                              <1> device_is_pointed:					;                      return;
   123 00000D84 8B8ED0060000        <1> 	mov	ecx, dword ptr [esi+IO_PORT+_DEVICE]	;                   }
   124 00000D8A F7C100008000        <1> 	test	ecx, 00800000h				;                }
   125 00000D90 74BF                <1> 	jz	no_authority				; 
   126 00000D92 F7C100004000        <1> 	test	ecx, 00400000h				;                device = base[128+device_index];
   127 00000D98 75B7                <1> 	jnz	no_authority				;            
   128 00000D9A 81E1FFFF3F00        <1> 	and	ecx, 003FFFFFh				;                if ((device & 0x00C00000) == 0x00800000)
   129 00000DA0 89DF                <1> 	mov	edi, ebx				;                {
   130 00000DA2 81E7FFFF3F00        <1> 	and	edi, 003FFFFFh	; catch any 00800000	;                   if ((value & 0x003FFFC0) > (device & 0x003FFFFF))
   131 00000DA8 39F9                <1> 	cmp	ecx, edi				;                   {
   132 00000DAA 7233                <1> 	jb	outwith		; beyond memory		;                   }
   133 00000DAC 899C86D0040000      <1> 	mov	[esi+IO_PORT+eax*4], ebx		;                   else
   134 00000DB3 C3                  <1> 	ret						;                   {
   135                              <1> 							;                      base[ea] = value;
   136                              <1> 							;                      return;
   137                              <1> 							;                   }
   138                              <1> 							;                }
   139                              <1> 							;             }
   140                              <1> 							;             else
   141                              <1> 							;             {
   142                              <1> 							;                /*******************************************
   143                              <1> ;	only a device zero page index will do		; 			page pointer to system memory
   144                              <1> 							;                *******************************************/
   145                              <1> page_pointer?:						; 
   146 00000DB4 F6C102              <1> 	test	cl, MEMZERONLY				;                if ((value & 0x00400000) == 0)
   147 00000DB7 7498                <1> 	jz	no_rule					;                {
   148 00000DB9 F7C30000C000        <1> 	test	ebx, 00C00000h				;                   if (value > (base[128] & 0x003FFFFF))
   149 00000DBF 7590                <1> 	jnz	no_authority				;                   {
   150                              <1> 							;                   }
   151                              <1> memory_page_pointer:					;                   else
   152 00000DC1 8B8ED0060000        <1> 	mov	ecx, dword ptr [esi+IO_PORT+_DEVICE]	;                   {
   153 00000DC7 81E1FFFF3F00        <1> 	and	ecx, 003FFFFFh				;                      base[ea] = value;
   154 00000DCD 81E3FFFFFF00        <1> 	and	ebx, 00FFFFFFh				;                      return;
   155 00000DD3 39D9                <1> 	cmp	ecx, ebx				;                   }
   156 00000DD5 7208                <1> 	jb	outwith					;                }
   157 00000DD7 899C86D0040000      <1> 	mov	dword ptr [esi+IO_PORT+eax*4], ebx		;             }
   158 00000DDE C3                  <1> 	ret						;          }
   159                              <1> 							;       }
   160                              <1> 							;    }
   161                              <1> outwith:							; 
   162 00000DDF B90E000000          <1> 	mov	ecx, LP_ADDRESS				;    GUARD_AUTHORITY;
   163 00000DE4 E90E010000          <1> 	jmp	guard_ii_escape				; }							; 
    36                                  	%include	"ii.msm"
     1 00000DE9 660986A0040000      <1> _on:	or	word ptr [esi+PSR], ax	; only touch low-order 16 bits
     2 00000DF0 C3                  <1> 	ret
     3                              <1> 
     4 00000DF1 6683F0FF            <1> _off:	xor	ax, 0000FFFFh
     5 00000DF5 662186A0040000      <1> 	and	word ptr [esi+PSR], ax	; only touch low-order 16 bits
     6 00000DFC C3                  <1> 	ret
     7                              <1> 
     8                              <1> RELOAD_SMPP	equ	1
     9                              <1> III_TRACE	equ	0
    10                              <1> 
    11                              <1> _xi:
    12                              <1> 	%if	RELOAD_SMPP
    13                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
    14 00000DFD 0F7EFE              <1> 	movd	esi, mm7
    15                              <1> 	%endif
    16                              <1> 
    17 00000E00 20E4                <1> 	and	ah, ah				; 8 external interrupts?
    18 00000E02 741B                <1> 	jz	_xix_beat?			; nane
    19                              <1> 
    20 00000E04 30C9                <1> 	xor	cl, cl
    21                              <1> 
    22                              <1> _xi_next:					; external interrupt pending signals[8]
    23 00000E06 88A6F8050000        <1> 	mov	byte ptr [esi+IO_PORT+_XI_PENDING], ah	; position for inA|B from port XI_PENDING$	LL.mm.hh.zz
    24 00000E0C C6869504000000      <1> 	mov	byte ptr [esi+INDICATION+1], 0	; clear from platform indications fabric	ll.MM.hh.zz
    25 00000E13 31C9                <1> 	xor	ecx, ecx			; clear latent param
    26 00000E15 B802000000          <1> 	mov	eax, II_XINT			; select external interrupt
    27                              <1> 
    28 00000E1A E902010000          <1> 	jmp	_ii_
    29                              <1> 
    30                              <1> _xix_beat?:
    31 00000E1F A820                <1> 	test	al, TPULSE
    32 00000E21 7438                <1> 	jz	_xix
    33                              <1> 
    34 00000E23 BF[00000000]        <1> 	mov	edi, _core					; always core zero so far
    35                              <1> 
    36                              <1> _xi_atn_dayclock:
    37 00000E28 8B8F58020000        <1>         mov     ecx, dword ptr [edi+REGISTER+DAYCLOCK_U]
    38 00000E2E 8B9F5C020000        <1>         mov     ebx, dword ptr [edi+REGISTER+DAYCLOCK]
    39 00000E34 3B8F58020000        <1>         cmp     ecx, dword ptr [edi+REGISTER+DAYCLOCK_U]
    40 00000E3A 75EC                <1>         jnz     _xi_atn_dayclock
    41 00000E3C 899E5C020000        <1>         mov     dword ptr [esi+REGISTER+DAYCLOCK], ebx
    42 00000E42 898E58020000        <1>         mov     dword ptr [esi+REGISTER+DAYCLOCK_U], ecx
    43                              <1> 
    44 00000E48 8B9F64060000        <1>         mov     ebx, dword ptr [edi+IO_PORT+_TZONE]
    45 00000E4E 899E64060000        <1>         mov     dword ptr [esi+IO_PORT+_TZONE], ebx
    46                              <1> 
    47 00000E54 80A694040000DF      <1> 	and	byte ptr [esi+INDICATION], TPULSE^255
    48                              <1> 	
    49 00000E5B A880                <1> _xix:	test	al, ATTENTION					; core2core interrupt
    50 00000E5D 0F8452000000        <1> 	jz	near _xiy
    51                              <1> 
    52 00000E63 8B9E08060000        <1> 	mov	ebx, [esi+IO_PORT+_MCAST_PENDING]
    53 00000E69 BF[00000000]        <1> 	mov	edi, _core					; test bit progressing
    54 00000E6E 52                  <1> 	push	edx
    55 00000E6F BAFEFFFFFF          <1> 	mov	edx, -2
    56 00000E74 239EC4060000        <1> 	and	ebx, dword ptr [esi+IO_PORT+_CORES_MASK]
    57                              <1> 
    58                              <1> _xi_atn_sources:
    59 00000E7A D1EB                <1> 	shr	ebx, 1						; this source pending?
    60 00000E7C 7317                <1> 	jnc	_xi_atn_source_next				; no
    61                              <1> 
    62 00000E7E 219608060000        <1> 	and	dword ptr [esi+IO_PORT+_MCAST_PENDING], edx	; unpend
    63 00000E84 8B8F0C060000        <1> 	mov	ecx, dword ptr [edi+IO_PORT+_MCAST_TO]		; latent parameter from sending side
    64                              <1> 
    65 00000E8A B805000000          <1> 	mov	eax, II_ATTENTION				; no
    66 00000E8F 5A                  <1> 	pop	edx						; ragged but working ***
    67 00000E90 E98C000000          <1> 	jmp	_ii_						; _ii_ takes ecx for
    68                              <1> 								; interrupt latent parameter
    69                              <1> _xi_atn_source_next:
    70 00000E95 81C7D0070000        <1> 	add	edi, CORE_SIZE
    71                              <1> ;	shr	ebx, 1						; MCAST_PENDING in line with edi -> core
    72 00000E9B D1C2                <1> 	rol	edx, 1						; MCAST_PENDING flag-off mask
    73 00000E9D 21DB                <1> 	and	ebx, ebx					; no bits left = no more pending
    74 00000E9F 75D9                <1> 	jnz	_xi_atn_sources					; expect from new interrupts
    75                              <1> 
    76                              <1> _xi_atn_sources_all:
    77                              <1> 
    78 00000EA1 5A                  <1> 	pop	edx						; also popped if jump to _ii_ ***
    79                              <1> 
    80 00000EA2 F78608060000FFFFFF- <1> 	test	dword ptr [esi+IO_PORT+_MCAST_PENDING], 00FFFFFFh
    80 00000EAB 00                  <1>
    81 00000EAC 7507                <1> 	jnz	_xi_atn_new_sources				; new interrupts flagged up, keep ATTENTION
    82 00000EAE 80A6940400007F      <1> 	and	byte ptr [esi+INDICATION], ATTENTION^255
    83                              <1> _xi_atn_new_sources:
    84                              <1> 
    85                              <1> 	%if	III_TRACE
    86                              <1> 	mov	eax, dword ptr [esi+IO_PORT+_MCAST_PENDING]
    87                              <1> 	mov	dword ptr [esi+REGISTER+281*4], eax
    88                              <1> 	%endif
    89                              <1> 
    90                              <1> _xiy:
    91                              <1> 	%if	1
    92                              <1> 
    93 00000EB5 8B8694040000        <1> 	mov	eax, dword ptr [esi+INDICATION]			; case we did _xix in the same sweep
    94 00000EBB F6869404000040      <1> 	test	byte ptr [esi+INDICATION], INCREMENTER_CARRY	; nanosecond or other counter 
    95 00000EC2 7410                <1> 	jz	_xiz						; from minus to carrry on zero
    96                              <1> 								; to feed millisecond dayclock
    97 00000EC4 80A694040000BF      <1> 	and	byte ptr [esi+INDICATION], INCREMENTER_CARRY^255
    98 00000ECB B804000000          <1> 	mov	eax, II_MSECOND
    99 00000ED0 31C9                <1> 	xor	ecx, ecx
   100 00000ED2 EB4D                <1> 	jmp	_ii_
   101                              <1> 
   102                              <1> 	%endif
   103                              <1> 
   104 00000ED4 C3                  <1> _xiz:	ret
   105                              <1> 
   106                              <1> _ii_instruction:
   107 00000ED5 89C3                <1> 	mov	ebx, eax
   108 00000ED7 C1EB06              <1> 	shr	ebx, 6
   109 00000EDA 2B9EF0050000        <1> 	sub	ebx, dword ptr [esi+IO_PORT+_APP_THRESHOLD]	; application threshold
   110 00000EE0 7910                <1> 	jns	guard_ii_authority	; must have executed a character string
   111                              <1> 					; like 757575
   112 00000EE2 A9C0FFFFFF          <1> 	test	eax, -64
   113 00000EE7 751C                <1> 	jnz	_ii			; not in restart page OK
   114 00000EE9 F686A204000080      <1> 	test	byte ptr [esi+PSR+2], 128	; psr + 1 in BE-speak LE:L_M_H_Z
   115 00000EF0 7513                <1> 	jnz	_ii			; ISR may interrupt to restart page
   116                              <1> 
   117                              <1> 		; service call application to restart page not allowed
   118                              <1> 		; most likely to be an accident
   119                              <1> 		; drop thru and be quelled
   120                              <1> 
   121                              <1> guard_ii_authority:
   122 00000EF2 B901000000          <1> 	mov	ecx, LP_AUTHORITY
   123                              <1> guard_ii_escape:
   124 00000EF7 B85F000000          <1> 	mov	eax, II_GUARD
   125                              <1> _ii_escape:
   126                              <1> 	%if	RELOAD_SMPP
   127                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]		; read register 152 or 280
   128 00000EFC 0F7EFE              <1> 	movd	esi, mm7
   129                              <1> 	%endif						; depending ebp -> application / ISR registers
   130                              <1> 
   131 00000EFF 8BA67C040000        <1> 	mov	esp, dword ptr [esi+REGISTER+287*4]	; read esp at start of _execute
   132                              <1> 
   133 00000F05 83F85F              <1> _ii:	cmp	eax, II_GUARD
   134 00000F08 7517                <1> 	jnz	_ii_
   135 00000F0A F605[19000000]01    <1> 	test	byte ptr [_uflag+'Z'-'A'], 1		; break to debug console?
   136 00000F11 740E                <1> 	jz	_ii_					; not if not opted
   137 00000F13 808E9404000002      <1> 	or	byte ptr [esi+INDICATION], LOCKSTEP
   138 00000F1A 800D[00000000]02    <1> 	or	byte ptr [_general_indication], LOCKSTEP
   139                              <1> 	
   140 00000F21 8DAE00020000        <1> _ii_:	lea	ebp, [esi+128*4] 
   141                              <1> 
   142 00000F27 89AE8C040000        <1> 	mov	dword ptr [esi+REGISTER_SET], ebp
   143 00000F2D C7869C040000800000- <1> 	mov	dword ptr [esi+ISELECT], 128
   143 00000F36 00                  <1>
   144                              <1> 
   145 00000F37 8B5D3C              <1> 	mov	ebx, dword ptr [ebp+S_P]
   146 00000F3A 81FB00010000        <1> 	cmp	ebx, 256
   147 00000F40 0F87B9010000        <1> 	ja	near guard_stack
   148 00000F46 83C3FC              <1> 	add	ebx, -4
   149                              <1> 
   150 00000F49 81FB9A000000        <1> 	cmp	ebx, 128+24+2
   151 00000F4F 0F82AA010000        <1> 	jb	near guard_stack
   152 00000F55 895D3C              <1> 	mov	dword ptr [ebp+S_P], ebx
   153                              <1> 
   154 00000F58 2B9688040000        <1> 	sub	edx, dword ptr [esi+B0P]
   155 00000F5E C1EA02              <1> 	shr	edx, 2
   156 00000F61 89549E0C            <1> 	mov	dword ptr [esi+ebx*4+REGISTER+3*4], edx	; save PC offset
   157 00000F65 8B96A4040000        <1> 	mov	edx, dword ptr [esi+B0_NAME]
   158 00000F6B 89549E08            <1> 	mov	dword ptr [esi+ebx*4+REGISTER+2*4], edx	; save bank ID
   159 00000F6F 8B96A0040000        <1> 	mov	edx, dword ptr [esi+PSR]
   160 00000F75 89549E04            <1> 	mov	dword ptr [esi+ebx*4+REGISTER+4], edx	; saved PSR
   161 00000F79 890C9E              <1> 	mov	dword ptr [esi+ebx*4+REGISTER], ecx	; latent parameter
   162 00000F7C F7C200008000        <1> 	test	edx, 00800000h				; nested interrupt ?
   163 00000F82 7503                <1> 	jnz	_ii_ii
   164 00000F84 895D38              <1> 	mov	dword ptr [ebp+FP], ebx			; if not, mark interrupted
   165                              <1> 							; application stack frame
   166                              <1> _ii_ii:
   167 00000F87 81CA00008000        <1> 	or	edx, 00800000h				; ISR active
   168 00000F8D 8996A0040000        <1> 	mov	dword ptr [esi+PSR], edx
   169                              <1> 
   170 00000F93 89C2                <1> 	mov	edx, eax				; get to the operand
   171 00000F95 83E23F              <1> 	and	edx, 63					; address from interrupt vector
   172 00000F98 C1E806              <1> 	shr	eax, 6
   173 00000F9B 25FF030000          <1> 	and	eax, 000003FFh				; eax -> page containing ISR ; edx  -> vector
   174 00000FA0 31DB                <1> 	xor	ebx, ebx				; single page ISR
   175 00000FA2 E954060000          <1> 	jmp	_go2_frame
   176                              <1> 
   177                              <1> ;	_ir	sign extended ea is in eax
   178                              <1> 
   179 00000FA7 F686A204000080      <1> _ir:	test	byte ptr [esi+PSR+2], 128		; eax = EA = variation on return offset
   180 00000FAE 0F843EFFFFFF        <1> 	jz	guard_ii_authority		; not good to do Interrupt Return from application space
   181 00000FB4 89D7                <1> 	mov	edi, edx			; save in case the operation interrupts itself
   182 00000FB6 89C2                <1> 	mov	edx, eax			; +- displacement operand, offset in stack added later
   183                              <1> 
   184 00000FB8 E879010000          <1> 	call	stack_read4			; [ebp+ebx*4] -> interrupt stack frame
   185                              <1> 						; interrupt stack pointer is already updated ebx+4
   186                              <1> 
   187 00000FBD 8B449E08            <1> 	mov	eax, dword ptr [esi+ebx*4+2*4]		; interrupted b0_name
   188                              <1> 
   189 00000FC1 8B4C9E04            <1> 	mov	ecx, dword ptr [esi+ebx*4+1*4]		; interrupted psr
   190                              <1> 
   191 00000FC5 03549E0C            <1> 	add	edx, dword ptr [esi+ebx*4+3*4]		; add interrupted iframe offset to EA
   192                              <1> 
   193 00000FC9 31DB                <1> 	xor	ebx, ebx				; iframe default page high index  
   194 00000FCB A900008000          <1> 	test	eax, 00800000h
   195 00000FD0 7410                <1> 	jz	ir_4k_iframe				; 1-page iframe return target
   196                              <1> 
   197 00000FD2 89C3                <1> 	mov	ebx, eax				; iframe page high index
   198 00000FD4 C1E30C              <1> 	shl	ebx, 12					; from 6 bits at front of table
   199 00000FD7 0FB61C9D[01010000]  <1> 	movzx	ebx, byte ptr [_memory+ebx*4+64*4+1]	; at iframe + 64 words
   200 00000FDF C1EB02              <1> 	shr	ebx, 2					; shift 6 bits into 8 bits
   201                              <1> 
   202                              <1> ir_4k_iframe:
   203 00000FE2 898EA0040000        <1> 	mov	dword ptr [esi+PSR], ecx
   204 00000FE8 F7C100008000        <1> 	test	ecx, 00800000h				; returning ISR -> ISR ?
   205 00000FEE 741B                <1> 	jz	ir_application				; no
   206                              <1> 
   207 00000FF0 8DAE00020000        <1> 	lea	ebp, [esi+REGISTER+128*4]		; for nested interrupts
   208 00000FF6 89AE8C040000        <1> 	mov	dword ptr [esi+REGISTER_SET], ebp	; interrupt register set
   209 00000FFC C7869C040000800000- <1> 	mov	dword ptr [esi+ISELECT], 128		; interrupt register set
   209 00001005 00                  <1>
   210 00001006 E9F0050000          <1> 	jmp	_go2_frame				; yes
   211                              <1> 
   212                              <1> ir_application:
   213 0000100B 89F5                <1> 	mov	ebp, esi				; application register set
   214 0000100D 89AE8C040000        <1> 	mov	dword ptr [esi+REGISTER_SET], ebp
   215 00001013 C7869C040000000000- <1> 	mov	dword ptr [esi+ISELECT], 0
   215 0000101C 00                  <1>
   216 0000101D E9D9050000          <1> 	jmp	_go2_frame
   217                              <1> 
    37                                  	%include	"stack.msm"
     1                              <1> ;	stack operations call these to add or subract stack
     2                              <1> ;	limits are checked here
     3                              <1> ;	these routines always leave epb -> all registers 0..255
     4                              <1> ;	because both  interrupt internal stack pointer register 128 + 15
     5                              <1> ;		and application internal stack pointer register 15
     6                              <1> 
     7                              <1> ;	are absolute pointers to the entire register stack
     8                              <1> 
     9                              <1> ;	therefore instructions calling here must afterwards
    10                              <1> 
    11                              <1> ;		mov	ebp, dword ptr [_register_set]
    12                              <1> 
    13                              <1> ;	to get ebp back to application registers 0..127
    14                              <1> ;			or interrupt registers 128..255
    15                              <1> 
    16                              <1> ;	ebp governs which r k x y a b mantissa2 mantissa3 fp sp is implied in the instruction opcode
    17                              <1> ;	registers addressed as operand are always absolute in the range 0..255
    18                              <1> 
    19                              <1> ;	these don't move any data but leave [ebp+ebx*4] pointing to the required stack frame
    20                              <1> ;	and update the stack pointer
    21                              <1> 
    22                              <1> ;	although applications can and must read interrupt registers with load instructions
    23                              <1> ;	they can't read interrupt registers with runaway pop instructions
    24                              <1> ;	because the problem is easier to find with an interrupt as soon as 128+ gets popped
    25                              <1> 
    26                              <1> 
    27                              <1> 
    28                              <1> stack1:
    29                              <1> 	%if	0
    30                              <1> 	mov	ebx, dword ptr [ebp+S_P]
    31                              <1> 	dec	ebx
    32                              <1> 	mov	dword ptr [ebp+S_P], ebx
    33                              <1> 	ret
    34                              <1> 	%endif
    35                              <1> 
    36                              <1> 
    37 00001022 8B5D3C              <1> 	mov	ebx, dword ptr [ebp+S_P]	; read whichever internal sp
    38 00001025 F686A204000080      <1> 	test	byte ptr [esi+PSR+2], 128	; ISR ?
    39 0000102C 742B                <1> 	jz	stack1_a			; no ?
    40 0000102E 81FB00010000        <1> 	cmp	ebx, 256			; in upper range ?
    41 00001034 0F87C5000000        <1> 	ja	near guard_stack		; no ?
    42 0000103A 4B                  <1> 	dec	ebx				; decrement
    43 0000103B 0F88BE000000        <1> 	js	near guard_stack		; < 0 ?
    44 00001041 81FB98000000        <1> 	cmp	ebx, 128+24	; +2		; in clock registers?
    45 00001047 730C                <1> 	jnb	stack1_j			;
    46 00001049 81FB80000000        <1> 	cmp	ebx, 128			; in app stack? Allowed for thread switch
    47 0000104F 0F83AA000000        <1> 	jnb	near guard_stack		; in working registers page
    48                              <1> stack1_j:
    49 00001055 895D3C              <1> 	mov	dword ptr [ebp+S_P], ebx	; new frame
    50 00001058 C3                  <1> 	ret
    51                              <1> 
    52                              <1> stack1_a:					; this is application
    53 00001059 81FB80000000        <1> 	cmp	ebx, 128			; > interrupt register range start
    54 0000105F 0F879A000000        <1> 	ja	near guard_stack		; not allowed
    55 00001065 4B                  <1> 	dec	ebx				; decrement
    56 00001066 0F8893000000        <1> 	js	near guard_stack		; < 0 ?
    57 0000106C 83FB18              <1> 	cmp	ebx, 24				; in control registers ?
    58 0000106F 0F828A000000        <1> 	jb	near guard_stack		; not allowed
    59 00001075 895D3C              <1> 	mov	dword ptr [ebp+S_P], ebx	; new frame
    60 00001078 C3                  <1> 	ret
    61                              <1> 
    62                              <1> stack2:
    63                              <1> 	%if	0
    64                              <1> 	mov	ebx, dword ptr [ebp+S_P]
    65                              <1> 	add	ebx, -2
    66                              <1> 	mov	dword ptr [ebp+S_P], ebx
    67                              <1> 	ret
    68                              <1> 	%endif
    69                              <1> 
    70 00001079 8B5D3C              <1> 	mov	ebx, dword ptr [ebp+S_P]
    71 0000107C F686A204000080      <1> 	test	byte ptr [esi+PSR+2], 128
    72 00001083 742A                <1> 	jz	stack2_a
    73 00001085 81FB00010000        <1> 	cmp	ebx, 256
    74 0000108B 0F876E000000        <1> 	ja	near guard_stack
    75 00001091 83C3FE              <1> 	add	ebx, -2
    76 00001094 0F8865000000        <1> 	js	near guard_stack
    77 0000109A 81FB98000000        <1> 	cmp	ebx, 128+24
    78 000010A0 7309                <1> 	jnb	stack2_j
    79 000010A2 83FB7E              <1> 	cmp	ebx, 128-2
    80 000010A5 0F8754000000        <1> 	ja	near guard_stack
    81                              <1> 
    82                              <1> stack2_j:
    83 000010AB 895D3C              <1> 	mov	dword ptr [ebp+S_P], ebx
    84 000010AE C3                  <1> 	ret
    85                              <1> 
    86                              <1> stack2_a:
    87 000010AF 81FB80000000        <1> 	cmp	ebx, 128			; application push high limit 128,  ISR 256
    88 000010B5 7748                <1> 	ja	guard_stack
    89 000010B7 83C3FE              <1> 	add	ebx, -2
    90 000010BA 7843                <1> 	js	guard_stack
    91 000010BC 83FB18              <1> 	cmp	ebx, 24
    92 000010BF 723E                <1> 	jb	guard_stack			; stack top limit zero ISR and application
    93 000010C1 895D3C              <1> 	mov	dword ptr [ebp+S_P], ebx
    94 000010C4 C3                  <1> 	ret
    95                              <1> 
    96                              <1> stack4:
    97                              <1> 	%if	0
    98                              <1> 	mov	ebx, dword ptr [ebp+S_P]
    99                              <1> 	add	ebx, -4
   100                              <1> 	mov	dword ptr [ebp+S_P], ebx
   101                              <1> 	ret
   102                              <1> 	%endif
   103                              <1> 
   104 000010C5 8B5D3C              <1> 	mov	ebx, dword ptr [ebp+S_P]
   105 000010C8 F686A204000080      <1> 	test	byte ptr [esi+PSR+2], 128	; read psr interrupt bit
   106 000010CF 741B                <1> 	jz	stack4_a			; stack is registers 24..127
   107 000010D1 81FB00010000        <1> 	cmp	ebx, 256			; stack is registers  0..255
   108 000010D7 7726                <1> 	ja	guard_stack
   109 000010D9 83C3FC              <1> 	add	ebx, -4				; proposed frame
   110 000010DC 7821                <1> 	js	guard_stack			; not lower than register zero
   111 000010DE 81FB98000000        <1> 	cmp	ebx, 128+24
   112 000010E4 7305                <1> 	jnb	stack4_j
   113 000010E6 83FB7C              <1> 	cmp	ebx, 128-4			; in working registers page
   114 000010E9 7714                <1> 	ja	guard_stack
   115                              <1> 
   116                              <1> stack4_j:
   117                              <1> ;	mov	dword ptr [ebp+S_P], ebx	; caller does this
   118 000010EB C3                  <1> 	ret					; both sp are absolute pointers
   119                              <1> 
   120                              <1> stack4_a:
   121 000010EC 81FB80000000        <1> 	cmp	ebx, 128			; don't push into a higher register than 127
   122 000010F2 770B                <1> 	ja	guard_stack
   123 000010F4 83C3FC              <1> 	add	ebx, -4
   124 000010F7 7806                <1> 	js	guard_stack
   125 000010F9 83FB18              <1> 	cmp	ebx, 24				; dont push lower than 24
   126 000010FC 7201                <1> 	jb	guard_stack
   127                              <1> ;	mov	dword ptr [ebp+S_P], ebx	; caller does this
   128 000010FE C3                  <1> 	ret					; return new frame
   129                              <1> 
   130                              <1> guard_stack:
   131                              <1> stack_underflow:
   132 000010FF 8BAE8C040000        <1> 	mov	ebp, dword ptr [esi+REGISTER_SET] ; esi -> core.REGISTER
   133 00001105 F786A0040000000080- <1> 	test	dword ptr [esi+PSR], 00800000h	; interrupt mode?
   133 0000110E 00                  <1>
   134 0000110F 0F84DDFDFFFF        <1> 	jz	guard_ii_authority		; sideline the application
   135 00001115 C7453C00010000      <1> 	mov	dword ptr [ebp+S_P], 256	; restart the interrupt stack
   136 0000111C B801000000          <1> 	mov	eax, 1				; so the interrupt can be interrupted
   137 00001121 F605[19000000]01    <1> 	test	byte ptr [_uflag+'Z'-'A'], 1
   138 00001128 7407                <1> 	jz	gsago
   139 0000112A 808E9404000002      <1> 	or	byte ptr [esi+INDICATION], LOCKSTEP
   140 00001131 E9C6FDFFFF          <1> gsago:	jmp	_ii_escape
   141                              <1> 
   142                              <1> stack_read4:
   143 00001136 BB04000000          <1> 	mov	ebx, 4
   144 0000113B 035D3C              <1> 	add	ebx, dword ptr [ebp+S_P]
   145 0000113E 81FB80000000        <1> 	cmp	ebx, 128			; you can have stack locations up to here
   146 00001144 7611                <1> 	jna	stack_r4			; whoever you are
   147 00001146 F686A204000080      <1> 	test	byte ptr [esi+PSR+2], 128	; any higher you have to be an ISR
   148 0000114D 74B0                <1> 	jz	stack_underflow
   149 0000114F 81FB00010000        <1> 	cmp	ebx, 256			; and then not any higher than this
   150 00001155 77A8                <1> 	ja	stack_underflow
   151                              <1> 
   152                              <1> stack_r4:
   153 00001157 875D3C              <1> 	xchg	ebx, dword ptr [ebp+S_P]	; write new stack top
   154 0000115A C3                  <1> 	ret					; return old stack top
   155                              <1> 
   156                              <1> stack_read2:
   157 0000115B BB02000000          <1> 	mov	ebx, 2
   158 00001160 035D3C              <1> 	add	ebx, dword ptr [ebp+S_P]
   159 00001163 81FB80000000        <1> 	cmp	ebx, 128			; you can have stack locations up to here
   160 00001169 7611                <1> 	jna	stack_r2			; whoever you are
   161 0000116B F686A204000080      <1> 	test	byte ptr [esi+PSR+2], 128	; any higher you have to be an ISR
   162 00001172 748B                <1> 	jz	stack_underflow
   163 00001174 81FB00010000        <1> 	cmp	ebx, 256			; and then not any higher than this
   164 0000117A 7783                <1> 	ja	stack_underflow
   165                              <1> 
   166                              <1> stack_r2:
   167 0000117C 875D3C              <1> 	xchg	ebx, dword ptr [ebp+S_P]	; write new stack top
   168 0000117F C3                  <1> 	ret					; return old stack top
   169                              <1> 
   170                              <1> stack_read1:
   171 00001180 BB01000000          <1> 	mov	ebx, 1				; calculate
   172 00001185 035D3C              <1> 	add	ebx, dword ptr [ebp+S_P]	; new stack top
   173 00001188 81FB80000000        <1> 	cmp	ebx, 128			; you can have stack locations up to here
   174 0000118E 7619                <1> 	jna	stack_r1			; whoever you are
   175 00001190 F686A204000080      <1> 	test	byte ptr [esi+PSR+2], 128	; any higher you have to be an ISR
   176 00001197 0F8462FFFFFF        <1> 	jz	stack_underflow
   177 0000119D 81FB00010000        <1> 	cmp	ebx, 256			; and then not any higher than this
   178 000011A3 0F8756FFFFFF        <1> 	ja	stack_underflow
   179                              <1> 
   180                              <1> stack_r1:
   181 000011A9 875D3C              <1> 	xchg	ebx, dword ptr [ebp+S_P]	; write new stack top
   182 000011AC C3                  <1> 	ret					; return old stack top
   183                              <1> 
    38                                  	%include	"return.msm"
     1                              <1> _autoexit:
     2 000011AD B846000000          <1> 	mov	eax, II_EXIT
     3 000011B2 B90B000000          <1> 	mov	ecx, LP_AUTOEXIT
     4 000011B7 E940FDFFFF          <1> 	jmp	_ii_escape
     5                              <1> 
     6 000011BC F786A0040000000080- <1> _lret:	test	dword ptr [esi+PSR], 00800000h
     6 000011C5 00                  <1>
     7 000011C6 7509                <1> 	jnz	_lret_
     8                              <1> 
     9 000011C8 817D3C80000000      <1> 	cmp	dword ptr [ebp+S_P], 128
    10 000011CF 74DC                <1> 	jz	_autoexit
    11                              <1> 
    12 000011D1 E8AAFFFFFF          <1> _lret_:	call	stack_read1
    13 000011D6 03049E              <1> 	add	eax, dword ptr [esi+ebx*4]
    14 000011D9 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
    15 000011DE E921020000          <1> 	jmp	_j
    16                              <1> 
    17 000011E3 F786A0040000000080- <1> _fret:	test	dword ptr [esi+PSR], 00800000h
    17 000011EC 00                  <1>
    18 000011ED 7509                <1> 	jnz	_fret_
    19                              <1> 
    20 000011EF 817D3C80000000      <1> 	cmp	dword ptr [ebp+S_P], 128
    21 000011F6 74B5                <1> 	jz	_autoexit
    22                              <1> 
    23 000011F8 E85EFFFFFF          <1> _fret_:	call	stack_read2
    24 000011FD 899680040000        <1> 	mov	dword ptr [esi+APC], edx
    25 00001203 89C2                <1> 	mov	edx, eax
    26 00001205 03549E04            <1> 	add	edx, dword ptr [esi+ebx*4+1*4]	; add EA as displacement to offset on stack
    27 00001209 8B049E              <1> 	mov	eax, dword ptr [esi+ebx*4]
    28 0000120C 31DB                <1> 	xor	ebx, ebx			; 1-page frame?
    29 0000120E A900008000          <1> 	test	eax, 00800000h			; multipages frame?
    30 00001213 7410                <1> 	jz	_fret_1page
    31 00001215 89C3                <1> 	mov	ebx, eax
    32 00001217 C1E30C              <1> 	shl	ebx, 12
    33 0000121A 0FB61C9D[01010000]  <1> 	movzx	ebx, byte ptr [_memory+ebx*4+64*4+1]
    34 00001222 C1EB02              <1> 	shr	ebx, 2
    35                              <1> 
    36                              <1> _fret_1page:
    37 00001225 E9D1030000          <1> 	jmp	_go2_frame
    38                              <1> 
    39                              <1> _fpxpo_low_order:				; $residue exponent out of range
    40 0000122A 8B5C240C            <1>         mov     ebx, dword ptr [esp+3*4]        ; tell ISR which accumulator
    41                              <1> 
    42                              <1> 	%if 1
    43 0000122E 891D[00000000]      <1>         mov     dword ptr [_ultra], ebx         ; tell developer if that is true
    44                              <1> 	%endif
    45                              <1> 
    46 00001234 B803000000          <1> _fpxpo:	mov	eax, II_FPXPO
    47 00001239 89D9                <1> 	mov	ecx, ebx			; tell ISR which accumulator
    48 0000123B E9BCFCFFFF          <1> 	jmp	_ii_escape			; in latent parameter
    49                              <1> 
    39                                  	%include	"rta.msm"
     1                              <1> 
     2 00001240 80F904              <1> _sr:	cmp	cl, I
     3 00001243 0F849DF8FFFF        <1> 	jz	_inA
     4 00001249 80F905              <1> 	cmp	cl, XI
     5 0000124C 0F8497FBFFFF        <1> 	jz	_on
     6                              <1> 
     7 00001252 8B5D00              <1> 	mov	ebx, dword ptr [ebp+R]
     8 00001255 E989F2FFFF          <1> 	jmp	_operand_write
     9                              <1> 
    10 0000125A 80F904              <1> _sk:	cmp	cl, I
    11 0000125D 0F848EF8FFFF        <1> 	jz	_inB
    12 00001263 80F905              <1> 	cmp	cl, XI
    13 00001266 0F8485FBFFFF        <1> 	jz	_off
    14                              <1> 
    15 0000126C 8B5D04              <1> 	mov	ebx, dword ptr [ebp+K]
    16 0000126F E96FF2FFFF          <1> 	jmp	_operand_write
    17                              <1> 
    18 00001274 80F904              <1> _sx:	cmp	cl, I
    19 00001277 0F847FF8FFFF        <1> 	jz	_outA
    20 0000127D 80F905              <1> 	cmp	cl, XI
    21 00001280 0F846BF7FFFF        <1> 	jz	_rsr
    22                              <1> 
    23 00001286 8B5D08              <1> 	mov	ebx, dword ptr [ebp+X]
    24 00001289 E955F2FFFF          <1> 	jmp	_operand_write
    25                              <1> 
    26 0000128E 80F904              <1> _sy:	cmp	cl, I
    27 00001291 0F846DF8FFFF        <1> 	jz	_outB
    28 00001297 80F905              <1> 	cmp	cl, XI
    29 0000129A 0F84C1F7FFFF        <1> 	jz	_wsr
    30                              <1> 
    31 000012A0 8B5D0C              <1> 	mov	ebx, dword ptr [ebp+Y]
    32 000012A3 E93BF2FFFF          <1> 	jmp	_operand_write;
    33                              <1> 
    34 000012A8 80F904              <1> _sa:	cmp	cl, I
    35 000012AB 0F841BF9FFFF        <1> 	jz	_reload
    36 000012B1 80F905              <1> 	cmp	cl, XI
    37 000012B4 744E                <1> 	jz	escape
    38                              <1> 
    39 000012B6 8B5D10              <1> 	mov	ebx, dword ptr [ebp+A]
    40 000012B9 E925F2FFFF          <1> 	jmp	_operand_write
    41                              <1> 
    42 000012BE 80F904              <1> _sb:	cmp	cl, I
    43 000012C1 7441                <1> 	jz	escape
    44 000012C3 80F905              <1> 	cmp	cl, XI
    45 000012C6 743C                <1> 	jz	escape
    46                              <1> 
    47 000012C8 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]
    48 000012CB E913F2FFFF          <1> 	jmp	_operand_write
    49                              <1> 
    50 000012D0 80F904              <1> _z:	cmp	cl, I
    51 000012D3 0F8415F9FFFF        <1> 	jz	_sabr
    52 000012D9 80F905              <1> 	cmp	cl, XI
    53 000012DC 0F84DAFEFFFF        <1> 	jz	_lret
    54 000012E2 31DB                <1> 	xor	ebx, ebx
    55 000012E4 E9FAF1FFFF          <1> 	jmp	_operand_write
    56                              <1> 
    57 000012E9 80F904              <1> _pop:	cmp	cl, I
    58 000012EC 7416                <1> 	jz	escape
    59 000012EE 80F905              <1> 	cmp	cl, XI
    60 000012F1 0F84ECFEFFFF        <1> 	jz	_fret
    61                              <1> 
    62 000012F7 E884FEFFFF          <1> 	call	stack_read1
    63 000012FC 8B1C9E              <1> 	mov	ebx, dword ptr [esi+ebx*4]
    64 000012FF E9DFF1FFFF          <1> 	jmp	_operand_write
    65                              <1> 
    66 00001304 C3                  <1> escape	ret
    67                              <1> 
    68 00001305 E847F0FFFF          <1> _lr:	call	_operand_read
    69 0000130A 894500              <1> 	mov	dword ptr [ebp+R], eax
    70 0000130D C3                  <1> 	ret
    71                              <1> 
    72 0000130E E83EF0FFFF          <1> _lk:	call	_operand_read
    73 00001313 894504              <1> 	mov	dword ptr [ebp+K], eax
    74 00001316 C3                  <1> 	ret
    75 00001317 E835F0FFFF          <1> _lx:	call	_operand_read
    76 0000131C 894508              <1> 	mov	dword ptr [ebp+X], eax
    77 0000131F C3                  <1> 	ret
    78                              <1> 
    79 00001320 E82CF0FFFF          <1> _ly:	call	_operand_read
    80 00001325 89450C              <1> 	mov	dword ptr [ebp+Y], eax
    81 00001328 C3                  <1> 	ret
    82                              <1> 
    83 00001329 E823F0FFFF          <1> _la:	call	_operand_read
    84 0000132E 894510              <1> 	mov	dword ptr [ebp+A], eax
    85 00001331 C3                  <1> 	ret
    86                              <1> 
    87 00001332 E81AF0FFFF          <1> _lb:	call	_operand_read
    88 00001337 894514              <1> 	mov	dword ptr [ebp+B], eax
    89 0000133A C3                  <1> 	ret
    90                              <1> 
    91 0000133B 80F904              <1> _tz:	cmp	cl, I
    92 0000133E 0F844E140000        <1> 	jz	near _rex
    93 00001344 80F905              <1> 	cmp	cl, XI
    94 00001347 B900000000          <1> 	mov	ecx, 0
    95 0000134C 0F8483FBFFFF        <1> 	jz	_ii_instruction
    96                              <1> 
    97 00001352 E8FAEFFFFF          <1> 	call	_operand_read
    98 00001357 A9FFFFFF00          <1> 	test	eax, 00FFFFFFh
    99 0000135C 7503                <1> 	jnz	_tz_
   100 0000135E 83C204              <1> 	add	edx, 4
   101 00001361 C3                  <1> _tz_:	ret
   102                              <1> 
   103 00001362 80F904              <1> _tp:	cmp	cl, I
   104 00001365 742A                <1> 	jz	_jdz
   105 00001367 80F905              <1> 	cmp	cl, XI
   106 0000136A 0F8437FCFFFF        <1> 	jz	_ir
   107                              <1> 
   108 00001370 E8DCEFFFFF          <1> 	call	_operand_read
   109 00001375 A900008000          <1> 	test	eax, 00800000h
   110 0000137A 7503                <1> 	jnz	_tp_
   111 0000137C 83C204              <1> 	add	edx, 4
   112 0000137F C3                  <1> _tp_:	ret
   113                              <1> 
   114 00001380 E8CCEFFFFF          <1> _push:	call	_operand_read
   115                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
   116 00001385 0F7EFE              <1> 	movd	esi, mm7
   117                              <1> 
   118 00001388 E895FCFFFF          <1> 	call	stack1
   119 0000138D 89049E              <1> 	mov	dword ptr [esi+ebx*4], eax
   120 00001390 C3                  <1> 	ret
   121                              <1> 
   122 00001391 8B5D14              <1> _jdz:	mov	ebx, dword ptr [ebp+B]
   123 00001394 0B5D10              <1> 	or	ebx, dword ptr [ebp+A]
   124 00001397 0F8467000000        <1> 	jz	near _j
   125 0000139D C3                  <1> 	ret
   126                              <1> 
   127 0000139E 8B5D00              <1> _jdr:	mov	ebx, dword ptr [ebp+R]	; dec r and jump if it passed from zero to -1
   128 000013A1 81C3FFFFFF00        <1> 	add	ebx, 00FFFFFFh
   129 000013A7 C1C308              <1> 	rol	ebx, 8
   130 000013AA 88D9                <1> 	mov	cl, bl
   131 000013AC C1EB08              <1> 	shr	ebx, 8			; write back to registers only 00000000 thru 00FFFFFF
   132 000013AF 895D00              <1> 	mov	dword ptr [ebp+R], ebx
   133 000013B2 F6C101              <1> 	test	cl, 1
   134 000013B5 754D                <1> 	jnz	_j
   135 000013B7 C3                  <1> 	ret
   136                              <1> 
   137 000013B8 E865FCFFFF          <1> _lcal:	call	stack1
   138 000013BD 2B9688040000        <1> 	sub	edx, dword ptr [esi+B0P]
   139 000013C3 C1EA02              <1> 	shr	edx, 2
   140 000013C6 89149E              <1> 	mov	dword ptr [esi+ebx*4], edx
   141 000013C9 EB39                <1> 	jmp	_j			; EA is in eax
   142 000013CB C3                  <1> 	ret
   143                              <1> 
   144 000013CC F786A0040000010000- <1> _jnc:	test	dword ptr [esi+PSR], 1
   144 000013D5 00                  <1>
   145 000013D6 742C                <1> 	jz	_j
   146 000013D8 C3                  <1> 	ret
   147                              <1> 
   148 000013D9 F786A0040000010000- <1> _jc:	test	dword ptr [esi+PSR], 1
   148 000013E2 00                  <1>
   149 000013E3 751F                <1> 	jnz	_j
   150 000013E5 C3                  <1> 	ret
   151                              <1> 
   152 000013E6 F7451001000000      <1> _jao:	test	dword ptr [ebp+A], 1
   153 000013ED 7515                <1> 	jnz	_j
   154 000013EF C3                  <1> 	ret
   155                              <1> 
   156 000013F0 F7451000008000      <1> _jpa:	test	dword ptr [ebp+A], 00800000h
   157 000013F7 740B                <1> 	jz	_j
   158 000013F9 C3                  <1> 	ret
   159                              <1> 
   160 000013FA F7451400008000      <1> _jpb:	test	dword ptr [ebp+B], 00800000h
   161 00001401 7401                <1> 	jz	_j
   162 00001403 C3                  <1> 	ret
   163                              <1> 
   164 00001404 89D7                <1> _j:	mov	edi, edx			; save position for error handling
   165 00001406 8B9688040000        <1> 	mov	edx, dword ptr [esi+B0P]
   166                              <1> 
   167 0000140C C1E002              <1> 	shl	eax, 2
   168 0000140F 01C2                <1> 	add	edx, eax
   169 00001411 3B9684040000        <1> 	cmp	edx, dword ptr [esi+APCZ]
   170 00001417 7701                <1> 	ja	_j_check
   171 00001419 C3                  <1> 	ret
   172                              <1> 
   173                              <1> _j_check:
   174 0000141A 89FA                <1> 	mov	edx, edi			; restore updated apc
   175 0000141C B90E000000          <1> 	mov	ecx, LP_ADDRESS
   176 00001421 E9D1FAFFFF          <1> 	jmp	guard_ii_escape			; for interrupt come-from
   177                              <1> 
   178 00001426 E80B110000          <1> _jpo:	call	NEAR _get_parity
   179 0000142B 7BD7                <1> 	jpo	_j
   180 0000142D C3                  <1> 	ret
   181                              <1> 
   182 0000142E 816510FFFFFF00      <1> _jza:	and	dword ptr [ebp+A], 00FFFFFFh
   183 00001435 74CD                <1> 	jz	_j
   184 00001437 C3                  <1> 	ret
   185                              <1> 
   186 00001438 816514FFFFFF00      <1> _jzb:	and	dword ptr [ebp+B], 00FFFFFFh
   187 0000143F 74C3                <1> 	jz	_j
   188 00001441 C3                  <1> 	ret
   189                              <1> 
   190 00001442 816510FFFFFF00      <1> _jnza:	and	dword ptr [ebp+A], 00FFFFFFh
   191 00001449 75B9                <1> 	jnz	_j
   192 0000144B C3                  <1> 	ret
   193                              <1> 
   194 0000144C 816514FFFFFF00      <1> _jnzb:	and	dword ptr [ebp+B], 00FFFFFFh
   195 00001453 75AF                <1> 	jnz	_j
   196 00001455 C3                  <1> 	ret
   197                              <1> 
   198 00001456 F7451000008000      <1> _jna:	test	dword ptr [ebp+A], 00800000h
   199 0000145D 75A5                <1> 	jnz	_j
   200 0000145F C3                  <1> 	ret
   201                              <1> 
   202 00001460 F7451400008000      <1> _jnb:	test	dword ptr [ebp+B], 00800000h
   203 00001467 759B                <1> 	jnz	_j
   204 00001469 C3                  <1> 	ret
   205                              <1> 
   206 0000146A 8B5D08              <1> _jxge:	mov	ebx, dword ptr [ebp+X]
   207 0000146D 2B5D00              <1> 	sub	ebx, dword ptr [ebp+R]
   208 00001470 F7C300000001        <1> 	test	ebx, 01000000h		; microcarry?
   209 00001476 748C                <1> 	jz	_j			; no:  x <  r,    jump
   210 00001478 C3                  <1> 	ret				; yes: x >= r, no jump
   211                              <1> 
   212 00001479 8B5D0C              <1> _jyge:	mov	ebx, dword ptr [ebp+Y]
   213 0000147C 2B5D00              <1> 	sub	ebx, dword ptr [ebp+R]
   214 0000147F F7C300000001        <1> 	test	ebx, 01000000h		; microcarry?
   215 00001485 0F8479FFFFFF        <1> 	jz	_j			; no:  y <  r,    jump
   216 0000148B C3                  <1> 	ret				; yes: y >= r, no jump
   217                              <1> 
   218 0000148C BB04000000          <1> _qs:	mov	ebx, a
   219 00001491 E9D7EFFFFF          <1> 	jmp	_burst_write4
   220                              <1> 
   221 00001496 BB04000000          <1> _ql:	mov	ebx, a
   222 0000149B E984EEFFFF          <1> 	jmp	_burst_read4
   223                              <1> 
   224 000014A0 E891FCFFFF          <1> _qpop:	call	stack_read4			; places 4 stack registers in the scope of burst write
   225 000014A5 55                  <1> 	push	ebp
   226                              <1> ;	mov	ebp, dword ptr [ebp+CORE_INDEX1] 
   227 000014A6 0F7EFD              <1> 	movd	ebp, mm7
   228                              <1> 
   229 000014A9 E8BFEFFFFF          <1> 	call	_burst_write4
   230 000014AE 5D                  <1> 	pop	ebp
   231 000014AF C3                  <1> 	ret					; stack pointers are absolute
   232                              <1> 
   233 000014B0 E810FCFFFF          <1> _qpush: call	stack4
   234 000014B5 55                  <1> 	push	ebp
   235                              <1> ;	mov	ebp, dword ptr [ebp+CORE_INDEX1]
   236 000014B6 0F7EFD              <1> 	movd	ebp, mm7
   237                              <1> 
   238 000014B9 E866EEFFFF          <1> 	call	_burst_read4
   239 000014BE 5D                  <1> 	pop	ebp
   240 000014BF 895D3C              <1> 	mov	dword ptr [ebp+S_P], ebx	; update RTA1 sp after writing stack frame
   241 000014C2 C3                  <1> 	ret					; not done until this point
   242                              <1> 
   243 000014C3 E893FCFFFF          <1> _dpop:	call	stack_read2
   244 000014C8 55                  <1> 	push	ebp
   245                              <1> ;	mov	ebp, dword ptr [ebp+CORE_INDEX1]
   246 000014C9 0F7EFD              <1> 	movd	ebp, mm7
   247                              <1> 
   248 000014CC E8E1EFFFFF          <1> 	call	_burst_write2
   249 000014D1 5D                  <1> 	pop	ebp
   250 000014D2 C3                  <1> 	ret
   251                              <1> 
   252 000014D3 E837EEFFFF          <1> _dpush:	call	_burst_read2
   253                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
   254 000014D8 0F7EFE              <1> 	movd	esi, mm7
   255                              <1> 
   256 000014DB 89D9                <1> 	mov	ecx, ebx
   257 000014DD E897FBFFFF          <1> 	call	stack2				; RTA1 sp updated at this point
   258 000014E2 894C9E04            <1> 	mov	dword ptr [esi+ebx*4+4], ecx
   259 000014E6 89049E              <1> 	mov	dword ptr [esi+ebx*4], eax
   260 000014E9 C3                  <1> 	ret
   261                              <1> 
   262 000014EA E862EEFFFF          <1> _mta:	call	_operand_read
   263 000014EF 334510              <1> 	xor	eax, dword ptr [ebp+A]
   264 000014F2 234504              <1> 	and	eax, dword ptr [ebp+K]
   265 000014F5 7503                <1> 	jnz	_mta_
   266 000014F7 83C204              <1> 	add	edx, 4		; k AND (a XOR operand) = 0, skip 1 instruction
   267 000014FA C3                  <1> _mta_:	ret
   268                              <1> 
   269 000014FB E80FEEFFFF          <1> _dte:	call	_burst_read2
   270 00001500 334510              <1> 	xor	eax, dword ptr [ebp+A]
   271 00001503 7508                <1> 	jnz	_dte_
   272 00001505 335D14              <1> 	xor	ebx, dword ptr [ebp+B]
   273 00001508 7503                <1> 	jnz	_dte_
   274 0000150A 83C204              <1> 	add	edx, 4
   275 0000150D C3                  <1> _dte_:	ret	
   276                              <1> 
   277 0000150E 8B9EA0040000        <1> _sc:	mov	ebx, dword ptr [esi+PSR]
   278 00001514 83E301              <1> 	and	ebx, 1		; store carry 
   279 00001517 E9C7EFFFFF          <1> 	jmp	_operand_write
   280                              <1> 
   281 0000151C E830EEFFFF          <1> _mlb:	call	_operand_read
   282 00001521 8B5D04              <1> 	mov	ebx, dword ptr [ebp+K]
   283 00001524 21D8                <1> 	and	eax, ebx
   284 00001526 81F3FFFFFF00        <1> 	xor	ebx, 00FFFFFFh
   285 0000152C 235D14              <1> 	and	ebx, dword ptr [ebp+B]
   286 0000152F 09C3                <1> 	or	ebx, eax
   287 00001531 895D14              <1> 	mov	dword ptr [ebp+B], ebx	; b = (b AND (NOT k)) OR (operand AND k)
   288 00001534 C3                  <1> 	ret
   289                              <1> 
   290 00001535 BB04000000          <1> _ds:	mov	ebx, a
   291 0000153A E973EFFFFF          <1> 	jmp	_burst_write2
   292                              <1> 
   293 0000153F E8CBEDFFFF          <1> _dl:	call	_burst_read2
   294 00001544 895D14              <1> 	mov	dword ptr [ebp+B], ebx
   295 00001547 894510              <1> 	mov	dword ptr [ebp+A], eax
   296 0000154A C3                  <1> 	ret
   297                              <1> 
   298 0000154B C3                  <1> _spare:	ret
   299                              <1> 
   300 0000154C E8E9F0FFFF          <1> _ex:	call	memory_read
   301                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
   302 00001551 0F7EFE              <1> 	movd	esi, mm7
   303                              <1> 
   304 00001554 E9FCEBFFFF          <1> 	jmp	_execute
   305                              <1> 
   306 00001559 E813F1FFFF          <1> _ts:	call	memory_lock			; edi + esi -> memory word
   307 0000155E 66B80080            <1> 	mov	ax, 08000h
   308 00001562 668704B7            <1> 	xchg	ax, word ptr [edi+esi*4]	; swap -> t1 for 080 under lock
   309 00001566 6621C0              <1> 	and	ax, ax
   310 00001569 7803                <1> 	js	_ts___				; no action if already locked
   311                              <1> 
   312 0000156B 83C204              <1> 	add	edx, 4				; skip if ms bit was clear before
   313                              <1> 
   314 0000156E C3                  <1> _ts___:	ret
   315                              <1> 
   316                              <1> 
   317 0000156F E8D1F0FFFF          <1> _sim:	call	memoreg				; edi -> device		edi <- NULL
   318                              <1> 						; esi -> word	OR	ebx -> register
   319                              <1> 						; eax <- data
   320                              <1> ;	mov	ecx, dword ptr [ebp+CORE_INDEX1]
   321 00001574 0F7EF9              <1> 	movd	ecx, mm7
   322                              <1> 
   323 00001577 66C1E008            <1> 	shl	ax, 8
   324 0000157B 8A81A2040000        <1> 	mov	al, byte ptr [ecx+PSR+2]
   325 00001581 C1C803              <1> 	ror	eax, 3
   326 00001584 C0C003              <1> 	rol	al, 3
   327 00001587 8881A2040000        <1> 	mov	byte ptr [ecx+PSR+2], al
   328 0000158D C1E81D              <1> 	shr	eax, 32-3
   329                              <1> 
   330 00001590 E990F0FFFF          <1> 	jmp	memoreg_writeback
   331                              <1> 
   332 00001595 52                  <1> _call:	push	edx
   333 00001596 E8DEFAFFFF          <1> 	call	stack2
   334 0000159B 2B9688040000        <1> 	sub	edx, dword ptr [esi+B0P]
   335 000015A1 C1EA02              <1> 	shr	edx, 2
   336 000015A4 89549E04            <1> 	mov	dword ptr [esi+ebx*4+1*4], edx
   337 000015A8 8B96A4040000        <1> 	mov	edx, dword ptr [esi+B0_NAME]
   338 000015AE 89149E              <1> 	mov	dword ptr [esi+ebx*4], edx
   339 000015B1 5A                  <1> 	pop	edx		; in case the jump goes wrong
   340                              <1> 				; and an interrupt frame needs constructed
   341                              <1> 
   342 000015B2 899680040000        <1> _go:	mov	dword ptr [esi+APC], edx
   343 000015B8 E894EDFFFF          <1> 	call	_operand_read	; may be memory or register
   344                              <1> 
   345                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
   346 000015BD 0F7EFE              <1> 	movd	esi, mm7
   347                              <1> 
   348 000015C0 89C2                <1> 	mov	edx, eax	; lookaside to calculate the vector
   349 000015C2 A900008000          <1> 	test	eax, 00800000h	; gate?
   350 000015C7 7425                <1> 	jz	_go2_4k_frame
   351                              <1> 
   352 000015C9 25FFFF7F00          <1> 	and	eax, 007FFFFFh	; read the gate constant
   353 000015CE E83CEDFFFF          <1> 	call	_burst_read2	;
   354                              <1> 
   355                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
   356 000015D3 0F7EFE              <1> 	movd	esi, mm7
   357                              <1> 
   358 000015D6 89C2                <1> 	mov	edx, eax	; page high index ++ word offset
   359 000015D8 89D8                <1> 	mov	eax, ebx	; storage block base page index
   360 000015DA C1C20E              <1> 	rol	edx, 6+8
   361 000015DD 89D3                <1> 	mov	ebx, edx	; instruction frame page high index
   362 000015DF 83E33F              <1> 	and	ebx, 63
   363 000015E2 7405                <1> 	jz	_go_gate	; one page iframe
   364 000015E4 0D00008000          <1> 	or	eax, 00800000h	; two+ page iframe
   365                              <1> 
   366                              <1> _go_gate:
   367 000015E9 C1EA0E              <1> 	shr	edx, 6+8	; net word offset
   368                              <1> 
   369 000015EC EB0D                <1> 	jmp	_go2_frame
   370                              <1> 	
   371                              <1> _go2_4k_frame:
   372 000015EE 83E23F              <1> 	and	edx, 63		; target is in 4k block, 64 vectors
   373 000015F1 C1E806              <1> 	shr	eax, 6		; new b0_name
   374 000015F4 25FFFF0000          <1> 	and	eax, 0000FFFFh	; bit 22 of GO / CALL word reserved
   375 000015F9 31DB                <1> 	xor	ebx, ebx	; frame high page index
   376                              <1> 
   377                              <1> _go2_frame:
   378 000015FB F686A204000080      <1> 	test	byte ptr [esi+PSR+2], 128	; already in interrupt code?
   379 00001602 751B                <1> 	jnz	_go2_base_frame	; 	; may branch into interrupt code
   380                              <1> 					; because he is interrupt code
   381 00001604 89C1                <1> 	mov	ecx, eax
   382 00001606 81E1FFFF3F00        <1> 	and	ecx, 03FFFFFh
   383 0000160C 2B8EF0050000        <1> 	sub	ecx, dword ptr [esi+IO_PORT+_APP_THRESHOLD]	; applications lower limit
   384 00001612 7D0B                <1> 	jnl	_go2_base_frame
   385                              <1> 
   386 00001614 8B9680040000        <1> 	mov	edx, dword ptr [esi+APC]
   387 0000161A E9D3F8FFFF          <1> 	jmp	guard_ii_authority
   388                              <1> 
   389                              <1> _go2_base_frame:
   390                              <1> 
   391 0000161F 8986A4040000        <1> 	mov	dword ptr [esi+B0_NAME], eax	; with flags
   392 00001625 25FFFF3F00          <1> 	and	eax, 003FFFFFh			; base page index only
   393 0000162A 01C3                <1> 	add	ebx, eax
   394 0000162C 899ED0050000        <1> 	mov	dword ptr [esi+IO_PORT+_IFRAME_U], ebx
   395                              <1> 
   396                              <1> 	%if	1
   397 00001632 8B8ED0060000        <1> 	mov	ecx, dword ptr [esi+IO_PORT+_DEVICE]	; memory page high index
   398 00001638 81E1FFFF3F00        <1> 	and	ecx, 003FFFFFh			; strip memory type bits
   399 0000163E 29D9                <1> 	sub	ecx, ebx			; iframe high page may be = not >
   400 00001640 7910                <1> 	jns	_go2_frame_in_range
   401                              <1> 
   402 00001642 B90E000000          <1> 	mov	ecx, LP_ADDRESS
   403 00001647 8B9680040000        <1> 	mov	edx, dword ptr [esi+APC]
   404 0000164D E9A5F8FFFF          <1> 	jmp	guard_ii_escape
   405                              <1> 
   406                              <1> _go2_frame_in_range:
   407                              <1> 
   408                              <1> 	%else
   409                              <1> 	PATH NOT IN USE
   410                              <1> 	mov	ecx, dword ptr [esi+IO_PORT+_DEVICE]	; have we the highest frame page?
   411                              <1> 	and	ecx, 003FFFFFh			; read highest page index
   412                              <1> ; NO!	mov	esi, LP_ADDRESS			; trim off flags
   413                              <1> 	sub	ecx, ebx			; compare
   414                              <1> 	xchg	edx, dword ptr [esi+APC]
   415                              <1> 	js	guard_ii_escape			; if negative that should catch it
   416                              <1> 	xchg	edx, dword ptr [esi+APC]
   417                              <1> 	%endif
   418                              <1> 
   419 00001652 C1E30C              <1> 	shl	ebx, 12
   420 00001655 8D1C9D[FC3F0000]    <1> 	lea	ebx, [_memory+ebx*4+4095*4]	; last instruction word in iframe
   421                              <1> 						; higher = wrong
   422 0000165C 899E84040000        <1> 	mov	dword ptr [esi+APCZ], ebx	; set execution limit pointer
   423                              <1> 
   424 00001662 8986D0040000        <1> 	mov	dword ptr [esi+IO_PORT], eax
   425 00001668 C1E00E              <1> 	shl	eax, 12+2	; 4kword block multiplied by 4 for word
   426 0000166B 05[00000000]        <1> 	add	eax, _memory	; add the platform location of executable space
   427 00001670 898688040000        <1> 	mov	dword ptr [esi+B0P], eax
   428 00001676 C1E202              <1> 	shl	edx, 2		; add the vector offset * 4 for word
   429 00001679 01C2                <1> 	add	edx, eax
   430 0000167B C3                  <1> _go_:	ret
   431                              <1> 
    40                                  	%include	"alu.msm"
     1                              <1> 
     2                              <1> 
     3 0000167C E8D0ECFFFF          <1> _ax:	call	_operand_read
     4 00001681 034508              <1> 	add	eax, dword ptr [ebp+X]
     5 00001684 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
     6 00001689 894508              <1> 	mov	dword ptr [ebp+X], eax
     7 0000168C C3                  <1> 	ret
     8                              <1> 
     9 0000168D E8BFECFFFF          <1> _ay:	call	_operand_read
    10 00001692 03450C              <1> 	add	eax, dword ptr [ebp+Y]
    11 00001695 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
    12 0000169A 89450C              <1> 	mov	dword ptr [ebp+Y], eax
    13 0000169D C3                  <1> 	ret
    14                              <1> 
    15 0000169E E8AEECFFFF          <1> _or:	call	_operand_read
    16 000016A3 094510              <1> 	or	dword ptr [ebp+A], eax
    17 000016A6 C3                  <1> 	ret
    18                              <1> 
    19 000016A7 E8A5ECFFFF          <1> _orB:	call	_operand_read
    20 000016AC 094514              <1> 	or	dword ptr [ebp+B], eax
    21 000016AF C3                  <1> 	ret
    22                              <1> 
    23 000016B0 E89CECFFFF          <1> _and:	call	_operand_read
    24 000016B5 214510              <1> 	and	dword ptr [ebp+A], eax
    25 000016B8 C3                  <1> 	ret
    26                              <1> 
    27 000016B9 E893ECFFFF          <1> _andB:	call	_operand_read
    28 000016BE 214514              <1> 	and	dword ptr [ebp+B], eax
    29 000016C1 C3                  <1> 	ret
    30                              <1> 
    31 000016C2 E88AECFFFF          <1> _xor:	call	_operand_read
    32 000016C7 314510              <1> 	xor	dword ptr [ebp+A], eax
    33 000016CA C3                  <1> 	ret
    34                              <1> 
    35 000016CB E881ECFFFF          <1> _xorB:	call	_operand_read
    36 000016D0 314514              <1> 	xor	dword ptr [ebp+B], eax
    37 000016D3 C3                  <1> 	ret
    38                              <1> 
    39 000016D4 E878ECFFFF          <1> _aa:	call	_operand_read
    40 000016D9 EB0D                <1> 	jmp	_aa_
    41                              <1> 
    42 000016DB E871ECFFFF          <1> _ana:	call	_operand_read
    43 000016E0 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
    44 000016E5 83C001              <1> 	add	eax, 1
    45                              <1> 
    46 000016E8 034510              <1> _aa_:	add	eax, dword ptr [ebp+A]
    47 000016EB E8B9040000          <1> 	call	_alu_carry
    48                              <1> 
    49 000016F0 894510              <1> 	mov	dword ptr [ebp+A], eax
    50 000016F3 C3                  <1> 	ret
    51                              <1> 
    52 000016F4 E858ECFFFF          <1> _ab:	call	_operand_read
    53 000016F9 EB0D                <1> 	jmp	_ab_
    54                              <1> 
    55 000016FB E851ECFFFF          <1> _anb:	call	_operand_read
    56 00001700 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
    57 00001705 83C001              <1> 	add	eax, 1
    58                              <1> 
    59 00001708 034514              <1> _ab_:	add	eax, dword ptr [ebp+B]
    60 0000170B E899040000          <1> 	call	_alu_carry
    61                              <1> 
    62 00001710 894514              <1> 	mov	dword ptr [ebp+B], eax
    63 00001713 C3                  <1> 	ret
    64                              <1> 
    65 00001714 52                  <1> _m:	push	edx			; 80386 platform has it ready made, so
    66 00001715 E837ECFFFF          <1> 	call	_operand_read
    67 0000171A C1E008              <1> 	shl	eax, 8			; prepare multiplier to be multiplicand 
    68 0000171D C1F808              <1> 	sar	eax, 8			; sign it in eax
    69 00001720 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]	; this is register side multiplicand but
    70                              <1> 					; it makes no difference which is which
    71 00001723 C1E308              <1> 	shl	ebx, 8			; so use it as multiplier if that is OK
    72 00001726 C1FB08              <1> 	sar	ebx, 8			; sign it first
    73                              <1> 
    74 00001729 F7EB                <1> 	imul	ebx
    75                              <1> 
    76 0000172B C1C008              <1> 	rol	eax, 8			; move 8 bits up from eax to edx
    77 0000172E C1E208              <1> 	shl	edx, 8
    78 00001731 88C2                <1> 	mov	dl, al
    79 00001733 C1E808              <1> 	shr	eax, 8
    80 00001736 894514              <1> 	mov	dword ptr [ebp+B], eax	; product bits 23..0
    81 00001739 C1E208              <1> 	shl	edx, 8
    82 0000173C C1EA08              <1> 	shr	edx, 8
    83 0000173F 895510              <1> 	mov	dword ptr [ebp+A], edx	; product high order bits
    84 00001742 5A                  <1> 	pop	edx
    85 00001743 C3                  <1> 	ret
    86                              <1> 
    87 00001744 52                  <1> _mf:	push	edx		; the multiplier is signed the multiplicand unsigned
    88 00001745 E807ECFFFF          <1> 	call	_operand_read
    89 0000174A 89C1                <1> 	mov	ecx, eax	; just to remember the multiplier sign
    90 0000174C A900008000          <1> 	test	eax, 00800000h
    91 00001751 7408                <1> 	jz	_mfplusplus
    92 00001753 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
    93 00001758 83C001              <1> 	add	eax, 1
    94                              <1> _mfplusplus:
    95 0000175B 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]	; this is the multiplicand, unsigned
    96 0000175E F7E3                <1> 	mul	ebx		; two 24-bit unsigned values should be OK here
    97 00001760 C1C008              <1> 	rol	eax, 8
    98 00001763 C1E208              <1> 	shl	edx, 8
    99 00001766 88C2                <1> 	mov	dl, al
   100 00001768 C1E808              <1> 	shr	eax, 8
   101 0000176B C1E208              <1> 	shl	edx, 8
   102 0000176E C1EA08              <1> 	shr	edx, 8
   103 00001771 F7C100008000        <1> 	test	ecx, 00800000h	; was the multiplier signed?
   104 00001777 741F                <1> 	jz	_mfstore
   105 00001779 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   106 0000177E 81F2FFFFFF00        <1> 	xor	edx, 00FFFFFFh
   107 00001784 83C001              <1> 	add	eax, 1
   108 00001787 C1C008              <1> 	rol	eax, 8
   109 0000178A 0FB6C8              <1> 	movzx	ecx, al
   110 0000178D C1E808              <1> 	shr	eax, 8
   111 00001790 01CA                <1> 	add	edx, ecx
   112 00001792 81E2FFFFFF00        <1> 	and	edx, 00FFFFFFh
   113                              <1> _mfstore:
   114 00001798 894514              <1> 	mov	dword ptr [ebp+B], eax
   115 0000179B 895510              <1> 	mov	dword ptr [ebp+A], edx
   116 0000179E 5A                  <1> 	pop	edx
   117 0000179F C3                  <1> 	ret
   118                              <1> 
   119 000017A0 BF04000000          <1> _d:	mov	edi, a
   120 000017A5 E80A000000          <1> 	call	_divide
   121 000017AA 895D10              <1> 	mov	dword ptr [ebp+A], ebx
   122 000017AD 894518              <1> 	mov	dword ptr [ebp+MANTISSA2], eax
   123 000017B0 894D14              <1> 	mov	dword ptr [ebp+B], ecx
   124 000017B3 C3                  <1> 	ret
   125                              <1> 
   126                              <1> 	%if	1
   127                              <1> 
   128                              <1> ;	this divide made from 2 Intel divides should be a better method
   129                              <1> ;	than the procession of 1-bit shifts and test subtracts
   130                              <1> ;	which is the %else which it replaces. That also works
   131                              <1> 
   132                              <1> ;	this converts to and from positive magnitude
   133                              <1> ;	because zoning the 2nd divide with a zero 1st remainder
   134                              <1> ;	can't tell +0 from -0 in platform 2s complement
   135                              <1> 
   136                              <1> ;	polarity conversions before and after need no explanation
   137                              <1> 
   138                              <1> ;	1st dividend is 48 zero bits and high order 16 data bits
   139                              <1> ;	of the the 48-bit RTA1 dividend
   140                              <1> 
   141                              <1> ;	2nd dividend is 1st remainder and the remaining 32 bits
   142                              <1> ;	the the RTA1 dividend
   143                              <1> 
   144                              <1> ;	input is compressed from 24-bit words and output unpacked
   145                              <1> ;	to 24-bit words
   146                              <1> 
   147                              <1> ;	64-bit dividend in 386 mode is high order bits in edx, low in eax
   148                              <1> ;	platform faults if quotient carries from eax. Remainder in edx
   149                              <1> 
   150                              <1> ;	RTA1 quotient is 48 bits so it takes 2 divides in 32-bit mode
   151                              <1> 
   152                              <1> _divide:
   153 000017B4 52                  <1> 	push	edx
   154 000017B5 57                  <1> 	push	edi
   155 000017B6 E896EBFFFF          <1> 	call	_operand_read	; read divisor
   156 000017BB 5F                  <1> 	pop	edi
   157 000017BC 31C9                <1> 	xor	ecx, ecx	; final sign
   158 000017BE A900008000          <1> 	test	eax, 00800000h
   159 000017C3 7408                <1> 	jz	_dsig?
   160 000017C5 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   161 000017CA F7D1                <1> 	not	ecx		; reverse final sign
   162 000017CC 40                  <1> 	inc	eax
   163 000017CD 25FFFFFF00          <1> _dsig?:	and	eax, 00FFFFFFh	; check zerodiv here mebbes
   164 000017D2 89C3                <1> 	mov	ebx, eax	; eax will be used twice as divisor LS word
   165 000017D4 746D                <1> 	jz	_d_ont		; zero results in eax ebx already
   166                              <1> 
   167 000017D6 8B44BD04            <1> 	mov	eax, dword ptr [ebp+edi*4+4]
   168 000017DA 8B54BD00            <1> 	mov	edx, dword ptr [ebp+edi*4]
   169 000017DE C1E008              <1> 	shl	eax, 8		; pack two 24-bit words to 64 bits 
   170 000017E1 88D0                <1> 	mov	al, dl
   171 000017E3 C1C808              <1> 	ror	eax, 8
   172 000017E6 C1E208              <1> 	shl	edx, 8
   173 000017E9 C1EA10              <1> 	shr	edx, 16
   174 000017EC 6689D1              <1> 	mov	cx, dx		; save dividend sign
   175 000017EF 6621D2              <1> 	and	dx, dx		; bit 47 on?
   176 000017F2 7912                <1> 	jns	_dive_in
   177                              <1> 
   178 000017F4 81F10000FFFF        <1> 	xor	ecx, 0FFFF0000h	; reverse final sign
   179 000017FA F7D0                <1> 	not	eax
   180 000017FC 66F7D2              <1> 	not	dx
   181 000017FF 83C001              <1> 	add	eax, 1
   182 00001802 6683D200            <1> 	adc	dx, 0
   183                              <1> 
   184                              <1> _dive_in:
   185 00001806 89C6                <1> 	mov	esi, eax	; reserve 2nd dividend
   186 00001808 89D0                <1> 	mov	eax, edx	; position 1st dividend
   187 0000180A 31D2                <1> 	xor	edx, edx	; with leading zero
   188 0000180C F7F3                <1> 	div	ebx
   189 0000180E 96                  <1> 	xchg	eax, esi	; save 1st quotient
   190 0000180F F7F3                <1> 	div	ebx		; generate 2nd quotient
   191                              <1> 
   192 00001811 6621C9              <1> 	and	cx, cx		; dividend negative?
   193 00001814 7903                <1> 	jns	_d_remainder_plus
   194 00001816 F7D2                <1> 	not	edx
   195 00001818 42                  <1> 	inc	edx
   196                              <1> 
   197                              <1> _d_remainder_plus:
   198 00001819 81E2FFFFFF00        <1> 	and	edx, 00FFFFFFh
   199 0000181F 87D1                <1> 	xchg	edx, ecx	; remainder -> ecx / final sign -> edx
   200                              <1> 
   201 00001821 89C3                <1> 	mov	ebx, eax	; low order quotient
   202 00001823 89F0                <1> 	mov	eax, esi	; high order quotient
   203                              <1> 
   204 00001825 21D2                <1> 	and	edx, edx	; final sign?
   205 00001827 790C                <1> 	jns	_d_quotient_plus
   206                              <1> 
   207 00001829 F7D3                <1> 	not	ebx		; invert + increment quotient
   208 0000182B 66F7D0              <1> 	not	ax		; RTA1 integer is also 2s complement
   209 0000182E 83C301              <1> 	add	ebx, 1
   210 00001831 6683D000            <1> 	adc	ax, 0
   211                              <1> 
   212                              <1> _d_quotient_plus:
   213 00001835 0FB7C0              <1> 	movzx	eax, ax		; unpack from 32-bit words to 24-bit words
   214 00001838 C1E008              <1> 	shl	eax, 8		; move 8 bits up
   215 0000183B C1C308              <1> 	rol	ebx, 8
   216 0000183E 88D8                <1> 	mov	al, bl
   217 00001840 C1EB08              <1> 	shr	ebx, 8		; quotient in eax:ebx
   218                              <1> 
   219 00001843 5A                  <1> _d_ont:	pop	edx		; give back the emulated program counter
   220 00001844 C3                  <1> 	ret
   221                              <1> 
   222                              <1> 	%else
   223                              <1> 
   224                              <1> _divide:
   225                              <1> 	xor	ebx, ebx
   226                              <1> 	push	ebx		;
   227                              <1> 	push	ebx		; quotient
   228                              <1> 	push	ebx		; dividend[b]
   229                              <1> 	push	ebx		; dividend[a]
   230                              <1> 	push	ebx		; trailing divisor
   231                              <1> 	push	ebx		; divisor
   232                              <1> 	push	ebx		; signs2 
   233                              <1> 	push	ebx		; signs1
   234                              <1> 	mov	ebx, 24
   235                              <1> 	push	ebx		; beats
   236                              <1> 
   237                              <1> 
   238                              <1> _D_BEATS	equ	0
   239                              <1> _D_SIGNS1	equ	1*4
   240                              <1> _D_SIGNS2	equ	2*4
   241                              <1> _D_DIVISORU	equ	3*4
   242                              <1> _D_DIVISORL	equ	4*4
   243                              <1> _D_DIVIDENDU	equ	5*4
   244                              <1> _D_DIVIDENDL	equ	6*4
   245                              <1> _D_QUOTIENTU	equ	7*4
   246                              <1> _D_QUOTIENTL	equ	8*4
   247                              <1> 
   248                              <1> 	push	edi
   249                              <1> 	call	_operand_read
   250                              <1> 	pop	edi
   251                              <1> 
   252                              <1> 	test	eax, 00800000h
   253                              <1> 	jnz	_d_nmagnitude1			; must be stored negative
   254                              <1> 	xor	eax, 00FFFFFFh
   255                              <1> 	jmp	_d_nmagnitude2
   256                              <1> _d_nmagnitude1:
   257                              <1> 	add	eax, -1				; if it's already negative
   258                              <1> 	mov	dword ptr [esp+_D_SIGNS2], 0FFFFFFFFh
   259                              <1> _d_nmagnitude2:
   260                              <1> 	call	qscale
   261                              <1> 	cmp	bl, 24
   262                              <1> 	jz	_d_allsigns
   263                              <1> 	add	dword ptr [esp+_D_BEATS], ebx
   264                              <1> _d_allsigns:
   265                              <1> 	mov	ebx, 00FFFFFF00h ; make the divisor 48 bits contiguous	
   266                              <1> 	mov	bl, al
   267                              <1> 	ror	ebx, 8
   268                              <1> 	shl	eax, 8
   269                              <1> 	mov	ax, 65535
   270                              <1> 	ror	eax, 16
   271                              <1> 
   272                              <1> 	mov	dword ptr [esp+_D_DIVISORL], ebx
   273                              <1> 	mov	dword ptr [esp+_D_DIVISORU], eax
   274                              <1> 
   275                              <1> 	mov	ecx, 1				; precarry
   276                              <1> 
   277                              <1> ;	mov	ebx, dword ptr [ebp+B]	; dividend
   278                              <1> ;	mov	eax, dword ptr [ebp+A]
   279                              <1> 
   280                              <1> 	mov	ebx, dword ptr [ebp+edi*4+4]
   281                              <1> 	mov	eax, dword ptr [ebp+edi*4] 
   282                              <1> 
   283                              <1> 	test	eax, 00800000h
   284                              <1> 	jz	_d_pmagnitude			; must be stored positive
   285                              <1> 	mov	dword ptr [esp+_D_SIGNS1], 00FFFFFFFFh
   286                              <1> 	xor	ebx, 00FFFFFFh
   287                              <1> 	xor	eax, 00FFFFFFh
   288                              <1> 	add	ecx, ebx
   289                              <1> 	mov	ebx, ecx
   290                              <1> 	and	ebx, 00FFFFFFh
   291                              <1> 	shr	ecx, 24
   292                              <1> 	add	eax, ecx
   293                              <1> 	and	eax, 00FFFFFFh
   294                              <1> 
   295                              <1> _d_pmagnitude:
   296                              <1> 	shl	ebx, 8
   297                              <1> 	mov	bl, al
   298                              <1> 	ror	ebx, 8
   299                              <1> 	shl	eax, 8
   300                              <1> 	shr	eax, 16
   301                              <1> 	mov	dword ptr [esp+_D_DIVIDENDL], ebx
   302                              <1> 	mov	dword ptr [esp+_D_DIVIDENDU], eax
   303                              <1> 
   304                              <1> 	mov	ecx, dword ptr [esp+_D_BEATS]
   305                              <1> 
   306                              <1> 	add	ecx, -1
   307                              <1> _d_beat:			; iterative part as quick as possible
   308                              <1> 				; could study doing a pair of Intel divides here
   309                              <1> 	stc
   310                              <1> 	rcr	dword ptr [esp+_D_DIVISORU], 1
   311                              <1> 	rcr	dword ptr [esp+_D_DIVISORL], 1
   312                              <1> 
   313                              <1> 	stc
   314                              <1> 	adc	ebx, dword ptr [esp+_D_DIVISORL]
   315                              <1> 	adc	eax, dword ptr [esp+_D_DIVISORU]
   316                              <1> 
   317                              <1> 	jc	_d_carried
   318                              <1> 	mov	ebx, dword ptr [esp+_D_DIVIDENDL]
   319                              <1> 	mov	eax, dword ptr [esp+_D_DIVIDENDU]
   320                              <1> 	jmp	_d_carried_or_not
   321                              <1> 
   322                              <1> _d_carried:
   323                              <1> 	mov	dword ptr [esp+_D_DIVIDENDL], ebx
   324                              <1> 	mov	dword ptr [esp+_D_DIVIDENDU], eax
   325                              <1> 
   326                              <1> _d_carried_or_not:
   327                              <1> 	rcl	dword ptr [esp+_D_QUOTIENTL], 1
   328                              <1> 	rcl	dword ptr [esp+_D_QUOTIENTU], 1
   329                              <1> 	
   330                              <1> 	add	ecx, -1
   331                              <1> 	jc	_d_beat
   332                              <1> 
   333                              <1> 	pop	ecx		; BEATS
   334                              <1> 	pop	ecx		; SIGNS1
   335                              <1> 	pop	eax		; SIGNS2
   336                              <1> 	pop	ebx		; DIVISORU
   337                              <1> 	pop	ebx		; DIVISORL
   338                              <1> 	pop	ebx		; DIVIDENDU
   339                              <1> 	pop	ebx		; DIVIDENDL
   340                              <1> 
   341                              <1> 	xor	ebx, ecx	; set remainder to sign of dividend
   342                              <1> 	jns	_d_remplus
   343                              <1> 	inc	ebx		; set -remainder 2s complement
   344                              <1> 
   345                              <1> _d_remplus:
   346                              <1> 	and	ebx, 00FFFFFFh	; store remainder
   347                              <1> ;	mov	dword ptr [ebp+B], ebx
   348                              <1> 
   349                              <1> 	xor	ecx, eax	; set sign of quotient to difference of signs
   350                              <1> 	mov	ecx, ebx	; remainder for return
   351                              <1> 	pop	eax		; QUOTIENTU
   352                              <1> 	pop	ebx		; QUOTIENTL
   353                              <1> 
   354                              <1> 	jns	_d_quotient_plus		; cc set from xor of signy
   355                              <1> 
   356                              <1> 	not	eax
   357                              <1> 	not	ebx
   358                              <1> 	add	ebx, 1
   359                              <1> 	adc	eax, 0
   360                              <1> 
   361                              <1> _d_quotient_plus:
   362                              <1> 	shl	eax, 8
   363                              <1> 	rol	ebx, 8
   364                              <1> 	mov	al, bl
   365                              <1> 	shr	ebx, 8
   366                              <1> 	shl	eax, 8
   367                              <1> 	shr	eax, 8
   368                              <1> 
   369                              <1> ;	mov	dword ptr [ebp+A], ebx
   370                              <1> ;	mov	dword ptr [ebp+MANTISSA2], eax
   371                              <1> 	ret
   372                              <1> 
   373                              <1> 	%endif
   374                              <1> 
   375                              <1> 
   376 00001845 88C1                <1> _sar:	mov	cl, al			; eax shift radix is 31
   377 00001847 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
   378 0000184A F6C1E0              <1> 	test	cl, -32
   379 0000184D 7402                <1> 	jz	_sardo
   380 0000184F 31C0                <1> 	xor	eax, eax		; shift 32+ clears same as 24+
   381 00001851 D3E8                <1> _sardo:	shr	eax, cl
   382 00001853 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   383 00001858 894510              <1> 	mov	dword ptr [ebp+A], eax
   384 0000185B C3                  <1> 	ret
   385                              <1> 
   386 0000185C 88C1                <1> _sbr:	mov	cl, al
   387 0000185E 8B4514              <1> 	mov	eax, dword ptr [ebp+B]
   388 00001861 F6C1E0              <1> 	test	cl, -32
   389 00001864 7402                <1> 	jz	_sbrdo
   390 00001866 31C0                <1> 	xor	eax, eax		; shift 32+ clears same as 24+
   391 00001868 D3E8                <1> _sbrdo:	shr	eax, cl
   392 0000186A 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   393 0000186F 894514              <1> 	mov	dword ptr [ebp+B], eax
   394 00001872 C3                  <1> 	ret
   395                              <1> 
   396                              <1> 
   397 00001873 88C1                <1> _dsr:	mov	cl, al
   398 00001875 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]
   399 00001878 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
   400 0000187B E875000000          <1> 	call	dsr
   401 00001880 895D14              <1> 	mov	dword ptr [ebp+B], ebx
   402 00001883 894510              <1> 	mov	dword ptr [ebp+A], eax
   403 00001886 C3                  <1> 	ret
   404                              <1> 
   405 00001887 88C1                <1> _sal:	mov	cl, al			; shift radix eax is 31
   406 00001889 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
   407 0000188C F6C1E0              <1> 	test	cl, -32
   408 0000188F 7402                <1> 	jz	_saldo
   409 00001891 31C0                <1> 	xor	eax, eax		; shift 32+ clears same as 24+
   410 00001893 D3E0                <1> _saldo:	shl	eax, cl
   411 00001895 25FFFFFF00          <1> 	and	eax, 00FFFFFFh		; write back to registers only 00000000 thru 00FFFFFF
   412 0000189A 894510              <1> 	mov	dword ptr [ebp+A], eax
   413 0000189D C3                  <1> 	ret
   414                              <1> 
   415 0000189E 88C1                <1> _sbl:	mov	cl, al
   416 000018A0 8B4514              <1> 	mov	eax, dword ptr [ebp+B]
   417 000018A3 F6C1E0              <1> 	test	cl,-32
   418 000018A6 7402                <1> 	jz	_sbldo
   419 000018A8 31C0                <1> 	xor	eax, eax		; shift 32+ clears same as 24+
   420 000018AA D3E0                <1> _sbldo:	shl	eax, cl
   421 000018AC 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   422 000018B1 894514              <1> 	mov	dword ptr [ebp+B], eax
   423 000018B4 C3                  <1> 	ret
   424                              <1> 
   425 000018B5 88C1                <1> _dsl	mov	cl, al
   426 000018B7 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]
   427 000018BA 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
   428 000018BD E868000000          <1> 	call	dsl
   429 000018C2 895D14              <1> 	mov	dword ptr [ebp+B], ebx
   430 000018C5 894510              <1> 	mov	dword ptr [ebp+A], eax
   431 000018C8 C3                  <1> 	ret
   432                              <1> 
   433 000018C9 8B5D10              <1> _rar:	mov	ebx, dword ptr [ebp+A]
   434 000018CC E8C6000000          <1> 	call	rr
   435 000018D1 895D10              <1> 	mov	dword ptr [ebp+A], ebx
   436 000018D4 C3                  <1> 	ret
   437                              <1> 
   438 000018D5 8B5D14              <1> _rbr:	mov	ebx, dword ptr [ebp+B]
   439 000018D8 E8BA000000          <1> 	call	rr
   440 000018DD 895D14              <1> 	mov	dword ptr [ebp+B], ebx
   441 000018E0 C3                  <1> 	ret
   442                              <1> 
   443 000018E1 88C1                <1> _drr:	mov	cl, al
   444 000018E3 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]
   445 000018E6 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
   446 000018E9 E8F7000000          <1> 	call	drr
   447 000018EE 895D14              <1> 	mov	dword ptr [ebp+B], ebx
   448 000018F1 894510              <1> 	mov	dword ptr [ebp+A], eax
   449 000018F4 C3                  <1> 	ret
   450                              <1> 
   451                              <1> 
   452 000018F5 C1E008              <1> dsr:	shl	eax, 8
   453 000018F8 C1E308              <1> 	shl	ebx, 8
   454 000018FB 80C1E8              <1> dsru:	add	cl, -24
   455 000018FE 7306                <1> 	jnc	dsrl
   456 00001900 89C3                <1> 	mov	ebx, eax
   457 00001902 31C0                <1> 	xor	eax, eax
   458 00001904 EBF5                <1> 	jmp	dsru
   459 00001906 80C110              <1> dsrl:	add	cl, 16
   460 00001909 730D                <1> 	jnc	dsr7
   461 0000190B C1E808              <1> dsr8:	shr	eax, 8
   462 0000190E 88C3                <1> 	mov	bl, al
   463 00001910 C1CB08              <1> 	ror	ebx, 8
   464 00001913 80C1F8              <1> 	add	cl,-8
   465 00001916 72F3                <1> 	jc	dsr8
   466 00001918 80E107              <1> dsr7:	and	cl, 7
   467 0000191B D3E8                <1> 	shr	eax, cl
   468 0000191D 88C3                <1> 	mov	bl, al		; bits from al in high-order positions bl
   469 0000191F D2C3                <1> 	rol	bl, cl		; roll them to low-order positions
   470 00001921 D3CB                <1> 	ror	ebx, cl
   471 00001923 C1EB08              <1> 	shr	ebx, 8
   472 00001926 C1E808              <1> 	shr	eax, 8
   473 00001929 C3                  <1> 	ret
   474                              <1> 
   475 0000192A C1E008              <1> dsl:	shl	eax, 8
   476 0000192D C1E308              <1> 	shl	ebx, 8
   477 00001930 80C1E8              <1> dslu:	add	cl, -24
   478 00001933 7306                <1> 	jnc	dsll
   479 00001935 89D8                <1> 	mov	eax, ebx
   480 00001937 31DB                <1> 	xor	ebx, ebx
   481 00001939 EBF5                <1> 	jmp	dslu
   482 0000193B 80C110              <1> dsll:	add	cl, 16
   483 0000193E 730F                <1> 	jnc	dsl7
   484 00001940 C1C308              <1> dsl8:	rol	ebx, 8
   485 00001943 88D8                <1> 	mov	al, bl
   486 00001945 30DB                <1> 	xor	bl, bl
   487 00001947 C1E008              <1> 	shl	eax, 8
   488 0000194A 80C1F8              <1> 	add	cl, -8
   489 0000194D 72F1                <1> 	jc	dsl8
   490 0000194F 80E107              <1> dsl7:	and	cl, 7
   491 00001952 D3C3                <1> 	rol	ebx, cl
   492 00001954 88D8                <1> 	mov	al, bl		; bits from bl in low-order positions al
   493 00001956 D2C8                <1> 	ror	al, cl		; roll them to high-order positions
   494 00001958 D3E0                <1> 	shl	eax, cl
   495 0000195A C1EB08              <1> 	shr	ebx, 8
   496 0000195D C1E808              <1> 	shr	eax, 8
   497 00001960 C3                  <1> 	ret
   498                              <1> 
   499 00001961 C1E008              <1> dsa:	shl	eax, 8
   500 00001964 C1E308              <1> 	shl	ebx, 8
   501 00001967 80C1E8              <1> dsa24:	add	cl, -24
   502 0000196A 7307                <1> 	jnc	dsa16
   503 0000196C 89C3                <1> 	mov	ebx, eax
   504 0000196E C1F818              <1> 	sar	eax, 24
   505 00001971 EBF4                <1> 	jmp	dsa24
   506 00001973 80C110              <1> dsa16:	add	cl, 16
   507 00001976 730D                <1> 	jnc	dsa7
   508 00001978 C1F808              <1> dsa8:	sar	eax, 8
   509 0000197B 88C3                <1> 	mov	bl, al
   510 0000197D C1CB08              <1> 	ror	ebx, 8
   511 00001980 80C1F8              <1> 	add	cl, -8
   512 00001983 72F3                <1> 	jc	dsa8
   513 00001985 80E107              <1> dsa7:	and	cl, 7
   514 00001988 D3F8                <1> 	sar	eax, cl
   515 0000198A 88C3                <1> 	mov	bl, al		; bits from al in high-order positions bl
   516 0000198C D2C3                <1> 	rol	bl, cl		; roll them to low-order positions
   517 0000198E D3CB                <1> 	ror	ebx, cl
   518 00001990 C1E808              <1> 	shr	eax, 8
   519 00001993 C1EB08              <1> 	shr	ebx, 8
   520 00001996 C3                  <1> 	ret	
   521                              <1> 
   522                              <1> 
   523 00001997 88C1                <1> rr:	mov	cl, al
   524 00001999 C1E308              <1> 	shl	ebx, 8
   525 0000199C F6C118              <1> 	test	cl, 24		; bits 16:8 are self-cancelling
   526 0000199F 7A11                <1> 	jpe	rr7
   527 000019A1 F6C110              <1> 	test	cl, 16
   528 000019A4 7407                <1> 	jz	rr8		; 16 is off so 8 is on
   529 000019A6 C1C308              <1> 	rol	ebx, 8		; 8 left in 24-bit ring = 16 right
   530 000019A9 88DF                <1> 	mov	bh, bl		; compress 32-bit ring to 24-bit
   531 000019AB EB05                <1> 	jmp	short rr7
   532 000019AD 88FB                <1> rr8:	mov	bl, bh		; extend 24-bit ring to 32-bit
   533 000019AF C1CB08              <1> 	ror	ebx, 8
   534 000019B2 80E107              <1> rr7:	and	cl, 7		; isolate remaining count bits
   535 000019B5 88FB                <1> 	mov	bl, bh		; don't ask, just do it
   536 000019B7 D3CB                <1> 	ror	ebx, cl
   537 000019B9 C1EB08              <1> 	shr	ebx, 8
   538 000019BC C3                  <1> 	ret
   539                              <1> 
   540 000019BD 88C1                <1> rl:	mov	cl, al
   541 000019BF C1E308              <1> 	shl	ebx, 8
   542 000019C2 F6C118              <1> 	test	cl, 24		; bits 16:8 are self-cancelling
   543 000019C5 7A11                <1> 	jpe	rl7
   544 000019C7 F6C110              <1> 	test	cl, 16
   545 000019CA 7407                <1> 	jz	rl8		; 16 is off so 8 is on
   546 000019CC 88FB                <1> 	mov	bl, bh		; extend 24-bit ring to 32-bit
   547 000019CE C1CB08              <1> 	ror	ebx, 8		; 8 right in 24-bit ring = 16 left
   548 000019D1 EB05                <1> 	jmp	short rl7
   549 000019D3 C1C308              <1> rl8:	rol	ebx, 8
   550 000019D6 88DF                <1> 	mov	bh, bl		; compress 32-bit ring to 24-bit	
   551 000019D8 80E107              <1> rl7:	and	cl, 7
   552 000019DB 30DB                <1> 	xor	bl, bl
   553 000019DD D3C3                <1> 	rol	ebx, cl
   554 000019DF 08DF                <1> 	or	bh, bl
   555 000019E1 C1EB08              <1> 	shr	ebx, 8
   556 000019E4 C3                  <1> 	ret
   557                              <1> 
   558 000019E5 C1E008              <1> drr:	shl	eax, 8
   559 000019E8 C1E308              <1> 	shl	ebx, 8
   560                              <1> 
   561 000019EB F6C130              <1> 	test	cl, 48		; bits 32:16 are self-cancelling
   562 000019EE 7B07                <1> 	jpo	drr24		; rotate 48 = zero or 56 = 8 positions
   563 000019F0 F6C108              <1> 	test	cl, 8		; parity = pe dans le pays d'Intel
   564 000019F3 741C                <1> 	jz	drr7
   565 000019F5 EB15                <1> 	jmp	drr_cdrr8
   566                              <1> 
   567 000019F7 93                  <1> drr24:	xchg	eax, ebx	; rotate 24 right or left as you wish
   568 000019F8 F6C118              <1> 	test	cl, 24
   569 000019FB 7A0D                <1> 	jpe	drr24_32	; pattern is 100xxx or 011xxx
   570 000019FD F6C108              <1> 	test	cl, 8		; pattern is 010xxx or 101xxx
   571 00001A00 7401                <1> 	jz	drrl8		; pattern is 010
   572 00001A02 93                  <1> 	xchg	eax, ebx	; swap back, pattern 101 = 40 right = 8 left 
   573 00001A03 E828000000          <1> drrl8:	call	near drl8	; pattern is 010
   574 00001A08 EB07                <1> 	jmp	short drr7 	; already rotated 24 right, now 8 left
   575                              <1> 
   576                              <1> drr24_32:
   577 00001A0A 7505                <1> 	jnz	drr7		; pattern is 011 = rotate 24. We did
   578                              <1> drr_cdrr8:
   579 00001A0C E814000000          <1> 	call	near drr8	; pattern is 100 = rotate 32
   580 00001A11 80E107              <1> drr7:	and	cl, 7
   581 00001A14 7408                <1> 	jz	drrx
   582 00001A16 88E3                <1> 	mov	bl, ah		; rotate low bits ebx 31:8 to eax high positions
   583 00001A18 88F8                <1> 	mov	al, bh		; rotate low bits eax 31:8 to ebx high positions
   584 00001A1A D3C8                <1> 	ror	eax, cl		; bits from bh in low order positions al
   585 00001A1C D3CB                <1> 	ror	ebx, cl		; bits from ah in low order positions bl
   586 00001A1E C1E808              <1> drrx:	shr	eax, 8
   587 00001A21 C1EB08              <1> 	shr	ebx, 8
   588 00001A24 C3                  <1> 	ret
   589                              <1> 
   590 00001A25 88E3                <1> drr8:   mov     bl, ah          ; cross 8 bits from one 32-bit ring to another
   591 00001A27 88F8                <1>         mov     al, bh		
   592 00001A29 C1C808              <1>         ror     eax, 8
   593 00001A2C C1CB08              <1>         ror     ebx, 8
   594 00001A2F C3                  <1>         ret
   595                              <1> 
   596 00001A30 C1C008              <1> drl8:   rol     eax, 8
   597 00001A33 C1C308              <1>         rol     ebx, 8
   598 00001A36 88DC                <1>         mov     ah, bl          ; cross 8 bits from one 32-bit ring to another
   599 00001A38 88C7                <1>         mov     bh, al
   600 00001A3A C3                  <1>         ret
   601                              <1> 
   602 00001A3B C1E008              <1> drl:	shl	eax, 8
   603 00001A3E C1E308              <1> 	shl	ebx, 8
   604 00001A41 F6C130              <1> 	test	cl, 48		; values 32:16 cancel each other
   605 00001A44 7B07                <1> 	jpo	drl24
   606 00001A46 F6C108              <1> 	test	cl, 8
   607 00001A49 741C                <1> 	jz	drl7
   608 00001A4B EB15                <1> 	jmp	short drl_cdrl8
   609                              <1> 
   610 00001A4D 93                  <1> drl24:	xchg	eax, ebx
   611 00001A4E F6C118              <1> 	test	cl, 24
   612 00001A51 7A0D                <1> 	jpe	drl24_32	; pattern is 011xxx or 100xxx
   613 00001A53 F6C108              <1> 	test	cl, 8		; pattern is 010xxx or 101xxx
   614 00001A56 7401                <1> 	jz	drlr8		; pattern is 010 = 16 left = 8 right
   615 00001A58 93                  <1> 	xchg	eax, ebx	; swap back, pattern = 101 = 40 left = 8 right
   616 00001A59 E8C7FFFFFF          <1> drlr8:	call	drr8
   617 00001A5E EB07                <1> 	jmp	short drl7
   618                              <1> 
   619                              <1> drl24_32:
   620 00001A60 7505                <1> 	jnz	drl7		; pattern is 011 = rotate24. We did
   621                              <1> drl_cdrl8:			; pattern = 100xxx or 001xxx, rotate 8 more
   622 00001A62 E8C9FFFFFF          <1> 	call	drl8
   623 00001A67 80E107              <1> drl7:	and	cl, 7		; rotate positions 0..7
   624 00001A6A 30C0                <1> 	xor	al, al
   625 00001A6C 30DB                <1> 	xor	bl, bl
   626 00001A6E D3C0                <1> 	rol	eax, cl
   627 00001A70 D3C3                <1> 	rol	ebx, cl
   628 00001A72 08DC                <1> 	or	ah, bl
   629 00001A74 08C7                <1> 	or	bh, al
   630 00001A76 C1E808              <1> 	shr	eax, 8
   631 00001A79 C1EB08              <1> 	shr	ebx, 8
   632 00001A7C C3                  <1> 	ret
   633                              <1> 
   634 00001A7D 8B5D10              <1> _ral:	mov	ebx, dword ptr [ebp+A]
   635 00001A80 E838FFFFFF          <1> 	call	rl
   636 00001A85 895D10              <1> 	mov	dword ptr [ebp+A], ebx
   637 00001A88 C3                  <1> 	ret
   638                              <1> 
   639 00001A89 8B5D14              <1> _rbl:	mov	ebx, dword ptr [ebp+B]
   640 00001A8C E82CFFFFFF          <1> 	call	rl
   641 00001A91 895D14              <1> 	mov	dword ptr [ebp+B], ebx
   642 00001A94 C3                  <1> 	ret	
   643                              <1> 
   644 00001A95 88C1                <1> _drl:	mov	cl, al
   645 00001A97 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
   646 00001A9A 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]
   647 00001A9D E899FFFFFF          <1> 	call	drl
   648 00001AA2 895D14              <1> 	mov	dword ptr [ebp+B], ebx
   649 00001AA5 894510              <1> 	mov	dword ptr [ebp+A], eax
   650 00001AA8 C3                  <1> 	ret
   651                              <1> 
   652 00001AA9 88C1                <1> _saa:	mov	cl, al
   653 00001AAB 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
   654 00001AAE C1E008              <1> 	shl	eax, 8
   655 00001AB1 D3F8                <1> 	sar	eax, cl
   656 00001AB3 C1E808              <1> 	shr	eax, 8
   657 00001AB6 894510              <1> 	mov	dword ptr [ebp+A], eax
   658 00001AB9 C3                  <1> 	ret
   659                              <1> 
   660 00001ABA 88C1                <1> _sba:	mov	cl, al
   661 00001ABC 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]
   662 00001ABF C1E308              <1> 	shl	ebx, 8
   663 00001AC2 D3FB                <1> 	sar	ebx, cl
   664 00001AC4 C1EB08              <1> 	shr	ebx, 8
   665 00001AC7 895D14              <1> 	mov	dword ptr [ebp+B], ebx
   666 00001ACA C3                  <1> 	ret
   667                              <1> 
   668 00001ACB 88C1                <1> _dsa:	mov	cl, al
   669 00001ACD 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]
   670 00001AD0 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
   671 00001AD3 E889FEFFFF          <1> 	call	dsa
   672 00001AD8 895D14              <1> 	mov	dword ptr [ebp+B], ebx
   673 00001ADB 894510              <1> 	mov	dword ptr [ebp+A], eax
   674 00001ADE C3                  <1> 	ret
   675                              <1> 
   676 00001ADF E861EBFFFF          <1> _n:	call	memoreg
   677 00001AE4 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   678 00001AE9 E937EBFFFF          <1> 	jmp	memoreg_writeback
   679                              <1> 
   680 00001AEE E852EBFFFF          <1> _inc:	call	memoreg
   681 00001AF3 40                  <1> 	inc	eax
   682 00001AF4 E92CEBFFFF          <1> 	jmp	memoreg_writeback
   683                              <1> 
   684 00001AF9 E847EBFFFF          <1> _dec:	call	memoreg
   685 00001AFE 48                  <1> 	dec	eax
   686 00001AFF E921EBFFFF          <1> 	jmp	memoreg_writeback
   687                              <1> 
   688 00001B04 E83CEBFFFF          <1> _src:	call	memoreg
   689 00001B09 C1E008              <1> 	shl	eax, 8
   690 00001B0C 8A86A0040000        <1> 	mov	al, byte ptr [esi+PSR]
   691 00001B12 D1C8                <1> 	ror	eax, 1
   692 00001B14 D0C0                <1> 	rol	al, 1
   693 00001B16 8886A0040000        <1> 	mov	byte ptr [esi+PSR], al
   694 00001B1C C1E808              <1> 	shr	eax, 8
   695 00001B1F E901EBFFFF          <1> 	jmp	memoreg_writeback
   696                              <1> 
   697 00001B24 E81CEBFFFF          <1> _slc:	call	memoreg
   698 00001B29 C1E008              <1> 	shl	eax, 8
   699 00001B2C 8A86A0040000        <1> 	mov	al, byte ptr [esi+PSR]
   700 00001B32 D0C8                <1> 	ror	al, 1
   701 00001B34 D1C0                <1> 	rol	eax, 1
   702 00001B36 8886A0040000        <1> 	mov	byte ptr [esi+PSR], al
   703 00001B3C C1E808              <1> 	shr	eax, 8
   704 00001B3F E9E1EAFFFF          <1> 	jmp	memoreg_writeback
   705                              <1> 
   706                              <1> 	%if	0
   707                              <1> _popA:	call	stack_read1				; ebx <- stack pointer
   708                              <1> 	mov	ebx, dword ptr [esi+ebx*4+REGISTER]	; stack word
   709                              <1> 
   710                              <1> 	mov	ecx, esi				; keep core.REGISTER *
   711                              <1> 	push	ebx
   712                              <1> 	call	memoreg					; reply is memory edi + esi ->
   713                              <1> 							;     or register esi + ebx ->
   714                              <1> 	add	eax, dword ptr [esp]
   715                              <1> 	add	esp, 4
   716                              <1> 
   717                              <1> 	rol	eax, 8					; carry -> LS bit
   718                              <1> 	and	al, 1
   719                              <1> 
   720                              <1> 	and	byte ptr [ecx+PSR], 254
   721                              <1> 	or	byte ptr [ecx+PSR], al
   722                              <1> 	shr	eax, 8					; resulting value without carry
   723                              <1> 	jmp	memoreg_writeback			; eax -> target
   724                              <1> 							; [ edi ] + esi -> memory / register
   725                              <1> 	%else
   726                              <1> 
   727 00001B44 E8FCEAFFFF          <1> _popA:	call	memoreg					; eax <- addend for update
   728 00001B49 53                  <1> 	push	ebx					; ebx -> writeback register
   729 00001B4A 56                  <1> 	push	esi					; or [ edi esi ] -> writeback memory word
   730                              <1> 
   731 00001B4B 0F7EFE              <1> 	movd	esi, mm7
   732                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]	; get back the smp core for PSR and...
   733                              <1> 							; total register array and...
   734                              <1> 							; whichever of [ 2 * RTA1 sp ] is in ebx *
   735                              <1> 							; that is simple position in register list
   736                              <1> 							; not application / ISR relative as in ebp
   737                              <1> 							; although each (RTA1 sp) MOSTLY operates
   738                              <1> 							; its own portions of the register array
   739                              <1> 							; CORE_INDEX is in both scopes of ebp :-)
   740                              <1> 
   741 00001B4E E82DF6FFFF          <1> 	call	stack_read1				; ebx -> old (RTA1 internal stack) sp
   742 00001B53 03049E              <1> 	add	eax, dword ptr [esi+ebx*4+REGISTER]	; add word from internal stack
   743                              <1> 
   744 00001B56 C1C008              <1> 	rol	eax, 8					; isolate carry out of bit 23
   745 00001B59 2401                <1> 	and	al, 1
   746 00001B5B 8B9EA0040000        <1> 	mov	ebx, dword ptr [esi+PSR]		; platform memory read then write MIGHT
   747 00001B61 80E3FE              <1> 	and	bl, 254					; be better than 2 * read : write cycle
   748 00001B64 08C3                <1> 	or	bl, al
   749 00001B66 899EA0040000        <1> 	mov	dword ptr [esi+PSR], ebx		; write PSR back
   750                              <1> 
   751 00001B6C C1E808              <1> 	shr	eax, 8					; reposition and clean result
   752                              <1> 
   753 00001B6F 5E                  <1> 	pop	esi					; retrieve possible storage offset
   754 00001B70 5B                  <1> 	pop	ebx					; retrieve possible register writeback
   755 00001B71 E9AFEAFFFF          <1> 	jmp	memoreg_writeback
   756                              <1> 
   757                              <1> 	%endif
   758                              <1> 	
   759 00001B76 E894E7FFFF          <1> _da:	call	_burst_read2
   760 00001B7B EB11                <1> 	jmp	_da_
   761                              <1> 
   762 00001B7D E88DE7FFFF          <1> _dan:	call	_burst_read2
   763 00001B82 81F3FFFFFF00        <1> 	xor	ebx, 00FFFFFFh
   764 00001B88 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   765 00001B8D 43                  <1> 	inc	ebx			; carry from bit 23 
   766                              <1> 					; remains in bit 24 for now
   767                              <1> 
   768 00001B8E 035D14              <1> _da_:	add	ebx, [ebp+B]
   769 00001B91 C1E308              <1> 	shl	ebx, 8
   770 00001B94 83D000              <1> 	adc	eax, 0
   771 00001B97 C1EB08              <1> 	shr	ebx, 8
   772 00001B9A 895D14              <1> 	mov	[ebp+B], ebx
   773 00001B9D 034510              <1> 	add	eax, [ebp+A]
   774 00001BA0 E804000000          <1> 	call	_alu_carry
   775 00001BA5 894510              <1> 	mov	[ebp+A], eax
   776 00001BA8 C3                  <1> 	ret
   777                              <1> 
   778                              <1> _alu_carry:
   779                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
   780 00001BA9 0F7EFE              <1> 	movd	esi, mm7
   781                              <1> 
   782 00001BAC C1C008              <1> 	rol	eax, 8
   783 00001BAF 2401                <1> 	and	al, 1
   784 00001BB1 80A6A0040000FE      <1> 	and	byte ptr [esi+PSR], 254
   785 00001BB8 0886A0040000        <1> 	or	byte ptr [esi+PSR], al
   786 00001BBE C1E808              <1> 	shr	eax, 8
   787 00001BC1 C3                  <1> 	ret
   788                              <1> 
   789 00001BC2 040302020101010100- <1> scalex	db	4,3,2,2, 1,1,1,1, 0,0,0,0, 0,0,0,0
   789 00001BCB 00000000000000      <1>
   790                              <1> 
   791                              <1> field_scale:			; examine 24-bit integer in 8-position steps
   792 00001BD2 C1C008              <1> 	rol	eax, 8		; until high-order 8 bits are not all signs
   793 00001BD5 88C4                <1> 	mov	ah, al
   794 00001BD7 30E8                <1> 	xor	al, ch
   795 00001BD9 7509                <1> 	jnz	not8signs
   796 00001BDB 80C108              <1> 	add	cl, 8
   797 00001BDE 80F918              <1> 	cmp	cl, 24
   798 00001BE1 72EF                <1> 	jb	field_scale
   799 00001BE3 C3                  <1> 	ret			; 24 signs = the RTA1 computer word
   800                              <1> not8signs:			; al = 0 indicates it
   801 00001BE4 A8F0                <1> 	test	al, 240		; move back some positions but keep counting up
   802 00001BE6 7506                <1> 	jnz	scale_u
   803 00001BE8 80C104              <1> 	add	cl, 4
   804 00001BEB C0C004              <1> 	rol	al, 4
   805                              <1> scale_u:
   806 00001BEE C0E804              <1> 	shr	al, 4
   807 00001BF1 0FB6F0              <1> 	movzx	esi, al		; add to count-up 1..7
   808 00001BF4 2E028E[C21B0000]    <1> 	add	cl, [cs:esi+scalex]
   809 00001BFB 6651                <1> 	push	cx		; roll back 7..1 positions
   810 00001BFD 80E107              <1> 	and	cl, 7
   811 00001C00 80F107              <1> 	xor	cl, 7
   812 00001C03 80C101              <1> 	add	cl, 1
   813 00001C06 88E0                <1> 	mov	al, ah
   814 00001C08 D3C8                <1> 	ror	eax, cl
   815 00001C0A 6659                <1> 	pop	cx
   816 00001C0C C3                  <1> 	ret
   817                              <1> 
   818 00001C0D C1E008              <1> qscale:	shl	eax, 8		; 1.2.3
   819 00001C10 C1F808              <1> 	sar	eax, 8		; s.1.2.3
   820 00001C13 C1C008              <1> 	rol	eax, 8		; 1.2.3.s
   821 00001C16 6631C9              <1> 	xor	cx, cx
   822 00001C19 88C5                <1> 	mov	ch, al		; keep 8 sign bits
   823 00001C1B E8B2FFFFFF          <1> 	call	field_scale
   824                              <1> 
   825 00001C20 0FB6D9              <1> 	movzx	ebx, cl
   826                              <1> 
   827 00001C23 C1E808              <1> 	shr	eax, 8
   828 00001C26 C3                  <1> 	ret
   829                              <1> 
   830 00001C27 E825E7FFFF          <1> _lsc:	call	_operand_read
   831 00001C2C E8DCFFFFFF          <1> 	call	qscale
   832 00001C31 895D14              <1> 	mov	dword ptr [ebp+B], ebx	; store the scale
   833 00001C34 894510              <1> 	mov	dword ptr [ebp+A], eax	; store the rotated value
   834 00001C37 C3                  <1> 	ret
   835                              <1> 
   836 00001C38 E8D2E6FFFF          <1> _dlsc:	call	_burst_read2
   837 00001C3D 894510              <1> 	mov	dword ptr [ebp+A], eax		; keep original 1st word
   838 00001C40 C1E008              <1> 	shl	eax, 8
   839 00001C43 C1F808              <1> 	sar	eax, 8
   840 00001C46 C1C008              <1> 	rol	eax, 8
   841 00001C49 6631C9              <1> 	xor	cx, cx
   842 00001C4C 88C5                <1> 	mov	ch, al				; keep 8 sign bits
   843 00001C4E E87FFFFFFF          <1> 	call	field_scale
   844 00001C53 20C0                <1> 	and	al, al
   845 00001C55 7415                <1> 	jz	_dlsc24				; if the first word is all signs
   846                              <1> 
   847 00001C57 0FB6C1              <1> 	movzx	eax, cl
   848 00001C5A 894518              <1> 	mov	dword ptr [ebp+MANTISSA2], eax	; store the scale
   849 00001C5D 8B4510              <1> 	mov	eax, dword ptr [ebp+A]		; retrieve the input high order word
   850 00001C60 E8D6FDFFFF          <1> 	call	drl				; scale the two input words per cl
   851 00001C65 895D14              <1> 	mov	dword ptr [ebp+B], ebx
   852 00001C68 894510              <1> 	mov	dword ptr [ebp+A], eax  	; store the rotated value
   853 00001C6B C3                  <1> 	ret
   854                              <1> 
   855                              <1> _dlsc24:				; different when high order word is all signs
   856 00001C6C C1E808              <1> 	shr	eax, 8			; one result word of signs
   857 00001C6F 894514              <1> 	mov	dword ptr [ebp+B], eax	; into the low-order result word
   858 00001C72 89D8                <1> 	mov	eax, ebx		; scale the low-order input
   859 00001C74 C1E008              <1> 	shl	eax, 8
   860 00001C77 30C9                <1> 	xor	cl, cl			; restart the scale count-up
   861 00001C79 E854FFFFFF          <1> 	call	field_scale
   862 00001C7E 80C118              <1> 	add	cl, 24			; restore the early part of the count-up
   863                              <1> 
   864 00001C81 0FB6D9              <1> 	movzx	ebx, cl
   865 00001C84 895D18              <1> 	mov	dword ptr [ebp+MANTISSA2], ebx	; store the scale
   866                              <1> 
   867 00001C87 C1E808              <1> 	shr	eax, 8
   868 00001C8A 894510              <1> 	mov	dword ptr [ebp+A], eax	; store the rotated value
   869 00001C8D C3                  <1> 	ret
   870                              <1> 
   871                              <1> 	%if	0
   872                              <1> 
   873                              <1> _fpx:	call	_burst_read2		; data read in eax ebx
   874                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
   875                              <1> 	movd	esi, mm7
   876                              <1> 
   877                              <1> 	push	ebx			; ebx is used in RTA1 stack frame
   878                              <1> 	call	stack4			; construct RTA1 stack frame
   879                              <1> 
   880                              <1> 	shl	eax, 4			; move 12 mantissa bits out of eax
   881                              <1> 	movsx	ecx, ax			; and extend the normalising bit
   882                              <1> 
   883                              <1> 	rol	eax, 4+1		; shelter sign in eax bit 0
   884                              <1> 	shl	ax, 12			; better still in eax bit 12
   885                              <1> 	sar	eax, 12			; propagate the value at midpoint position
   886                              <1> 	ror	eax, 1			; have the sign back
   887                              <1> 	shr	eax, 8			; clear eax 31..24
   888                              <1> 	xor	eax, 003ffc00h		; reverse the 12 copies of midpoint bit
   889                              <1> 					; yon's ra complicated bit done
   890                              <1> 	mov	dword ptr [ebp+ebx*4], eax
   891                              <1> 
   892                              <1> 	xor	eax, ecx		; is the normalising bit opposite to signs ?
   893                              <1> 	test	eax, 00800000h
   894                              <1> 	jz	_fpx_allsigns		; no so unnormalised = zero
   895                              <1> 
   896                              <1> 	pop	eax			; the 2nd operand word, ya remember?
   897                              <1> 	shl	eax, 4			; get them 2 halves over the centre
   898                              <1> 
   899                              <1> 	shr	cx, 4			; zero quartets at high order of 16 bits
   900                              <1> 	shr	ax, 4
   901                              <1> 
   902                              <1> 	xchg	ax, cx			; low-order mantissa bits with unsigns in ecx
   903                              <1> 					; high-order mantissa bits with middle part in eax
   904                              <1> 
   905                              <1> 	shl	eax, 4			; LLLz | HHHz
   906                              <1> 	shr	ax, 4			; LLLz | zHHH
   907                              <1> 	rol	eax, 12			; zzHH | HLLL
   908                              <1> 
   909                              <1> 	mov	dword ptr [ebp+ebx*4+1*4], eax
   910                              <1> 	rol	ecx, 12
   911                              <1> 	xor	ecx, 0FFFh		; 12 normalising bits = 12 inverted signs
   912                              <1> 	mov	dword ptr [ebp+ebx*4+2*4], ecx
   913                              <1> 	not	ecx			; convert high order quartet to signs
   914                              <1> 	sar	ecx, 20			; 24 of them
   915                              <1> 	shr	ecx, 8
   916                              <1> 	mov	dword ptr [ebp+ebx*4+3*4], ecx
   917                              <1> ;	mov	ebp, dword ptr [esi+REGISTER_SET]
   918                              <1> 	mov	dword ptr [ebp+S_P], ebx	; update whichever sp that is
   919                              <1> 	ret
   920                              <1> 
   921                              <1> _fpx_allsigns:
   922                              <1> 	add	esp, 4			; take saved operand word back from stack
   923                              <1> 	sar	ecx, 8			; 16 unnormalised normalising bits
   924                              <1> 	shr	ecx, 8			; = 24 sign bits
   925                              <1> 
   926                              <1> 	mov	dword ptr [ebp+ebx*4], ecx
   927                              <1> 	mov	dword ptr [ebp+ebx*4+1*4], ecx
   928                              <1> 	mov	dword ptr [ebp+ebx*4+2*4], ecx
   929                              <1> 	mov	dword ptr [ebp+ebx*4+3*4], ecx
   930                              <1> 
   931                              <1> ;	mov	ebp, dword ptr [_register_set]
   932                              <1> 	mov	dword ptr [ebp+S_P], ebx	; update whichever sp that is
   933                              <1> 	ret
   934                              <1> 
   935                              <1> _fpp:	call	stack_read4
   936                              <1> 	push	eax				; thats EA
   937                              <1> 
   938                              <1> 	mov	eax, dword ptr [ebp+ebx*4]	; s + 23 exponent bits
   939                              <1> 	rol	eax, 8+2			; save sign and midpoint
   940                              <1> 	shl	eax, 12				; squeeze out 12 exponent bits
   941                              <1> 	shr	ax, 12				; bring sign + midpoint back
   942                              <1> 	ror	eax, 2				; and roll them back in
   943                              <1> 	shr	eax, 4				; position 12 bits low in 16 bits
   944                              <1> 	mov	ecx, dword ptr [ebp+ebx*4+1*4]	; take 1st mantissa word from the stack
   945                              <1> 	ror	ecx, 12				; rotate 12 bits down
   946                              <1> 	shl	cx, 4				; position 12 bits high in 16 bits
   947                              <1> 	mov	ax, cx				; merge
   948                              <1> 	shr	eax, 4				; position 24 bits low in 32 bits
   949                              <1> 	mov	dword ptr [ebp+ebx*4], eax	; place back in RTA1 stack frame
   950                              <1> 						; next 12 mantissa bits in ecx 31..20
   951                              <1> 
   952                              <1> 	mov	eax, dword ptr [ebp+ebx*4+2*4]	; read 24 more
   953                              <1> 	shr	eax, 12-4			; position 12 bits at ax 15..4
   954                              <1> 	shr	ecx, 4				;				
   955                              <1> 	mov	cx, ax				; juxtapose with mantissa 23..12
   956                              <1> 	shr	ecx, 4				; wirraff
   957                              <1> 
   958                              <1> 	mov	dword ptr [ebp+ebx*4+1*4], ecx	; making 2nd and final output word
   959                              <1> 
   960                              <1> 	pop	eax				; recover EA
   961                              <1> 	jmp	_burst_write2
   962                              <1> 
   963                              <1> 	%endif
    41                                  	%include	"fpu.msm"
     1                              <1> 
     2                              <1> compress4to8:			; readout floating operand
     3                              <1> 				; and pack to 32-bit words
     4                              <1> 				; for 1 bit-distance shifting
     5                              <1> 				; acquired operand is in 1st half of 
     6                              <1> 				; 8-register block [edi]
     7                              <1> 
     8 00001C8E 8B07                <1> 	mov	eax, dword ptr [edi]	; 1s-complement scale field
     9 00001C90 C1E008              <1> 	shl	eax, 8			; 1st data bit reveals sign
    10 00001C93 C1F808              <1> 	sar	eax, 8			; propagate that sign some
    11 00001C96 89C3                <1> 	mov	ebx, eax
    12 00001C98 C1F818              <1> 	sar	eax, 24			; propagate signs to 32 bits
    13 00001C9B 31C3                <1> 	xor	ebx, eax		; change scale to unsigned magnitude
    14 00001C9D 891F                <1> 	mov	dword ptr [edi], ebx	; position scale magnitude in 1st register
    15 00001C9F 89471C              <1> 	mov	dword ptr [edi+7*4], eax	; 96 trailing signs
    16 00001CA2 894718              <1> 	mov	dword ptr [edi+6*4], eax
    17 00001CA5 894714              <1> 	mov	dword ptr [edi+5*4], eax
    18 00001CA8 8B5F0C              <1> 	mov	ebx, dword ptr [edi+3*4]	; read low-order mantissa word
    19 00001CAB 88D8                <1> 	mov	al, bl				; low-order octet
    20 00001CAD C1C808              <1> 	ror	eax, 8				; is followed by 24 signs
    21 00001CB0 894710              <1> 	mov	dword ptr [edi+4*4], eax	; ebx also contains mantissa 23..8
    22                              <1> 						; in positions 23..8
    23                              <1> 
    24 00001CB3 8B4708              <1> 	mov	eax, dword ptr [edi+2*4]	; eax now contains mantissa 47..24
    25 00001CB6 C1E308              <1> 	shl	ebx, 8
    26 00001CB9 6689C3              <1> 	mov	bx, ax				; mantissa 39..24 -> ebx
    27 00001CBC C1C310              <1> 	rol	ebx, 16				; ebx now contains mantissa 40..8
    28 00001CBF 895F0C              <1> 	mov	dword ptr [edi+3*4], ebx
    29 00001CC2 8B5F04              <1> 	mov	ebx, dword ptr [edi+1*4]	; mantissa 71..48
    30 00001CC5 C1E308              <1> 	shl	ebx, 8
    31 00001CC8 C1E810              <1> 	shr	eax, 16				; mantissa 47..40
    32 00001CCB 88C3                <1> 	mov	bl, al
    33 00001CCD 895F08              <1> 	mov	dword ptr [edi+2*4], ebx	; mantissa 71..40
    34 00001CD0 8B4714              <1> 	mov	eax, dword ptr [edi+5*4]	; copy 32 signs
    35 00001CD3 894704              <1> 	mov	dword ptr [edi+1*4], eax	; to 2nd word of register block
    36 00001CD6 C3                  <1> 	ret
    37                              <1> 
    38                              <1> 
    39                              <1> ;	___________________________________
    40                              <1> ;	| magnitude scale|     32 signs   |
    41                              <1> ;	|________________|________________|
    42                              <1> ;	| platform word 7| platform word 6|
    43                              <1> 
    44                              <1> 
    45                              <1> ;	<------------ 168-bit mantissa 167..72-------------|
    46                              <1> ;	<------------  72-bit mantissa ------>
    47                              <1> ;	_____________|___________|____________|____________________________
    48                              <1> ;	|      24    | 8 |   16  |   16   | 8 |    24 signs|96 more signs for
    49                              <1> ;	|____________|___|______ |________|___|____________|residue calculation
    50                              <1> ;	| platform word 5| platform word 4|   +rounding <--- @  96-bit operation
    51                              <1> 
    52                              <1> ;	                 <---------------------------------[ platform words 2..0
    53                              <1> ;	                 :
    54                              <1> ;	                 [                                                  ]
    55                              <1> 
    56                              <1> ;	                 |--- 168-bit mantissa 71:0   -------->
    57                              <1> ;	                      rounding @ 192-bit operation --->+
    58                              <1> ;      	                 _________________________|____________|_____________
    59                              <1> ;	                 |      24    | 8 |   16  |   16   | 8 |    24 signs|
    60                              <1> ;	                 |____________|___|_______|________|___|____________|
    61                              <1> ;	                 | platform word 2| platform word 1| platform word 0|
    62                              <1> 
    63                              <1> ;	                 |    residue rounding -->+
    64                              <1> ;	                 |--- 144-bit mantissa -->	                                    
    65                              <1> 
    66                              <1> _deliver_:
    67                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
    68 00001CD7 0F7EFE              <1> 	movd	esi, mm7
    69                              <1> 
    70 00001CDA F786A0040000080000- <1> 	test	dword ptr [esi+PSR], FP_R
    70 00001CE3 00                  <1>
    71 00001CE4 0F847E000000        <1> 	jz	near _deliver
    72 00001CEA 53                  <1> 	push	ebx		; save result register index
    73 00001CEB 8B1F                <1> 	mov	ebx, dword ptr [edi]		; read scale unsigned magnitude
    74                              <1> 						; not yet signed
    75                              <1> 
    76                              <1> 				; all results except scale have been polarised
    77                              <1> 				; ebx = positive magnitude of major exponent
    78                              <1> 				; deliver floating residue
    79 00001CED 83C3B8              <1> 	add	ebx, -72	; calculate exponent of residue
    80 00001CF0 B148                <1> 	mov	cl, 72
    81                              <1> 
    82 00001CF2 8B4710              <1> 	mov	eax, dword ptr [edi+4*4]	; mantissa */ 64 bits
    83 00001CF5 C1E008              <1> 	shl	eax, 8		; separate residual mantissa
    84 00001CF8 C1E808              <1> 	shr	eax, 8
    85 00001CFB 50                  <1> 	push	eax
    86 00001CFC 8B4714              <1> 	mov	eax, dword ptr [edi+5*4]	; mantissa */ 96 bits
    87 00001CFF 50                  <1> 	push	eax
    88 00001D00 8B4718              <1> 	mov	eax, dword ptr [edi+6*4]	; mantissa */ 128 bits
    89 00001D03 668B4704            <1> 	mov	ax, word ptr [edi+1*4]		; change low-order half trailing word to signs
    90 00001D07 50                  <1> 	push	eax				; before normalising
    91                              <1> 
    92                              <1> _normalise_residue:
    93 00001D08 8B442408            <1> 	mov	eax, dword ptr [esp+2*4]	; residual mantissa high-order word
    94 00001D0C 334704              <1> 	xor	eax, dword ptr [edi+1*4]	; signs
    95 00001D0F 2500008000          <1> 	and	eax, 00800000h			; normalising position
    96 00001D14 751A                <1> 	jnz	_residue_normalised
    97 00001D16 8B4704              <1> 	mov	eax, dword ptr [edi+1*4]	; signs again
    98 00001D19 D1D0                <1> 	rcl	eax, 1				; place a sign in carry				
    99 00001D1B D11424              <1> 	rcl	dword ptr [esp], 1		; rotate 96 bits residual mantissa
   100 00001D1E D1542404            <1> 	rcl	dword ptr [esp+1*4], 1
   101 00001D22 D1542408            <1> 	rcl	dword ptr [esp+2*4], 1		; thirdly the high-order word
   102 00001D26 83C3FF              <1> 	add	ebx, -1
   103 00001D29 80C1FF              <1> 	add	cl, -1
   104 00001D2C 72DA                <1> 	jc	_normalise_residue
   105 00001D2E 31DB                <1> 	xor	ebx, ebx			; residue all signs zero -> scale
   106                              <1> _residue_normalised:
   107 00001D30 F7C3000080FF        <1> 	test	ebx, 0FF800000h
   108                              <1> 						; likeliest $residue underflow
   109 00001D36 0F85EEF4FFFF        <1> 	jnz	_fpxpo_low_order		; nonzero mantissa
   110                              <1> 						; and exponent underflow / overflow
   111                              <1> 						
   112                              <1> ;			residual mantissa on the stack now is
   113                              <1> ;			______________________________________________
   114                              <1> ;	sp------------->| mantissa bits 15..0 | 16 sign bits discard |
   115                              <1> ;			|_____________________|______________________|
   116                              <1> ;			|            mantissa bits 47..16            |
   117                              <1> ;			|____________________________________________| 
   118                              <1> ;			| 0000 0000  mantissa bits 71..48            |
   119                              <1> ;			|____________________________________________|
   120                              <1> ;			|	     result register indication      |
   121                              <1> ;			|____________________________________________|
   122                              <1> 
   123 00001D3C 8B4704              <1> 	mov	eax, dword ptr [edi+1*4]	; signs
   124 00001D3F 31D8                <1> 	xor	eax, ebx			; sign residue exponent now
   125 00001D41 C1E008              <1> 	shl	eax, 8				; trim characteristic to RTA1 24-bit word
   126 00001D44 C1E808              <1> 	shr	eax, 8
   127 00001D47 894520              <1> 	mov	dword ptr [ebp+8*4], eax	; scale XOR signs -> residue characteristic
   128                              <1> 
   129 00001D4A 5B                  <1> 	pop	ebx				; low order mantissa part
   130 00001D4B 58                  <1> 	pop	eax				; middle order mantissa part
   131 00001D4C 88C3                <1> 	mov	bl, al				; donate 8 bits
   132 00001D4E C1CB08              <1> 	ror	ebx, 8				; distribute as RTA1 24-bit words
   133 00001D51 C1EB08              <1> 	shr	ebx, 8				; mantissa 23..0
   134 00001D54 C1E808              <1> 	shr	eax, 8				; mantissa 47..24
   135 00001D57 895D2C              <1> 	mov	dword ptr [ebp+11*4], ebx
   136 00001D5A 894528              <1> 	mov	dword ptr [ebp+10*4], eax
   137 00001D5D 58                  <1> 	pop	eax				; high order residual mantissa part
   138 00001D5E 5B                  <1> 	pop	ebx				; saved result register index
   139 00001D5F C1E008              <1> 	shl	eax, 8
   140 00001D62 C1E808              <1> 	shr	eax, 8				; normalising position is bit 23
   141 00001D65 894524              <1> 	mov	dword ptr [ebp+9*4], eax	; mantissa 71..48
   142                              <1> 
   143                              <1> _deliver:					; deliver floating result
   144                              <1> 						; ebx = target register index
   145                              <1> 						; result register index [ebp+]ebx*4
   146 00001D68 8B07                <1> 	mov	eax, dword ptr [edi]		; unsigned scale magnitude
   147 00001D6A A9000080FF          <1> 	test	eax, 0FF800000h
   148 00001D6F 0F85BFF4FFFF        <1> 	jnz	_fpxpo				; exponent underflow / overflow
   149 00001D75 334704              <1> 	xor	eax, dword ptr [edi+1*4]	; sign it
   150 00001D78 C1E008              <1> 	shl	eax, 8
   151 00001D7B C1E808              <1> 	shr	eax, 8
   152                              <1> 
   153                              <1> _store_float:
   154 00001D7E 89449D00            <1>         mov     dword ptr [ebp+ebx*4], eax      ; store characteristic = scale XOR signs
   155 00001D82 8B4708              <1>         mov     eax, dword ptr [edi+2*4]	; read bits 71..40 major mantissa
   156 00001D85 0FB6C8              <1>         movzx   ecx, al
   157 00001D88 C1E808              <1>         shr     eax, 8
   158 00001D8B 89449D04            <1>         mov     dword ptr [ebp+ebx*4+4], eax	; store mantissa bits 71..48
   159 00001D8F 8B470C              <1>         mov     eax, dword ptr [edi+3*4]	; read mantissa bits 39..8
   160 00001D92 C1E110              <1>         shl     ecx, 16				; position mantissa bits 47..40
   161 00001D95 C1C810              <1>         ror     eax, 16
   162 00001D98 6689C1              <1>         mov     cx, ax				; position mantissa bits 39..24
   163 00001D9B 894C9D08            <1>         mov     dword ptr [ebp+ebx*4+8], ecx	; store mantissa bits 47..24
   164 00001D9F 8B4F10              <1>         mov     ecx, dword ptr [edi+4*4]	; read mantissa bits 7..0 plus 24 trailing bits
   165 00001DA2 C1E910              <1>         shr     ecx, 16				; position after mantissa 23..8
   166 00001DA5 6689C8              <1>         mov     ax, cx
   167 00001DA8 C1E808              <1>         shr     eax, 8				; store mantissa bits 23..0
   168 00001DAB 89449D0C            <1>         mov     dword ptr [ebp+ebx*4+12], eax
   169 00001DAF C3                  <1> 	ret
   170                              <1> 
   171                              <1> ;	_output equ	272
   172                              <1> ;	_inputr equ	264
   173                              <1> ;	_input2 equ	256
   174                              <1> 
   175                              <1> ;	_OUTPUT	equ	__register+_output*4
   176                              <1> ;	_INPUTR equ	__register+_inputr*4
   177                              <1> ;	_INPUT2 equ	__register+_input2*4
   178                              <1> ;	_BIAS	equ	_OUTPUT
   179                              <1> 
   180                              <1> zoutput:
   181 00001DB0 31C0                <1> 	xor	eax, eax
   182 00001DB2 8907                <1> 	mov	dword ptr [edi], eax
   183 00001DB4 894704              <1> 	mov	dword ptr [edi+1*4], eax
   184 00001DB7 894708              <1> 	mov	dword ptr [edi+2*4], eax
   185 00001DBA 89470C              <1> 	mov	dword ptr [edi+3*4], eax
   186 00001DBD 894710              <1> 	mov	dword ptr [edi+4*4], eax
   187 00001DC0 894714              <1> 	mov	dword ptr [edi+5*4], eax
   188 00001DC3 894718              <1> 	mov	dword ptr [edi+6*4], eax
   189 00001DC6 89471C              <1> 	mov	dword ptr [edi+7*4], eax
   190 00001DC9 C3                  <1> 	ret
   191                              <1> 
   192                              <1> 
   193                              <1> ;	round before add or divide
   194                              <1> ;	XOR rounding pattern to guard field
   195                              <1> 
   196 00001DCA 0F7EFB              <1> round1	movd	ebx, mm7
   197 00001DCD 8B834C020000        <1> 	mov	eax, dword ptr [ebx+REGISTER+FP_GUARD]	; register 147 = guard bits
   198 00001DD3 D3E8                <1> 	shr	eax, cl
   199 00001DD5 C1E008              <1> 	shl	eax, 8
   200                              <1> 
   201 00001DD8 0FB6DD              <1> 	movzx	ebx, ch
   202 00001DDB 31449F08            <1> 	xor	dword ptr [edi+ebx*4+2*4], eax
   203 00001DDF C3                  <1> 	ret
   204                              <1> 
   205 00001DE0 0FB6DD              <1> round2:	movzx	ebx, ch
   206                              <1> ;	mov	eax, dword ptr [ebp+CORE_INDEX1]	; ? can't have mattered
   207 00001DE3 0F7EFE              <1> 	movd	esi, mm7			; 
   208                              <1> 
   209 00001DE6 8B864C020000        <1> 	mov	eax, dword ptr [esi+REGISTER+FP_GUARD]
   210 00001DEC D3E8                <1> 	shr	eax, cl
   211 00001DEE C1E008              <1> 	shl	eax, 8
   212 00001DF1 01449F08            <1> 	add	dword ptr [edi+ebx*4+2*4], eax
   213                              <1> round2more:
   214 00001DF5 83549F0400          <1> 	adc	dword ptr [edi+ebx*4+1*4], 0
   215 00001DFA 4B                  <1> 	dec	ebx
   216 00001DFB 75F8                <1> 	jnz	round2more
   217 00001DFD C3                  <1> 	ret
   218                              <1> 
   219                              <1> end_around_carry:
   220                              <1> 
   221 00001DFE F75608              <1> 	not	dword ptr [esi+2*4]		; seems to vary or be vaguely documented
   222 00001E01 0FB64604            <1> 	movzx	eax, byte ptr [esi+1*4]		; what size the call return stack frame is
   223                              <1> 						; so we push ei and copy esp to it
   224                              <1> 						; to see stuff near the stack top
   225                              <1> 
   226 00001E05 F6460880            <1> 	test	byte ptr dword ptr [esi+2*4], 128
   227 00001E09 790B                <1> 	jns	end_around_carry_plus		; updated signs +
   228                              <1> 
   229 00001E0B B8FFFFFFFF          <1> 	mov	eax, -1				; 1 -> -1 in 1s complement
   230 00001E10 D3E8                <1> 	shr	eax, cl
   231 00001E12 F7D0                <1> 	not	eax
   232 00001E14 EB06                <1> 	jmp	eoc1
   233                              <1> 
   234                              <1> end_around_carry_plus:
   235 00001E16 21C0                <1> ?	and	eax, eax
   236 00001E18 7415                <1> 	jz	eox1				; ? don't call this if there is no carry
   237 00001E1A D3C8                <1> 	ror	eax, cl
   238                              <1> 
   239 00001E1C 0FB6DD              <1> eoc1:	movzx	ebx, ch
   240 00001E1F 01449F08            <1> 	add	dword ptr [edi+ebx*4+2*4], eax
   241                              <1> 
   242 00001E23 9C                  <1> 	pushf
   243 00001E24 C1F81F              <1> 	sar	eax, 31				; shift leave carry alone
   244 00001E27 9D                  <1> 	popfd
   245                              <1> 
   246 00001E28 43                  <1> 	inc	ebx				; but reference displacements - 2
   247                              <1> 
   248 00001E29 11049F              <1> eoc:	adc	dword ptr [edi+ebx*4], eax	; referencing displacements - 2
   249 00001E2C 4B                  <1> 	dec	ebx
   250 00001E2D 75FA                <1> 	jnz	eoc
   251 00001E2F C3                  <1> eox1:	ret
   252                              <1> 
   253                              <1> restore_trailing_signs:
   254 00001E30 0FB6DD              <1> 	movzx	ebx, ch
   255 00001E33 8B4704              <1> 	mov	eax, dword ptr [edi+1*4]
   256                              <1> 
   257 00001E36 89471C              <1> 	mov	dword ptr [edi+7*4], eax
   258                              <1> 
   259 00001E39 21C0                <1> 	and	eax, eax
   260 00001E3B 780B                <1> 	js	restore_trailing_ones
   261 00001E3D F7D0                <1> 	not	eax
   262 00001E3F D3E8                <1> 	shr	eax, cl
   263 00001E41 F7D0                <1> 	not	eax
   264 00001E43 21449F08            <1> 	and	dword ptr [edi+ebx*4+2*4], eax
   265                              <1> 
   266 00001E47 C3                  <1> 	ret
   267                              <1> restore_trailing_ones:
   268 00001E48 D3E8                <1> 	shr	eax, cl
   269 00001E4A 09449F08            <1> 	or	dword ptr [edi+ebx*4+2*4], eax
   270                              <1> 
   271 00001E4E C3                  <1> 	ret
   272                              <1> 	
   273                              <1> BIAS_FIELD	equ	8
   274                              <1> 
   275                              <1> bias_addend:					; input mantissa [esi] is biased into location _BIAS
   276 00001E4F 57                  <1> 	push	edi
   277 00001E50 89F7                <1> 	mov	edi, esi
   278                              <1> 
   279                              <1> ;	mov	esi, dword ptr[ebp+CORE_INDEX1]
   280 00001E52 0F7EFE              <1> 	movd	esi, mm7
   281 00001E55 8DB640040000        <1> 	lea	esi, [esi+_BIAS]
   282                              <1> 
   283 00001E5B 56                  <1> 	push	esi
   284 00001E5C E803000000          <1> 	call	biasfp
   285                              <1> 
   286 00001E61 5E                  <1> 	pop	esi
   287 00001E62 5F                  <1> 	pop	edi
   288 00001E63 C3                  <1> 	ret
   289                              <1> 
   290 00001E64 52                  <1> biasfp:	push	edx
   291 00001E65 51                  <1> 	push	ecx
   292                              <1> 
   293 00001E66 BB01000000          <1> 	mov	ebx, 1				; output index
   294 00001E6B 66C1E003            <1> 	shl	ax, 3				; words sign fill
   295 00001E6F C0E803              <1> 	shr	al, 3				; bits sign fill
   296 00001E72 6689C1              <1> 	mov	cx, ax
   297 00001E75 83C704              <1> 	add	edi, 4				; input pointer
   298 00001E78 8B07                <1> 	mov	eax, dword ptr [edi]		; there shall be this word of signs at least
   299                              <1> 
   300 00001E7A 89049E              <1> bias32:	mov	dword ptr [esi+ebx*4], eax	; write 1 word of signs
   301 00001E7D 43                  <1> 	inc	ebx				; consider the next output word
   302 00001E7E FECD                <1> 	dec	ch				; any more words of signs?
   303 00001E80 79F8                <1> 	jns	bias32
   304                              <1> 
   305 00001E82 20C9                <1> 	and	cl, cl
   306 00001E84 7422                <1> 	jz	bias_fast			; there is no 32-bit shift
   307                              <1> 
   308 00001E86 B520                <1> 	mov	ch, 32				; demonstrate the missing advantage
   309 00001E88 28CD                <1> 	sub	ch, cl				; of instruction architectures
   310                              <1> 						; with 2-register shifts
   311                              <1> biasup2:
   312 00001E8A 83FB08              <1> 	cmp	ebx, BIAS_FIELD
   313 00001E8D 742B                <1> 	jz	bias_addx
   314 00001E8F 83C704              <1> 	add	edi, 4				; read new mantissa word
   315 00001E92 8B17                <1> 	mov	edx, dword ptr [edi]		; it becomes word # new in edx
   316 00001E94 86E9                <1> 	xchg	ch, cl
   317 00001E96 D3E0                <1> 	shl	eax, cl				; shift buffered word left 32 - bit offset
   318 00001E98 86E9                <1> 	xchg	ch, cl
   319 00001E9A D3EA                <1> 	shr	edx, cl				; shift new mantissa word right bit offset
   320 00001E9C 09D0                <1> 	or	eax, edx
   321 00001E9E 89049E              <1> 	mov	dword ptr [esi+ebx*4], eax	; write 1 merged word
   322 00001EA1 8B07                <1> 	mov	eax, dword ptr [edi]		; read the same mantissa word again
   323 00001EA3 83C301              <1> 	add	ebx, 1				; it becomes word # previous in eax
   324 00001EA6 EBE2                <1> 	jmp	biasup2
   325                              <1> 
   326                              <1> bias_fast:
   327 00001EA8 83FB08              <1> 	cmp	ebx, BIAS_FIELD
   328 00001EAB 740D                <1> 	jz	bias_addx
   329 00001EAD 83C704              <1> 	add	edi, 4
   330 00001EB0 8B07                <1> 	mov	eax, dword ptr [edi]
   331 00001EB2 89049E              <1> 	mov	dword ptr [esi+ebx*4], eax
   332 00001EB5 83C301              <1> 	add	ebx, 1
   333 00001EB8 EBEE                <1> 	jmp	bias_fast
   334                              <1> 
   335                              <1> bias_addx:
   336 00001EBA 59                  <1> 	pop	ecx
   337 00001EBB 5A                  <1> 	pop	edx				; restore the program counter
   338 00001EBC C3                  <1> 	ret
   339                              <1> 
   340                              <1> frame_mantissa:
   341                              <1> ;	ror	ecx, 16				; words count is up, beats index down
   342 00001EBD 80C501              <1> 	add	ch, 1				; up the beats index to beats count
   343 00001EC0 66C1E905            <1> 	shr	cx, 5				; positions / 32 in ch
   344 00001EC4 C0E903              <1> 	shr	cl, 3				; positions /// 32 in cl
   345 00001EC7 0FB6DD              <1> 	movzx	ebx, ch				; derive platform words rounded down
   346 00001ECA C3                  <1> 	ret
   347                              <1> 
   348                              <1> renormalise:					; rule 1: restore sign fill in
   349                              <1> 						; low-order containing platform word
   350                              <1> ; done before end-around-carry, and saved
   351                              <1> ;;	call	frame_mantissa			; it was mashed by rounding and adding
   352 00001ECB E860FFFFFF          <1> 	call	restore_trailing_signs
   353 00001ED0 C1C910              <1> 	ror	ecx, 16				; the governing parameter is now
   354                              <1> 						; the containing words count in cx
   355                              <1> renormalise32:
   356 00001ED3 8B4708              <1> 	mov	eax, dword ptr [edi+2*4]	; sample 32 mantissa bits
   357 00001ED6 3B4704              <1> 	cmp	eax, dword ptr [edi+1*4]	; compare it with 32 signs
   358 00001ED9 750C                <1> 	jnz	renormalise8
   359 00001EDB E83E000000          <1> 	call	rotate32left			; this also discovers if it's ALL signs = 0
   360 00001EE0 21C0                <1> 	and	eax, eax			; and is the only place that needs examined
   361 00001EE2 75EF                <1> 	jnz	renormalise32
   362                              <1> 
   363 00001EE4 8907                <1> 	mov	dword ptr [edi], eax		; mantissa is signed zero, +0 -> scale
   364                              <1> renormalised:
   365 00001EE6 C3                  <1> 	ret
   366                              <1> 
   367                              <1> renormalise8:					; from this point on the value is nonzero
   368 00001EE7 C1C008              <1> 	rol	eax, 8				; are there 8 signs at head of mantissa?
   369 00001EEA 3A4707              <1> 	cmp	al, byte ptr [edi+1*4+3]	; this is Intel and the 4th byte is high-order
   370 00001EED 750A                <1> 	jnz	renormalise1			; you have found the 8 bits containing the
   371                              <1> 						; normalising bit
   372 00001EEF E849000000          <1> 	call	rotate8left			; or else you haven't
   373 00001EF4 8B4708              <1> 	mov     eax, dword ptr [edi+2*4]	; sample the moved mantissa
   374 00001EF7 EBEE                <1> 	jmp	renormalise8
   375                              <1> 
   376                              <1> renormalise1:
   377                              <1> ;	movzx	ebx, cx	
   378 00001EF9 8B4704              <1> 	mov	eax, dword ptr [edi+1*4]		
   379                              <1> ;	mov	dword ptr [edi+ebx*4+1*4], eax	; in case polarity has changed
   380 00001EFC 334708              <1> 	xor	eax, dword ptr [edi+2*4]	; normalising bit opposite polarity to sign?
   381 00001EFF 78E5                <1> 	js	renormalised			; arrived
   382 00001F01 E802000000          <1> 	call	bitwise_scale			; almost arrived
   383 00001F06 EBF1                <1> 	jmp	renormalise1
   384                              <1> 
   385                              <1> 
   386                              <1> bitwise_scale:
   387 00001F08 D1571C              <1> 	rcl	dword ptr [edi+7*4], 1	; so it doesn't matter whether 0 or 1
   388 00001F0B D15718              <1> 	rcl	dword ptr [edi+6*4], 1	; gets shifted into the 192nd bit
   389 00001F0E D15714              <1> 	rcl	dword ptr [edi+5*4], 1
   390 00001F11 D15710              <1> 	rcl	dword ptr [edi+4*4], 1	; it's quicker to shift 6 words
   391 00001F14 D1570C              <1> 	rcl	dword ptr [edi+3*4], 1	; than a counted loop of 4 or 5 or 6 words
   392 00001F17 D15708              <1> 	rcl	dword ptr [edi+2*4], 1
   393                              <1> 
   394 00001F1A 8307FF              <1> 	add	dword ptr [edi], -1	; scale down
   395 00001F1D C3                  <1> 	ret
   396                              <1> 
   397                              <1> rotate32left:				; rotate all containing platform words of mantissa
   398 00001F1E 52                  <1> 	push	edx			; 32 bit positions left and report if all signs
   399 00001F1F 51                  <1> 	push	ecx
   400 00001F20 0FB7D9              <1> 	movzx	ebx, cx
   401 00001F23 31D2                <1> 	xor	edx, edx		; initialise equality = all signs
   402                              <1> 
   403                              <1> rotate32next:				; the word initially loaded in eax is all signs
   404 00001F25 4B                  <1> 	dec	ebx
   405 00001F26 87449F08            <1> 	xchg	eax, dword ptr [edi+ebx*4+2*4]
   406 00001F2A 89C1                <1> 	mov	ecx, eax
   407 00001F2C 334F04              <1> 	xor	ecx, dword ptr [edi+1*4] ; difference between this word and signs
   408 00001F2F 09CA                <1> 	or	edx, ecx		; sum of differences
   409 00001F31 21DB                <1> 	and	ebx, ebx
   410 00001F33 75F0                <1> 	jnz	rotate32next
   411 00001F35 8307E0              <1> 	add	dword ptr [edi], -32	; scale down
   412 00001F38 89D0                <1> 	mov	eax, edx
   413 00001F3A 59                  <1> 	pop	ecx
   414 00001F3B 5A                  <1> 	pop	edx
   415 00001F3C C3                  <1> 	ret
   416                              <1> 
   417                              <1> rotate8left:				; rotate all containing platform words of mantissa
   418 00001F3D 51                  <1> 	push	ecx			; 8 bit positions left. 1st word is rotated already
   419 00001F3E 0FB7D9              <1> 	movzx	ebx, cx			; and contains signs in 8 low-order bit positions
   420                              <1> rotate8next:
   421 00001F41 8B4C9F08            <1> 	mov	ecx, dword ptr [edi+ebx*4+2*4]
   422 00001F45 C1C108              <1> 	rol	ecx, 8
   423 00001F48 86C1                <1> 	xchg	al, cl
   424 00001F4A 894C9F08            <1> 	mov	dword ptr [edi+ebx*4+2*4], ecx
   425 00001F4E 83C3FF              <1> 	add	ebx, -1
   426 00001F51 72EE                <1> 	jc	rotate8next
   427 00001F53 8307F8              <1> 	add	dword ptr [edi], -8	; scale down
   428 00001F56 59                  <1> 	pop	ecx
   429 00001F57 C3                  <1> 	ret
   430                              <1> 
   431 00001F58 F75708              <1> zover:	not	dword ptr [edi+2*4]
   432 00001F5B F7570C              <1> 	not	dword ptr [edi+3*4]
   433 00001F5E F75710              <1> 	not	dword ptr [edi+4*4]
   434 00001F61 F75714              <1> 	not	dword ptr [edi+5*4]
   435 00001F64 F75718              <1> 	not	dword ptr [edi+6*4]
   436 00001F67 F7571C              <1> 	not	dword ptr [edi+7*4]
   437 00001F6A C3                  <1> 	ret
   438                              <1> 
   439                              <1> _add_low:
   440 00001F6B 8B961C040000        <1>         mov     edx, dword ptr [esi+_INPUT2+7*4]
   441 00001F71 13963C040000        <1>         adc     edx, dword ptr [esi+_INPUTR+7*4]
   442 00001F77 8B9E18040000        <1>         mov     ebx, dword ptr [esi+_INPUT2+6*4]
   443 00001F7D 139E38040000        <1>         adc     ebx, dword ptr [esi+_INPUTR+6*4]
   444 00001F83 8B8614040000        <1>         mov     eax, dword ptr [esi+_INPUT2+5*4]
   445 00001F89 138634040000        <1>         adc     eax, dword ptr [esi+_INPUTR+5*4]
   446 00001F8F C3                  <1>         ret
   447                              <1> 
   448                              <1> _add_high:
   449 00001F90 8B9610040000        <1>         mov     edx, dword ptr [esi+_INPUT2+4*4]
   450 00001F96 139630040000        <1>         adc     edx, dword ptr [esi+_INPUTR+4*4]
   451 00001F9C 8B9E0C040000        <1>         mov     ebx, dword ptr [esi+_INPUT2+3*4]
   452 00001FA2 139E2C040000        <1>         adc     ebx, dword ptr [esi+_INPUTR+3*4]
   453 00001FA8 8B8608040000        <1>         mov     eax, dword ptr [esi+_INPUT2+2*4]
   454 00001FAE 138628040000        <1>         adc     eax, dword ptr [esi+_INPUTR+2*4]
   455 00001FB4 C3                  <1>         ret
   456                              <1> 
   457 00001FB5 8DBE00040000        <1> fan:	lea	edi, [esi+_INPUT2]
   458 00001FBB E898FFFFFF          <1> 	call	zover				; mantissa
   459 00001FC0 F79604040000        <1> 	not	dword ptr [esi+_INPUT2+1*4]	; 32 signs
   460                              <1> 
   461 00001FC6 8DBE20040000        <1> fa:	lea	edi, [esi+_INPUTR]
   462 00001FCC 8DB600040000        <1> 	lea	esi, [esi+_INPUT2]
   463                              <1> 
   464 00001FD2 8B4604              <1> 	mov	eax, dword ptr [esi+1*4]	; normalised?
   465 00001FD5 334608              <1> 	xor	eax, dword ptr [esi+2*4]	; normalising bit must ^ signs
   466 00001FD8 7801                <1> 	js	fa_addend_normalised		; yes
   467 00001FDA C3                  <1> fa_nop:	ret					; accumulator block unchanged
   468                              <1> 
   469                              <1> fa_addend_normalised:
   470 00001FDB 8B4704              <1> 	mov	eax, dword ptr [edi+1*4]	; register side operand normalised?
   471 00001FDE 334708              <1> 	xor	eax, dword ptr [edi+2*4]	; normalising bit must ^ signs
   472 00001FE1 7803                <1> 	js	fa_promote_magnitude		; normalised, get on with it
   473 00001FE3 89F7                <1> 	mov	edi, esi			; accumulator block is not normalised
   474 00001FE5 C3                  <1> 	ret					; storage addend zero-added
   475                              <1> 
   476                              <1> fa_promote_magnitude:
   477 00001FE6 8B07                <1> 	mov	eax, dword ptr [edi]
   478 00001FE8 2B06                <1> 	sub	eax, dword ptr [esi]
   479                              <1> 
   480 00001FEA 7904                <1> 	jns	fa_add				; register-side operand is not lower
   481                              <1> 
   482 00001FEC 87F7                <1> 	xchg	esi, edi			;
   483 00001FEE F7D8                <1> 	neg	eax
   484                              <1> 
   485                              <1> fa_add:	;	call	frame_mantissa
   486 00001FF0 50                  <1> 	push	eax				; exponent difference
   487 00001FF1 E8D4FDFFFF          <1> 	call	round1
   488                              <1> 
   489 00001FF6 58                  <1> 	pop	eax				; exponent difference
   490 00001FF7 21C0                <1> 	and	eax, eax			; is + and either zero or not
   491 00001FF9 740C                <1> 	jz	fa_addfast
   492                              <1> 
   493 00001FFB 3DA7000000          <1> 	cmp	eax, 167			; do they touch?
   494 00002000 77D8                <1> 	ja	fa_nop
   495                              <1> 
   496 00002002 E848FEFFFF          <1> 	call	bias_addend
   497                              <1> 
   498                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1] ; done inside bias_addend
   499                              <1> ;	anyway movd	esi, mm7
   500                              <1> ;	lea	esi, [esi+_BIAS]		; shifted added
   501                              <1> 
   502                              <1> fa_addfast:
   503 00002007 8B4704              <1> 	mov	eax, dword ptr [edi+1*4]	; before look signs
   504 0000200A 50                  <1> 	push	eax				; near stack top until fa_normalised
   505                              <1> 
   506 0000200B C1C910              <1> 	ror	ecx, 16				; get containing compute words
   507 0000200E 0FB7D9              <1> 	movzx	ebx, cx				; index / count
   508 00002011 C1C910              <1> 	ror	ecx, 16
   509                              <1> 
   510                              <1> 	%if	BIAS_FIELD=8
   511 00002014 81671C000000FF      <1> 	and	dword ptr [edi+7*4], 0FF000000h
   512 0000201B 81661C000000FF      <1> 	and	dword ptr [esi+7*4], 0FF000000h
   513                              <1> 	%endif
   514                              <1> 
   515                              <1> ; call ultrate
   516                              <1> 	%if	0
   517                              <1> 	mov	eax, dword ptr [esi+1*4]	; signs word in _OUTPUT 
   518                              <1> 
   519                              <1> 	rol	eax, 1
   520                              <1> 
   521                              <1> 	%else
   522 00002022 F8                  <1> 	clc
   523                              <1> 	%endif
   524                              <1> 
   525                              <1> fa_action:
   526 00002023 8B049E              <1> 	mov	eax, dword ptr [esi+ebx*4]
   527 00002026 11049F              <1> 	adc	dword ptr [edi+ebx*4], eax
   528 00002029 4B                  <1> 	dec	ebx				; process word 1
   529 0000202A 75F7                <1> 	jnz	fa_action			; leave word 0 alone
   530                              <1> 
   531                              <1> ; call ultrate
   532                              <1> 
   533 0000202C 0F92C3              <1> 	setc	bl				; boolean instructions following
   534 0000202F 53                  <1> 	push	ebx				; should not change carry but
   535                              <1> 
   536                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
   537 00002030 0F7EFE              <1> 	movd	esi, mm7
   538                              <1> 	
   539 00002033 8B4704              <1> 	mov	eax, dword ptr [edi+1*4]	; has sign switched ?
   540 00002036 33442404            <1> 	xor	eax, dword ptr [esp+1*4]
   541                              <1> 	
   542 0000203A 7918                <1> 	jns	fa_testcarry
   543                              <1> 
   544                              <1> ;	not	dword ptr [esi+7*4]
   545                              <1> 
   546 0000203C F686A004000008      <1> 	test	byte ptr [esi+PSR], FP_R	; flag 8 = store residue
   547 00002043 7506                <1> 	jnz	switch_long
   548                              <1> 
   549 00002045 F75718              <1> 	not	dword ptr [edi+6*4]		; if double size (+ residue)
   550 00002048 F75714              <1> 	not	dword ptr [edi+5*4]		; these are written in the add loop
   551                              <1> switch_long:
   552                              <1> 
   553                              <1> ;	not	dword ptr [edi+7*4]		; thru zero
   554                              <1> 
   555 0000204B 56                  <1> 	push	esi				; have a clear expectation
   556 0000204C 89E6                <1> 	mov	esi, esp			; where the first stack words are
   557 0000204E E8ABFDFFFF          <1> 	call	end_around_carry
   558 00002053 5E                  <1> 	pop	esi
   559                              <1> 
   560                              <1> fa_testcarry:
   561                              <1> 
   562 00002054 8B442404            <1> 	mov	eax, dword ptr [esp+1*4]		; [ esp + 1L ] -> updated signs
   563 00002058 334704              <1> 	xor	eax, dword ptr [edi+1*4]		; carry from normalising position?
   564                              <1> 
   565 0000205B 2401                <1> 	and	al, 1
   566 0000205D 7422                <1> 	jz	fa_normalise
   567                              <1> 
   568 0000205F FF07                <1> 	inc	dword ptr [edi]				; exponent magnitude++
   569                              <1> 
   570 00002061 8B442404            <1> 	mov	eax, dword ptr [esp+1*4]	 	; read 32 signs
   571 00002065 D1C8                <1> 	ror	eax, 1					; move a sign to carry	
   572                              <1> 
   573 00002067 D15F04              <1> 	rcr	dword ptr [edi+1*4], 1			; shift from signs word
   574 0000206A D15F08              <1> 	rcr	dword ptr [edi+2*4], 1			; to normalising position
   575 0000206D D15F0C              <1> 	rcr	dword ptr [edi+3*4], 1			; keep going
   576 00002070 D15F10              <1> 	rcr	dword ptr [edi+4*4], 1
   577 00002073 D15F14              <1> 	rcr	dword ptr [edi+5*4], 1
   578 00002076 D15F18              <1> 	rcr	dword ptr [edi+6*4], 1
   579 00002079 D15F1C              <1> 	rcr	dword ptr [edi+7*4], 1
   580                              <1> 
   581 0000207C 894704              <1> 	mov	dword ptr [edi+1*4], eax		; write all signs back to signs word
   582                              <1> 
   583 0000207F EB0A                <1> 	jmp	fa_normalised
   584                              <1> 
   585                              <1> fa_normalise:
   586                              <1> 	%if	BIAS_FIELD=8
   587 00002081 E80D040000          <1> 	call	fp_registers_m
   588                              <1> 	%endif
   589                              <1> 
   590 00002086 E840FEFFFF          <1> 	call	renormalise				; in case the sum is plenty positions
   591                              <1> 
   592                              <1> fa_normalised:
   593 0000208B 5B                  <1> 	pop	ebx
   594 0000208C 58                  <1> 	pop	eax					; below the fractional point
   595 0000208D C3                  <1> 	ret
   596                              <1> 	
   597 0000208E 8DBE40040000        <1> fm:	lea	edi, [esi+_OUTPUT]			; initialise final accumulation
   598 00002094 E817FDFFFF          <1> 	call	zoutput
   599                              <1> 
   600 00002099 8B9E24040000        <1> 	mov	ebx, dword ptr [esi+_INPUTR+1*4]	; read register-side signs
   601 0000209F 8B8628040000        <1> 	mov	eax, dword ptr [esi+_INPUTR+2*4]	; and high-end mantissa
   602 000020A5 31D8                <1> 	xor	eax, ebx	 			; cache if-normalised in eax
   603 000020A7 339E04040000        <1> 	xor	ebx, dword ptr [esi+_INPUT2+1*4]	; multiply signs
   604 000020AD 899E44040000        <1> 	mov	dword ptr [esi+_OUTPUT+1*4], ebx	; save the output sign
   605 000020B3 21C0                <1> 	and	eax, eax				; test the cached if-normalised
   606 000020B5 790E                <1> 	jns	fmdont
   607                              <1> 
   608 000020B7 8B8604040000        <1> 	mov	eax, dword ptr [esi+_INPUT2+1*4]	; is the multiplier normalised?
   609 000020BD 338608040000        <1> 	xor	eax, dword ptr [esi+_INPUT2+2*4]	; sign XOR normalising bit?
   610 000020C3 782F                <1> 	js	fmgo					; yes, proceed
   611                              <1> 
   612 000020C5 899E48040000        <1> fmdont:	mov	dword ptr [esi+_OUTPUT+2*4], ebx
   613 000020CB 899E4C040000        <1> 	mov	dword ptr [esi+_OUTPUT+3*4], ebx
   614 000020D1 899E50040000        <1> 	mov	dword ptr [esi+_OUTPUT+4*4], ebx
   615 000020D7 899E54040000        <1> 	mov	dword ptr [esi+_OUTPUT+5*4], ebx
   616 000020DD 899E58040000        <1> 	mov	dword ptr [esi+_OUTPUT+6*4], ebx
   617 000020E3 899E5C040000        <1> 	mov	dword ptr [esi+_OUTPUT+7*4], ebx
   618 000020E9 C78640040000000000- <1> 	mov	dword ptr [esi+_OUTPUT], 0		; mantissa to go
   618 000020F2 00                  <1>
   619                              <1> 
   620 000020F3 C3                  <1> 	ret					; no, effective zero multiplier
   621                              <1> 
   622 000020F4 51                  <1> fmgo:	push	ecx
   623 000020F5 8B8624040000        <1> 	mov	eax, dword ptr [esi+_INPUTR+1*4]
   624 000020FB B148                <1> 	mov	cl, 72				; beats count exactly 72
   625 000020FD 21C0                <1> 	and	eax, eax
   626                              <1> 
   627 000020FF 790B                <1> 	jns	fmp1
   628 00002101 8DBE20040000        <1> 	lea	edi, [esi+_INPUTR]
   629 00002107 E84CFEFFFF          <1> 	call	zover
   630                              <1> 
   631 0000210C 8B8604040000        <1> fmp1:	mov	eax, dword ptr [esi+_INPUT2+1*4]
   632 00002112 21C0                <1> 	and	eax, eax
   633 00002114 790B                <1> 	jns	fmadd
   634 00002116 8DBE00040000        <1> 	lea	edi, [esi+_INPUT2]
   635 0000211C E837FEFFFF          <1> 	call	zover
   636                              <1> 
   637 00002121 F8                  <1> fmadd:	clc
   638                              <1> 
   639 00002122 8DBE20040000        <1> 	lea	edi, [esi+_INPUTR]
   640 00002128 D15F08              <1> 	rcr	dword ptr [edi+2*4], 1		; addend shift right
   641 0000212B D15F0C              <1> 	rcr	dword ptr [edi+3*4], 1
   642 0000212E D15F10              <1> 	rcr	dword ptr [edi+4*4], 1
   643 00002131 D15F14              <1> 	rcr	dword ptr [edi+5*4], 1
   644 00002134 D15F18              <1> 	rcr	dword ptr [edi+6*4], 1
   645 00002137 D15F1C              <1> 	rcr	dword ptr [edi+7*4], 1
   646                              <1> 
   647 0000213A 8DBE00040000        <1> 	lea	edi, [esi+_INPUT2]
   648                              <1> 
   649                              <1> 	%if	0
   650                              <1> 	rcl	dword ptr [edi+7*4], 1		; multiplier shift left
   651                              <1> 	rcl	dword ptr [edi+6*4], 1
   652                              <1> 	rcl	dword ptr [edi+5*4], 1		; multiplier mantissa is only 72 bits
   653                              <1> 	%endif
   654                              <1> 
   655 00002140 D15710              <1> 	rcl	dword ptr [edi+4*4], 1
   656 00002143 D1570C              <1> 	rcl	dword ptr [edi+3*4], 1
   657 00002146 D15708              <1> 	rcl	dword ptr [edi+2*4], 1
   658                              <1> 
   659 00002149 8DBE40040000        <1> 	lea	edi, [esi+_OUTPUT]
   660 0000214F 7336                <1> 	jnc	fmadx
   661                              <1> 						; 1 shifted from multiplier
   662 00002151 8B863C040000        <1> fmadc:	mov	eax, dword ptr [esi+_INPUTR+7*4]	
   663 00002157 01471C              <1> 	add	dword ptr [edi+7*4], eax	; do not use carry
   664 0000215A 8B8638040000        <1> 	mov	eax, dword ptr [esi+_INPUTR+6*4]
   665 00002160 114718              <1> 	adc	dword ptr [edi+6*4], eax	; start using carry
   666 00002163 8B8634040000        <1> 	mov	eax, dword ptr [esi+_INPUTR+5*4]
   667 00002169 114714              <1> 	adc	dword ptr [edi+5*4], eax
   668 0000216C 8B8630040000        <1> 	mov	eax, dword ptr [esi+_INPUTR+4*4]
   669 00002172 114710              <1> 	adc	dword ptr [edi+4*4], eax
   670 00002175 8B862C040000        <1> 	mov	eax, dword ptr [esi+_INPUTR+3*4]
   671 0000217B 11470C              <1> 	adc	dword ptr [edi+3*4], eax
   672 0000217E 8B8628040000        <1> 	mov	eax, dword ptr [esi+_INPUTR+2*4]
   673 00002184 114708              <1> 	adc	dword ptr [edi+2*4], eax
   674                              <1> 
   675 00002187 FEC9                <1> fmadx:	dec	cl
   676 00002189 7596                <1> 	jnz	fmadd
   677                              <1> 
   678 0000218B 59                  <1> fmadz:	pop	ecx
   679                              <1> 
   680 0000218C 8B4708              <1> 	mov	eax, dword ptr [edi+2*4] 	; normalised?
   681 0000218F D1D0                <1> 	rcl	eax, 1
   682 00002191 721B                <1> 	jc	fm_normalised
   683                              <1> 
   684 00002193 838620040000FF      <1> 	add	dword ptr [esi+_INPUTR], -1		; take 1 from scale
   685 0000219A D1571C              <1> 	rcl	dword ptr [edi+7*4], 1
   686 0000219D D15718              <1> 	rcl	dword ptr [edi+6*4], 1
   687 000021A0 D15714              <1> 	rcl	dword ptr [edi+5*4], 1
   688 000021A3 D15710              <1> 	rcl	dword ptr [edi+4*4], 1
   689 000021A6 D1570C              <1> 	rcl	dword ptr [edi+3*4], 1
   690 000021A9 D15708              <1> 	rcl	dword ptr [edi+2*4], 1
   691                              <1> 
   692 000021AC EB26                <1> 	jmp	fm_inrange
   693                              <1> 
   694                              <1> fm_normalised:
   695 000021AE 8DBE40040000        <1> 	lea	edi, [esi+_OUTPUT]
   696 000021B4 E827FCFFFF          <1> 	call	round2
   697 000021B9 7319                <1> 	jnc	fm_inrange
   698                              <1> 
   699 000021BB D15F08              <1> 	rcr	dword ptr [edi+2*4], 1
   700 000021BE D15F0C              <1> 	rcr	dword ptr [edi+3*4], 1
   701 000021C1 D15F10              <1> 	rcr	dword ptr [edi+4*4], 1
   702 000021C4 D15F14              <1> 	rcr	dword ptr [edi+5*4], 1
   703 000021C7 D15F18              <1> 	rcr	dword ptr [edi+6*4], 1
   704 000021CA D15F1C              <1> 	rcr	dword ptr [edi+7*4], 1
   705 000021CD 83862004000001      <1> 	add	dword ptr [esi+_INPUTR], 1
   706                              <1> 
   707                              <1> fm_inrange:
   708 000021D4 8B8620040000        <1> 	mov	eax, dword ptr [esi+_INPUTR]
   709 000021DA 038600040000        <1> 	add	eax, dword ptr [esi+_INPUT2]
   710 000021E0 050000C0FF          <1> 	add	eax, -00400000h
   711 000021E5 8907                <1> 	mov	dword ptr [edi], eax		; insert unsigned magnitude product scale
   712 000021E7 8B4704              <1> 	mov	eax, dword ptr [edi+1*4]
   713 000021EA 314708              <1> 	xor	dword ptr [edi+2*4], eax	; the mantissa gets polarised here
   714 000021ED 31470C              <1> 	xor	dword ptr [edi+3*4], eax
   715 000021F0 314710              <1> 	xor	dword ptr [edi+4*4], eax
   716 000021F3 314714              <1> 	xor	dword ptr [edi+5*4], eax
   717 000021F6 314718              <1> 	xor	dword ptr [edi+6*4], eax
   718 000021F9 31471C              <1> 	xor	dword ptr [edi+7*4], eax
   719 000021FC C3                  <1> 	ret
   720                              <1> 
   721 000021FD 8DBE40040000        <1> fd:	lea	edi, [esi+_OUTPUT]
   722 00002203 E8A8FBFFFF          <1> 	call	zoutput				; result which may stay zero
   723 00002208 8B8604040000        <1> 	mov	eax, dword ptr [esi+_INPUT2+1*4]	; signs
   724 0000220E 89C3                <1> 	mov	ebx, eax
   725 00002210 338608040000        <1> 	xor	eax, dword ptr [esi+_INPUT2+2*4]	; normalising bit 31
   726 00002216 780C                <1> 	js	fdgo
   727 00002218 F79644040000        <1> 	not	dword ptr [esi+_OUTPUT+1*4]		; divisor 0 or otherwise unnormalised
   728 0000221E E835FDFFFF          <1> 	call	zover				; return -0.0
   729 00002223 C3                  <1> fdnop:	ret					; not normalised = zero divisor
   730                              <1> 
   731 00002224 8B8624040000        <1> fdgo:	mov     eax, dword ptr [esi+_INPUTR+1*4]	; make sure the dividend is present
   732 0000222A 338628040000        <1> 	xor	eax, dword ptr [esi+_INPUTR+2*4]	; normalising bit must be not sign
   733 00002230 783B                <1> 	js	fdop				; go after all
   734                              <1> 						; unnormalised = 0 = unnormalised
   735 00002232 8B8624040000        <1> 	mov	eax, dword ptr [esi+_INPUTR+1*4]	; read the signs I tell you
   736 00002238 C78640040000000000- <1> 	mov	dword ptr [esi+_OUTPUT], 0		; exponent magnitude of nowhere
   736 00002241 00                  <1>
   737 00002242 898644040000        <1> 	mov	dword ptr [esi+_OUTPUT+1*4], eax	; signs
   738 00002248 898648040000        <1> 	mov	dword ptr [esi+_OUTPUT+2*4], eax	; and as much mantissa as you like
   739 0000224E 89864C040000        <1> 	mov	dword ptr [esi+_OUTPUT+3*4], eax
   740 00002254 898650040000        <1> 	mov	dword ptr [esi+_OUTPUT+4*4], eax
   741 0000225A 898654040000        <1> 	mov	dword ptr [esi+_OUTPUT+5*4], eax
   742 00002260 898658040000        <1> 	mov	dword ptr [esi+_OUTPUT+6*4], eax
   743 00002266 89865C040000        <1> 	mov	dword ptr [esi+_OUTPUT+7*4], eax
   744 0000226C C3                  <1> 	ret
   745                              <1> 
   746 0000226D 21DB                <1> fdop:	and	ebx, ebx				; divisor either is negative magnitude
   747 0000226F 780B                <1> 	js	fd_comp1	
   748 00002271 8DBE00040000        <1> 	lea	edi, [esi+_INPUT2]			; or shall be
   749 00002277 E8DCFCFFFF          <1> 	call	zover
   750                              <1> fd_comp1:
   751 0000227C F78624040000000000- <1> 	test	dword ptr [esi+_INPUTR+1*4], 080000000h
   751 00002285 80                  <1>
   752 00002286 740B                <1> 	jz	fd_upright			; dividend must be positive magnitude
   753 00002288 8DBE20040000        <1> 	lea	edi, [esi+_INPUTR]
   754 0000228E E8C5FCFFFF          <1> 	call	zover
   755                              <1> fd_upright:
   756 00002293 8DBE20040000        <1> 	lea	edi, [esi+_INPUTR]
   757                              <1> 
   758 00002299 E82CFBFFFF          <1> 	call	round1				; this also sets counters
   759                              <1> 
   760 0000229E 52                  <1> 	push	edx
   761 0000229F 51                  <1> 	push	ecx
   762                              <1> 
   763                              <1> ;	add	cx, 01818h		; a divide needs 24 more beats
   764                              <1> 					; than a multiply
   765                              <1> 
   766 000022A0 89C8                <1> 	mov	eax, ecx		; save words count in add range
   767 000022A2 B15F                <1> 	mov	cl, 95
   768                              <1> 
   769 000022A4 C1E810              <1> 	shr	eax, 16			; isolate words count in add range
   770 000022A7 6683C0FA            <1> 	add	ax, -6			; is it big?
   771 000022AB 0F8391000000        <1> 	jnc	near fd_72
   772                              <1> 
   773                              <1> ;	test	ch, 128
   774                              <1> ;	jz	near fd_72
   775                              <1> 
   776 000022B1 89E7                <1> 	mov	edi, esp
   777                              <1> 
   778 000022B3 B1BF                <1> 	mov	cl, 191			;
   779                              <1> 
   780 000022B5 F9                  <1> fd_144:	stc				; add negative mantissa
   781 000022B6 E8B0FCFFFF          <1> 	call	_add_low		; to positive dividend
   782 000022BB 52                  <1> 	push	edx			; save the low half in the stack
   783 000022BC 53                  <1> 	push	ebx
   784 000022BD 50                  <1> 	push	eax
   785 000022BE E8CDFCFFFF          <1> 	call	_add_high			; add the high half in eax edx ebx
   786                              <1> 
   787 000022C3 7327                <1> 	jnc	fd_144level			; no carry = drop the result
   788                              <1> 
   789 000022C5 898628040000        <1> 	mov	dword ptr [esi+_INPUTR+2*4], eax	; carry = update the dividend
   790 000022CB 899E2C040000        <1> 	mov	dword ptr [esi+_INPUTR+3*4], ebx
   791 000022D1 899630040000        <1> 	mov	dword ptr [esi+_INPUTR+4*4], edx
   792                              <1> 
   793 000022D7 58                  <1> 	pop	eax
   794 000022D8 898634040000        <1> 	mov	dword ptr [esi+_INPUTR+5*4], eax
   795 000022DE 58                  <1> 	pop	eax
   796 000022DF 898638040000        <1> 	mov	dword ptr [esi+_INPUTR+6*4], eax
   797 000022E5 58                  <1> 	pop	eax
   798 000022E6 89863C040000        <1> 	mov	dword ptr [esi+_INPUTR+7*4], eax
   799                              <1> fd_144level:
   800 000022EC 89FC                <1> 	mov	esp, edi	; clear stack whether popped or not
   801 000022EE D1965C040000        <1> 	rcl	dword ptr [esi+_OUTPUT+7*4], 1	; shift value of carry into quotient
   802 000022F4 D19658040000        <1> 	rcl	dword ptr [esi+_OUTPUT+6*4], 1
   803 000022FA D19654040000        <1> 	rcl	dword ptr [esi+_OUTPUT+5*4], 1
   804 00002300 D19650040000        <1> 	rcl	dword ptr [esi+_OUTPUT+4*4], 1
   805 00002306 D1964C040000        <1> 	rcl	dword ptr [esi+_OUTPUT+3*4], 1
   806 0000230C D19648040000        <1> 	rcl	dword ptr [esi+_OUTPUT+2*4], 1
   807                              <1> 
   808 00002312 F9                  <1> 	stc
   809 00002313 D19E08040000        <1> 	rcr	dword ptr [esi+_INPUT2+2*4], 1	; shift negative addend
   810 00002319 D19E0C040000        <1> 	rcr	dword ptr [esi+_INPUT2+3*4], 1	; 1 position starboard
   811 0000231F D19E10040000        <1> 	rcr	dword ptr [esi+_INPUT2+4*4], 1
   812 00002325 D19E14040000        <1> 	rcr	dword ptr [esi+_INPUT2+5*4], 1
   813 0000232B D19E18040000        <1> 	rcr	dword ptr [esi+_INPUT2+6*4], 1
   814 00002331 D19E1C040000        <1> 	rcr	dword ptr [esi+_INPUT2+7*4], 1
   815                              <1> 
   816 00002337 80C1FF              <1> 	add	cl, -1
   817 0000233A 0F8275FFFFFF        <1> 	jc	fd_144
   818 00002340 EB44                <1> 	jmp	fd_restore	
   819                              <1> 
   820 00002342 F9                  <1> fd_72:	stc					; add negative mantissa
   821 00002343 E848FCFFFF          <1> 	call	_add_high			; to positive dividend
   822 00002348 7312                <1> 	jnc	fd_72level			; no carry = drop the result
   823                              <1> 
   824 0000234A 898628040000        <1> 	mov	dword ptr [esi+_INPUTR+2*4], eax	; carry = update the dividend
   825 00002350 899E2C040000        <1> 	mov	dword ptr [esi+_INPUTR+3*4], ebx
   826 00002356 899630040000        <1> 	mov	dword ptr [esi+_INPUTR+4*4], edx
   827                              <1> fd_72level:
   828 0000235C D19650040000        <1> 	rcl	dword ptr [esi+_OUTPUT+4*4], 1	; shift value of carry into quotient
   829 00002362 D1964C040000        <1> 	rcl	dword ptr [esi+_OUTPUT+3*4], 1
   830 00002368 D19648040000        <1> 	rcl	dword ptr [esi+_OUTPUT+2*4], 1
   831                              <1> 
   832 0000236E F9                  <1> 	stc
   833 0000236F D19E08040000        <1> 	rcr	dword ptr [esi+_INPUT2+2*4], 1	; shift negative addend
   834 00002375 D19E0C040000        <1> 	rcr	dword ptr [esi+_INPUT2+3*4], 1	; 1 position starboard
   835 0000237B D19E10040000        <1> 	rcr	dword ptr [esi+_INPUT2+4*4], 1	;
   836                              <1> 
   837 00002381 80C1FF              <1> 	add	cl, -1
   838 00002384 72BC                <1> 	jc	fd_72
   839                              <1> 
   840 00002386 59                  <1> fd_restore:	pop	ecx
   841 00002387 5A                  <1> 		pop	edx				; hand the program counter back
   842                              <1> 
   843                              <1> 
   844                              <1> ;		mov	esi, dword ptr [ebp+CORE_INDEX1] ; fd kept esi -> core state
   845                              <1> ;	mm7	anyway
   846                              <1> 
   847 00002388 8B8620040000        <1> 		mov	eax, dword ptr [esi+_INPUTR]	; + magnitude dividend exponent
   848 0000238E 2B8600040000        <1> 		sub	eax, dword ptr [esi+_INPUT2]	; + magnitude divisor exponent
   849 00002394 0501004000          <1> 		add	eax, 00400001h			; midpoint + 1
   850 00002399 898640040000        <1> 		mov	dword ptr [esi+_OUTPUT], eax	; magnitude of quotient scale
   851                              <1> 							; -> front of delivery string
   852 0000239F 8DBE40040000        <1> 		lea	edi, [esi+_OUTPUT]
   853                              <1> 
   854 000023A5 E821FBFFFF          <1> 		call	renormalise
   855                              <1> 
   856 000023AA 8DBE40040000        <1> 		lea	edi, [esi+_OUTPUT]			; tell rewrite where it is
   857 000023B0 8B8624040000        <1> 		mov	eax, dword ptr [esi+_INPUTR+1*4]	; determine sign of quotient
   858 000023B6 338604040000        <1> 		xor	eax, dword ptr [esi+_INPUT2+1*4]
   859 000023BC 894704              <1> 		mov	[edi+1*4], eax			; output 32 signs
   860                              <1> 							; _deliver_ polarises the quotient scale
   861 000023BF 314708              <1> 		xor	dword ptr [edi+2*4], eax	; switch quotient mantissa
   862 000023C2 31470C              <1> 		xor	dword ptr [edi+3*4], eax
   863 000023C5 314710              <1> 		xor	dword ptr [edi+4*4], eax
   864 000023C8 314714              <1> 		xor	dword ptr [edi+5*4], eax	; switch the long mantissa
   865 000023CB 314718              <1> 		xor	dword ptr [edi+6*4], eax
   866 000023CE 31471C              <1> 		xor	dword ptr [edi+7*4], eax
   867                              <1> 
   868 000023D1 C3                  <1> fd_z:		ret
   869                              <1> 
   870                              <1> 	;	these instructions take the left-side + target as
   871                              <1> 	;	[register_set]->a:b:mantissa2:mantissa3
   872                              <1> 	;	and the right side as [ea]
   873                              <1> 
   874                              <1> 	;	after acquisition and before delivery they call modules
   875                              <1> ;	fa fan fm fd
   876                              <1> ;	which may be used in extended instruction sets
   877                              <1> ;	using source and target registers in the internal stack
   878                              <1> ;	with maximum mantissa size 168 bits
   879                              <1> 
   880                              <1> 
   881                              <1> ;	esi -> core state but must also be used dynamically a lot
   882                              <1> ;	ebp -> always points at either one of two locations
   883                              <1> 
   884                              <1> ;		RTA1 application registers [ 0..127 ] modeled in 128 integers
   885                              <1> ;		RTA1 interrupt registers [ 128..255 ] modeled in 128 integers
   886                              <1> ;
   887                              <1> ;	there is always a copy of esi for retrieval at [ ebp + 152 integers ] ->
   888                              <1> 
   889                              <1> ;	_________________________.------ esi and ebp in application mode
   890                              <1> ;	|  RTA1 register 0	|					|
   891                              <1> ;	|_______________________|					|
   892                              <1> ;									|
   893                              <1> ;	________________________.------- ebp in ISR mode		|
   894                              <1> ;	|  RTA1 register 128	|			|		|
   895                              <1> ;	|_______________________|			|		|
   896                              <1> ;							|		|
   897                              <1> ;							|		|
   898                              <1> ;							|		|
   899                              <1> ;	_________________________.______________________|_______________|
   900                              <1> ;	| 64-bit mm7 = esi save + refresh 
   901                              <1> ;	|_______________________|
   902                              <1> 
   903                              <1> 
   904                              <1> 	%if	BIAS_FIELD=8
   905                              <1> BIAS_POINTERS	equ	fp_registers_a
   906                              <1> 	%else
   907                              <1> BIAS_POINTERS	equ	fp_registers_m
   908                              <1> 	%endif
   909                              <1> 
   910 000023D2 BB04000000          <1> _fa:	mov 	ebx, a
   911 000023D7 53                  <1> _far:	push	ebx
   912 000023D8 E86D000000          <1> 	call	fp_operands
   913 000023DD E897000000          <1> 	call	BIAS_POINTERS
   914 000023E2 E8DFFBFFFF          <1> 	call	fa
   915 000023E7 5B                  <1> 	pop	ebx
   916 000023E8 E9EAF8FFFF          <1> 	jmp	_deliver_
   917                              <1> 
   918 000023ED BB04000000          <1> _fan:	mov	ebx, a
   919 000023F2 53                  <1> _fanr:	push	ebx
   920 000023F3 E852000000          <1> 	call	fp_operands
   921 000023F8 E87C000000          <1> 	call	BIAS_POINTERS
   922 000023FD E8B3FBFFFF          <1> 	call	fan
   923 00002402 5B                  <1> 	pop	ebx
   924 00002403 E9CFF8FFFF          <1> 	jmp	_deliver_
   925                              <1> 
   926 00002408 BB04000000          <1> _fm:	mov	ebx, a
   927 0000240D 53                  <1> _fmr:	push	ebx
   928 0000240E E837000000          <1> 	call	fp_operands
   929 00002413 E87B000000          <1> 	call	fp_registers_m
   930 00002418 E871FCFFFF          <1> 	call	fm
   931 0000241D 5B                  <1> 	pop	ebx
   932 0000241E 8DBE40040000        <1> 	lea	edi, [esi+_OUTPUT]
   933 00002424 E9AEF8FFFF          <1> 	jmp	 _deliver_
   934                              <1> 
   935 00002429 BB04000000          <1> _fd:	mov	ebx, a				; default target register
   936 0000242E 53                  <1> _fdr:	push	ebx
   937 0000242F E816000000          <1> 	call	fp_operands
   938 00002434 E85A000000          <1> 	call	fp_registers_m
   939 00002439 E8BFFDFFFF          <1> 	call	fd
   940 0000243E 5B                  <1> 	pop	ebx
   941 0000243F 8DBE40040000        <1> 	lea	edi, [esi+_OUTPUT]
   942 00002445 E98DF8FFFF          <1> 	jmp	_deliver_
   943                              <1> 
   944                              <1> fp_operands:
   945 0000244A 8DBE20040000        <1> 	lea	edi, [esi+_INPUTR]
   946 00002450 50                  <1> 	push	eax				; save effective address
   947 00002451 E857000000          <1> 	call	_load_quad
   948 00002456 E833F8FFFF          <1> 	call	compress4to8
   949 0000245B 58                  <1> 	pop	eax				; restore effective address
   950                              <1> 
   951 0000245C 55                  <1> 	push	ebp				; ebp must momentarily
   952 0000245D 89F5                <1> 	mov	ebp, esi			; -> start of all register list
   953 0000245F BB00010000          <1> 	mov	ebx, _input2			; into starboard buffer
   954 00002464 E8BBDEFFFF          <1> 	call	_burst_read4			; memory or registers @ ea
   955 00002469 5D                  <1> 	pop	ebp				; App / Int register context
   956                              <1> 
   957                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
   958 0000246A 0F7EFE              <1> 	movd	esi, mm7
   959                              <1> 
   960 0000246D 8DBE00040000        <1> 	lea	edi, [esi+_INPUT2]		; but still in ebp
   961 00002473 E816F8FFFF          <1> 	call	compress4to8
   962 00002478 C3                  <1> 	ret
   963                              <1> 
   964                              <1> fp_registers_a:
   965                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
   966 00002479 0F7EFE              <1> 	movd	esi, mm7
   967                              <1> 
   968 0000247C B908020400          <1> 	mov	ecx, 00040208h
   969 00002481 F786A0040000080000- <1> 	test	dword ptr [esi+PSR], FP_R
   969 0000248A 00                  <1>
   970 0000248B 7405                <1> 	jz	fp_registers_x
   971 0000248D B910040700          <1> 	mov	ecx, 00070410h
   972                              <1> fp_registers_x:
   973 00002492 C3                  <1> 	ret
   974                              <1> 
   975                              <1> fp_registers_m:
   976                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
   977 00002493 0F7EFE              <1> 	movd	esi, mm7
   978                              <1> 
   979 00002496 B908020400          <1> 	mov	ecx, 00040208h
   980 0000249B F786A0040000080000- <1> 	test	dword ptr [esi+PSR], FP_R
   980 000024A4 00                  <1>
   981 000024A5 7405                <1> 	jz	fp_registers_z
   982 000024A7 B910040600          <1> 	mov	ecx, 00060410h
   983                              <1> fp_registers_z:
   984 000024AC C3                  <1> 	ret
   985                              <1> 
   986                              <1> _load_quad:
   987 000024AD 8B449D0C            <1> 	mov	eax, dword ptr[ebp+ebx*4+3*4]
   988 000024B1 89470C              <1> 	mov	dword ptr [edi+3*4], eax
   989 000024B4 8B449D08            <1> 	mov	eax, dword ptr  [ebp+ebx*4+2*4]
   990 000024B8 894708              <1> 	mov	dword ptr [edi+2*4], eax
   991 000024BB 8B449D04            <1> 	mov	eax, dword ptr [ebp+ebx*4+1*4]
   992 000024BF 894704              <1> 	mov	dword ptr [edi+1*4], eax
   993 000024C2 8B449D00            <1> 	mov	eax, dword ptr [ebp+ebx*4]
   994 000024C6 8907                <1> 	mov	dword ptr [edi], eax
   995 000024C8 C3                  <1> 	ret
   996                              <1> 
   997                              <1> 	%if	1
   998                              <1> ultrate:
   999 000024C9 8B07                <1> 	mov	eax, dword ptr [edi]
  1000 000024CB A3[00000000]        <1> 	mov	dword ptr [_ultra], eax
  1001                              <1>  
  1002 000024D0 8B4704              <1> 	mov     eax, dword ptr [edi+1*4]
  1003 000024D3 A3[00000000]        <1> 	mov     dword ptr [_ultra1], eax
  1004                              <1> 
  1005 000024D8 8B4708              <1>         mov     eax, dword ptr [edi+2*4]
  1006 000024DB A3[00000000]        <1>         mov     dword ptr [_ultra2], eax
  1007                              <1> 
  1008 000024E0 8B470C              <1>         mov     eax, dword ptr [edi+3*4]
  1009 000024E3 A3[00000000]        <1>         mov     dword ptr [_ultra3], eax
  1010                              <1> 
  1011 000024E8 8B4710              <1>         mov     eax, dword ptr [edi+4*4]
  1012 000024EB A3[00000000]        <1>         mov     dword ptr [_ultra4], eax
  1013                              <1> 
  1014 000024F0 8B4714              <1>         mov     eax, dword ptr [edi+5*4]
  1015 000024F3 A3[00000000]        <1>         mov     dword ptr [_ultra5], eax
  1016                              <1> 
  1017 000024F8 8B4718              <1>         mov     eax, dword ptr [edi+6*4]
  1018 000024FB A3[00000000]        <1>         mov     dword ptr [_ultra6], eax
  1019                              <1> 
  1020 00002500 8B471C              <1>         mov     eax, dword ptr [edi+7*4]
  1021 00002503 A3[00000000]        <1>         mov     dword ptr [_ultra7], eax
  1022                              <1> 
  1023 00002508 C3                  <1> 	ret
  1024                              <1> 
  1025                              <1> zultrate:
  1026 00002509 57                  <1> 	push	edi
  1027 0000250A BF[16250000]        <1> 	mov	edi, __ZERO
  1028 0000250F E8B5FFFFFF          <1> 	call	ultrate
  1029 00002514 5F                  <1> 	pop	edi
  1030 00002515 C3                  <1> 	ret
  1031                              <1> 
  1032 00002516 000000000000000000- <1> __ZERO	dd	0, 0, 0, 0, 0, 0, 0, 0
  1032 0000251F 000000000000000000- <1>
  1032 00002528 000000000000000000- <1>
  1032 00002531 0000000000          <1>
  1033                              <1> 	%endif
    42                                  	%include	"parity.msm"
     1                              <1> _get_parity:
     2 00002536 8B5D10              <1>         mov     ebx, dword ptr [ebp+A]
     3 00002539 235D04              <1>         and     ebx, dword ptr [ebp+K]
     4                              <1> _fold_parity:
     5 0000253C 30DF                <1>         xor     bh, bl
     6 0000253E C1EB08              <1>         shr     ebx, 8
     7 00002541 30FB                <1>         xor     bl, bh
     8 00002543 C3                  <1>         ret
     9                              <1> 
    43                                  	%include	"margin.msm"
     1                              <1> read_straddle_12b?:
     2                              <1> 
     3 00002544 F6C101              <1> 	test	cl, 1				; 4 words? You are here because
     4 00002547 7534                <1> 	jnz	split_read4w			; offset is within last 3 of page
     5                              <1> 						; 2 words then
     6 00002549 81FEFF0F0000        <1> 	cmp	esi, 0FFFh			; starting @ last word of page?
     7 0000254F 722B                <1> 	jb	readout				; not so, go ahead with burst read
     8                              <1> 
     9                              <1> split_read2w:
    10                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
    11 00002551 0F7EFE              <1> 	movd	esi, mm7
    12                              <1> 
    13 00002554 893C24              <1> 	mov	dword ptr [esp], edi		; delete 1st return address + save EA
    14 00002557 89F8                <1> 	mov	eax, edi			; recover EA
    15 00002559 30C9                <1> 	xor	cl, cl				; request 1 word
    16 0000255B E809DEFFFF          <1> 	call	_bus_read			;
    17 00002560 870424              <1> 	xchg	eax, dword ptr [esp]		; save 1st word read + load updated EA
    18 00002563 40                  <1> 	inc	eax				; advance EA onto next page
    19 00002564 30C9                <1> 	xor	cl, cl				; request 1 word
    20 00002566 E8FEDDFFFF          <1> 	call	_bus_read			; read new page or block
    21 0000256B 89C3                <1> 	mov	ebx, eax
    22 0000256D 58                  <1> 	pop	eax				; recover 1st read word
    23 0000256E C3                  <1> 	ret					; return to caller of operand_read
    24                              <1> 
    25                              <1> read_straddle_18b?:
    26 0000256F F6C101              <1> 	test	cl, 1				; 4 words? You are here because 
    27 00002572 7509                <1> 	jnz	split_read4w			; offset is within last 3 of of bank
    28                              <1> 						; 2 words then
    29 00002574 81FEFFFF0300        <1> 	cmp	esi, 0003FFFFh			; starting @ last word of bank?
    30 0000257A 73D5                <1> 	jnb	split_read2w			; otherwise fall thru to burst read
    31                              <1> 
    32                              <1> readout:
    33 0000257C C3                  <1> 	ret					; burst read in order
    34                              <1> 
    35                              <1> split_read4w:					; write EA over stack top return address
    36                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
    37 0000257D 0F7EFE              <1> 	movd	esi, mm7
    38                              <1> 
    39 00002580 893C24              <1> 	mov	dword ptr [esp], edi		; one or other of these 2-word reads
    40 00002583 89F8                <1> 	mov	eax, edi			; splits down to 1-word reads
    41 00002585 E807000000          <1> 	call	read2				; when offset is [3F]FFD
    42 0000258A E802000000          <1> 	call	read2				;             or [3F]FFF
    43 0000258F 58                  <1> 	pop	eax				;   but not when [3F]FFE
    44 00002590 C3                  <1> 	ret					; return to caller of caller
    45                              <1> 	
    46 00002591 50                  <1> read2:	push	eax				; EA
    47 00002592 53                  <1> 	push	ebx				; destination index on stack top
    48 00002593 B106                <1> 	mov	cl, 6				; ask bus for 2 words
    49 00002595 E8CFDDFFFF          <1> 	call	_bus_read			; replaces eax and ebx
    50 0000259A 871C24              <1> 	xchg	ebx, dword ptr [esp]		; get destination index up again
    51 0000259D 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax	; write 1st result word
    52 000025A1 58                  <1> 	pop	eax				; recover 2nd result word
    53 000025A2 89449D04            <1> 	mov	dword ptr [ebp+ebx*4+1*4], eax	; write 2nd result word
    54 000025A6 58                  <1> 	pop	eax				; EA
    55 000025A7 83C002              <1> 	add	eax, 2
    56 000025AA 83C302              <1> 	add	ebx, 2
    57 000025AD C3                  <1> 	ret	
    58                              <1> 
    44                                  	%include	"margin_w.msm"
     1                              <1> write_straddle_12b?:				; multiword write request
     2                              <1> write_straddle12b?:				; in last 3 words of block
     3 000025AE F6C101              <1> 	test	cl, 1				; 4-word write request?
     4 000025B1 7539                <1> 	jnz	split_write4w			;
     5 000025B3 81FEFF0F0000        <1> 	cmp	esi, 0FFFH			; 2 words then. In last word?
     6 000025B9 7230                <1> 	jb	writeout			; no
     7                              <1> 						; yes
     8                              <1> split_write2w:
     9                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
    10 000025BB 0F7EFE              <1> 	movd	esi, mm7
    11                              <1> 
    12 000025BE 891C24              <1> 	mov	dword ptr [esp], ebx		; not returning to there
    13 000025C1 57                  <1> 	push	edi				; esp -> saved eax [ea], saved ebx
    14 000025C2 89F8                <1> 	mov	eax, edi			; place ea in eax
    15 000025C4 30C9                <1> 	xor	cl, cl				; request 1-word write
    16 000025C6 8B5C9D00            <1> 	mov	ebx, dword ptr [ebp+ebx*4]	; data from register array
    17 000025CA E837DFFFFF          <1> 	call	bus_write
    18 000025CF 58                  <1> 	pop	eax				; retrieve ea from stack
    19 000025D0 5B                  <1> 	pop	ebx				; retrieve register index
    20 000025D1 40                  <1> 	inc	eax				; advance ea to next block
    21 000025D2 8B5C9D04            <1> 	mov	ebx, dword ptr [ebp+ebx*4+4]	; data from register array
    22 000025D6 30C9                <1> 	xor	cl, cl				; request 1-word write
    23 000025D8 E829DFFFFF          <1> 	call	bus_write
    24 000025DD C3                  <1> 	ret					; return caller of caller
    25                              <1> 
    26                              <1> write_straddle_18b?:				; multiword write request
    27                              <1> write_straddle18b?:				; in last 3 words of block
    28 000025DE F6C101              <1> 	test	cl, 1				; 4 words?
    29 000025E1 7509                <1> 	jnz	split_write4w
    30 000025E3 81FEFFFF0300        <1> 	cmp	esi, 0003FFFFh			; 2 words then. In last word?
    31 000025E9 73D0                <1> 	jnb	split_write2w			; yes
    32                              <1> 						; no
    33                              <1> writeout:
    34 000025EB C3                  <1> 	ret					; return to burst write
    35                              <1> 
    36                              <1> split_write4w:
    37                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
    38 000025EC 0F7EFE              <1> 	movd	esi, mm7
    39                              <1> 
    40 000025EF 893C24              <1> 	mov	dword ptr [esp], edi		; return address at stack top not used
    41 000025F2 89F8                <1> 	mov	eax, edi			; copy ea
    42 000025F4 E807000000          <1> 	call	write2				; request 2 writes word pairs
    43 000025F9 E802000000          <1> 	call	write2				; if 1 of them straddles it splits again
    44 000025FE 58                  <1> 	pop	eax				; this is ea
    45 000025FF C3                  <1> 	ret					; return to caller of caller
    46                              <1> 
    47                              <1> 
    48 00002600 B106                <1> write2:	mov	cl, 6				; request 2-word bus write
    49 00002602 50                  <1> 	push	eax				; save ea
    50 00002603 53                  <1> 	push	ebx				; save register array index
    51 00002604 E8FDDEFFFF          <1> 	call	bus_write			; send write pair request
    52 00002609 5B                  <1> 	pop	ebx				; retrieve register index
    53 0000260A 58                  <1> 	pop	eax				; and ea
    54 0000260B 83C302              <1> 	add	ebx, 2				; update register index
    55 0000260E 83C002              <1> 	add	eax, 2				; and ea
    56 00002611 C3                  <1> 	ret
    45                                  	%include	"rex.msm"
     1                              <1> SIMD_192	equ	1
     2                              <1> 
     3                              <1> _rextable_1
     3          ******************  <1>  warning: label alone on a line without a colon might be in error [-w+orphan-labels]
     4 00002612 000000000000000000- <1> 	dd	0, 0, 0, 0,		r_sa, r_sb, r_z, 0
     4 0000261B 00000000000000-     <1>
     4 00002622 [95290000]-         <1>
     4 00002626 [8D290000]-         <1>
     4 0000262A [AE290000]00000000  <1>
     5 00002632 000000000000000000- <1> 	dd	0, 0, 0, 0,		r_la, r_lb, r_tz, r_tp
     5 0000263B 00000000000000-     <1>
     5 00002642 [C8290000]-         <1>
     5 00002646 [C0290000]-         <1>
     5 0000264A [56290000]-         <1>
     5 0000264E [71290000]          <1>
     6 00002652 0000000000000000-   <1> 	dd	0, 0, r_or, r_orB,	r_and, r_andB, r_xor, r_xorB
     6 0000265A [E5290000]-         <1>
     6 0000265E [DD290000]-         <1>
     6 00002662 [062A0000]-         <1>
     6 00002666 [FE290000]-         <1>
     6 0000266A [272A0000]-         <1>
     6 0000266E [1F2A0000]          <1>
     7 00002672 [482A0000]-         <1> 	dd	r_aa, r_ab, r_ana, r_anb, r_m, r_mf, r_d, 0
     7 00002676 [402A0000]-         <1>
     7 0000267A [652A0000]-         <1>
     7 0000267E [5D2A0000]-         <1>
     7 00002682 [A12A0000]-         <1>
     7 00002686 [802A0000]-         <1>
     7 0000268A [462B0000]00000000  <1>
     8                              <1> 
     9                              <1> _rextable_6
     9          ******************  <1>  warning: label alone on a line without a colon might be in error [-w+orphan-labels]
    10 00002692 [842B0000]-         <1> 	dd	r_sar, r_sbr, r_dsr, 0, r_sal, r_sbl, r_dsl, 0
    10 00002696 [7C2B0000]-         <1>
    10 0000269A [9F2B0000]00000000- <1>
    10 000026A2 [CA2B0000]-         <1>
    10 000026A6 [C22B0000]-         <1>
    10 000026AA [E52B0000]00000000  <1>
    11 000026B2 [102C0000]-         <1> 	dd	r_rar, r_rbr, r_drr, 0, r_ral, r_rbl, r_drl, 0
    11 000026B6 [082C0000]-         <1>
    11 000026BA [292C0000]00000000- <1>
    11 000026C2 [542C0000]-         <1>
    11 000026C6 [4C2C0000]-         <1>
    11 000026CA [6D2C0000]00000000  <1>
    12 000026D2 [982C0000]-         <1> 	dd	r_saa, r_sba, r_dsa, 0, 0, 0, 0, 0
    12 000026D6 [902C0000]-         <1>
    12 000026DA [B42C0000]00000000- <1>
    12 000026E2 000000000000000000- <1>
    12 000026EB 00000000000000      <1>
    13 000026F2 000000000000000000- <1> 	dd	0, 0, 0, 0, 		0, 0, 0, 0
    13 000026FB 000000000000000000- <1>
    13 00002704 000000000000000000- <1>
    13 0000270D 0000000000          <1>
    14                              <1> 
    15                              <1> _rextable_7
    15          ******************  <1>  warning: label alone on a line without a colon might be in error [-w+orphan-labels]
    16 00002712 000000000000000000- <1> 	dd	0, 0, 0, 0,		0, 0, 0, 0
    16 0000271B 000000000000000000- <1>
    16 00002724 000000000000000000- <1>
    16 0000272D 0000000000          <1>
    17 00002732 [D72C0000]-         <1> 	dd	r_qs, r_ql, r_dte, 0,	r_fa, r_fan, r_fm, r_fd
    17 00002736 [E62C0000]-         <1>
    17 0000273A [F52C0000]00000000- <1>
    17 00002742 [EC280000]-         <1>
    17 00002746 [05290000]-         <1>
    17 0000274A [1E290000]-         <1>
    17 0000274E [3A290000]          <1>
    18 00002752 000000000000000000- <1> 	dd	0, 0, 0, 0, 		0, r_mta, 0, 0
    18 0000275B 000000000000000000- <1>
    18 00002764 0000[0B2D0000]0000- <1>
    18 0000276C 000000000000        <1>
    19 00002772 [292D0000]-         <1> 	dd	r_ds, r_dl, r_da, r_dan, 0, 0, 0, 0
    19 00002776 [382D0000]-         <1>
    19 0000277A [6B2D0000]-         <1>
    19 0000277E [512D0000]00000000- <1>
    19 00002786 000000000000000000- <1>
    19 0000278F 000000              <1>
    20                              <1> 
    21                              <1> 
    22 00002792 F686A204000080      <1> _rex:	test	byte ptr [esi+PSR+2], 128
    23 00002799 0F88D4000000        <1> 	js	near _rex_z				; ISRs can't do this
    24                              <1> 
    25 0000279F E896DEFFFF          <1> 	call	memory_read				; ea -> instruction for repeat	
    26                              <1> 
    27                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]	; retrieve smp core ->
    28 000027A4 0F7EFE              <1> 	movd	esi, mm7
    29                              <1> 
    30 000027A7 898678040000        <1> 	mov	dword ptr [esi+REGISTER+286*4], eax	; save instruction word
    31 000027AD E84BD9FFFF          <1> 	call	__ea					; get initial ea of repeated  instruction
    32 000027B2 0FB6DD              <1> 	movzx	ebx, ch					; spin-off is opcode index in ch
    33                              <1> 							; and operand type in cl
    34 000027B5 80F906              <1> 	cmp	cl, 6
    35 000027B8 7214                <1> 	jb	_rex_itable1
    36 000027BA 7709                <1> 	ja	_rex_itable7
    37                              <1> 							; instruction list 6
    38 000027BC 8B1C9D[92260000]    <1> 	mov	ebx, dword ptr [_rextable_6+ebx*4]	; shifts and jumps
    39 000027C3 EB10                <1> 	jmp	_rex_evaluate
    40                              <1> 
    41                              <1> _rex_itable7:						; instruction list 7
    42 000027C5 8B1C9D[12270000]    <1> 	mov	ebx, dword ptr [_rextable_7+ebx*4]	; large arithmetic
    43 000027CC EB07                <1> 	jmp	_rex_evaluate
    44                              <1> 
    45                              <1> _rex_itable1:						; instruction list 1
    46 000027CE 8B1C9D[12260000]    <1> 	mov	ebx, dword ptr [_rextable_1+ebx*4]	; single integer arithmetic
    47                              <1> 
    48                              <1> _rex_evaluate:
    49 000027D5 21DB                <1> 	and	ebx, ebx				; instruction for repeat execute?
    50 000027D7 0F8496000000        <1> 	jz	near _rex_z				; no
    51 000027DD 899E74040000        <1> 	mov	dword ptr [esi+REGISTER+285*4], ebx	; yes: save execution logic pointer
    52                              <1> 
    53                              <1> 							; if repeat instruction is indexed:
    54                              <1> 							; quick lookup tag for index increment
    55 000027E3 C78670040000000000- <1> 	mov	dword ptr [esi+REGISTER+284*4], 0		; default no index register referenced
    55 000027EC 00                  <1>
    56 000027ED 8B9E78040000        <1> 	mov	ebx, dword ptr [esi+REGISTER+286*4]	; identify any index register tag
    57 000027F3 6621DB              <1> 	and	bx, bx					; in the instruction word
    58 000027F6 791A                <1> 	jns	_rex_ready				; by testing bit 15
    59 000027F8 66C1EB0C            <1> 	shr	bx, 12
    60                              <1> 							; must be > indirection tags *B0+ *B1+
    61 000027FC 80FB0A              <1> 	cmp	bl, 10					; pointers in storage not incremented
    62 000027FF 7211                <1> 	jb	_rex_ready				; index registers may increment
    63 00002801 80FB0E              <1> 	cmp	bl, 14
    64 00002804 7303                <1> 	jnb	_rex_indexed				; [   fp sp ]  registers   [ 14 15 ]
    65 00002806 80E307              <1> 	and	bl, 7					; [ x y a b ]  registers [ 2 3 4 5 ]
    66                              <1> 
    67                              <1> _rex_indexed:
    68 00002809 83E30F              <1> 	and	ebx, 15					; make 32-bit index value
    69 0000280C 899E70040000        <1> 	mov	dword ptr [esi+REGISTER+284*4], ebx	; write quick lookup
    70                              <1> 
    71                              <1> _rex_ready:
    72 00002812 8B5E34              <1> 	mov	ebx, dword ptr [esi+REGISTER+Q]		; default target register [ q ] ->	
    73 00002815 FF9674040000        <1> 	call	dword ptr [esi+REGISTER+285*4]		; execute logic ->
    74                              <1> 
    75 0000281B 8B8670040000        <1> 	mov	eax, dword ptr [esi+REGISTER+284*4]	; index register tag?
    76 00002821 6621C0              <1> 	and	ax, ax
    77 00002824 7417                <1> 	jz	_rex_count				; no
    78                              <1> 
    79 00002826 8B4E5C              <1> 	mov	ecx, dword ptr [esi+REGISTER+WDATA]
    80 00002829 81E1FFFFFF00        <1> 	and	ecx, 00FFFFFFh				; index register increment configured?
    81 0000282F 740C                <1> 	jz	_rex_count				; no
    82                              <1> 
    83 00002831 030C86              <1> 	add	ecx, dword ptr [esi+REGISTER+eax*4]	; calculate index + increment
    84 00002834 81E1FFFFFF00        <1> 	and	ecx, 00FFFFFFh				; 
    85 0000283A 890C86              <1> 	mov	dword ptr [esi+REGISTER+eax*4], ecx	; write back to tagged index register
    86                              <1> 
    87                              <1> _rex_count:
    88 0000283D 8B4650              <1> 	mov	eax, dword ptr [esi+REGISTER+RDATAC]
    89 00002840 48                  <1> 	dec	eax
    90 00002841 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
    91                              <1> 
    92 00002846 894650              <1> 	mov	dword ptr [esi+REGISTER+RDATAC], eax
    93 00002849 A900008000          <1> 	test	eax, 00800000h
    94 0000284E 7523                <1> 	jnz	_rex_z					; reached -1 end
    95                              <1> 
    96 00002850 66F78694040000E0FF  <1> 	test	word ptr [esi+INDICATION], EXTERNAL_INDICATIONS
    97 00002859 7405                <1> 	jz	_rex_along
    98                              <1> 
    99 0000285B 83C2FC              <1> 	add	edx, -4					; restart after
   100 0000285E EB13                <1> 	jmp	_rex_z					; yielding to interrupt
   101                              <1> 
   102                              <1> _rex_along:
   103 00002860 8B8678040000        <1> 	mov	eax, [esi+REGISTER+286*4]			; instruction encoding
   104 00002866 E892D8FFFF          <1> 	call	__ea
   105 0000286B 8B9E74040000        <1> 	mov	ebx, [esi+REGISTER+285*4]			; command pointer
   106 00002871 EB9F                <1> 	jmp	_rex_ready
   107 00002873 C3                  <1> _rex_z:	ret
   108                              <1> 
   109                              <1> _rex_prime_final_count:
   110 00002874 F7455000008000      <1> 	test	dword ptr [ebp+RDATAC], 00800000h
   111 0000287B 7422                <1> 	jz	_rex_primed
   112 0000287D 8B5D58              <1> 	mov	ebx, dword ptr [ebp+WDATAC]
   113 00002880 895D50              <1> 	mov	dword ptr [ebp+RDATAC], ebx
   114 00002883 C3                  <1> 	ret
   115                              <1> 
   116                              <1> _rex_prime:
   117 00002884 F7455000008000      <1> 	test	dword ptr [ebp+RDATAC], 00800000h
   118 0000288B 7412                <1> 	jz	_rex_primed
   119 0000288D 8B5D58              <1> 	mov	ebx, dword ptr [ebp+WDATAC]
   120 00002890 895D50              <1> 	mov	dword ptr [ebp+RDATAC], ebx
   121 00002893 8B5D3C              <1> 	mov	ebx, dword ptr [ebp+S_P]
   122 00002896 81E3FFFFFF00        <1> 	and	ebx, 00FFFFFFh
   123 0000289C 895D34              <1> 	mov	dword ptr [ebp+Q], ebx
   124                              <1> _rex_primed:
   125 0000289F C3                  <1> 	ret
   126                              <1> 
   127                              <1> _rex_accumulate:
   128                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
   129 000028A0 0F7EFE              <1> 	movd	esi, mm7
   130                              <1> 
   131 000028A3 8B5E54              <1> 	mov	ebx, dword ptr [esi+RDATA]
   132 000028A6 035D34              <1> 	add	ebx, dword ptr [ebp+Q]
   133 000028A9 81E3FFFFFF00        <1> 	and	ebx, 00FFFFFFh
   134 000028AF 895D34              <1> 	mov	dword ptr [ebp+Q], ebx
   135 000028B2 C3                  <1> 	ret
   136                              <1> 
   137                              <1> _rex_chex_127:
   138 000028B3 E8CCFFFFFF          <1> 	call	_rex_prime
   139 000028B8 83FB7F              <1> 	cmp	ebx, 127
   140 000028BB 7624                <1> 	jna	_rex_chex_low
   141 000028BD EB28                <1> 	jmp	_rex_chexit
   142                              <1> 
   143                              <1> _rex_chex_126:
   144 000028BF E8C0FFFFFF          <1> 	call	_rex_prime
   145 000028C4 83FB7E              <1> 	cmp	ebx, 126
   146 000028C7 7618                <1> 	jna	_rex_chex_low
   147 000028C9 EB1C                <1> 	jmp	_rex_chexit
   148                              <1> 
   149                              <1> 	%if	SIMD_192
   150                              <1> _rex_chex_120:
   151 000028CB E8B4FFFFFF          <1> 	call	_rex_prime
   152 000028D0 83FB78              <1> 	cmp	ebx, 120
   153 000028D3 760C                <1> 	jna	_rex_chex_low
   154 000028D5 EB10                <1> 	jmp	_rex_chexit
   155                              <1> 	%endif
   156                              <1> 
   157                              <1> _rex_chex_124:
   158 000028D7 E8A8FFFFFF          <1> 	call	_rex_prime
   159 000028DC 83FB7C              <1> 	cmp	ebx, 124
   160 000028DF 7706                <1> 	ja	_rex_chexit
   161                              <1> _rex_chex_low:
   162 000028E1 83FB18              <1> 	cmp	ebx, 24
   163 000028E4 7201                <1> 	jb	_rex_chexit
   164 000028E6 C3                  <1> 	ret
   165                              <1> 
   166                              <1> _rex_chexit:
   167 000028E7 E906E6FFFF          <1> 	jmp	guard_ii_authority
   168                              <1> 
   169                              <1> ;	eax = EA
   170                              <1> ;	q -> target register selected
   171                              <1> 
   172                              <1> r_fa:
   173                              <1> 	%if	SIMD_192
   174 000028EC F686A004000008      <1> 	test	byte ptr [esi+PSR], FP_R
   175 000028F3 0F85A1040000        <1> 	jnz	r_fa_192
   176                              <1> 
   177                              <1> 	%endif
   178                              <1> 
   179 000028F9 E8D9FFFFFF          <1> 	call	_rex_chex_124
   180 000028FE E8D4FAFFFF          <1> 	call	_far
   181 00002903 EB9B                <1> 	jmp	_rex_accumulate
   182                              <1> 
   183                              <1> r_fan:
   184                              <1> 	%if	SIMD_192
   185 00002905 F686A004000008      <1> 	test	byte ptr [esi+PSR], FP_R
   186 0000290C 0F85A4040000        <1> 	jnz	r_fan_192
   187                              <1> 
   188                              <1> 	%endif
   189                              <1> 
   190 00002912 E8C0FFFFFF          <1> 	call	_rex_chex_124
   191 00002917 E8D6FAFFFF          <1> 	call	_fanr
   192 0000291C EB82                <1> 	jmp	_rex_accumulate
   193                              <1> 
   194                              <1> r_fm:
   195                              <1> 	%if	SIMD_192
   196 0000291E F686A004000008      <1> 	test	byte ptr [esi+PSR], FP_R	; 192-bit operation?
   197 00002925 0F85A7040000        <1> 	jnz	r_fm_192			; yes
   198                              <1> 						; no
   199                              <1> 	%endif
   200                              <1> 
   201 0000292B E8A7FFFFFF          <1> 	call	_rex_chex_124
   202 00002930 E8D8FAFFFF          <1> 	call	_fmr
   203 00002935 E966FFFFFF          <1> 	jmp	_rex_accumulate
   204                              <1> 
   205                              <1> r_fd:
   206                              <1> 	%if	SIMD_192
   207 0000293A F686A004000008      <1> 	test	byte ptr [esi+PSR], FP_R	; 192-bit operation?
   208 00002941 0F85A4040000        <1> 	jnz	r_fd_192			; yes
   209                              <1> 						; no
   210                              <1> 	%endif
   211                              <1> 
   212 00002947 E88BFFFFFF          <1> 	call	_rex_chex_124
   213 0000294C E8DDFAFFFF          <1> 	call	_fdr
   214 00002951 E94AFFFFFF          <1> 	jmp	_rex_accumulate
   215                              <1> 
   216 00002956 E819FFFFFF          <1> r_tz:	call	_rex_prime_final_count
   217 0000295B 80F904              <1> 	cmp	cl, 4				; may not be [ i xi ]
   218 0000295E 732C                <1> 	jnb	r_noskip			; but pointers are updated on no_op
   219 00002960 E8ECD9FFFF          <1> 	call	_operand_read
   220 00002965 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   221 0000296A 7520                <1> 	jnz	r_noskip
   222                              <1> 
   223 0000296C E9AE030000          <1> 	jmp	r_skipout		; stop search repeat
   224                              <1> 
   225 00002971 E8FEFEFFFF          <1> r_tp:	call	_rex_prime_final_count
   226 00002976 80F904              <1> 	cmp	cl, 4			; may not be [ i xi ]
   227 00002979 7311                <1> 	jnb	r_noskip		; but pointers are updated on no_op
   228 0000297B E8D1D9FFFF          <1> 	call	_operand_read
   229 00002980 A900008000          <1> 	test	eax, 00800000h
   230 00002985 7505                <1> 	jnz	r_noskip
   231                              <1> 
   232 00002987 E993030000          <1> 	jmp	r_skipout		; stop search repeat
   233                              <1> 
   234 0000298C C3                  <1> r_noskip:	ret
   235                              <1> 
   236 0000298D E82DFFFFFF          <1> r_sb:	call	_rex_chex_126
   237 00002992 43                  <1> 	inc	ebx			; starboard lane
   238 00002993 EB05                <1> 	jmp	r_s
   239 00002995 E819FFFFFF          <1> r_sa:	call	_rex_chex_127
   240 0000299A 80F904              <1> r_s:	cmp	cl, 4			; may not be [ i xi ]
   241 0000299D 7309                <1> 	jnb	r_no_op_s		; but pointers are updated 
   242 0000299F 8B5C9D00            <1> 	mov	ebx, dword ptr [ebp+ebx*4]
   243 000029A3 E83BDBFFFF          <1> 	call	_operand_write
   244                              <1> r_no_op_s:
   245 000029A8 E9F3FEFFFF          <1> 	jmp	_rex_accumulate
   246 000029AD C3                  <1> 	ret
   247                              <1> 
   248 000029AE E8C1FEFFFF          <1> r_z:	call	_rex_prime_final_count
   249 000029B3 80F904              <1> 	cmp	cl, 4			; may not be [ i xi ]
   250 000029B6 7307                <1> 	jnb	r_no_op_z		; but pointers are updated
   251 000029B8 31DB                <1> 	xor	ebx, ebx
   252 000029BA E924DBFFFF          <1> 	jmp	_operand_write
   253                              <1> r_no_op_z:
   254 000029BF C3                  <1> 	ret
   255                              <1> 
   256 000029C0 E8FAFEFFFF          <1> r_lb:	call	_rex_chex_126
   257 000029C5 43                  <1> 	inc	ebx			; starboard lane
   258 000029C6 EB05                <1> 	jmp	r_l
   259 000029C8 E8E6FEFFFF          <1> r_la:	call	_rex_chex_127
   260 000029CD 53                  <1> r_l:	push	ebx
   261 000029CE E87ED9FFFF          <1> 	call	_operand_read
   262 000029D3 5B                  <1> 	pop	ebx
   263 000029D4 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   264 000029D8 E9C3FEFFFF          <1> 	jmp	_rex_accumulate
   265                              <1> 
   266 000029DD E8DDFEFFFF          <1> r_orB:	call	_rex_chex_126
   267 000029E2 43                  <1> 	inc	ebx			; starboard lane
   268 000029E3 EB05                <1> 	jmp	r_OR
   269 000029E5 E8C9FEFFFF          <1> r_or:	call	_rex_chex_127
   270 000029EA 53                  <1> r_OR:	push	ebx
   271 000029EB E861D9FFFF          <1> 	call	_operand_read
   272 000029F0 5B                  <1> 	pop	ebx
   273 000029F1 0B449D00            <1> 	or	eax, dword ptr [ebp+ebx*4]
   274 000029F5 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   275 000029F9 E9A2FEFFFF          <1> 	jmp	_rex_accumulate
   276                              <1> 
   277 000029FE E8BCFEFFFF          <1> r_andB:	call	_rex_chex_126
   278 00002A03 43                  <1> 	inc	ebx		; starboard lane
   279 00002A04 EB05                <1> 	jmp	r_AND
   280 00002A06 E8A8FEFFFF          <1> r_and:	call	_rex_chex_127
   281 00002A0B 53                  <1> r_AND:	push	ebx
   282 00002A0C E840D9FFFF          <1> 	call	_operand_read
   283 00002A11 5B                  <1> 	pop	ebx
   284 00002A12 23449D00            <1> 	and	eax, dword ptr [ebp+ebx*4]
   285 00002A16 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   286 00002A1A E981FEFFFF          <1> 	jmp	_rex_accumulate
   287                              <1> 
   288 00002A1F E89BFEFFFF          <1> r_xorB:	call	_rex_chex_126
   289 00002A24 43                  <1> 	inc	ebx		; starboard lane
   290 00002A25 EB05                <1> 	jmp	r_XOR
   291 00002A27 E887FEFFFF          <1> r_xor:	call	_rex_chex_127
   292 00002A2C 53                  <1> r_XOR:	push	ebx
   293 00002A2D E81FD9FFFF          <1> 	call	_operand_read
   294 00002A32 5B                  <1> 	pop	ebx
   295 00002A33 33449D00            <1> 	xor	eax, dword ptr [ebp+ebx*4]
   296 00002A37 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   297 00002A3B E960FEFFFF          <1> 	jmp	_rex_accumulate
   298                              <1> 
   299 00002A40 E87AFEFFFF          <1> r_ab:	call	_rex_chex_126
   300 00002A45 43                  <1> 	inc	ebx		; starboard lane
   301 00002A46 EB05                <1> 	jmp	r_a
   302 00002A48 E866FEFFFF          <1> r_aa:	call	_rex_chex_127
   303 00002A4D 53                  <1> r_a:	push	ebx
   304 00002A4E E8FED8FFFF          <1> 	call	_operand_read
   305 00002A53 5F                  <1> 	pop	edi
   306 00002A54 0344BD00            <1> 	add	eax, dword ptr [ebp+edi*4]
   307 00002A58 E92F030000          <1> 	jmp	r_store_carry
   308                              <1> 
   309 00002A5D E85DFEFFFF          <1> r_anb:	call	_rex_chex_126
   310 00002A62 43                  <1> 	inc	ebx		; starboard lane
   311 00002A63 EB05                <1> 	jmp	r_an
   312 00002A65 E849FEFFFF          <1> r_ana:	call	_rex_chex_127
   313 00002A6A 53                  <1> r_an:	push	ebx
   314 00002A6B E8E1D8FFFF          <1> 	call	_operand_read
   315 00002A70 5F                  <1> 	pop	edi
   316 00002A71 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   317 00002A76 40                  <1> 	inc	eax
   318 00002A77 0344BD00            <1> 	add	eax, dword ptr [ebp+edi*4]
   319 00002A7B E90C030000          <1> 	jmp	r_store_carry
   320                              <1> 
   321 00002A80 E82EFEFFFF          <1> r_mf:	call    _rex_chex_127
   322 00002A85 52                  <1> 	push	edx
   323 00002A86 53                  <1> 	push	ebx
   324 00002A87 E8C5D8FFFF          <1> 	call	_operand_read
   325 00002A8C 5F                  <1> 	pop	edi
   326 00002A8D 0FAF44BD00          <1> 	imul	eax, dword ptr [ebp+edi*4]
   327 00002A92 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   328 00002A97 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
   329 00002A9B 5A                  <1> 	pop	edx
   330 00002A9C E9FFFDFFFF          <1> 	jmp	_rex_accumulate
   331                              <1> 
   332                              <1> ; use the platform unsigned multiply
   333                              <1> ; work in positive magnitude
   334                              <1> ; adjust the final sign after offset-adding products
   335                              <1> 
   336 00002AA1 E819FEFFFF          <1> r_m:	call	_rex_chex_126
   337 00002AA6 52                  <1> 	push	edx
   338 00002AA7 53                  <1> 	push	ebx			; register stack cursor
   339 00002AA8 E8A4D8FFFF          <1> 	call	_operand_read
   340 00002AAD 5F                  <1> 	pop	edi			; recover register stack cursor
   341                              <1> 
   342 00002AAE 31C9                <1> 	xor	ecx, ecx		; final sign
   343 00002AB0 A900008000          <1> 	test	eax, 00800000h		;
   344 00002AB5 740D                <1> 	jz	r_msigu?		; negative multiplier?
   345 00002AB7 F7D1                <1> 	not	ecx			; final sign reverse
   346 00002AB9 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   347 00002ABE 40                  <1> 	inc	eax			; 2s complement
   348 00002ABF 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   349                              <1> 
   350                              <1> r_msigu?:
   351 00002AC4 89C3                <1> 	mov	ebx, eax		; multiplier 2b used twice
   352 00002AC6 8B44BD00            <1> 	mov	eax, dword ptr [ebp+edi*4]
   353 00002ACA A900008000          <1> 	test	eax, 00800000h		; multiply high order part 1st
   354 00002ACF 7426                <1> 	jz	r_mgoferit_yall
   355                              <1> 
   356 00002AD1 F7D1                <1> 	not	ecx			; final sign reverse
   357 00002AD3 8B54BD04            <1> 	mov	edx, dword ptr [ebp+edi*4+4]
   358 00002AD7 81F2FFFFFF00        <1> 	xor	edx, 00FFFFFFh
   359 00002ADD 42                  <1> 	inc	edx			; 2s complement
   360 00002ADE C1C208              <1> 	rol	edx, 8
   361 00002AE1 0FB6F2              <1> 	movzx	esi, dl
   362 00002AE4 C1EA08              <1> 	shr	edx, 8
   363 00002AE7 8954BD04            <1> 	mov	dword ptr [ebp+edi*4+4], edx
   364 00002AEB 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh		; ms register long multiplicand
   365 00002AF0 01F0                <1> 	add	eax, esi
   366 00002AF2 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   367                              <1> 
   368                              <1> r_mgoferit_yall:
   369 00002AF7 F7E3                <1> 	mul	ebx			; multiply high order part
   370 00002AF9 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax	; save lower half of product
   371 00002AFD 8B44BD04            <1> 	mov	eax, dword ptr [ebp+edi*4+4]	; multiply low order part
   372 00002B01 F7E3                <1> 	mul	ebx
   373 00002B03 C1E208              <1> 	shl	edx, 8			; 8 bits of eax must shift up to edx
   374 00002B06 C1C008              <1> 	rol	eax, 8
   375 00002B09 88C2                <1> 	mov	dl, al
   376 00002B0B C1E808              <1> 	shr	eax, 8			; leaving 8 zeros in eax high end
   377 00002B0E 0354BD00            <1> 	add	edx, dword ptr [ebp+edi*4]	; add2 lower half of 1st product
   378 00002B12 21C9                <1> 	and	ecx, ecx		; final sign?
   379 00002B14 7917                <1> 	jns	r_m_writeback
   380                              <1> 
   381 00002B16 81F2FFFFFF00        <1> 	xor	edx, 00FFFFFFh
   382 00002B1C 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   383 00002B21 40                  <1> 	inc	eax			; 2s complement
   384 00002B22 C1C008              <1> 	rol	eax, 8			; carried out single bit?
   385 00002B25 0FB6F0              <1> 	movzx	esi, al			; must add to edx
   386 00002B28 C1E808              <1> 	shr	eax, 8
   387 00002B2B 01F2                <1> 	add	edx, esi
   388                              <1> 
   389                              <1> r_m_writeback:
   390 00002B2D 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   391 00002B32 81E2FFFFFF00        <1> 	and	edx, 00FFFFFFh
   392 00002B38 8944BD04            <1> 	mov	dword ptr [ebp+edi*4+4], eax	
   393 00002B3C 8954BD00            <1> 	mov	dword ptr [ebp+edi*4], edx
   394 00002B40 5A                  <1> 	pop	edx
   395 00002B41 E95AFDFFFF          <1> 	jmp	_rex_accumulate
   396                              <1> 
   397 00002B46 E874FDFFFF          <1> r_d:	call	_rex_chex_126
   398 00002B4B 89DF                <1> 	mov	edi, ebx		; register cursor
   399 00002B4D E862ECFFFF          <1> 	call	_divide
   400 00002B52 895CBD04            <1> 	mov	dword ptr [ebp+edi*4+4], ebx
   401 00002B56 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
   402                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
   403 00002B5A 0F7EFE              <1> 	movd	esi, mm7
   404                              <1> 
   405 00002B5D F686A004000008      <1> 	test	byte ptr [esi+PSR], FP_R
   406 00002B64 0F8436FDFFFF        <1> 	jz	_rex_accumulate
   407 00002B6A 83FF7D              <1> 	cmp	edi, 125
   408 00002B6D 0F872DFDFFFF        <1> 	ja	_rex_accumulate
   409 00002B73 894CBD08            <1> 	mov	dword ptr [ebp+edi*4+8], ecx
   410 00002B77 E924FDFFFF          <1> r_dnor:	jmp	_rex_accumulate
   411                              <1> 
   412 00002B7C E83EFDFFFF          <1> r_sbr:	call	_rex_chex_126
   413 00002B81 43                  <1> 	inc	ebx		; starboard lane
   414 00002B82 EB05                <1> 	jmp	r_lsr
   415 00002B84 E82AFDFFFF          <1> r_sar:	call	_rex_chex_127
   416 00002B89 88C1                <1> r_lsr	mov	cl, al
   417 00002B8B 8B449D00            <1> 	mov	eax, dword ptr [ebp+ebx*4]
   418 00002B8F D3E8                <1> 	shr	eax, cl
   419 00002B91 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   420 00002B96 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   421 00002B9A E901FDFFFF          <1> 	jmp	_rex_accumulate
   422                              <1> 
   423 00002B9F E81BFDFFFF          <1> r_dsr:	call	_rex_chex_126
   424 00002BA4 88C1                <1> 	mov	cl, al
   425 00002BA6 89DF                <1> 	mov	edi, ebx
   426 00002BA8 8B44BD00            <1> 	mov	eax, dword ptr [ebp+edi*4]
   427 00002BAC 8B5CBD04            <1> 	mov	ebx, dword ptr [ebp+edi*4+4]
   428 00002BB0 E840EDFFFF          <1> 	call	dsr
   429 00002BB5 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
   430 00002BB9 895CBD04            <1> 	mov	dword ptr [ebp+edi*4+4], ebx
   431 00002BBD E9DEFCFFFF          <1> 	jmp	_rex_accumulate
   432                              <1> 
   433 00002BC2 E8F8FCFFFF          <1> r_sbl:	call	_rex_chex_126
   434 00002BC7 43                  <1> 	inc	ebx		; starboard lane
   435 00002BC8 EB05                <1> 	jmp	r_lsl
   436 00002BCA E8E4FCFFFF          <1> r_sal:	call	_rex_chex_127
   437 00002BCF 88C1                <1> r_lsl:	mov	cl, al
   438 00002BD1 8B449D00            <1> 	mov	eax, dword ptr [ebp+ebx*4]
   439 00002BD5 D3E0                <1> 	shl	eax, cl
   440 00002BD7 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   441 00002BDC 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   442 00002BE0 E9BBFCFFFF          <1> 	jmp	_rex_accumulate
   443                              <1> 
   444 00002BE5 E8D5FCFFFF          <1> r_dsl:	call	_rex_chex_126
   445 00002BEA 88C1                <1> 	mov	cl, al
   446 00002BEC 89DF                <1> 	mov	edi, ebx
   447 00002BEE 8B44BD00            <1> 	mov	eax, dword ptr [ebp+edi*4]
   448 00002BF2 8B5CBD04            <1> 	mov	ebx, dword ptr [ebp+edi*4+4]
   449 00002BF6 E82FEDFFFF          <1> 	call	dsl
   450 00002BFB 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
   451 00002BFF 895CBD04            <1> 	mov	dword ptr [ebp+edi*4+4], ebx
   452 00002C03 E998FCFFFF          <1> 	jmp	_rex_accumulate
   453                              <1> 
   454 00002C08 E8B2FCFFFF          <1> r_rbr:	call	_rex_chex_126
   455 00002C0D 43                  <1> 	inc	ebx		; starboard lane
   456 00002C0E EB05                <1> 	jmp	r_rr
   457 00002C10 E89EFCFFFF          <1> r_rar:	call	_rex_chex_127
   458 00002C15 89DF                <1> r_rr:	mov	edi, ebx
   459 00002C17 8B5CBD00            <1> 	mov	ebx, dword ptr [ebp+edi*4]
   460 00002C1B E877EDFFFF          <1> 	call	rr
   461 00002C20 895CBD00            <1> 	mov	dword ptr [ebp+edi*4], ebx
   462 00002C24 E977FCFFFF          <1> 	jmp	_rex_accumulate
   463                              <1> 
   464 00002C29 E891FCFFFF          <1> r_drr:	call	_rex_chex_126
   465 00002C2E 88C1                <1> 	mov	cl, al
   466 00002C30 89DF                <1> 	mov	edi, ebx
   467 00002C32 8B44BD00            <1> 	mov	eax, dword ptr [ebp+edi*4]
   468 00002C36 8B5CBD04            <1> 	mov	ebx, dword ptr [ebp+edi*4+4]
   469 00002C3A E8A6EDFFFF          <1> 	call	drr
   470 00002C3F 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
   471 00002C43 895CBD04            <1> 	mov	dword ptr [ebp+edi*4+4], ebx
   472 00002C47 E954FCFFFF          <1> 	jmp	_rex_accumulate
   473                              <1> 
   474 00002C4C E86EFCFFFF          <1> r_rbl:	call	_rex_chex_126
   475 00002C51 43                  <1> 	inc	ebx		; starboard lane
   476 00002C52 EB05                <1> 	jmp	r_rl
   477 00002C54 E85AFCFFFF          <1> r_ral:	call	_rex_chex_127
   478 00002C59 89DF                <1> r_rl:	mov	edi, ebx
   479 00002C5B 8B5CBD00            <1> 	mov	ebx, dword ptr [ebp+edi*4]
   480 00002C5F E859EDFFFF          <1> 	call	rl
   481 00002C64 895CBD00            <1> 	mov	dword ptr [ebp+edi*4], ebx
   482 00002C68 E933FCFFFF          <1> 	jmp	_rex_accumulate
   483                              <1> 
   484 00002C6D E84DFCFFFF          <1> r_drl:	call	_rex_chex_126
   485 00002C72 88C1                <1> 	mov	cl, al
   486 00002C74 89DF                <1> 	mov	edi, ebx
   487 00002C76 8B44BD00            <1> 	mov	eax, dword ptr [ebp+edi*4]
   488 00002C7A 8B5CBD04            <1> 	mov	ebx, dword ptr [ebp+edi*4+4]
   489 00002C7E E8B8EDFFFF          <1> 	call	drl
   490 00002C83 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
   491 00002C87 895CBD04            <1> 	mov	dword ptr [ebp+edi*4+4], ebx
   492 00002C8B E910FCFFFF          <1> 	jmp	_rex_accumulate
   493                              <1> 
   494 00002C90 E82AFCFFFF          <1> r_sba:	call	_rex_chex_126
   495 00002C95 43                  <1> 	inc	ebx		; starboard lane
   496 00002C96 EB05                <1> 	jmp	r_asr
   497 00002C98 E816FCFFFF          <1> r_saa:	call	_rex_chex_127
   498 00002C9D 88C1                <1> r_asr:	mov	cl, al
   499 00002C9F 8B449D00            <1> 	mov	eax, dword ptr [ebp+ebx*4]
   500 00002CA3 C1E008              <1> 	shl	eax, 8
   501 00002CA6 D3F8                <1> 	sar	eax, cl
   502 00002CA8 C1E808              <1> 	shr	eax, 8
   503 00002CAB 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   504 00002CAF E9ECFBFFFF          <1> 	jmp	_rex_accumulate
   505                              <1> 
   506 00002CB4 E806FCFFFF          <1> r_dsa:	call	_rex_chex_126
   507 00002CB9 88C1                <1> 	mov	cl, al
   508 00002CBB 89DF                <1> 	mov	edi, ebx
   509 00002CBD 8B44BD00            <1> 	mov	eax, dword ptr [ebp+edi*4]
   510 00002CC1 8B5CBD04            <1> 	mov	ebx, dword ptr [ebp+edi*4+4]
   511 00002CC5 E897ECFFFF          <1> 	call	dsa
   512 00002CCA 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
   513 00002CCE 895CBD04            <1> 	mov	dword ptr [ebp+edi*4+4], ebx
   514 00002CD2 E9C9FBFFFF          <1> 	jmp	_rex_accumulate
   515                              <1> 
   516 00002CD7 E8FBFBFFFF          <1> r_qs:	call	_rex_chex_124
   517 00002CDC E88CD7FFFF          <1> 	call	_burst_write4	; eax -> ea / ebx -> register cursor
   518 00002CE1 E9BAFBFFFF          <1> 	jmp	_rex_accumulate
   519                              <1> 
   520 00002CE6 E8ECFBFFFF          <1> r_ql:	call	_rex_chex_124
   521 00002CEB E834D6FFFF          <1> 	call	_burst_read4	; eax -> ea / ebx -> register cursor
   522 00002CF0 E9ABFBFFFF          <1> 	jmp	_rex_accumulate
   523                              <1> 
   524 00002CF5 E87AFBFFFF          <1> r_dte:	call	_rex_prime_final_count
   525 00002CFA E810D6FFFF          <1> 	call	_burst_read2
   526 00002CFF 334510              <1> 	xor	eax, dword ptr [ebp+A]
   527 00002D02 7524                <1> 	jnz	r_mtax
   528 00002D04 335D14              <1> 	xor	ebx, dword ptr [ebp+B]
   529 00002D07 751F                <1> 	jnz	r_mtax
   530 00002D09 EB14                <1> 	jmp	r_skipout		; stop search repeat
   531                              <1> 
   532 00002D0B E864FBFFFF          <1> r_mta:	call	_rex_prime_final_count
   533 00002D10 B100                <1> 	mov	cl, 0		; operand size 1 word
   534 00002D12 E83AD6FFFF          <1> 	call	_operand_read
   535 00002D17 334510              <1> 	xor	eax, dword ptr [ebp+A]
   536 00002D1A 234504              <1> 	and	eax, dword ptr [ebp+K]
   537 00002D1D 7509                <1> 	jnz	r_mtax
   538                              <1> 
   539                              <1> r_skipout:				; stop search repeat
   540 00002D1F 83C204              <1> 	add	edx, 4
   541 00002D22 8BA57C040000        <1> 	mov	esp, dword ptr [ebp+287*4]
   542 00002D28 C3                  <1> r_mtax:	ret
   543                              <1> 
   544 00002D29 E891FBFFFF          <1> r_ds:	call	_rex_chex_126
   545 00002D2E E87FD7FFFF          <1> 	call	_burst_write2	; eax -> ea / ebx -> register cursor
   546 00002D33 E968FBFFFF          <1> 	jmp	_rex_accumulate
   547                              <1> 
   548 00002D38 E882FBFFFF          <1> r_dl:	call	 _rex_chex_126
   549 00002D3D 53                  <1> 	push	ebx
   550 00002D3E E8CCD5FFFF          <1> 	call	_burst_read2
   551 00002D43 5F                  <1> 	pop	edi
   552 00002D44 895CBD04            <1> 	mov	dword ptr [ebp+edi*4+4], ebx
   553 00002D48 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
   554 00002D4C E94FFBFFFF          <1> 	jmp	_rex_accumulate
   555                              <1> 
   556 00002D51 E869FBFFFF          <1> r_dan:	call	 _rex_chex_126
   557 00002D56 53                  <1> 	push	ebx
   558 00002D57 E8B3D5FFFF          <1> 	call	_burst_read2
   559 00002D5C 5F                  <1> 	pop	edi
   560 00002D5D 81F3FFFFFF00        <1> 	xor	ebx, 00FFFFFFh
   561 00002D63 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   562 00002D68 43                  <1> 	inc	ebx
   563 00002D69 EB0C                <1> 	jmp	r_danad
   564                              <1> 
   565 00002D6B E84FFBFFFF          <1> r_da:	call	 _rex_chex_126
   566 00002D70 53                  <1> 	push	ebx
   567 00002D71 E899D5FFFF          <1> 	call	_burst_read2
   568 00002D76 5F                  <1> 	pop	edi
   569                              <1> 
   570                              <1> r_danad:
   571 00002D77 035CBD04            <1> 	add	ebx, dword ptr [ebp+edi*4+4]
   572 00002D7B C1E308              <1> 	shl	ebx, 8
   573 00002D7E 83D000              <1> 	adc	eax, 0
   574 00002D81 C1EB08              <1> 	shr	ebx, 8
   575 00002D84 895CBD04            <1> 	mov	dword ptr [ebp+edi*4+4], ebx
   576 00002D88 0344BD00            <1> 	add	eax, dword ptr [ebp+edi*4]
   577                              <1> 
   578                              <1> r_store_carry:
   579 00002D8C E818EEFFFF          <1> 	call	_alu_carry
   580 00002D91 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
   581 00002D95 E906FBFFFF          <1> 	jmp	_rex_accumulate
   582                              <1> 
    46                                  	%include	"144.msm"
     1                              <1> 	%if	SIMD_192
     2                              <1> 
     3                              <1> r_fa_192:
     4 00002D9A E865000000          <1> 	call	fp_192_concentrate
     5 00002D9F E8D5F6FFFF          <1> 	call	BIAS_POINTERS			; needs 1 octet of 8th platform word 
     6 00002DA4 E81DF2FFFF          <1> 	call	fa
     7 00002DA9 0F7EFE              <1> 	movd	esi, mm7
     8 00002DAC E8AA000000          <1> 	call	fp_192_store_left_right
     9 00002DB1 E9EAFAFFFF          <1> 	jmp	_rex_accumulate
    10                              <1> 
    11                              <1> r_fan_192:
    12 00002DB6 E849000000          <1> 	call	fp_192_concentrate
    13 00002DBB E8B9F6FFFF          <1> 	call	BIAS_POINTERS			; needs 1 octet of 8th platform word
    14 00002DC0 E8F0F1FFFF          <1> 	call	fan
    15 00002DC5 0F7EFE              <1> 	movd	esi, mm7
    16 00002DC8 E88E000000          <1> 	call	fp_192_store_left_right
    17 00002DCD E9CEFAFFFF          <1> 	jmp	_rex_accumulate
    18                              <1> 
    19                              <1> r_fm_192:
    20 00002DD2 E82D000000          <1> 	call	fp_192_concentrate
    21 00002DD7 E8B7F6FFFF          <1> 	call	fp_registers_m
    22 00002DDC E814010000          <1> 	call	_144_fm
    23 00002DE1 E86C000000          <1> 	call	fp_192_store
    24 00002DE6 E9B5FAFFFF          <1> 	jmp	_rex_accumulate
    25                              <1> 
    26                              <1> r_fd_192:
    27 00002DEB E814000000          <1> 	call	fp_192_concentrate
    28 00002DF0 E89EF6FFFF          <1> 	call	fp_registers_m
    29 00002DF5 E803F4FFFF          <1> 	call	fd
    30 00002DFA E853000000          <1> 	call	fp_192_store
    31 00002DFF E99CFAFFFF          <1> 	jmp	_rex_accumulate
    32                              <1> 
    33                              <1> fp_192_concentrate:
    34 00002E04 50                  <1> 	push	eax
    35 00002E05 E8C1FAFFFF          <1> 	call	_rex_chex_120
    36 00002E0A 8B0424              <1> 	mov	eax, dword ptr [esp]
    37 00002E0D E838F6FFFF          <1> 	call	fp_operands
    38 00002E12 0F7EFE              <1> 	movd	esi, mm7
    39 00002E15 8D7D20              <1> 	lea	edi, [ebp+8*4]
    40 00002E18 8B5D34              <1> 	mov	ebx, dword ptr [ebp+Q]
    41 00002E1B 83C304              <1> 	add	ebx, 4				; starboard sum
    42 00002E1E E88AF6FFFF          <1> 	call	_load_quad
    43 00002E23 8DBE20040000        <1> 	lea	edi, [esi+_INPUTR]
    44                              <1> 
    45 00002E29 E84B000000          <1> 	call	pack_144
    46                              <1> ; call ultrate
    47 00002E2E BB08000000          <1> 	mov	ebx, 8
    48 00002E33 58                  <1> 	pop	eax				; ea
    49 00002E34 83C004              <1> 	add	eax, 4				; +
    50 00002E37 E8E8D4FFFF          <1> 	call	_burst_read4
    51 00002E3C 0F7EFE              <1> 	movd	esi, mm7
    52 00002E3F 8DBE00040000        <1> 	lea	edi, [esi+_INPUT2]
    53 00002E45 E82F000000          <1> 	call	pack_144
    54                              <1> 
    55 00002E4A 808EA004000008      <1> 	or	byte ptr [esi+PSR], FP_R
    56                              <1> ;	call	fp_registers_m			; moved to operations r_fa...
    57 00002E51 C3                  <1> 	ret
    58                              <1> 	
    59                              <1> fp_192_store:
    60 00002E52 0F7EFE              <1> 	movd	esi, mm7
    61 00002E55 8DBE40040000        <1> 	lea	edi, [esi+_OUTPUT]
    62                              <1> fp_192_store_left_right:			; fa / fan decide out-string ->
    63 00002E5B 8B5D34              <1> 	mov	ebx, dword ptr [ebp+Q]
    64 00002E5E E874EEFFFF          <1> 	call	_deliver_
    65                              <1> 
    66 00002E63 8B5D34              <1> 	mov	ebx, dword ptr [ebp+Q]
    67 00002E66 0F6F7520            <1> 	movq	mm6, qword ptr [ebp+8*4]
    68 00002E6A 0F7F749D10          <1> 	movq	qword ptr [ebp+ebx*4+4*4], mm6
    69 00002E6F 0F6F7528            <1> 	movq	mm6, qword ptr [ebp+10*4]
    70 00002E73 0F7F749D18          <1> 	movq	qword ptr [ebp+ebx*4+6*4], mm6
    71 00002E78 C3                  <1> 	ret
    72                              <1> 
    73                              <1> pack_144:
    74 00002E79 52                  <1> 	push	edx
    75 00002E7A 51                  <1> 	push	ecx
    76 00002E7B 53                  <1> 	push	ebx
    77 00002E7C 50                  <1> 	push	eax
    78                              <1> 
    79 00002E7D 8B4520              <1> 	mov	eax, [ebp+8*4]
    80 00002E80 334524              <1> 	xor	eax, [ebp+9*4]
    81 00002E83 A900008000          <1> 	test	eax, 00800000h			; is 2nd sum normalised?
    82 00002E88 7466                <1> 	jz	end_pack_144			; no? words 4..7 are alraady signs
    83                              <1> 
    84 00002E8A 8B552C              <1> 	mov	edx, dword ptr [ebp+11*4]	; read starboard end 2nd value
    85 00002E8D C1C210              <1> 	rol	edx, 16				; move 8 bits up
    86 00002E90 8B5D28              <1> 	mov	ebx, dword ptr [ebp+10*4]	; to higher order word
    87 00002E93 C1E308              <1> 	shl	ebx, 8
    88 00002E96 88D3                <1> 	mov	bl, dl
    89 00002E98 8B4704              <1> 	mov	eax, dword ptr [edi+1*4]	; do partial longs register:register
    90                              <1> 						; to avoid contemplating endianism
    91 00002E9B 6689C2              <1> 	mov	dx, ax				; add 16 signs to low-order word
    92                              <1> 
    93 00002E9E 8B4524              <1> 	mov	eax, dword ptr [ebp+9*4]	; starboard mantissa high-order word
    94                              <1> 
    95 00002EA1 8B4D20              <1> 	mov	ecx, dword ptr [ebp+8*4]	; starboard exponent in register 8
    96                              <1> 						; loaded exponent is positive magnitude
    97 00002EA4 81E1FFFFFF00        <1> 	and	ecx, 00FFFFFFh			; should be impossible to need that...
    98 00002EAA F7C100008000        <1> 	test	ecx, 00800000h			; this one may be 1s-complement
    99 00002EB0 7406                <1> 	jz	exponent_magnitude_difference
   100 00002EB2 81F1FFFFFF00        <1> 	xor	ecx, 00FFFFFFh			; 1s-complement RTA1 data word
   101                              <1> 						; still won't compute
   102                              <1> exponent_magnitude_difference:			; if component numbers are out of order
   103 00002EB8 F7D9                <1> 	neg	ecx				; 2s-complement platform integer
   104 00002EBA 030F                <1> 	add	ecx, dword ptr [edi]		; subtract it from
   105                              <1> 						; the exponent you first thought of
   106 00002EBC 83C1B8              <1> 	add	ecx, -72
   107 00002EBF 7418                <1> 	jz	_144_normalised			; net normalising count zero
   108 00002EC1 782D                <1> 	js	end_pack_144			; bad one, values in wrong order
   109                              <1> 						; just leave signs in bits 71..0
   110 00002EC3 83F947              <1> 	cmp	ecx, 71				; no use replacing 72+ signs
   111 00002EC6 7728                <1> 	ja	end_pack_144			; with signs
   112                              <1> 						; especially not millions of them
   113 00002EC8 C1E008              <1> 	shl	eax, 8
   114 00002ECB 88D0                <1> 	mov	al, dl				; 8 sign bits
   115 00002ECD C1C808              <1> 	ror	eax, 8
   116                              <1> 
   117                              <1> insert_sign:
   118 00002ED0 D1F8                <1> 	sar	eax, 1				; normalising shift field <- signs
   119 00002ED2 D1DB                <1> 	rcr	ebx, 1
   120 00002ED4 D1DA                <1> 	rcr	edx, 1
   121                              <1> 
   122 00002ED6 49                  <1> 	dec	ecx
   123 00002ED7 75F7                <1> 	jnz	insert_sign
   124                              <1> 
   125                              <1> _144_normalised:
   126 00002ED9 895718              <1> 	mov	dword ptr [edi+6*4], edx	; mantissa 15..0 : 16 signs
   127 00002EDC 895F14              <1> 	mov	dword ptr [edi+5*4], ebx	; mantissa 47..16
   128 00002EDF 8B5F10              <1> 	mov	ebx, dword ptr [edi+4*4]	; mantissa bits 79..72 : unknown
   129 00002EE2 C1E008              <1> 	shl	eax, 8				; mantissa bits 71..48
   130 00002EE5 C1C308              <1> 	rol	ebx, 8
   131 00002EE8 88D8                <1> 	mov	al, bl				; mantissa bits 79..72
   132 00002EEA C1C808              <1> 	ror	eax, 8				; mantissa bits 79..48
   133 00002EED 894710              <1> 	mov	dword ptr [edi+4*4], eax
   134                              <1> 
   135                              <1> end_pack_144:
   136 00002EF0 58                  <1> 	pop	eax
   137 00002EF1 5B                  <1> 	pop	ebx
   138 00002EF2 59                  <1> 	pop	ecx
   139 00002EF3 5A                  <1> 	pop	edx
   140 00002EF4 C3                  <1> 	ret
   141                              <1> 
   142                              <1> 	%endif
    47                                  	%include	"_144_fm.msm"
     1                              <1> ;	this is like fm: routine in fpu.msm
     2                              <1> ;	except it has uconditionally different radix and repeat count
     3                              <1> ;	and so exists separately to avoid condition jumps
     4                              <1> ;	and to avoid messing with the original for new parameters
     5                              <1> 
     6                              <1> _144_fm:
     7 00002EF5 8DBE40040000        <1> 	lea	edi, [esi+_OUTPUT]			; initialise final accumulation
     8 00002EFB E8B0EEFFFF          <1> 	call	zoutput
     9                              <1> 
    10 00002F00 8B9E24040000        <1> 	mov	ebx, dword ptr [esi+_INPUTR+1*4]	; read register-side signs
    11 00002F06 8B8628040000        <1> 	mov	eax, dword ptr [esi+_INPUTR+2*4]	; and high-end mantissa
    12 00002F0C 31D8                <1> 	xor	eax, ebx	 			; cache if-normalised in eax
    13 00002F0E 339E04040000        <1> 	xor	ebx, dword ptr [esi+_INPUT2+1*4]	; multiply signs
    14 00002F14 899E44040000        <1> 	mov	dword ptr [esi+_OUTPUT+1*4], ebx	; save the output sign
    15 00002F1A 21C0                <1> 	and	eax, eax				; test the cached if-normalised
    16 00002F1C 790E                <1> 	jns	_144_fmdont
    17                              <1> 
    18 00002F1E 8B8604040000        <1> 	mov	eax, dword ptr [esi+_INPUT2+1*4]	; is the multiplier normalised?
    19 00002F24 338608040000        <1> 	xor	eax, dword ptr [esi+_INPUT2+2*4]	; sign XOR normalising bit?
    20 00002F2A 782F                <1> 	js	_144_fmgo				; yes, proceed
    21                              <1> 
    22                              <1> _144_fmdont:
    23 00002F2C 899E48040000        <1> 	mov	dword ptr [esi+_OUTPUT+2*4], ebx
    24 00002F32 899E4C040000        <1> 	mov	dword ptr [esi+_OUTPUT+3*4], ebx
    25 00002F38 899E50040000        <1> 	mov	dword ptr [esi+_OUTPUT+4*4], ebx
    26 00002F3E 899E54040000        <1> 	mov	dword ptr [esi+_OUTPUT+5*4], ebx
    27 00002F44 899E58040000        <1> 	mov	dword ptr [esi+_OUTPUT+6*4], ebx
    28 00002F4A 899E5C040000        <1> 	mov	dword ptr [esi+_OUTPUT+7*4], ebx
    29 00002F50 C78640040000000000- <1> 	mov	dword ptr [esi+_OUTPUT], 0		; mantissa to go
    29 00002F59 00                  <1>
    30                              <1> 
    31 00002F5A C3                  <1> 	ret					; no, effective zero multiplier
    32                              <1> 
    33                              <1> _144_fmgo:
    34 00002F5B 51                  <1> 	push	ecx
    35 00002F5C 8B8624040000        <1> 	mov	eax, dword ptr [esi+_INPUTR+1*4]
    36                              <1> 
    37 00002F62 B190                <1> 	mov	cl, 144				; beats count exactly mantissa size
    38                              <1> 
    39 00002F64 21C0                <1> 	and	eax, eax
    40                              <1> 
    41 00002F66 790B                <1> 	jns	_144_fmp1
    42 00002F68 8DBE20040000        <1> 	lea	edi, [esi+_INPUTR]
    43 00002F6E E8E5EFFFFF          <1> 	call	zover
    44                              <1> 
    45                              <1> _144_fmp1:
    46 00002F73 8B8604040000        <1> 	mov	eax, dword ptr [esi+_INPUT2+1*4]
    47 00002F79 21C0                <1> 	and	eax, eax
    48 00002F7B 790B                <1> 	jns	_144_fmadd
    49 00002F7D 8DBE00040000        <1> 	lea	edi, [esi+_INPUT2]
    50 00002F83 E8D0EFFFFF          <1> 	call	zover
    51                              <1> 
    52                              <1> _144_fmadd:
    53 00002F88 F8                  <1> 	clc
    54                              <1> 
    55 00002F89 8DBE20040000        <1> 	lea	edi, [esi+_INPUTR]
    56 00002F8F D15F08              <1> 	rcr	dword ptr [edi+2*4], 1		; addend shift right
    57 00002F92 D15F0C              <1> 	rcr	dword ptr [edi+3*4], 1
    58 00002F95 D15F10              <1> 	rcr	dword ptr [edi+4*4], 1
    59 00002F98 D15F14              <1> 	rcr	dword ptr [edi+5*4], 1
    60 00002F9B D15F18              <1> 	rcr	dword ptr [edi+6*4], 1
    61 00002F9E D15F1C              <1> 	rcr	dword ptr [edi+7*4], 1
    62                              <1> 
    63 00002FA1 8DBE00040000        <1> 	lea	edi, [esi+_INPUT2]
    64                              <1> 
    65                              <1> 	%if	1
    66 00002FA7 D1571C              <1> 	rcl	dword ptr [edi+7*4], 1		; multiplier shift left
    67 00002FAA D15718              <1> 	rcl	dword ptr [edi+6*4], 1
    68 00002FAD D15714              <1> 	rcl	dword ptr [edi+5*4], 1		; multiplier mantissa is only 72 bits
    69                              <1> 	%endif
    70                              <1> 
    71 00002FB0 D15710              <1> 	rcl	dword ptr [edi+4*4], 1
    72 00002FB3 D1570C              <1> 	rcl	dword ptr [edi+3*4], 1
    73 00002FB6 D15708              <1> 	rcl	dword ptr [edi+2*4], 1
    74                              <1> 
    75 00002FB9 8DBE40040000        <1> 	lea	edi, [esi+_OUTPUT]
    76 00002FBF 7336                <1> 	jnc	_144_fmadx
    77                              <1> 						; 1 shifted from multiplier
    78                              <1> _144_fmadc:
    79 00002FC1 8B863C040000        <1> 	mov	eax, dword ptr [esi+_INPUTR+7*4]	
    80 00002FC7 01471C              <1> 	add	dword ptr [edi+7*4], eax	; do not use carry
    81 00002FCA 8B8638040000        <1> 	mov	eax, dword ptr [esi+_INPUTR+6*4]
    82 00002FD0 114718              <1> 	adc	dword ptr [edi+6*4], eax	; start using carry
    83 00002FD3 8B8634040000        <1> 	mov	eax, dword ptr [esi+_INPUTR+5*4]
    84 00002FD9 114714              <1> 	adc	dword ptr [edi+5*4], eax
    85 00002FDC 8B8630040000        <1> 	mov	eax, dword ptr [esi+_INPUTR+4*4]
    86 00002FE2 114710              <1> 	adc	dword ptr [edi+4*4], eax
    87 00002FE5 8B862C040000        <1> 	mov	eax, dword ptr [esi+_INPUTR+3*4]
    88 00002FEB 11470C              <1> 	adc	dword ptr [edi+3*4], eax
    89 00002FEE 8B8628040000        <1> 	mov	eax, dword ptr [esi+_INPUTR+2*4]
    90 00002FF4 114708              <1> 	adc	dword ptr [edi+2*4], eax
    91                              <1> 
    92                              <1> _144_fmadx:
    93 00002FF7 FEC9                <1> 	dec	cl
    94 00002FF9 758D                <1> 	jnz	_144_fmadd
    95                              <1> 
    96                              <1> _144_fmadz:
    97 00002FFB 59                  <1> 	pop	ecx
    98                              <1> 
    99 00002FFC 8B4708              <1> 	mov	eax, dword ptr [edi+2*4] 	; normalised?
   100 00002FFF D1D0                <1> 	rcl	eax, 1
   101 00003001 721B                <1> 	jc	_144_fm_normalised
   102                              <1> 
   103 00003003 838620040000FF      <1> 	add	dword ptr [esi+_INPUTR], -1		; take 1 from scale
   104 0000300A D1571C              <1> 	rcl	dword ptr [edi+7*4], 1
   105 0000300D D15718              <1> 	rcl	dword ptr [edi+6*4], 1
   106 00003010 D15714              <1> 	rcl	dword ptr [edi+5*4], 1
   107 00003013 D15710              <1> 	rcl	dword ptr [edi+4*4], 1
   108 00003016 D1570C              <1> 	rcl	dword ptr [edi+3*4], 1
   109 00003019 D15708              <1> 	rcl	dword ptr [edi+2*4], 1
   110                              <1> 
   111 0000301C EB26                <1> 	jmp	_144_fm_inrange
   112                              <1> 
   113                              <1> _144_fm_normalised:
   114 0000301E 8DBE40040000        <1> 	lea	edi, [esi+_OUTPUT]
   115 00003024 E8B7EDFFFF          <1> 	call	round2
   116 00003029 7319                <1> 	jnc	_144_fm_inrange
   117                              <1> 
   118 0000302B D15F08              <1> 	rcr	dword ptr [edi+2*4], 1
   119 0000302E D15F0C              <1> 	rcr	dword ptr [edi+3*4], 1
   120 00003031 D15F10              <1> 	rcr	dword ptr [edi+4*4], 1
   121 00003034 D15F14              <1> 	rcr	dword ptr [edi+5*4], 1
   122 00003037 D15F18              <1> 	rcr	dword ptr [edi+6*4], 1
   123 0000303A D15F1C              <1> 	rcr	dword ptr [edi+7*4], 1
   124 0000303D 83862004000001      <1> 	add	dword ptr [esi+_INPUTR], 1
   125                              <1> 
   126                              <1> _144_fm_inrange:
   127 00003044 8B8620040000        <1> 	mov	eax, dword ptr [esi+_INPUTR]
   128 0000304A 038600040000        <1> 	add	eax, dword ptr [esi+_INPUT2]
   129 00003050 050000C0FF          <1> 	add	eax, -00400000h
   130 00003055 8907                <1> 	mov	dword ptr [edi], eax		; insert unsigned magnitude product scale
   131 00003057 8B4704              <1> 	mov	eax, dword ptr [edi+1*4]
   132 0000305A 314708              <1> 	xor	dword ptr [edi+2*4], eax	; the mantissa gets polarised here
   133 0000305D 31470C              <1> 	xor	dword ptr [edi+3*4], eax
   134 00003060 314710              <1> 	xor	dword ptr [edi+4*4], eax
   135 00003063 314714              <1> 	xor	dword ptr [edi+5*4], eax
   136 00003066 314718              <1> 	xor	dword ptr [edi+6*4], eax
   137 00003069 31471C              <1> 	xor	dword ptr [edi+7*4], eax
   138 0000306C C3                  <1> 	ret
   139                              <1> 
    48                                  					; data follows here
    49                                  					; if it is in this assembly
    50                                  	%if	RTA_MBANKS
    51                                  
    52                                  	section		.data
    53                                  	%include	"rta_data.msm"
    54                                  
    55                                  	section		.bss
    56                                  _memory	resd	MEMORY
    57                                  
    58                                  	%endif
    59                                  
    60                                  	end
    60          ******************       warning: label alone on a line without a colon might be in error [-w+orphan-labels]
    61                                  
