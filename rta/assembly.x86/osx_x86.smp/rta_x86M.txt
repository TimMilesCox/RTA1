     1                                  
     2                                  	%include	"rta_x86n.def"
     1                              <1> 
     2                              <1> __SMP		equ	8
     3                              <1> 
     4                              <1> TIME_UPDATE	equ     1
     5                              <1> LOCKSTEP	equ	2
     6                              <1> BREAKPOINT	equ	4
     7                              <1> CHILLDOWN	equ	8
     8                              <1> TOUCHPOINT	equ	16
     9                              <1> 
    10                              <1> EXTERNAL_INTERRUPT 	equ	00FF00h
    11                              <1> ATTENTION		equ	128
    12                              <1> INCREMENTER_CARRY	equ	64
    13                              <1> TPULSE			equ	32
    14                              <1> 
    15                              <1> 		%if	DRANG & 2
    16                              <1> INDICATIONS	equ	CHILLDOWN|TIME_UPDATE|LOCKSTEP
    17                              <1> 		%else
    18                              <1> INDICATIONS	equ	CHILLDOWN|TIME_UPDATE|LOCKSTEP|BREAKPOINT
    19                              <1> 		%endif
    20                              <1> 
    21                              <1> EXTERNAL_INDICATIONS equ EXTERNAL_INTERRUPT|ATTENTION|INCREMENTER_CARRY|TPULSE
    22                              <1> 
    23                              <1> IO_PORTS	equ	192
    24                              <1> 
    25                              <1> 	%if	RTA_MBANKS
    26                              <1> global	_metric
    27                              <1> global	_indication
    28                              <1> global	_iselect
    29                              <1> global	_iselectu
    30                              <1> global	_readout
    31                              <1> global	_readoutx
    32                              <1> global	_readoutp
    33                              <1> global	_psr
    34                              <1> global	_apc
    35                              <1> global	_apcz
    36                              <1> global	_breakpoint
    37                              <1> global	_b0_name
    38                              <1> global	_b0p
    39                              <1> global	_devices
    40                              <1> global	_base
    41                              <1> global	_register_set
    42                              <1> global	__register
    43                              <1> global	_memory
    44                              <1> 
    45                              <1> 	%if	RTA_MBANKS<1
    46                              <1> RTA_MPAGES	equ	32
    47                              <1> 	%else
    48                              <1> RTA_MPAGES	equ	RTA_MBANKS*64
    49                              <1> 	%endif
    50                              <1> 
    51                              <1> 	%else
    52                              <1> ;	extern	_metric
    53                              <1> extern	_general_indication
    54                              <1> ;	extern	_iselect
    55                              <1> ;	extern	_iselectu
    56                              <1> ;	extern	_psr
    57                              <1> ;	extern	_apc
    58                              <1> ;	extern	_apcu
    59                              <1> ;	extern	_apcz
    60                              <1> 
    61                              <1> extern	_breakpoint
    62                              <1> extern	_touchpoint
    63                              <1> extern	_touchpoint2
    64                              <1> 
    65                              <1> ;	extern	_b0_name
    66                              <1> ;	extern	_b0p
    67                              <1> extern	_devices
    68                              <1> ;	extern	_base
    69                              <1> ;	extern	_register_set
    70                              <1> ;	extern	__register
    71                              <1> extern	_memory
    72                              <1> 
    73                              <1> _output equ     272
    74                              <1> _inputr equ     264
    75                              <1> _input2 equ     256
    76                              <1> 
    77                              <1> _OUTPUT	equ	_output*4
    78                              <1> _INPUTR	equ	_inputr*4
    79                              <1> _INPUT2 equ	_input2*4
    80                              <1> _BIAS	equ	_OUTPUT
    81                              <1> 
    82                              <1> 	%endif
    83                              <1> 
    84                              <1> 	extern	_flag
    85                              <1> 	extern	_uflag
    86                              <1> 
    87                              <1> HALF_W	equ	128
    88                              <1> FP_R	equ	8
    89                              <1> B_STREAMZR  equ 64
    90                              <1> B_STREAM16R equ 32
    91                              <1> B_STREAM16W equ 16
    92                              <1> 
    93                              <1> r	equ	0
    94                              <1> k	equ	1
    95                              <1> x	equ	2
    96                              <1> y	equ	3
    97                              <1> a	equ	4
    98                              <1> b	equ	5
    99                              <1> mantissa2 equ	6
   100                              <1> mantissa3 equ	7
   101                              <1> residue	equ	8
   102                              <1> p	equ	12
   103                              <1> q	equ	13
   104                              <1> fp	equ	14
   105                              <1> s_p	equ	15
   106                              <1> 
   107                              <1> rdatac	equ	20
   108                              <1> rdata	equ	21
   109                              <1> wdatac	equ	22
   110                              <1> wdata	equ	23
   111                              <1> 
   112                              <1> 
   113                              <1> fp_guard equ	128+19
   114                              <1> 
   115                              <1> rt_clock equ	128+20
   116                              <1> priority equ	128+21
   117                              <1> dayclock_u equ	128+22
   118                              <1> dayclock equ	128+23
   119                              <1> 
   120                              <1> R	equ	r*4
   121                              <1> K	equ	k*4
   122                              <1> X	equ	x*4
   123                              <1> Y	equ	y*4
   124                              <1> A	equ	a*4
   125                              <1> B	equ	b*4
   126                              <1> MANTISSA2 equ	mantissa2*4
   127                              <1> MANTISSA3 equ	mantissa3*4
   128                              <1> RESIDUE	equ	residue*4
   129                              <1> 
   130                              <1> P	equ	p*4
   131                              <1> Q	equ	q*4
   132                              <1> FP	equ	fp*4
   133                              <1> S_P	equ	s_p*4
   134                              <1> 
   135                              <1> RDATAC	equ	rdatac*4
   136                              <1> RDATA	equ	rdata*4
   137                              <1> WDATAC	equ	wdatac*4
   138                              <1> WDATA	equ	wdata*4
   139                              <1> 
   140                              <1> FP_GUARD equ	fp_guard*4
   141                              <1> 
   142                              <1> RT_CLOCK equ	rt_clock*4
   143                              <1> PRIORITY equ	priority*4
   144                              <1> DAYCLOCK_U equ	dayclock_u*4
   145                              <1> DAYCLOCK equ	dayclock*4
   146                              <1> 
   147                              <1> I	equ	4
   148                              <1> XI	equ	5
   149                              <1> 
   150                              <1> DEVICE  equ	32768
   151                              <1> SYSMEM  equ	16384
   152                              <1> DATA16  equ	1
   153                              <1> FSYS24  equ	2
   154                              <1> 
   155                              <1> II_GUARD equ	64+31
   156                              <1> II_EXIT	equ	64+6
   157                              <1> II_YIELD equ	64+1
   158                              <1> II_SPAWN equ	64+2
   159                              <1> II_BANK equ	64+3
   160                              <1> II_ARRAY equ	64+4
   161                              <1> II_BANK_FREE equ 64+5
   162                              <1> II_TWAIT equ	64+27
   163                              <1> II_EVENT_WAIT equ 64+28
   164                              <1> II_FPXPO equ	0+3
   165                              <1> 
   166                              <1> II_XINT		equ	0+2
   167                              <1> II_MSECOND	equ	0+4
   168                              <1> II_ATTENTION	equ	0+5
   169                              <1> 
   170                              <1> LP_AUTHORITY	equ	1		; latent parameters GUARD$
   171                              <1> LP_ADDRESS	equ	14
   172                              <1> 
   173                              <1> LP_TIMESLICE	equ	10		; latent parameter timeslice -> yield
   174                              <1> LP_RANGE	equ	12		; latent parameter FP$XPO
   175                              <1> LP_AUTOEXIT	equ	11		; latent parameter return -> EXIT$
     3                                  	%include	"rta_smp.def"
     1                              <1> __POINTER	equ	4
     2                              <1> 
     3                              <1> REGISTER	equ	0			; /*	288	int	*/
     4                              <1> 
     5                              <1> APC		equ	REGISTER+288*4		; /*	1	->	*/
     6                              <1> APCZ		equ	APC+__POINTER		; /*	1	->	*/
     7                              <1> B0P		equ	APCZ+__POINTER		; /*	1	->	*/
     8                              <1> REGISTER_SET	equ	B0P+__POINTER 
     9                              <1> 
    10                              <1> RESTART_VECTOR	equ	REGISTER_SET+__POINTER	; /*	1	int	*/
    11                              <1> INDICATION	equ	RESTART_VECTOR+4	; /*	1	int	*/	
    12                              <1> LATENT_PARAMETER equ	INDICATION+4		; /*	1	int	*/
    13                              <1> ISELECT		equ	LATENT_PARAMETER+4	; /*	1	int	*/	
    14                              <1> 
    15                              <1> PSR		equ	ISELECT+4		; /*	1	int	*/
    16                              <1> B0_NAME		equ	PSR+4			; /*	1	int	*/
    17                              <1> B0_SCOPE	equ	B0_NAME+4		; /*	1	int	*/
    18                              <1> 
    19                              <1> spare		equ	B0_SCOPE+4		; align with C structure
    20                              <1> 						; and align  metric block 
    21                              <1> 
    22                              <1> DELTA		equ	spare+4			; /*	1	int	*/
    23                              <1> __METRIC	equ	DELTA+4			; /*	1	int	*/
    24                              <1> 
    25                              <1> DELTA_BASE	equ	__METRIC+4		; /*	1	long	*/
    26                              <1> TOTAL_DELTA	equ	DELTA_BASE+8		; /*	1	long	*/
    27                              <1> TOTAL_METRIC	equ	TOTAL_DELTA+8		; /*	1	long	*/
    28                              <1> 
    29                              <1> IO_PORT		equ	TOTAL_METRIC+8		; /*	192	int	*/
    30                              <1> DATAFRAME	equ	IO_PORT+192*4		; /*	nothing		*/
    31                              <1> 
    32                              <1> CORE_SIZE	equ	DATAFRAME+0
    33                              <1> 
    34                              <1> 		%if	0
    35                              <1> CORE_INDEX2	equ	4*280
    36                              <1> CORE_INDEX1	equ	4*(280-128)
    37                              <1> 		%endif
     4                                  	%include	"io.def"
     1                              <1> 
     2                              <1> ;	_NAMES of ports as referenced in implementation or emulation 
     3                              <1> 
     4                              <1> _CORE_PIN		equ	73*4	; read-only port 1 */ _CORE_SOCKET
     5                              <1> 
     6                              <1> _XI_PENDING		equ	74*4	; mask of external interrupt sources
     7                              <1> _XI_ACK			equ	75*4	; writeable ack to quench pending signals
     8                              <1> _INCREMENTER_RESTART	equ	76*4
     9                              <1> _CORE_SOCKET		equ	77*4	; socket index this core read only
    10                              <1> 
    11                              <1> _MCAST_PENDING		equ	78*4	; mask of cores which have multicast to here
    12                              <1> _MCAST_TO		equ	79*4	; -> latent parameter
    13                              <1> 					; destinations mask in register k
    14                              <1> _TZONE			equ	101*4
    15                              <1> 
    16                              <1> _APP_THRESHOLD		equ	72*4	; lowest application code page / limit ISRs
    17                              <1> _INDICATE		equ	102*4	; control commands powersave + others
    18                              <1> _CHILLDOWN		equ	103*4	; powersave microseconds
    19                              <1> 
    20                              <1> _SYS_SWITCH		equ	126*4	; if a switch block is connected
    21                              <1> _SYS_LEDS		equ	127*4	; if a LEDs block is connected
    22                              <1> 
    23                              <1> _DEVICE			equ	128*4	; descriptors 64 devices starting executable space
    24                              <1> _RAM_THRESHOLD		equ	124*4	; 1st writeable page executable space
    25                              <1> _IFRAME_U		equ	64*4	; highest page instruction frame B0 + iframe pages - 1
    26                              <1> 
    27                              <1> _I_DATA			equ	80*4	; external data read port
    28                              <1> _O_DATA			equ	88*4	; external daza write port
    29                              <1> 
    30                              <1> _CORES_MASK		equ	125*4	; bit map cores present +(1*/RTA_SMP)-1
     5                                  
     6                                  ;	this is not PIC code
     7                                  ;	but does relative jumps for compactness
     8                                  
     9                                  %define ptr
    10                                  %define include
    11                                  %define .model
    12                                  %define .code
    13                                  
    14                                  SYSMEM_FLAG	equ	00800000h
    15                                  DATA16_FLAG	equ	00400000h
    16                                  FSYS24_FLAG	equ	00C00000h
    17                                  
    18                                  					; instruction code starts here
    19                                  	section		.text
    20                                  	global		_leloup
    21                                  	global		_execute
    22                                  	global		_device_readp
    23                                  	global		_bus_readp
    24                                  	global		_memory_read
    25                                  	global		_bus_read
    26                                  	global		_device_read
    27                                  
    28                                  	%include	"leloup.msm"
     1                              <1> 
     2                              <1> 	extern	_ultra
     3                              <1> 	extern	_ultra1
     4                              <1> 	extern	_ultra2
     5                              <1> 	extern	_ultra3
     6                              <1> 	extern	_ultra4
     7                              <1> 	extern	_ultra5
     8                              <1> 	extern	_ultra6
     9                              <1> 	extern	_ultra7
    10                              <1> 	extern	_core
    11                              <1> 
    12                              <1> _save_ebp	equ	0
    13                              <1> _save_return	equ	4
    14                              <1> _1st_param	equ	8
    15                              <1> 
    16                              <1> _leloup:
    17 00000000 55                  <1> 	push	ebp
    18 00000001 56                  <1> 	push	esi
    19 00000002 57                  <1> 	push	edi
    20                              <1> 
    21                              <1> 	%if	0
    22                              <1> 	add	esp, -8
    23                              <1> 	movq	qword ptr [esp], mm7
    24                              <1> 	%endif
    25                              <1> 
    26                              <1> 	%if	0			; cdecl
    27                              <1> 	push	eax
    28                              <1> 	push	ecx
    29                              <1> 	push	edx
    30                              <1> 	%endif
    31                              <1> 
    32 00000003 53                  <1> 	push	ebx
    33                              <1> 
    34 00000004 8B7508              <1> 	mov	esi, dword ptr [ebp+8]	; structure smp ->
    35 00000007 56                  <1> 	push	esi			; balanced on stack top
    36 00000008 0F6EFE              <1> 	movd	mm7, esi		; refresh from mmx during instruction
    37                              <1> 
    38 0000000B 8B9680040000        <1> 	mov	edx, dword ptr [esi+APC]
    39 00000011 8BAE8C040000        <1> 	mov	ebp, dword ptr [esi+REGISTER_SET]
    40                              <1> 
    41 00000017 3B9684040000        <1> loup:	cmp	edx, dword ptr [esi+APCZ]
    42 0000001D 7740                <1> 	ja	off_limits
    43                              <1> 
    44 0000001F 8B02                <1> 	mov	eax, dword ptr [edx]
    45 00000021 0FC8                <1> 	bswap	eax
    46 00000023 83C204              <1> 	add	edx, 4
    47                              <1> 
    48 00000026 E82A010000          <1> 	call	_execute
    49                              <1> 
    50 0000002B 8B3424              <1> 	mov	esi, dword ptr [esp] 	; core pointer needed all the way round
    51                              <1> 
    52                              <1> 	%if	TSLICE
    53 0000002E F786A0040000000087- <1> 	test	dword ptr [esi+PSR], 00870000h	; not while ISR or interrupt mask
    53 00000037 00                  <1>
    54 00000038 752F                <1> 	jnz	louping
    55 0000003A F78650020000FFFFFF- <1> 	test	dword ptr [esi+RT_CLOCK], 00FFFFFFh
    55 00000043 00                  <1>
    56 00000044 7423                <1> 	jz	louping
    57                              <1> 
    58 00000046 FF8E50020000        <1> 	dec	dword ptr [esi+RT_CLOCK]
    59 0000004C 751B                <1> 	jnz	louping
    60                              <1> 
    61 0000004E B841000000          <1> 	mov	eax, II_YIELD
    62                              <1> 
    63 00000053 B90A000000          <1> 	mov	ecx, LP_TIMESLICE
    64 00000058 E8A00E0000          <1> 	call	_ii
    65                              <1> 
    66                              <1> 	%endif
    67                              <1> 
    68 0000005D EB0A                <1> 	jmp	louping
    69                              <1> 
    70                              <1> off_limits:
    71 0000005F B85F000000          <1> 	mov	eax, II_GUARD
    72 00000064 E8940E0000          <1> 	call	_ii
    73                              <1> 
    74                              <1> louping:
    75 00000069 8A0D[00000000]      <1> 	mov	cl, byte ptr [_general_indication]
    76 0000006F F6C104              <1> 	test	cl, BREAKPOINT
    77 00000072 7420                <1> 	jz	loup_count
    78 00000074 A1[00000000]        <1> 	mov	eax, dword ptr [_breakpoint]
    79 00000079 31D0                <1> 	xor	eax, edx
    80 0000007B 7517                <1> 	jnz	loup_count
    81 0000007D 800D[00000000]02    <1> 	or	byte ptr [_general_indication], LOCKSTEP
    82 00000084 808E9404000002      <1> 	or	byte ptr [esi+INDICATION], LOCKSTEP
    83 0000008B 800D[12000000]01    <1> 	or	byte ptr [_flag+'s'-'a'], 1
    84 00000092 EB50                <1> 	jmp	indicated
    85                              <1> 
    86                              <1> loup_count:
    87 00000094 FF8E6C040000        <1> 	dec	dword ptr [esi+283*4]
    88 0000009A 7908                <1> 	jns	loup_away
    89 0000009C 66838E9404000001    <1> 	or	word ptr [esi+INDICATION], TIME_UPDATE
    90                              <1> loup_away:
    91                              <1> 
    92 000000A4 668B8694040000      <1> 	mov	ax, word ptr [esi+INDICATION]
    93 000000AB 8A8EA2040000        <1> 	mov	cl, byte ptr [esi+PSR+2]
    94 000000B1 80E107              <1> 	and	cl, 7				; highest interrupt mask?
    95 000000B4 80F107              <1> 	xor	cl, 7
    96                              <1> 
    97 000000B7 7421                <1> 	jz	internal_indications?		; maskable interrupts are masked
    98                              <1> 
    99 000000B9 66A9EBFF            <1>         test	ax, INDICATIONS|EXTERNAL_INDICATIONS	; 1 or both of internal++external
   100 000000BD 0F8454FFFFFF        <1> 	jz	loup					; indications? No?
   101 000000C3 66A9E0FF            <1> 	test	ax, EXTERNAL_INDICATIONS	; external indications among the yes?
   102                              <1> 
   103 000000C7 741B                <1> 	jz	indicated			; external indications there are not
   104                              <1> 						; therefore internal indications there are
   105                              <1> ;	push	esi	; already on stack top	; therefore raise their interrupts
   106 000000C9 E8270D0000          <1> 	call	_xi
   107 000000CE 8B3424              <1> 	mov	esi, dword ptr [esp]
   108                              <1> 
   109 000000D1 80A6940400007F      <1> 	and	byte ptr [esi+INDICATION], 127
   110 000000D8 EB8F                <1> 	jmp	louping				; keep going intil pending flags are off
   111                              <1> 
   112                              <1> internal_indications?:
   113 000000DA 66A90B00            <1> 	test	ax, INDICATIONS			; just read from esi->INDICATION
   114 000000DE 0F8433FFFFFF        <1> 	jz	loup
   115                              <1> 
   116                              <1> indicated:
   117 000000E4 80A694040000FD      <1> 	and	byte ptr [esi+INDICATION], LOCKSTEP^255
   118 000000EB 89AE8C040000        <1> 	mov	dword ptr [esi+REGISTER_SET], ebp
   119 000000F1 899680040000        <1> 	mov	dword ptr [esi+APC], edx
   120                              <1> 
   121 000000F7 5B                  <1> 	pop	ebx				; core  pointer
   122 000000F8 5B                  <1> 	pop	ebx				; caller values
   123                              <1> 
   124                              <1> 	%if	0				; cdecl
   125                              <1> 	pop	edx
   126                              <1> 	pop	ecx
   127                              <1> 	pop	eax
   128                              <1> 	%endif
   129                              <1> 
   130                              <1> 	%if	0
   131                              <1> 	movq	mm7, qword ptr [esp]
   132                              <1> 	add	esp, 8
   133                              <1> 	%endif
   134                              <1> 
   135 000000F9 5F                  <1> 	pop	edi
   136 000000FA 5E                  <1> 	pop	esi
   137 000000FB 5D                  <1> 	pop	ebp
   138 000000FC C3                  <1> 	ret
   139                              <1> 
    29                                  	%include	"execute.msm"
     1                              <1> ;	include	rta_x86.h
     2                              <1> 	.model	small
     2          ******************  <1>  warning: label alone on a line without a colon might be in error [-w+orphan-labels]
     3                              <1> 	.code
     4                              <1> ;	_execute:
     5                              <1> ;        mov     dword ptr [__register+287*4], esp
     6                              <1> 
     7 000000FD 89C1                <1> __ea:	mov	ecx, eax
     8 000000FF C1E108              <1> 	shl	ecx, 8
     9 00000102 C1E913              <1> 	shr	ecx, 24-5		; instruction index in ch
    10 00000105 C0E905              <1> 	shr	cl, 5			; operand designator in cl
    11                              <1> 
    12 00000108 C1E010              <1> 	shl	eax, 16
    13 0000010B 80F905              <1> 	cmp	cl, XI			; sign extended immediate?
    14 0000010E 7508                <1> 	jnz	derive_ea
    15                              <1> 
    16 00000110 C1F808              <1> 	sar	eax, 8			; different from other EAs
    17 00000113 C1E808              <1> 	shr	eax, 8
    18 00000116 EB3C                <1> 	jmp	ea_derived
    19                              <1> 
    20                              <1> derive_ea:
    21 00000118 C1E810              <1> 	shr	eax, 16			; no sign of it
    22 0000011B 6621C0              <1> 	and	ax, ax			; indexing / indirection ?
    23 0000011E 7934                <1> 	jns	ea_derived		; no
    24                              <1> 
    25 00000120 89C3                <1> 	mov	ebx, eax
    26 00000122 80E47F              <1> 	and	ah, 127			; ie: and ax 32767
    27 00000125 66C1EB0C            <1> 	shr	bx, 12			; position index tag
    28 00000129 F6C306              <1> 	test	bl, 6			; indirect or indexed ?
    29 0000012C 7415                <1> 	jz	indirect
    30                              <1> 					; pe = PF set
    31                              <1> 					; can only be tested on b7..0
    32 0000012E 7A03                <1> 	jpe	indexed_4bit		; indexed fp / sp
    33                              <1> 					; indexed x / y / a / b
    34 00000130 80E307              <1> 	and	bl, 7			; zero bit 3
    35                              <1> 
    36                              <1> indexed_4bit:
    37 00000133 6625FF0F            <1> 	and	ax, 4095		; isolate address offset
    38 00000137 03449D00            <1> 	add	eax, dword ptr [ebp+ebx*4]
    39                              <1> 
    40 0000013B C1E008              <1> 	shl	eax, 8			; truncate any overflow
    41 0000013E C1E808              <1> 	shr	eax, 8
    42                              <1> 
    43 00000141 EB11                <1> 	jmp	ea_derived
    44                              <1> 
    45                              <1> indirect:				; indirect via page B0 / B1
    46 00000143 6689CB              <1> 	mov	bx, cx
    47 00000146 6631C9              <1> 	xor	cx, cx			; cl <- zero to read 1-word indirection pointer
    48 00000149 E803020000          <1> 	call	_operand_read
    49 0000014E 6689D9              <1> 	mov	cx, bx			; retrieve instruction:class into cx
    50                              <1> 
    51                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]	; retrieve smp core ->
    52 00000151 0F7EFE              <1> 	movd	esi, mm7
    53                              <1> ea_derived:
    54 00000154 C3                  <1> 	ret
    55                              <1> 
    56                              <1> _execute:
    57 00000155 89A67C040000        <1> 	mov	dword ptr [esi+REGISTER+287*4], esp
    58 0000015B E89DFFFFFF          <1> 	call	__ea
    59                              <1> 
    60 00000160 0FB6DD              <1> 	movzx	ebx, ch			; instruction index
    61 00000163 80F906              <1> 	cmp	cl, 6
    62 00000166 0F848F000000        <1> 	jz	near shifts_jumps
    63 0000016C 0F8712010000        <1> 	ja	near large_operations
    64                              <1> 
    65                              <1> integer_operations:
    66 00000172 8B1C9D[7B010000]    <1> 	mov	ebx, dword ptr [operations1+ebx*4]
    67 00000179 FFE3                <1> 	jmp	ebx
    68                              <1> 
    69                              <1> operations1:
    70 0000017B [38120000]          <1>         dd	_sr
    71 0000017F [52120000]          <1>         dd	_sk
    72 00000183 [6C120000]          <1>         dd	_sx
    73 00000187 [86120000]          <1>         dd	_sy
    74 0000018B [A0120000]          <1>         dd	_sa
    75 0000018F [B6120000]          <1>         dd	_sb
    76 00000193 [C8120000]          <1>         dd	_z
    77 00000197 [E1120000]          <1>         dd	_pop
    78                              <1> 
    79 0000019B [FD120000]          <1>         dd	_lr
    80 0000019F [06130000]          <1>         dd	_lk
    81 000001A3 [0F130000]          <1>         dd	_lx
    82 000001A7 [18130000]          <1>         dd	_ly
    83 000001AB [21130000]          <1>         dd	_la
    84 000001AF [2A130000]          <1>         dd	_lb
    85 000001B3 [33130000]          <1>         dd	_tz
    86 000001B7 [5A130000]          <1>         dd	_tp
    87                              <1> 
    88 000001BB [74160000]          <1>         dd	_ax
    89 000001BF [85160000]          <1>         dd	_ay
    90 000001C3 [96160000]          <1>         dd	_or
    91 000001C7 [9F160000]          <1>         dd	_orB
    92 000001CB [A8160000]          <1>         dd	_and
    93 000001CF [B1160000]          <1>         dd	_andB
    94 000001D3 [BA160000]          <1>         dd	_xor
    95 000001D7 [C3160000]          <1>         dd	_xorB
    96                              <1> 
    97 000001DB [CC160000]          <1>         dd	_aa
    98 000001DF [EC160000]          <1>         dd	_ab
    99 000001E3 [D3160000]          <1>         dd	_ana
   100 000001E7 [F3160000]          <1>         dd	_anb
   101 000001EB [0C170000]          <1>         dd	_m
   102 000001EF [3C170000]          <1>         dd	_mf
   103 000001F3 [98170000]          <1>         dd	_d
   104 000001F7 [78130000]          <1>         dd	_push
   105                              <1> 
   106                              <1> shifts_jumps:
   107 000001FB 8B1C9D[04020000]    <1> 	mov	ebx, dword ptr [operations6+ebx*4]
   108 00000202 FFE3                <1> 	jmp	ebx
   109                              <1> 
   110                              <1> operations6:
   111 00000204 [3D180000]          <1>         dd	_sar
   112 00000208 [54180000]          <1>         dd	_sbr
   113 0000020C [6B180000]          <1>         dd	_dsr
   114 00000210 [96130000]          <1>         dd	_jdr
   115 00000214 [7F180000]          <1>         dd	_sal
   116 00000218 [96180000]          <1>         dd	_sbl
   117 0000021C [AD180000]          <1>         dd	_dsl
   118 00000220 [B0130000]          <1>         dd	_lcal
   119                              <1> 
   120 00000224 [C1180000]          <1>         dd	_rar
   121 00000228 [CD180000]          <1>         dd	_rbr
   122 0000022C [D9180000]          <1>         dd	_drr
   123 00000230 [C4130000]          <1>         dd	_jnc
   124 00000234 [751A0000]          <1>         dd	_ral
   125 00000238 [811A0000]          <1>         dd	_rbl
   126 0000023C [8D1A0000]          <1>         dd	_drl
   127 00000240 [D1130000]          <1>         dd	_jc
   128                              <1> 
   129 00000244 [A11A0000]          <1>         dd	_saa
   130 00000248 [B21A0000]          <1>         dd	_sba
   131 0000024C [C31A0000]          <1>         dd	_dsa
   132 00000250 [DE130000]          <1>         dd	_jao
   133 00000254 [E8130000]          <1>         dd	_jpa
   134 00000258 [F2130000]          <1>         dd	_jpb
   135 0000025C [FC130000]          <1>         dd	_j
   136 00000260 [1E140000]          <1>         dd	_jpo
   137                              <1> 
   138 00000264 [26140000]          <1>         dd	_jza
   139 00000268 [30140000]          <1>         dd	_jzb
   140 0000026C [3A140000]          <1>         dd	_jnza
   141 00000270 [44140000]          <1>         dd	_jnzb
   142 00000274 [4E140000]          <1>         dd	_jna
   143 00000278 [58140000]          <1>         dd	_jnb
   144 0000027C [62140000]          <1>         dd	_jxge
   145 00000280 [71140000]          <1>         dd	_jyge
   146                              <1> 
   147                              <1> 
   148                              <1> large_operations:
   149 00000284 8B1C9D[8F020000]    <1> 	mov	ebx, dword ptr [operations7+ebx*4]
   150 0000028B B100                <1> 	mov	cl, 0		; default size large operand
   151 0000028D FFE3                <1> 	jmp	ebx		; 1 word
   152                              <1> 
   153                              <1> operations7:
   154 0000028F [51150000]          <1>         dd	_ts
   155 00000293 [D71A0000]          <1>         dd	_n
   156 00000297 [E61A0000]          <1>         dd	_inc
   157 0000029B [F11A0000]          <1>         dd	_dec
   158 0000029F [67150000]          <1>         dd	_sim
   159 000002A3 [3C1B0000]          <1>         dd	_popA
   160 000002A7 [FC1A0000]          <1>         dd	_src
   161 000002AB [1C1B0000]          <1>         dd	_slc
   162                              <1> 
   163 000002AF [84140000]          <1>         dd	_qs
   164 000002B3 [8E140000]          <1>         dd	_ql
   165 000002B7 [F3140000]          <1>         dd	_dte
   166 000002BB [BB140000]          <1>         dd	_dpop
   167 000002BF [CA230000]          <1>         dd	_fa
   168 000002C3 [E5230000]          <1>         dd	_fan
   169 000002C7 [00240000]          <1>         dd	_fm
   170 000002CB [21240000]          <1>         dd	_fd
   171                              <1> 
   172 000002CF [98140000]          <1>         dd	_qpop
   173 000002D3 [A8140000]          <1>         dd	_qpush
   174 000002D7 [44150000]          <1>         dd	_ex
   175 000002DB [CB140000]          <1>         dd	_dpush
   176 000002DF [1F1C0000]          <1>         dd	_lsc
   177 000002E3 [E2140000]          <1>         dd	_mta
   178 000002E7 [06150000]          <1>         dd	_sc
   179 000002EB [14150000]          <1>         dd	_mlb
   180                              <1> 
   181 000002EF [2D150000]          <1>         dd	_ds
   182 000002F3 [37150000]          <1>         dd	_dl
   183 000002F7 [6E1B0000]          <1>         dd	_da
   184 000002FB [751B0000]          <1>         dd	_dan
   185 000002FF [301C0000]          <1>         dd	_dlsc
   186 00000303 [43150000]          <1>         dd	_spare
   187 00000307 [AA150000]          <1>         dd	_go
   188 0000030B [8D150000]          <1>         dd	_call
   189                              <1> 
    30                                  	%include	"rw.msm"
     1                              <1> 
     2                              <1> 
     3                              <1> ;	include	rta_x86.h
     4                              <1> ;	.model	large
     5                              <1> ;	.code
     6                              <1> 
     7                              <1> ;	this is the operand reader / writer
     8                              <1> ;	for emulated RTA1 on x86
     9                              <1> 
    10                              <1> ;	layout is
    11                              <1> 
    12                              <1> ;	RTA1 24-bit registers are modeled in an array of
    13                              <1> ;	platform-endian integers. In x86 these are 32-bit
    14                              <1> ;	little-endian integers
    15                              <1> 
    16                              <1> ;	platform-endian doesn't affect registers
    17                              <1> ;	because endianness is not at the CPU
    18                              <1> ;	side of the bus, but at the memory side
    19                              <1> 
    20                              <1> ;	when Intel circuitry in the x86 CPU staticises the value
    21                              <1> ;	of an emulated register, that value is big endian
    22                              <1> 
    23                              <1> ;	the stored integers where emulated registers are modeled
    24                              <1> ;	are platform-endian, with identical effect on big and
    25                              <1> ;	little endian emulator platforms
    26                              <1> 
    27                              <1> ;	RTA1 24-bit executable space storage words are modeled in
    28                              <1> ;	another array of platform-endian 32-bit integers. Emulation
    29                              <1> ;	on x86 swaps the byte order of storage words on read and
    30                              <1> ;	before write to conform with RTA1 canonical storage order
    31                              <1> 
    32                              <1> ;       RTA1 architecture has registers in the first 256 locations
    33                              <1> ;       of address space and access differentiates registers from
    34                              <1> ;       from memory according to effective address
    35                              <1> 
    36                              <1> ;	location of registers and storage are handed to read / write
    37                              <1> ;	routines as RTA1 word linear effective addresses
    38                              <1> 
    39                              <1> ;	These routines maintain the RTA1 linear addresses passed
    40                              <1> ;	in x86 registers and apply them with shifted scale plus
    41                              <1> ;	displacement, for example
    42                              <1> 
    43                              <1> ;		mov	eax, dword ptr [edi+esi*4+_memory]
    44                              <1> ;		bswap	eax
    45                              <1> ;		mov	dword_ptr [ebp+ebx*4], eax
    46                              <1> 
    47                              <1> ;	RTA1 register addresses are already absolute in terms of
    48                              <1> ;	the emulated RTA1 machine
    49                              <1> 
    50                              <1> ;	ebp points at the context register frame. There are two
    51                              <1> ;	register frames, application and interrupt. Registers
    52                              <1> ;	addressed as storage operand are in a single list
    53                              <1> 
    54                              <1> ;		mov	eax, dword ptr [esi*4+__register]
    55                              <1> 
    56                              <1> ;	RTA1 storage addresses are translated by RTA1 relocation
    57                              <1> ;	architecture before application. The updated linear addresses
    58                              <1> ;	of the emulated machine are in esi
    59                              <1> 
    60                              <1> ;	The operand routines in this file point edi to the x86 platform
    61                              <1> ;	storage array start of the storage device, most often emulated
    62                              <1> ;	RTA1 executable space
    63                              <1> 
    64                              <1> ;	instructions call these operand routines with RTA1 effective 
    65                              <1> ;	address in eax
    66                              <1> 
    67                              <1> ;	instructions receive load operand values in eax and ebx, or in
    68                              <1> ;	a list of RTA1 emulated register locations pointed by ebp+ebx
    69                              <1> 
    70                              <1> ;	store instructions submit a value in ebx, or values in list of
    71                              <1> ;	RTA1 emulated register locations pointed by ebp+ebx
    72                              <1> 
    73                              <1> ;	to preserve linear address consistency, application instruction
    74                              <1> ;	work areas, where needed in addition to x86 registers, are
    75                              <1> ;	implemented as sub-architectural extra RTA1 registers at the end
    76                              <1> ;	of the 256-longword register stack. x86 register ebp+ebx*4 identify
    77                              <1> ;	these locations by linear RTA1 word quantum as "registers"
    78                              <1> 
    79                              <1> ;	RTA1 registers and storage alike are in 24-bit word address quantum space
    80                              <1> 
    81                              <1> ;	emulated instructions loading or storing multiple hidden extra work
    82                              <1> ;	registers should unconditionally set ebp to the start or application
    83                              <1> ;	frame of the emulated register array, so that [ebp+ebx*4] accesses the
    84                              <1> ;	correct locations at register occurence 256+
    85                              <1> 
    86                              <1> ;               _floating_operand2 equ  256+12
    87                              <1> 
    88                              <1> ;		push	ebp
    89                              <1> ;		mov	ebp, __register	; point to application register frame[0]
    90                              <1> ;		mov	ebx, 256+_floating_operand2
    91                              <1> ;		call	_burst_read4
    92                              <1> 
    93                              <1> ;		pop	ebp		; return to previous register frame[0] application
    94                              <1> 					;                          or frame[1] interrupt
    95                              <1> 
    96                              <1> ;	Both internal stack pointers are also absolute, so for stack operations
    97                              <1> ;	ebp should be momentarily forced to the lower-addressed (application) stack
    98                              <1> ;	frame after being used to point the stack location of reference
    99                              <1> 
   100                              <1> ;		mov	ebx, dword ptr [ebp+S_P]	; read one of the two stack pointers
   101                              <1> ;		cmp	ebx, ebp+STACK_LOWER_LIMIT	; 24*4 within context of either stack
   102                              <1> ;		jl	II_GUARD
   103                              <1> ;		add	ebx, -1				; new stack top
   104                              <1> ;		mov	dword ptr [ebp+S_P], ebx
   105                              <1> ;		push	ebp				; which ever stack pointer it is, it points
   106                              <1> ;		mov	ebp,__register			; relative to all the register stack
   107                              <1> ;		call	_operand_read			; for I am the single-word push instruction
   108                              <1> ;		pop	ebp				;
   109                              <1> 
   110                              <1> ;	register identities supplied from emulated instructions to these routines
   111                              <1> ;	are their lowercase names equated to RTA1 word addresses
   112                              <1> 
   113                              <1> ;	There exist also uppercase spellings which instruction routines may
   114                              <1> ;	access internally. The uppercase names are four times in value the
   115                              <1> ;	equivalent lowercase ordinal names to give x86 platform offset values
   116                              <1> 
   117                              <1> ;       Assembly language equate is like parentheses! What's in a label
   118                              <1> ;       is not an expression but its value. Nothing like C preprocessor.
   119                              <1> ;       Just in case you're developing enhancements in assembly using
   120                              <1> ;       preprocessor and #define
   121                              <1> 
   122                              <1> ;		_floating_operand2 equ	256+12
   123                              <1> ;		FLOATING_OPERAND2 equ	_floating_operand2*4
   124                              <1> 
   125                              <1> 
   126                              <1> ;		a	equ	4
   127                              <1> ;		b	equ	5
   128                              <1> ;		mantissa2 equ	6
   129                              <1> 
   130                              <1> ;		A	equ	a*4
   131                              <1> ;		B	equ	b*4
   132                              <1> ;		MANTISSA2 equ	mantissa2*4
   133                              <1> 
   134                              <1> ;		mov	ebx, dword ptr [bp+MANTISSA2]	; the very same!
   135                              <1> ;		mov	ebx, dword ptr [bp+mantissa2*4]	; the very same
   136                              <1> 
   137                              <1> ;	but to identify an instruction-implied register to these operand routines
   138                              <1> 
   139                              <1> ;		mov	ebx, mantissa2		; bp already says which register set
   140                              <1> 
   141                              <1> ;	instruction evaluation supplies right-hand side operand EA in eax
   142                              <1> ;	Instruction implementation needs not examine EA. Call _operand_read
   143                              <1> ;	or _operand_write. eax must be as supplied to the instruction routine
   144                              <1> ;	on on operand retrieve and store
   145                              <1> 
   146                              <1> ;	simple instructions receive operand mode in cl from instruction
   147                              <1> ;	evaluation
   148                              <1> 
   149                              <1> ;	shifts and jumps use the ea which is already indexed or indirected
   150                              <1> ;	if necessary and make no operand call
   151                              <1> 
   152                              <1> ;	instructions call _burst_read2 or _burst_write2 for two-word operand cycles
   153                              <1> ;	instructions call _burst_read4 or _burst_write4 for four-word operand cycles
   154                              <1> 
   155                              <1> ;	operand reads of 1 or 2 words return values in eax:ebx
   156                              <1> 
   157                              <1> ;		call	_burst_read2
   158                              <1> ;		mov	dword ptr [ebp+A], eax
   159                              <1> ;		mov	dword ptr [ebp+B], ebx
   160                              <1> 
   161                              <1> ;	to store one operand word place it in ebx
   162                              <1> 
   163                              <1> ;	_sc	mov	ebx, dword ptr[_psr]	; I am the store carry instruction sc
   164                              <1> ;		and	ebx, 1			; CARRY
   165                              <1> ;		call	_operand_write
   166                              <1> 
   167                              <1> ;	to store two or four words or to load four words, point bx to register
   168                              <1> 
   169                              <1> ;	_qpop	mov	ebx, dword ptr [ebp+S_P] ; internal stack pointer
   170                              <1> ;						; either application sp or interrupt sp
   171                              <1> ;
   172                              <1> ;		add	dword ptr [ebp+S_P], 4	; internal stack+= 4
   173                              <1> ;		push	ebp			;
   174                              <1> ;		mov	ebp, __register		; in case context is interrupt registers
   175                              <1> ;		call	_burst_write4		; both internal stack pointers are absolute
   176                              <1> ;		pop	ebp			; point epb back to application registers
   177                              <1> ;						;                or interrupt registers
   178                              <1> 
   179                              <1> ;	more complex instructions do something to the registers after
   180                              <1> ;	acquiring operands
   181                              <1> 
   182                              <1> ;		call	_operand_read
   183                              <1> ;		add	eax, dword ptr [ebp+A]
   184                              <1> ;		rol	eax
   185                              <1> ;		and	al, CARRY		; 1
   186                              <1> ;		or	byte ptr [_psr], al	; low-order byte of longword _psr
   187                              <1> ;		shr	eax, 8
   188                              <1> ;		mov	dword ptr [ebp+A], eax
   189                              <1> 
   190                              <1> ;	emulated RTA1 instructions which both read and write (modify)
   191                              <1> ;	storage use the address in [edi+esi*4] to rewrite. edi is
   192                              <1> ;	NULL if it's not a suitable memory for a modify operation
   193                              <1> 
   194                              <1> ;	modify instructions which may have a register operand (not TS)
   195                              <1> ;	call _operand_write to rewrite a register. This guards aganst
   196                              <1> ;	applications writing interrupt registers.
   197                              <1>  
   198                              <1> ;	the effect of storage buses characteristically different
   199                              <1> ;	from RTA1 executable space is emulated in the routines
   200                              <1> ;	device_read and device_write
   201                              <1> 
   202                              <1> ;	Peripheral bus types implemented are
   203                              <1> 
   204                              <1> ;		filestore containing extents of up to 768K octets
   205                              <1> ;		accessible to RTA1 as up to 256K words in each extent.
   206                              <1> ;		The 3-octet words are in canonical order and packed
   207                              <1> 
   208                              <1> ;		network interface buffer store shared with the emulator
   209                              <1> ;		platform and reading out to RTA1 at 16 data bits per word
   210                              <1> ;		with eight high-order zero bits. RTA writes 16 data bits
   211                              <1> ;		to these locations from register low-order bit positions.
   212                              <1> ;		Storage byte order is canonical. These buffers are normal
   213                              <1> ;		and contiguous byte arrays of the emulator platform.
   214                              <1> ;		To RTA1 they are an attached device array of 16-bit words
   215                              <1> 
   216                              <1> ;	Device array types are
   217                              <1> 
   218                              <1> ;		executable space
   219                              <1> ;		24-bit filestore array
   220                              <1> ;		16-bit network interface array
   221                              <1> 
   222                              <1> ;	devices are identified in RTA1 memory relocation pointers and
   223                              <1> ;	tagged with device type. Executable space is device zero
   224                              <1> 
   225                              <1> ;	esi -> core.REGISTER
   226                              <1> 
   227                              <1> _burst_read2:
   228 0000030F 66B90600            <1> 	mov	cx, 6
   229 00000313 A900FFFF00          <1> 	test	eax, 00FFFF00h
   230 00000318 7402                <1> 	jz	read2_registers
   231 0000031A EB4D                <1> 	jmp	_bus_read
   232                              <1> 
   233                              <1> read2_registers:				; load registers from registers
   234 0000031C 8B5C8604            <1> 	mov	ebx, dword ptr [esi+eax*4+4]
   235 00000320 8B0486              <1> 	mov	eax, dword ptr [esi+eax*4]
   236 00000323 C3                  <1> 	ret
   237                              <1> 	
   238                              <1> ;	esi -> core.REGISTER
   239                              <1> 
   240                              <1> _burst_read4:				; buffered read
   241 00000324 66B90700            <1> 	mov	cx, 7			; that will help the caller
   242 00000328 A900FFFF00          <1> 	test	eax, 00FFFF00h		; ebp+ebx contains a register number
   243 0000032D 7402                <1> 	jz	read4_registers		; may also identify extra
   244 0000032F EB38                <1> 	jmp	_bus_read
   245                              <1> 					; workspace registers
   246                              <1> read4_registers:			; at register stack tail
   247 00000331 8B4C860C            <1> 	mov	ecx, dword ptr [esi+eax*4+3*4]
   248 00000335 894C9D0C            <1> 	mov	dword ptr [ebp+ebx*4+3*4], ecx
   249 00000339 8B4C8608            <1> 	mov	ecx, dword ptr [esi+eax*4+2*4]
   250 0000033D 894C9D08            <1> 	mov	dword ptr [ebp+ebx*4+2*4], ecx
   251 00000341 8B4C8604            <1> 	mov	ecx, dword ptr [esi+eax*4+4]
   252 00000345 894C9D04            <1> 	mov	dword ptr [ebp+ebx*4+4], ecx
   253 00000349 8B0C86              <1> 	mov	ecx, dword ptr [esi+eax*4]
   254 0000034C 894C9D00            <1> 	mov	dword ptr [ebp+ebx*4], ecx
   255 00000350 C3                  <1> 	ret
   256                              <1> 
   257                              <1> ;	esi -> core.REGISTER
   258                              <1> 
   259                              <1> _operand_read:			; call here with designator coded in cx
   260 00000351 80E107              <1> 	and	cl, 7		; and ea in eax
   261 00000354 80F904              <1> 	cmp	cl, 4
   262 00000357 740F                <1> 	je	immediate	; EA is operand
   263 00000359 80F905              <1> 	cmp	cl, 5
   264 0000035C 740A                <1> 	je	immediate_xi	; EA is operand
   265                              <1> 
   266 0000035E A900FFFF00          <1> 	test	eax, 00FFFF00h
   267 00000363 7504                <1> 	jnz	_bus_read	; ea does not point to registers
   268 00000365 8B0486              <1> 	mov	eax, dword ptr [esi+eax*4]
   269                              <1> 
   270                              <1> immediate:
   271                              <1> immediate_xi:
   272 00000368 C3                  <1> 	ret 
   273                              <1> 
   274                              <1> _bus_read:				; readout any memory
   275                              <1> 
   276 00000369 E881050000          <1> 	call	base_read_pointer	; returns eax <- storage block
   277                              <1> 					; 	  esi <- word offset
   278                              <1> 					;	  edi <- EA
   279                              <1> 
   280 0000036E A900004000          <1> 	test	eax, 00400000h		; big block?
   281 00000373 741B                <1> 	je	memory_read_4k_block
   282                              <1> 
   283 00000375 80F906              <1> 	cmp	cl, 6			; multiword operation?
   284 00000378 720D                <1> 	jb	_bus_read_256k_block
   285                              <1> 
   286 0000037A 81FEFCFF0300        <1> 	cmp	esi, 03FFFCh		; near the edge?
   287 00000380 7605                <1> 	jna	_bus_read_256k_block	; no
   288                              <1> 
   289 00000382 E8E0210000          <1> 	call	read_straddle_18b?
   290                              <1> 
   291                              <1> _bus_read_256k_block:
   292 00000387 A83F                <1> 	test	al, 63
   293 00000389 7429                <1> 	jz	memory_read_page
   294                              <1> 
   295 0000038B E983030000          <1> 	jmp	device_read
   296                              <1> 
   297                              <1> memory_read_4k_block:
   298 00000390 F7C600F00300        <1> 	test	esi, 0003F000h		; inside 4k block?
   299 00000396 740A                <1> 	jz	memory_read_thru
   300                              <1> 
   301 00000398 B90E000000          <1> 	mov	ecx, LP_ADDRESS
   302 0000039D E94D0B0000          <1> 	jmp	guard_ii_escape		; no
   303                              <1> 
   304                              <1> memory_read_thru:
   305 000003A2 80F906              <1> 	cmp	cl, 6
   306 000003A5 720D                <1> 	jb	memory_read_page
   307                              <1> 
   308 000003A7 81FEFC0F0000        <1> 	cmp	esi, 0FFCh		; near the edge?
   309 000003AD 7605                <1> 	jna	memory_read_page	; no
   310                              <1> 
   311 000003AF E888210000          <1> 	call	read_straddle_12b?
   312                              <1> 
   313                              <1> memory_read_page:
   314 000003B4 C1E00C              <1> 	shl	eax, 12			; multiply by page and lose bit 00400000
   315 000003B7 01C6                <1> 	add	esi, eax
   316                              <1> ;	mov	ch, byte ptr [edi+PSR]	; field of PSR with byte options
   317 000003B9 BF[00000000]        <1> 	mov	edi, _memory		; byte address
   318                              <1> 
   319                              <1> memory_read_on:
   320 000003BE 8D3CB7              <1> 	lea	edi, [edi+esi*4]
   321                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
   322 000003C1 0F7EFE              <1> 	movd	esi, mm7
   323                              <1> 
   324 000003C4 0FB6C1              <1> 	movzx	eax, cl
   325 000003C7 8B0485[D0030000]    <1> 	mov	eax, dword ptr [read_action+eax*4]
   326 000003CE FFE0                <1> 	jmp	eax
   327                              <1> 
   328                              <1> read_action:
   329 000003D0 [F0030000]          <1> 	dd	memory_read_w0
   330 000003D4 [31040000]          <1> 	dd	memory_t1
   331 000003D8 [38040000]          <1> 	dd	memory_t2	; or h1
   332 000003DC [48040000]          <1> 	dd	memory_t3	; or h2
   333 000003E0 [68030000]          <1> 	dd	immediate	; don't get here
   334 000003E4 [68030000]          <1> 	dd	immediate_xi	; don't get here
   335 000003E8 [F7030000]          <1> 	dd	memory_read2
   336 000003EC [05040000]          <1> 	dd	memory_read4
   337                              <1> 
   338                              <1> memory_read_w0:			; readout system memory 1 word
   339                              <1> ;	mov	dword ptr [esi+REGISTER+154*4], edi
   340                              <1> ;	mov	dword ptr [esi+REGISTER+155*4], esi
   341 000003F0 8B07                <1> 	mov	eax, dword ptr [edi]
   342 000003F2 B000                <1> 	mov	al, 0
   343 000003F4 0FC8                <1> 	bswap	eax
   344                              <1> ; immediate:
   345                              <1> ; immediate_xi:
   346 000003F6 C3                  <1>  	ret
   347                              <1> 
   348                              <1> memory_read2:			; readout system memory 2 words
   349 000003F7 8B5F04              <1> 	mov	ebx, dword ptr [edi+4]
   350 000003FA 8B07                <1> 	mov	eax, dword ptr [edi]
   351                              <1> 
   352 000003FC B000                <1> 	mov	al, 0
   353 000003FE B300                <1> 	mov	bl, 0
   354 00000400 0FC8                <1> 	bswap	eax
   355 00000402 0FCB                <1> 	bswap	ebx
   356 00000404 C3                  <1> 	ret
   357                              <1> 				; readout system memory 4 words
   358                              <1> memory_read4:			; store by pointer
   359                              <1> 				; this will be useful to the caller
   360                              <1> 
   361 00000405 8B07                <1> 	mov	eax, dword ptr [edi]
   362 00000407 B000                <1> 	mov	al, 0
   363 00000409 0FC8                <1> 	bswap	eax
   364 0000040B 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   365 0000040F 8B4704              <1> 	mov	eax, dword ptr [edi+4]
   366 00000412 B000                <1> 	mov	al, 0
   367 00000414 0FC8                <1> 	bswap	eax
   368 00000416 89449D04            <1> 	mov	dword ptr [ebp+ebx*4+4], eax
   369 0000041A 8B4708              <1> 	mov	eax, dword ptr [edi+2*4]
   370 0000041D B000                <1> 	mov	al, 0
   371 0000041F 0FC8                <1> 	bswap	eax
   372 00000421 89449D08            <1> 	mov	dword ptr [ebp+ebx*4+2*4], eax
   373 00000425 8B470C              <1> 	mov	eax, dword ptr [edi+3*4]
   374 00000428 B000                <1> 	mov	al, 0
   375 0000042A 0FC8                <1> 	bswap	eax
   376 0000042C 89449D0C            <1> 	mov	dword ptr [ebp+ebx*4+3*4], eax
   377 00000430 C3                  <1> 	ret
   378                              <1> 
   379                              <1> memory_t1:
   380 00000431 8B07                <1> 	mov	eax, dword ptr [edi]
   381 00000433 C1E010              <1> 	shl	eax, 16		; t1 = 3.2.THIS.zero
   382 00000436 EB1B                <1> 	jmp	memory_tw
   383                              <1> 
   384                              <1> memory_t2:
   385 00000438 8B07                <1> 	mov	eax, dword ptr [edi]
   386 0000043A F686A004000080      <1> 	test	byte ptr [esi+PSR], HALF_W
   387 00000441 7517                <1> 	jnz	memory_h1
   388 00000443 C1E008              <1> 	shl	eax, 8		; t2 = 3.THIS.1.zero
   389 00000446 EB0B                <1> 	jmp	memory_tw
   390                              <1> 
   391                              <1> memory_t3:
   392 00000448 8B07                <1> 	mov	eax, dword ptr [edi]
   393 0000044A F686A004000080      <1> 	test	byte ptr [esi+PSR], HALF_W
   394 00000451 750E                <1> 	jnz	memory_h2
   395                              <1> memory_tw:
   396 00000453 C1F810              <1> 	sar	eax, 16		; t3 = THIS.2.1.zero
   397 00000456 C1E808              <1> 	shr	eax, 8
   398 00000459 C3                  <1> 	ret
   399                              <1> 
   400                              <1> memory_h1:
   401 0000045A 0FC8                <1> 	bswap	eax		; already loaded but not swapped
   402 0000045C C1E008              <1> 	shl	eax, 8		; h1 = zero.HERE.2.3
   403 0000045F EB05                <1> 	jmp	memory_hw
   404                              <1> 
   405                              <1> memory_h2:
   406 00000461 0FC8                <1> 	bswap	eax		; already loaded but not swapped
   407 00000463 C1E014              <1> 	shl	eax, 8+12
   408                              <1> memory_hw:
   409 00000466 C1F80C              <1> 	sar	eax, 12
   410 00000469 C1E808              <1> 	shr	eax, 8
   411 0000046C C3                  <1> 	ret
   412                              <1> 
   413                              <1> ;	esi -> core.REGISTER
   414                              <1> 				; store system memory
   415                              <1> _burst_write4:
   416 0000046D 66B90700            <1> 	mov	cx, 7
   417 00000471 A900FFFF00          <1> 	test	eax, 00FFFF00h
   418 00000476 0F858A000000        <1> 	jnz	NEAR bus_write
   419                              <1> 
   420                              <1> 	; store emulated registers to emulated registers
   421                              <1> 
   422 0000047C F786A0040000000080- <1> 	test	dword ptr [esi+PSR], 0800000h	; ISR ?
   422 00000485 00                  <1>
   423 00000486 750A                <1> 	jnz	write4_registers	; ISRs may write some spare registers
   424 00000488 83F87C              <1> 	cmp	eax, 124
   425 0000048B 7605                <1> 	jna	write4_registers
   426 0000048D E9580A0000          <1> 	jmp	guard_ii_authority	; but applications may not write
   427                              <1> 					; any interrupt registers
   428                              <1> 
   429                              <1> write4_registers:
   430                              <1> ;	mov	edi, eax		; eax can be freed
   431                              <1> 
   432 00000492 8B4C9D00            <1> 	mov	ecx, dword ptr [ebp+ebx*4]	; data for store
   433                              <1> 					; ebp+ebx is a register number
   434                              <1> 					; which can be extra register locations
   435                              <1> 					; serving as workspace at the tail of
   436                              <1> 					; the register stack
   437                              <1> 
   438 00000496 890C86              <1> 	mov	dword ptr [esi+eax*4], ecx
   439 00000499 8B4C9D04            <1> 	mov	ecx, dword ptr [ebp+ebx*4+4]
   440 0000049D 894C8604            <1> 	mov	dword ptr [esi+eax*4+4], ecx
   441                              <1> 
   442 000004A1 8B4C9D08            <1> 	mov	ecx, dword ptr [ebp+ebx*4+2*4]
   443 000004A5 894C8608            <1> 	mov	dword ptr [esi+eax*4+2*4], ecx
   444 000004A9 8B4C9D0C            <1> 	mov	ecx, dword ptr [ebp+ebx*4+3*4]
   445 000004AD 894C860C            <1> 	mov	dword ptr [esi+eax*4+3*4], ecx
   446 000004B1 C3                  <1> 	ret
   447                              <1> 
   448                              <1> ;	esi -> core.REGISTER
   449                              <1> 
   450                              <1> _burst_write2:
   451 000004B2 66B90600            <1> 	mov	cx, 6
   452 000004B6 A900FFFF00          <1> 	test	eax, 00FFFF00h
   453 000004BB 7549                <1> 	jnz	bus_write
   454                              <1> 
   455                              <1> 	; store to emulated registers
   456                              <1> 
   457 000004BD F786A0040000000080- <1> 	test	dword ptr [esi+PSR], 0800000h	; ISR ?
   457 000004C6 00                  <1>
   458 000004C7 750A                <1> 	jnz	write2_registers	; there are spare registers at the end
   459 000004C9 83F87E              <1> 	cmp	eax, 126		; but applications may not write
   460 000004CC 7605                <1> 	jna	write2_registers	; any interrupt registers
   461 000004CE E9170A0000          <1> 	jmp	guard_ii_authority
   462                              <1> 
   463                              <1> write2_registers:
   464                              <1> ;	mov	edi, eax			; time to free eax
   465 000004D3 8B4C9D00            <1> 	mov	ecx, dword ptr [ebp+ebx*4]
   466 000004D7 890C86              <1> 	mov	dword ptr [esi+eax*4], ecx
   467 000004DA 8B4C9D04            <1> 	mov	ecx, dword ptr [ebp+ebx*4+4]
   468 000004DE 894C8604            <1> 	mov	dword ptr [esi+eax*4++4], ecx
   469 000004E2 C3                  <1> 	ret
   470                              <1> 
   471                              <1> ;	esi -> core.REGISTER
   472                              <1> 
   473                              <1> _operand_write:
   474 000004E3 A900FFFF00          <1> 	test	eax, 00FFFF00h
   475 000004E8 751C                <1> 	jnz	bus_write
   476                              <1> 
   477                              <1> _operand_write_register:
   478 000004EA A980000000          <1> 	test	eax, 80h		; in the interrupt registers?
   479 000004EF 7411                <1> 	jz	write1_register
   480 000004F1 F786A0040000000080- <1> 	test	dword ptr [esi+PSR], 0800000h
   480 000004FA 00                  <1>
   481 000004FB 7505                <1> 	jnz	write1_register
   482 000004FD E9E8090000          <1> 	jmp	guard_ii_authority
   483                              <1> 
   484                              <1> write1_register:
   485 00000502 891C86              <1> 	mov	dword ptr [esi+eax*4], ebx
   486 00000505 C3                  <1> 	ret
   487                              <1> 
   488                              <1> bus_write:				; write any memory
   489                              <1> 					;	eax <- EA
   490                              <1> 					;	ebx <- data | [ ebp + ebx * 4] -> 1st data word
   491                              <1> 					;	cl  <- encoding [ word * 1 / 2 / 4 ] / byte
   492                              <1> 					;	esi <- core
   493                              <1> 
   494                              <1> 
   495 00000506 E878040000          <1> 	call	base_write_pointer	; returns eax <- block
   496                              <1> 					;         edi <- EA
   497                              <1> 					;	  esi <- word offset
   498                              <1> 
   499 0000050B A900004000          <1> 	test	eax, 00400000h		; big block?
   500 00000510 741E                <1> 	jz	memory_write_4k_block	; no
   501 00000512 80F906              <1> 	cmp	cl, 6			; multiword operation?
   502 00000515 720D                <1> 	jb	bus_write_256k_block	; no
   503                              <1> 
   504 00000517 81FEFCFF0300        <1> 	cmp	esi, 03FFFCh		; near the edge?
   505 0000051D 7605                <1> 	jna	bus_write_256k_block	; no
   506                              <1> 
   507 0000051F E8B2200000          <1> 	call	write_straddle_18b?
   508                              <1> 
   509                              <1> bus_write_256k_block:
   510 00000524 A93F000000          <1> 	test	eax, 63			; a device array?
   511 00000529 7429                <1> 	jz	memory_write_page	; no. scaling shift will scrub bit 400000
   512 0000052B E9E6020000          <1> 	jmp	_device_write		; yes a device array
   513                              <1> 
   514                              <1> memory_write_4k_block:
   515 00000530 F7C600F00300        <1> 	test	esi, 0003F000h		; inside a 4k page?
   516 00000536 740A                <1> 	jz	memory_write_thru
   517 00000538 B90E000000          <1> 	mov	ecx, LP_ADDRESS
   518 0000053D E9AD090000          <1> 	jmp	guard_ii_escape		; no
   519                              <1> 
   520                              <1> memory_write_thru:
   521 00000542 80F906              <1> 	cmp	cl, 6			; multiword operation?
   522 00000545 720D                <1> 	jb	memory_write_page	; no
   523                              <1> 
   524 00000547 81FEFC0F0000        <1> 	cmp	esi, 0FFCh		; near the edge?
   525 0000054D 7605                <1> 	jna	memory_write_page	; no
   526                              <1> 
   527 0000054F E852200000          <1> 	call	write_straddle_12b?
   528                              <1> 
   529                              <1> memory_write_page:
   530                              <1> ;	mov	edi, dword ptr [ebp+CORE_INDEX1]
   531 00000554 0F7EFF              <1> 	movd	edi, mm7
   532                              <1> 
   533 00000557 3B87C0060000        <1> 	cmp	eax, dword ptr [edi+IO_PORT+_RAM_THRESHOLD] ; edi -> core registers
   534 0000055D 0F8887090000        <1> 	js	near guard_ii_authority	; guard the NVRAM whether real or emulated
   535                              <1> 
   536 00000563 C1E00C              <1> 	shl	eax, 12			; multiply by page and lose bit 00400000
   537                              <1> 
   538 00000566 01C6                <1> 	add	esi, eax		; add offset
   539                              <1> 
   540 00000568 BF[00000000]        <1> 	mov	edi, _memory
   541                              <1> 
   542                              <1> memory_write_on:
   543 0000056D 8D3CB7              <1> 	lea	edi, [edi+esi*4]
   544                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
   545 00000570 0F7EFE              <1> 	movd	esi, mm7
   546                              <1> 
   547                              <1> 	%if	0
   548                              <1> 	test	dword ptr [_general_indication], TOUCHPOINT
   549                              <1> 	jz	memory_write_on_go
   550                              <1> 
   551                              <1> 	cmp	edi, dword ptr [_touchpoint]
   552                              <1> 	js	memory_write_on_go
   553                              <1> 	cmp	edi, dword ptr [_touchpoint2]
   554                              <1> 	jns	memory_write_on_go
   555                              <1> 	jmp	guard_ii_authority
   556                              <1> 	%endif
   557                              <1> 
   558                              <1> memory_write_on_go:
   559 00000573 0FB6C1              <1> 	movzx	eax, cl
   560 00000576 8B0485[7F050000]    <1> 	mov	eax, dword ptr [write_action+eax*4]
   561 0000057D FFE0                <1> 	jmp	eax
   562                              <1> 
   563                              <1> write_action:
   564 0000057F [9F050000]          <1> 	dd	memory_write
   565 00000583 [A4050000]          <1> 	dd	write_t1
   566 00000587 [A8050000]          <1> 	dd	write_t2	; or h1
   567 0000058B [B5050000]          <1> 	dd	write_t3	; or h2
   568 0000058F [A3050000]          <1> 	dd	just_dont
   569 00000593 [A3050000]          <1> 	dd	just_dont
   570 00000597 [EF050000]          <1> 	dd	memory_write2
   571 0000059B [01060000]          <1> 	dd	memory_write4
   572                              <1> 
   573                              <1> memory_write:					; store system memory 1 word
   574 0000059F 0FCB                <1> 	bswap	ebx
   575 000005A1 891F                <1> 	mov	dword ptr [edi], ebx
   576                              <1> 
   577                              <1> just_dont:
   578 000005A3 C3                  <1> 	ret
   579                              <1> 
   580                              <1> write_t1:
   581 000005A4 885F01              <1> 	mov	byte ptr [edi+1], bl
   582 000005A7 C3                  <1> 	ret
   583                              <1> 
   584                              <1> write_t2:
   585 000005A8 F686A004000080      <1> 	test	byte ptr [esi+PSR], HALF_W
   586 000005AF 7511                <1> 	jnz	write_h1
   587 000005B1 885F02              <1> 	mov	byte ptr [edi+2], bl
   588 000005B4 C3                  <1> 	ret
   589                              <1> 
   590                              <1> write_t3:
   591 000005B5 F686A004000080      <1> 	test	byte ptr [esi+PSR], HALF_W
   592 000005BC 751A                <1> 	jnz	write_h2
   593 000005BE 885F03              <1> 	mov	byte ptr [edi+3], bl
   594 000005C1 C3                  <1> 	ret
   595                              <1> 
   596                              <1> write_h1:
   597 000005C2 8B07                <1> 	mov	eax, dword ptr [edi]
   598 000005C4 0FC8                <1> 	bswap	eax
   599 000005C6 81E3FF0F0000        <1> 	and	ebx, 4095
   600 000005CC C1E30C              <1> 	shl	ebx, 12
   601 000005CF 25FF0F0000          <1> 	and	eax, 4095
   602 000005D4 09D8                <1> 	or	eax, ebx
   603 000005D6 EB12                <1> 	jmp	write_hw
   604                              <1> 
   605                              <1> write_h2:
   606 000005D8 8B07                <1> 	mov	eax, dword ptr [edi]
   607 000005DA 0FC8                <1> 	bswap	eax
   608 000005DC C1E80C              <1> 	shr	eax, 12
   609 000005DF C1E00C              <1> 	shl	eax, 12
   610 000005E2 81E3FF0F0000        <1> 	and	ebx, 4095
   611 000005E8 09D8                <1> 	or	eax, ebx
   612                              <1> 
   613                              <1> write_hw:
   614 000005EA 0FC8                <1> 	bswap	eax
   615 000005EC 8907                <1> 	mov	dword ptr [edi], eax
   616 000005EE C3                  <1> 	ret
   617                              <1> 					; store system memory 2 words
   618                              <1> memory_write2:				; eax is already free
   619 000005EF 8B449D00            <1> 	mov	eax, dword ptr [ebp+ebx*4]
   620 000005F3 0FC8                <1> 	bswap	eax
   621 000005F5 8907                <1> 	mov	dword ptr [edi], eax
   622                              <1> 
   623 000005F7 8B449D04            <1> 	mov	eax, dword ptr [ebp+ebx*4+4]
   624 000005FB 0FC8                <1> 	bswap	eax
   625 000005FD 894704              <1> 	mov	dword ptr [edi+4], eax
   626 00000600 C3                  <1> 	ret
   627                              <1> 
   628                              <1> memory_write4:					; store system memory 4 words
   629 00000601 8B449D00            <1> 	mov	eax, dword ptr [ebp+ebx*4]	; bx is a register number and may
   630                              <1> 						; identify extra workspace registers
   631                              <1> 						; at register stack tail
   632 00000605 0FC8                <1> 	bswap	eax
   633 00000607 8907                <1> 	mov	dword ptr [edi], eax
   634 00000609 8B449D04            <1> 	mov	eax, dword ptr [ebp+ebx*4+4]
   635 0000060D 0FC8                <1> 	bswap	eax
   636 0000060F 894704              <1> 	mov	dword ptr [edi+4], eax
   637 00000612 8B449D08            <1> 	mov	eax, dword ptr [ebp+ebx*4+8]
   638 00000616 0FC8                <1> 	bswap	eax
   639 00000618 894708              <1> 	mov	dword ptr [edi+2*4], eax
   640 0000061B 8B449D0C            <1> 	mov	eax, dword ptr [ebp+ebx*4+12]
   641 0000061F 0FC8                <1> 	bswap	eax
   642 00000621 89470C              <1> 	mov	dword ptr [edi+3*4], eax
   643 00000624 C3                  <1> 	ret
   644                              <1> 
   645                              <1> ;	modify instructions n inc dec src slc sim popA
   646                              <1> ;	rewrite here
   647                              <1> 
   648                              <1> 
   649                              <1> memoreg_writeback:
   650                              <1> 	%if	1
   651 00000625 21FF                <1> 	and	edi, edi
   652 00000627 7509                <1> 	jnz	memory_direct
   653 00000629 25FFFFFF00          <1> 	and	eax, 00FFFFFFh			; unchanged esi -> core.REGISTER	
   654 0000062E 89049E              <1> 	mov	[esi+ebx*4+REGISTER], eax	; platform endian
   655                              <1> 						; register writeback index ebx ->
   656 00000631 C3                  <1> 	ret
   657                              <1> 	%else
   658                              <1> 
   659                              <1> 
   660                              <1> 	test	ebx, -256			; save EA is ?
   661                              <1> 	jnz	memory_direct			; a memory device
   662                              <1> 	xchg	eax, ebx			; a register
   663                              <1> 	and	ebx, 00FFFFFFh
   664                              <1> 	jmp	_operand_write_register		; esi -> core.REGISTER
   665                              <1> 
   666                              <1> ;	if not a register rewrite
   667                              <1> ;	n inc dec src slc sim popA
   668                              <1> ;	write RTA memory at its saved platform address
   669                              <1> 	%endif
   670                              <1> 
   671                              <1> memory_direct:					; esi <- memory_offset
   672 00000632 0FC8                <1> 	bswap	eax				; write components edi esi kept from base_read
   673 00000634 30C0                <1> 	xor	al, al				
   674 00000636 8904B7              <1> 	mov	dword ptr [edi+esi*4], eax
   675 00000639 C3                  <1> 	ret
   676                              <1> 
   677                              <1> 
   678                              <1> ;	execute calls memory read
   679                              <1> ;	ea < 256 is not for execute a register
   680                              <1> ;	operand is at a readable address in system memory or array
   681                              <1> 
   682                              <1> memory_read:					; for execute and modify instructions:
   683 0000063A E867000000          <1> 	call	memory_point			; read only executable space
   684 0000063F 8B04B7              <1> 	mov	eax, dword ptr [edi+esi*4]	; and similar memory types
   685 00000642 0FC8                <1> 	bswap	eax
   686 00000644 C3                  <1> 	ret
   687                              <1> 
   688                              <1> ;	modify instructions n inc dec src slc sim popA call here
   689                              <1> ;	ea < 256 is a register
   690                              <1> 
   691                              <1> memoreg:					; read-modify-write registers / system memory
   692 00000645 A900FFFFFF          <1> 	test	eax, -256			; but nothing marked as a peripheral bus
   693 0000064A 751A                <1> 	jnz	memory_read_lock
   694 0000064C A880                <1> 	test	al, 128				; interrupt register?
   695 0000064E 740E                <1> 	jz	register_read_for_write		; no, clear to update
   696 00000650 F686A204000080      <1> 	test	byte ptr [esi+PSR+2], 128	; ISR ?
   697 00000657 7505                <1> 	jnz	register_read_for_write
   698 00000659 E98C080000          <1> 	jmp	guard_ii_authority
   699                              <1> 
   700                              <1> register_read_for_write:			; unchanged esi -> core.REGISTER
   701 0000065E 89C3                <1>         mov     ebx, eax                        ; copy of ea -> registers to memoreg_writeback
   702 00000660 31FF                <1>         xor     edi, edi                        ; tell memoreg->writeback that's how it is, no device
   703 00000662 8B0486              <1>         mov     eax, dword ptr [esi+REGISTER+eax*4]
   704 00000665 C3                  <1>         ret					; register writeback index ebx ->
   705                              <1> 
   706                              <1> 
   707                              <1> ;	RAM boundary in port 124 defines the upper page limit
   708                              <1> ;	of a real or emulated NVRAM containing the fixed system image
   709                              <1> 
   710                              <1> ;	fixed system image may be kernel + loader in a dozen pages
   711                              <1> ;	or it may be the entire application
   712                              <1> 
   713                              <1> ;	emulated machine applies the update limit
   714                              <1> ;	whether NVRAM is emulated or real
   715                              <1> 
   716                              <1> ;	if not a register
   717                              <1> ;	n inc dec src slc sim popA read a memory word which is legal to write
   718                              <1> ;	and keep the platform address to write the modified value
   719                              <1> ;	modify instructions do not lock memory between read and rewrite
   720                              <1> 
   721                              <1> memory_read_lock:
   722 00000666 E806000000          <1> 	call	memory_lock
   723 0000066B 8B04B7              <1> 	mov	eax, dword ptr [edi+esi*4]
   724 0000066E 0FC8                <1> 	bswap	eax
   725 00000670 C3                  <1> 	ret
   726                              <1> 
   727                              <1> ;	memory_read_lock calls here for modify instructions if ea > registers
   728                              <1> ;	ts calls here with ea whatever range always -> memory
   729                              <1> 
   730                              <1> ;	ea must be a legally writable memory word
   731                              <1> ;	memory_lock does not lock but identifies a platform write address  
   732                              <1> ;	ts reads / unconditionally replaces word.t1
   733                              <1> ;	under platform locking protocol, xchg platform instruction
   734                              <1> 
   735                              <1> memory_lock:					; point for update
   736                              <1> 						; barred below RAM boundary as write is
   737 00000671 E80D030000          <1> 	call	base_write_pointer		; resolve device:block:offset from EA
   738                              <1> 						; edi <- core.REGISTERS <- esi
   739                              <1> 						; eax <- memory block index
   740                              <1> 						; esi <- memory word offset
   741                              <1> 
   742                              <1> ;	mov	edi, dword ptr [ebp+CORE_INDEX1]
   743 00000676 0F7EFF              <1> 	movd	edi, mm7
   744                              <1> 
   745 00000679 A900004000          <1> 	test	eax, 00400000h			; update block name is a big bank ?
   746 0000067E 7419                <1> 	jz	memory_lock_page		; no
   747 00000680 A93F000000          <1> 	test	eax, 63				; a device outside executable space ?
   748 00000685 754D                <1> 	jnz	_yspace_read			; yes
   749 00000687 25FFFF3F00          <1> 	and	eax, 003FFFFFh			; bit 0400000 is gets stripped later anyway
   750 0000068C 3B87C0060000        <1> 	cmp	eax, dword ptr [edi+IO_PORT+_RAM_THRESHOLD]	; below RAM boundary?
   751 00000692 7339                <1> 	jnb	_xspace_read			; no, go ahead
   752 00000694 E951080000          <1> 	jmp	guard_ii_authority
   753                              <1> 
   754                              <1> memory_lock_page:
   755 00000699 3B87C0060000        <1> 	cmp	eax, dword ptr [edi+IO_PORT+_RAM_THRESHOLD]	; below RAM boundary?
   756 0000069F 731A                <1> 	jnb	_xspace_read4K			; no, go head if offset < 1000 hex
   757 000006A1 E944080000          <1> 	jmp	guard_ii_authority
   758                              <1> 
   759                              <1> 
   760                              <1> ;	memory_read calls here for execute
   761                              <1> ;	identify a platform read address of an RTA memory word
   762                              <1> 
   763                              <1> memory_point:
   764 000006A6 E844020000          <1> 	call	base_read_pointer		; edi <- core.REGISTERS <- esi
   765                              <1> 						; esi <- word offset in memory block
   766 000006AB A900004000          <1> 	test	eax, 00400000h			; eax <- page index
   767 000006B0 7409                <1> 	jz	_xspace_read4K
   768                              <1> 
   769 000006B2 A93F000000          <1> 	test	eax, 63
   770 000006B7 7414                <1> 	jz	_xspace_read
   771 000006B9 EB19                <1> 	jmp	_yspace_read			; ie a device either appropriate or not
   772                              <1> 
   773                              <1> _xspace_read4K:
   774 000006BB F7C600F00300        <1> 	test	esi, 003F000h
   775 000006C1 740A                <1> 	jz	_xspace_read
   776 000006C3 B90E000000          <1> 	mov	ecx, LP_ADDRESS
   777 000006C8 E922080000          <1> 	jmp	guard_ii_escape
   778                              <1> 
   779                              <1> _xspace_read:
   780 000006CD BF[00000000]        <1> 	mov	edi, _memory
   781 000006D2 EB34                <1> 	jmp	_memory_deliver			; device array zero
   782                              <1> 
   783                              <1> _yspace_read:
   784 000006D4 A900008000          <1> 	test	eax, 00800000h			; a tripsy non-space?
   785 000006D9 7533                <1> 	jnz	_zspace_read			; not allowed
   786                              <1> 
   787 000006DB 89C7                <1> 	mov	edi, eax
   788 000006DD 83E73F              <1> 	and	edi, 63
   789 000006E0 8BBCBED0060000      <1> 	mov	edi, dword ptr [esi+IO_PORT+_DEVICE+edi*4]
   790 000006E7 F7C700008000        <1> 	test	edi, SYSMEM_FLAG
   791 000006ED 741F                <1> 	jz	_zspace_read
   792 000006EF F7C700004000        <1> 	test	edi, DATA16_FLAG
   793 000006F5 7517                <1> 	jnz	_zspace_read
   794                              <1> 
   795 000006F7 C1E002              <1> 	shl	eax, 2				; al = 4 * device index
   796 000006FA 0FB6F8              <1> 	movzx	edi, al
   797                              <1> 
   798 000006FD 8BBF[00000000]      <1> 	mov	edi, dword ptr [_devices+edi]	; and platform pointers are also 32-bit
   799 00000703 30C0                <1> 	xor	al, al				; necessary to lose the device bits now
   800 00000705 C1E802              <1> 	shr	eax, 2
   801                              <1> 
   802                              <1> _memory_deliver:
   803 00000708 C1E00C              <1> 	shl	eax, 12		; multiply by page and lose bit 00400000
   804 0000070B 01C6                <1> 	add	esi, eax
   805                              <1> 
   806                              <1> 	%if	__SMP
   807                              <1> 	%else
   808                              <1> 	mov	eax, dword ptr [edi+esi*4]
   809                              <1> 	bswap	eax
   810                              <1> 	%endif
   811 0000070D C3                  <1> 	ret
   812                              <1> 
   813                              <1> _zspace_read:
   814 0000070E E9D7070000          <1> 	jmp	guard_ii_authority
   815                              <1> 
   816                              <1> ;	esi -> core
   817                              <1> 
   818                              <1> ;	sub-architectural measure on sabr and reload instructions
   819                              <1> 
   820                              <1> ;	check the target memory block is in range and the bus characteristic
   821                              <1> ;	of the memory device when selecting blocks of memory, not when
   822                              <1> ;	accessing them. Use 8 spare bits in the word containing _base[]
   823                              <1> ;	for a quick recall of the emulated bus attribute on reference
   824                              <1> 
   825                              <1> ;	because this software emulation needs to act differently for
   826                              <1> 
   827                              <1> ;		executable space	rta1 24-bit words canonical memory
   828                              <1> ;					modeled in platform 32-bit words
   829                              <1> 
   830                              <1> ;		shared network buffers	16-bit words canonical in memory
   831                              <1> ;					and zero extend on readout to RTA1
   832                              <1> 
   833                              <1> ;		24-bit filestore array	3-octet words stored big-endian
   834                              <1> ;					in packed array
   835                              <1> 
   836                              <1> ;	concept RTA1 device arrays with bus behaviour differences are completely
   837                              <1> ;	emulated on PC emulations because device arrays are modeled in PC RAM.
   838                              <1> 
   839                              <1> ;	Various bus behaviours are emulated transparently to RTA1 target software
   840                              <1> ;	in anticipation	that different memories for different uses may be attached
   841                              <1> ;	on product boards, making core-emulated RTA1s much more efficient for not
   842                              <1> ;	needing this part of emulation
   843                              <1> 
   844                              <1> ;	devices
   845                              <1> 
   846                              <1> ;	device 0 is always executable space, but there may be more devices
   847                              <1> ;	with bus characteristics like device 0. The device descriptors are
   848                              <1> 
   849                              <1> ;		_________________________________________________________________
   850                              <1> ;		| 16 bits flags	| 16 bits banks	|       32 bits pointer		|
   851                              <1> ;		|_______________|____high index_|_______________________________|
   852                              <1> 
   853                              <1> 
   854                              <1> ;	[out]	sabr	[go]	[call]	reload instructions call here
   855                              <1> ;	go and call can probably check quicker themself
   856                              <1> ;	out can be trusted because applications don't out memory _base[] ports
   857                              <1> 
   858                              <1> ;	a big block in an RTA1 address window is 262144 words.
   859                              <1> ;	this checking concerns address windows tagged 2..63
   860                              <1> ;	a device is an array up to 65536 big blocks or banks
   861                              <1> 
   862                              <1> ;	you get here with the relocation handle in ebx
   863                              <1> ;	and the target window tag in eax, because that is the EA of a sabr instruction
   864                              <1> 
   865                              <1> device_read:				; readout device arrays
   866 00000713 A900008000          <1>         test    eax, 0800000h           ; the vilainous bank index?
   867 00000718 7537                <1>         jnz     device_read_escape
   868                              <1> 
   869                              <1> 					; edi -> core.REGISTER
   870 0000071A C1E002              <1> 	shl	eax, 2			; al is device index * 4
   871 0000071D 50                  <1> 	push	eax			; rest of eax is block index * 4
   872 0000071E 0FB6C0              <1> 	movzx	eax, al			; extend device number
   873                              <1> 					; sense device descriptor
   874                              <1> 
   875                              <1> ;	mov	edi, dword ptr [ebp+CORE_INDEX1]
   876 00000721 0F7EFF              <1> 	movd	edi, mm7
   877                              <1> 
   878 00000724 F68438D2060000C0    <1> 	test	byte ptr [edi+eax+IO_PORT+_DEVICE+2], 192
   879                              <1> 
   880 0000072C 58                  <1> 	pop	eax			; recover storage block index
   881                              <1> 
   882 0000072D 7422                <1> 	jz	device_read_escape	; neither type flag set
   883                              <1> 
   884 0000072F 9C                  <1> 	pushfd				; sign is set for descriptor bit 23	
   885                              <1> 					; parity is set if both bits are
   886                              <1> 
   887 00000730 8AAFA0040000        <1> 	mov	ch, byte ptr [edi+PSR]	; flag field with byte options for memory read
   888 00000736 0FB6F8              <1> 	movzx	edi, al			; device select
   889                              <1> 
   890 00000739 30C0                <1> 	xor	al, al			; add storage block to offset
   891 0000073B C1E00A              <1> 	shl	eax, 10			; block index * 64 * 4 now times 262144
   892 0000073E 01C6                <1> 	add	esi, eax		; offset += <-
   893                              <1> 
   894 00000740 8BBF[00000000]      <1> 	mov	edi,  dword ptr [_devices+edi]
   895                              <1> 
   896                              <1> 					; known that one or two bits is set
   897 00000746 58                  <1> 	pop	eax			; flags from test of device	
   898                              <1> 
   899 00000747 A804                <1> 	test	al, 4			; parity?
   900 00000749 755C                <1> 	jnz	device_read_array24	; parity -> 2 bits set -> FSYS24 bus
   901                              <1> 
   902 0000074B A880                <1> 	test	al, 128			; sign -> descriptor bit 23 -> SYSMEM
   903 0000074D 7411                <1> 	jz	device_read_data16	; otherwise NET16 trunk
   904 0000074F EB0A                <1> 	jmp	device_read_sysmem	; system memory type if yes				
   905                              <1> 
   906                              <1> device_read_escape:
   907 00000751 B90E000000          <1> 	mov	ecx, LP_ADDRESS
   908 00000756 E994070000          <1> 	jmp	guard_ii_escape
   909                              <1> 
   910                              <1> 
   911                              <1> device_read_sysmem:			; readout system memory array
   912 0000075B E95EFCFFFF          <1> 	jmp	memory_read_on		; allow all variations partial word / multiword
   913                              <1> 
   914                              <1> device_read_data16:			; readout 16-bit array
   915                              <1> 
   916 00000760 80F907              <1> 	cmp	cl, 7
   917 00000763 741A                <1> 	jz	device_read_data16_4
   918 00000765 80F906              <1> 	cmp	cl, 6
   919 00000768 7409                <1> 	jz	device_read_data16_2
   920 0000076A EB00                <1> 	jmp	device_read_data16_1
   921                              <1> 
   922                              <1> device_read_data16_1:			; readout 1 word of 16-bit array
   923 0000076C 0FB70477            <1> 	movzx	eax, word ptr [edi+esi*2]
   924 00000770 86E0                <1> 	xchg	ah, al
   925 00000772 C3                  <1> 	ret
   926                              <1> 
   927                              <1> device_read_data16_2:			; readout 2 words of 16-bit array
   928 00000773 8B0477              <1> 	mov	eax, dword ptr [edi+esi*2]	; 4.3.2.1
   929 00000776 0FC8                <1> 	bswap	eax				; 1.2.3.4
   930 00000778 0FB7D8              <1> 	movzx	ebx, ax				; 0.0.3.4
   931 0000077B C1E810              <1> 	shr	eax, 16				; 0.0.1.2
   932 0000077E C3                  <1> 	ret
   933                              <1> 
   934                              <1> device_read_data16_4:			; readout 4 words of 16-bit array
   935 0000077F 8B0477              <1> 	mov	eax, dword ptr [edi+esi*2]
   936 00000782 0FC8                <1> 	bswap	eax				; 1.2.3.4
   937 00000784 0FB7C8              <1> 	movzx	ecx, ax
   938 00000787 C1E810              <1> 	shr	eax, 16
   939 0000078A 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   940 0000078E 894C9D04            <1> 	mov	dword ptr [ebp+ebx*4+4], ecx
   941                              <1> 
   942 00000792 8B447704            <1> 	mov     eax, dword ptr [edi+esi*2+4]
   943 00000796 0FC8                <1> 	bswap	eax				; 5.6.7.8
   944 00000798 0FB7C8              <1> 	movzx	ecx, ax
   945 0000079B C1E810              <1> 	shr	eax, 16
   946 0000079E 89449D08            <1> 	mov	dword ptr [ebp+ebx*4+8], eax
   947 000007A2 894C9D0C            <1> 	mov	dword ptr [ebp+ebx*4+12], ecx
   948 000007A6 C3                  <1> 	ret
   949                              <1> 
   950                              <1> device_read_array24:			; readout from packed 24-bit array
   951 000007A7 E83C010000          <1> 	call	device_array24_setpointer
   952                              <1> 
   953 000007AC 80F907              <1> 	cmp	cl, 7
   954 000007AF 7440                <1> 	jz	device_read_array24_4
   955 000007B1 80F906              <1> 	cmp	cl, 6
   956 000007B4 7430                <1> 	jz	device_read_array24_2
   957 000007B6 EB00                <1> 	jmp	device_read_array24_1
   958                              <1> 
   959                              <1> device_read_array24_1:			; readout a word of packed 24-bit array
   960 000007B8 660FB60437          <1> 	movzx	ax, byte ptr [edi+esi]
   961 000007BD C1E008              <1> 	shl	eax, 8
   962 000007C0 8A443701            <1> 	mov	al, byte ptr [edi+esi+1]
   963 000007C4 C1E008              <1> 	shl	eax, 8
   964 000007C7 8A443702            <1> 	mov	al, byte ptr [edi+esi+2]
   965 000007CB 83C603              <1> 	add	esi, 3
   966 000007CE C3                  <1> 	ret
   967                              <1> 
   968                              <1> device_read_array24_1R:
   969 000007CF 660FB61C37          <1> 	movzx	bx, byte ptr [edi+esi]
   970 000007D4 C1E308              <1> 	shl	ebx, 8
   971 000007D7 8A5C3701            <1> 	mov	bl, byte ptr [edi+esi+1]
   972 000007DB C1E308              <1> 	shl	ebx, 8
   973 000007DE 8A5C3702            <1> 	mov	bl, byte ptr [edi+esi+2]
   974 000007E2 83C603              <1> 	add	esi, 3
   975 000007E5 C3                  <1> 	ret
   976                              <1> 
   977                              <1> device_read_array24_2:			; readout 2 words of packed 24-bit array
   978 000007E6 E8CDFFFFFF          <1> 	call	device_read_array24_1
   979 000007EB E8DFFFFFFF          <1> 	call	device_read_array24_1R
   980 000007F0 C3                  <1> 	ret
   981                              <1> 
   982                              <1> device_read_array24_4:			; readout 4 words of packed 24-bit array
   983 000007F1 E8C2FFFFFF          <1> 	call	device_read_array24_1
   984 000007F6 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   985 000007FA E8B9FFFFFF          <1> 	call	device_read_array24_1
   986 000007FF 89449D04            <1> 	mov	dword ptr [ebp+ebx*4+4], eax
   987 00000803 E8B0FFFFFF          <1> 	call	device_read_array24_1
   988 00000808 89449D08            <1> 	mov	dword ptr [ebp+ebx*4+8], eax
   989 0000080C E8A7FFFFFF          <1> 	call	device_read_array24_1
   990 00000811 89449D0C            <1> 	mov	dword ptr [ebp+ebx*4+12], eax
   991 00000815 C3                  <1> 	ret
   992                              <1> 
   993                              <1> _device_write:				; store device arrays
   994 00000816 A900008000          <1> 	test	eax, 0800000h		; the vilainous bank index?
   995 0000081B 7537                <1> 	jnz	device_write_escape
   996                              <1> 
   997                              <1>                                         ; edi -> core.REGISTER
   998 0000081D C1E002              <1>         shl     eax, 2                  ; al is device index * 4
   999 00000820 50                  <1>         push    eax                     ; rest of eax is block index * 4
  1000 00000821 0FB6C0              <1>         movzx   eax, al                 ; extend device number
  1001                              <1>                                         ; sense device descriptor
  1002                              <1> 
  1003                              <1> ;	mov	edi, dword ptr [ebp+CORE_INDEX1]
  1004 00000824 0F7EFF              <1> 	movd	edi, mm7
  1005                              <1> 
  1006 00000827 F68438D2060000C0    <1>         test    byte ptr [edi+eax+IO_PORT+_DEVICE+2], 192
  1007                              <1> 
  1008 0000082F 58                  <1>         pop     eax                     ; recover storage block index
  1009                              <1> 
  1010 00000830 7422                <1>         jz      device_write_escape      ; neither type flag set
  1011                              <1> 
  1012 00000832 9C                  <1>         pushfd                          ; sign is set for descriptor bit 23     
  1013                              <1>                                         ; parity is set if both bits are
  1014                              <1> 
  1015 00000833 8AAFA0040000        <1>         mov     ch, byte ptr [edi+PSR]  ; flag field with byte options for memory read
  1016 00000839 0FB6F8              <1>         movzx   edi, al                 ; device select
  1017                              <1> 
  1018 0000083C 30C0                <1>         xor     al, al                  ; add storage block to offset
  1019 0000083E C1E00A              <1>         shl     eax, 10                 ; block index * 64 * 4 now times 262144
  1020 00000841 01C6                <1>         add     esi, eax                ; offset += <-
  1021                              <1> 
  1022 00000843 8BBF[00000000]      <1>         mov     edi,  dword ptr [_devices+edi]
  1023                              <1> 
  1024                              <1>                                         ; known that one or two bits is set
  1025 00000849 58                  <1>         pop     eax                     ; flags from test of device     
  1026                              <1> 
  1027 0000084A A804                <1>         test    al, 4                   ; parity?
  1028 0000084C 754E                <1>         jnz     device_write_array24    ; parity -> 2 bits set -> FSYS24 bus
  1029 0000084E A880                <1>         test    al, 128                 ; sign -> descriptor bit 23 -> SYSMEM
  1030 00000850 7411                <1>         jz      device_write_data16     ; otherwise NET16 trunk
  1031 00000852 EB0A                <1>         jmp     device_write_sysmem     ; system memory type if yes                     
  1032                              <1> 
  1033                              <1> device_write_escape:
  1034 00000854 B90E000000          <1> 	mov	ecx, LP_ADDRESS
  1035 00000859 E991060000          <1> 	jmp	guard_ii_escape
  1036                              <1> 
  1037                              <1> 
  1038                              <1> device_write_sysmem:
  1039 0000085E E90AFDFFFF          <1> 	jmp	memory_write_on		; allow all variations partial word / multiword
  1040                              <1> 
  1041                              <1> device_write_data16:
  1042                              <1> 
  1043 00000863 80F907              <1> 	cmp	cl, 7
  1044 00000866 740E                <1> 	jz	device_write_data16_4
  1045 00000868 80F906              <1> 	cmp	cl, 6
  1046 0000086B 741C                <1> 	jz	device_write_data16_2
  1047 0000086D EB00                <1> 	jmp	device_write_data16_1
  1048                              <1> 
  1049                              <1> device_write_data16_1:			; store 16-bit array
  1050 0000086F 86FB                <1> 	xchg	bh, bl
  1051 00000871 66891C77            <1> 	mov	word ptr [edi+esi*2], bx
  1052 00000875 C3                  <1> 	ret
  1053                              <1> 
  1054                              <1> 
  1055                              <1> device_write_data16_4:			; store 4 words in 16-bit array
  1056                              <1> 					; low-order half is swapped on bus read
  1057                              <1> 					; and canonical in eax
  1058 00000876 668B449D08          <1> 	mov	ax, word ptr [ebp+ebx*4+8]	; get low-order half 3rd register
  1059 0000087B C1E010              <1> 	shl	eax, 16				; 5.6.0.0
  1060 0000087E 668B449D0C          <1> 	mov	ax, word ptr [ebp+ebx*4+12]	; 5.6.7.8
  1061 00000883 0FC8                <1> 	bswap	eax				; it's correct so swap for bus write
  1062 00000885 89447704            <1> 	mov	dword ptr [edi+esi*2+4], eax
  1063                              <1> 
  1064                              <1> 
  1065                              <1> device_write_data16_2:			; store 2 words in 16-bit array
  1066                              <1> 					; registers are modeled in storage
  1067                              <1> 					; so each bus read corrects an octet pair
  1068                              <1> 
  1069 00000889 668B449D00          <1> 	mov	ax, word ptr [ebp+ebx*4]	; get low-order half 1st register
  1070 0000088E C1E010              <1> 	shl	eax, 16				; 1.2.0.0
  1071 00000891 668B449D04          <1> 	mov	ax, word ptr [ebp+ebx*4+4]	; 1.2.3.4
  1072 00000896 0FC8                <1> 	bswap	eax				; it's correct, so swap for bus write
  1073 00000898 890477              <1> 	mov	dword ptr [edi+esi*2], eax
  1074 0000089B C3                  <1> 	ret
  1075                              <1> 
  1076                              <1> device_write_array24:			; store 24-bit packed array
  1077 0000089C E847000000          <1> 	call	device_array24_setpointer
  1078                              <1> 
  1079 000008A1 80F907              <1> 	cmp	cl, 7
  1080 000008A4 7434                <1> 	jz	device_write_array24_4
  1081 000008A6 80F906              <1> 	cmp	cl, 6
  1082 000008A9 741C                <1> 	jz	device_write_array24_2
  1083 000008AB EB00                <1> 	jmp	device_write_array24_1
  1084                              <1> 
  1085                              <1> device_write_array24_1:			; store 1 word in packed 24-bit array
  1086 000008AD 89D8                <1> 	mov	eax, ebx
  1087                              <1> device_write_array24_x:
  1088 000008AF C1C010              <1> 	rol	eax, 16
  1089 000008B2 880437              <1> 	mov	byte ptr [edi+esi], al
  1090 000008B5 C1C008              <1> 	rol	eax, 8
  1091 000008B8 88443701            <1> 	mov	byte ptr [edi+esi+1], al
  1092 000008BC C1C008              <1> 	rol	eax, 8
  1093 000008BF 88443702            <1> 	mov	byte ptr [edi+esi+2], al
  1094 000008C3 83C603              <1> 	add	esi, 3
  1095 000008C6 C3                  <1> 	ret
  1096                              <1> 
  1097                              <1> device_write_array24_2:			; store 2 words in packed 24-bit array
  1098 000008C7 8B449D00            <1> 	mov	eax, [ebp+ebx*4]
  1099 000008CB E8DFFFFFFF          <1> 	call	device_write_array24_x
  1100 000008D0 8B449D04            <1> 	mov	eax, [ebp+ebx*4+4]
  1101 000008D4 E8D6FFFFFF          <1> 	call	device_write_array24_x
  1102                              <1> ;	add	ebx, 2
  1103 000008D9 C3                  <1> 	ret
  1104                              <1> 
  1105                              <1> device_write_array24_4:			; store 4 words in packed 24-bit array
  1106 000008DA E8E8FFFFFF          <1> 	call	device_write_array24_2
  1107 000008DF 83C302              <1> 	add	ebx, 2
  1108 000008E2 E8E0FFFFFF          <1> 	call	device_write_array24_2
  1109 000008E7 C3                  <1> 	ret
  1110                              <1> 
  1111                              <1> device_array24_setpointer:
  1112 000008E8 89F0                <1> 	mov	eax, esi			; think of a number
  1113 000008EA D1E0                <1> 	shl	eax, 1				; double it
  1114 000008EC 01C6                <1> 	add	esi, eax			; add it to the number you first thought of...
  1115 000008EE C3                  <1> 	ret
  1116                              <1> 
    31                                  	%include	"base_map.msm"
     1                              <1> base_read_pointer:
     2 000008EF 89C7                <1> 	mov	edi, eax		; keep EA for +words reads
     3                              <1> 					; straddling storage blocks
     4 000008F1 C1C910              <1> 	ror	ecx, 16			; conserve designator / word counts
     5                              <1> 
     6 000008F4 C1C812              <1> 	ror	eax, 18
     7 000008F7 A83F                <1> 	test	al, 63
     8 000008F9 750C                <1> 	jnz	read_address18
     9 000008FB C1C006              <1> 	rol	eax, 6
    10 000008FE 660FB6C8            <1> 	movzx	cx, al
    11 00000902 C1E814              <1> 	shr	eax, 32-12
    12                              <1> 					; advise caller address 6.12
    13 00000905 EB07                <1> 	jmp	resolve_read_tag	; this path is  most storage reads
    14                              <1> 	
    15                              <1> read_address18:
    16 00000907 660FB6C8            <1> 	movzx	cx, al
    17 0000090B C1E80E              <1> 	shr	eax, 32-18
    18                              <1> 
    19                              <1> resolve_read_tag:
    20                              <1> 
    21 0000090E 80E13F              <1> 	and	cl, 63
    22 00000911 7418                <1> 	jz	read_window_clear	; everyone may read B0
    23 00000913 F6C138              <1> 	test	cl, 56
    24 00000916 7513                <1> 	jnz	read_window_clear
    25 00000918 80F10F              <1> 	xor	cl, 15			; [ 1 2 3 4 5 6 7 ] -> 8 + [ 6 5 4 3 2 1 0]
    26 0000091B 660FA38EA0040000    <1> 	bt	word ptr [esi+PSR], cx	; in memory bytes ffff f00c 0xxx xxxx
    27 00000923 7303                <1> 	jnc	read_application_window	; x86 bus read -> 0xxx xxxx ffff f00c
    28 00000925 80C940              <1> 	or	cl, 64
    29                              <1> 
    30                              <1> read_application_window:
    31 00000928 80F10F              <1> 	xor	cl, 15			; [ 1 2 3 4 5 6 7 ] <- 8 + [ 6 5 4 3 2 1 0]
    32                              <1> 
    33                              <1> read_window_clear:
    34 0000092B 50                  <1> 	push	eax
    35 0000092C 0FB6C1              <1> 	movzx	eax, cl
    36 0000092F 8B8486D0040000      <1> 	mov	eax, dword ptr [esi+eax*4+IO_PORT]
    37 00000936 5E                  <1> 	pop	esi
    38                              <1> 
    39 00000937 C1C910              <1> 	ror	ecx, 16
    40 0000093A C3                  <1> 	ret
    41                              <1> 
    42 0000093B FF00800000000000    <1> write_rule	db	255, 0, 128, 0, 0, 0, 0, 0
    43 00000943 0000000000000000    <1> 		db	0, 0, 0, 0, 0, 0, 0, 0
    44 0000094B 0000000000000000    <1> 		db	0, 0, 0, 0, 0, 0, 0, 0
    45 00000953 0000000000000000    <1> 		db	0, 0, 0, 0, 0, 0, 0, 0
    46 0000095B 0000000000000000    <1> 		db	0, 0, 0, 0, 0, 0, 0, 0
    47 00000963 0000000000000000    <1> 		db	0, 0, 0, 0, 0, 0, 0, 0
    48 0000096B 0000000000000000    <1> 		db	0, 0, 0, 0, 0, 0, 0, 0
    49 00000973 0000000000000000    <1> 		db	0, 0, 0, 0, 0, 0, 0, 0
    50 0000097B FF80808080808080    <1> 		db	255, 128, 128, 128, 128, 128, 128, 128
    51                              <1> 
    52                              <1> base_write_pointer:
    53                              <1> 
    54 00000983 89C7                <1> 	mov	edi, eax		; keep EA for +words writes
    55 00000985 C1C910              <1> 	ror	ecx, 16			; straddling storage blocks
    56                              <1> 					; protect designators in ecx
    57 00000988 C1C812              <1> 	ror	eax, 18			
    58                              <1> 
    59 0000098B A83F                <1> 	test	al, 63
    60 0000098D 750C                <1> 	jnz	write_address18
    61 0000098F C1C006              <1> 	rol	eax, 6
    62 00000992 660FB6C8            <1> 	movzx	cx, al
    63 00000996 C1E814              <1> 	shr	eax, 32-12
    64 00000999 EB07                <1> 	jmp	resolve_write_tag	; this path is
    65                              <1> 					; most storge writes
    66                              <1> write_address18:
    67 0000099B 660FB6C8            <1> 	movzx	cx, al
    68 0000099F C1E80E              <1> 	shr	eax, 32-18
    69                              <1> 	
    70                              <1> resolve_write_tag:
    71                              <1> 
    72 000009A2 80E13F              <1> 	and	cl, 63
    73 000009A5 0F843F050000        <1> 	jz	near guard_ii_authority	; no-one may write B0
    74 000009AB F6C138              <1> 	test	cl, 56
    75 000009AE 7513                <1> 	jnz	write_window_known
    76 000009B0 80F10F              <1> 	xor	cl, 15			; [ 1 2 3 4 5 6 7 ] -> 8 + [ 6 5 4 3 2 1 0]
    77 000009B3 660FA38EA0040000    <1> 	bt	word ptr [esi+PSR], cx		; in memory bytes ffff f00c 0xxx xxxx
    78 000009BB 7303                <1> 	jnc	write_application_window	; x86 bus read -> 0xxx xxxx ffff f00c
    79 000009BD 80C940              <1> 	or	cl, 64
    80                              <1> 
    81                              <1> write_application_window:
    82 000009C0 80F10F              <1> 	xor	cl, 15			; [ 1 2 3 4 5 6 7 ] <- 8 + [ 6 5 4 3 2 1 0]
    83                              <1> 
    84                              <1> write_window_known:
    85 000009C3 50                  <1> 	push	eax
    86 000009C4 0FB6C1              <1> 	movzx	eax, cl
    87 000009C7 F680[3B090000]80    <1> 	test	byte ptr [eax+write_rule], 128
    88 000009CE 740D                <1> 	jz	write_window_free
    89 000009D0 F686A204000080      <1> 	test	byte ptr [esi+PSR+2], 128	; ISR ?
    90 000009D7 0F840D050000        <1> 	jz	near guard_ii_authority		; the unbalanced push is harmless
    91                              <1> 						; stack is reset on faults
    92                              <1> write_window_free:
    93 000009DD 8B8486D0040000      <1> 	mov	eax, dword ptr [esi+eax*4+IO_PORT]
    94 000009E4 5E                  <1> 	pop	esi
    95                              <1> 
    96 000009E5 C1C910              <1> 	ror	ecx, 16		; restore designator information
    97 000009E8 C3                  <1> 	ret
    32                                  	%include	"sr.msm"
     1                              <1> 
     2                              <1> ;	read staging register
     3                              <1> ;	read bits from a stream of bits
     4                              <1> 
     5 000009E9 8B4E50              <1> _rsr:	mov	ecx, dword ptr [esi+RDATAC]
     6 000009EC 88CD                <1> 	mov	ch, cl
     7 000009EE 88C1                <1> 	mov	cl, al
     8                              <1> 
     9 000009F0 31C0                <1> 	xor	eax, eax
    10 000009F2 F786A0040000400000- <1> 	test	dword ptr [esi+PSR], B_STREAMZR
    10 000009FB 00                  <1>
    11 000009FC 7503                <1> 	jnz	_rsr_zadd
    12 000009FE 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
    13                              <1> _rsr_zadd:
    14 00000A01 20C9                <1> 	and	cl, cl
    15 00000A03 7450                <1> 	jz	_rsr_x
    16 00000A05 8B5E54              <1> 	mov	ebx, dword ptr [esi+RDATA]
    17                              <1> 
    18 00000A08 20ED                <1> 	and	ch, ch			; any data loaded yet?
    19 00000A0A 740F                <1> 	jz	_rsr_read		; if not read first no question 
    20 00000A0C 38CD                <1> 	cmp	ch, cl			; otherwise, already enough for request?
    21 00000A0E 7330                <1> 	jnb	_rsr_draw		; if so deliver data
    22 00000A10 28E9                <1> 	sub	cl, ch			; if not trim the oustanding count
    23 00000A12 86CD                <1> 	xchg	cl, ch			
    24 00000A14 E8090F0000          <1> 	call	dsl			; and deliver available data
    25 00000A19 86E9                <1> 	xchg	ch, cl			; before reading some more
    26                              <1> _rsr_read:
    27 00000A1B E894000000          <1> 	call	stream_read
    28                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]	; after call to operand_read
    29 00000A20 0F7EFE              <1> 	movd	esi, mm7
    30                              <1> 
    31 00000A23 C7465018000000      <1> 	mov	dword ptr [esi+RDATAC], 24
    32 00000A2A F786A0040000200000- <1> 	test	dword ptr [esi+PSR], B_STREAM16R
    32 00000A33 00                  <1>
    33 00000A34 740A                <1> 	jz	_rsr_draw
    34 00000A36 C7465010000000      <1> 	mov	dword ptr [esi+RDATAC], 16
    35 00000A3D C1E308              <1> 	shl	ebx, 8
    36                              <1> _rsr_draw:
    37 00000A40 6651                <1> 	push	cx
    38 00000A42 E8DB0E0000          <1> 	call	dsl
    39 00000A47 6659                <1> 	pop	cx
    40 00000A49 81E1FF000000        <1> 	and	ecx, 255
    41 00000A4F 294E50              <1> 	sub	dword ptr [esi+RDATAC], ecx
    42 00000A52 895E54              <1> 	mov	dword ptr [esi+RDATA], ebx
    43                              <1> _rsr_x:
    44 00000A55 894510              <1> 	mov	dword ptr [ebp+A], eax
    45 00000A58 C3                  <1> 	ret
    46                              <1> 
    47                              <1> 
    48                              <1> ;	write staging register
    49                              <1> ;	write bits to a stream of bits
    50                              <1> 
    51 00000A59 8B4E58              <1> _wsr:	mov	ecx, dword ptr [esi+WDATAC]
    52 00000A5C 88CD                <1> 	mov	ch, cl					; accumulated count
    53 00000A5E 88C1                <1> 	mov	cl, al					; new request
    54                              <1> 
    55 00000A60 8B465C              <1> 	mov	eax, dword ptr [esi+WDATA]	; accumulated data
    56 00000A63 8B5D10              <1> 	mov	ebx, dword ptr [ebp+A]		; source new data
    57                              <1> 
    58 00000A66 80C5E8              <1> 	add	ch, -24				; space for new data expressed negative
    59 00000A69 F786A0040000100000- <1> 	test	dword ptr [esi+PSR], B_STREAM16W	; 16 bits / word flag
    59 00000A72 00                  <1>
    60 00000A73 7403                <1> 	jz	_wsr24
    61 00000A75 80C508              <1> 	add	ch, 8
    62                              <1> 
    63 00000A78 00CD                <1> _wsr24:	add	ch, cl			; increment towards zero
    64 00000A7A 7404                <1> 	jz	_wsr_write		; accumulated word exactly full
    65 00000A7C 731D                <1> 	jnc	_wsr_add		; not yet full
    66                              <1> 
    67 00000A7E 28E9                <1> 	sub	cl, ch			; full + some more
    68                              <1> 
    69                              <1> _wsr_write:
    70 00000A80 E89D0E0000          <1> 	call	dsl			; fill output word
    71 00000A85 88E9                <1> 	mov	cl, ch			; position outstanding count
    72 00000A87 E83D000000          <1> 	call	stream_write
    73                              <1> 
    74                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]	; after call to operand_write
    75 00000A8C 0F7EFE              <1> 	movd	esi, mm7
    76                              <1> 
    77 00000A8F B800000000          <1> 	mov	eax, 0
    78 00000A94 C7465800000000      <1> 	mov	dword ptr [esi+REGISTER+WDATAC], 0
    79                              <1> 
    80                              <1> _wsr_add:
    81 00000A9B 6651                <1> 	push	cx
    82 00000A9D E8800E0000          <1> 	call	dsl			; add to output word
    83 00000AA2 6659                <1> 	pop	cx
    84 00000AA4 81E1FF000000        <1> 	and	ecx, 255		; format ecx for add to accumulated count 
    85 00000AAA 014E58              <1> 	add	dword ptr [esi+REGISTER+WDATAC], ecx
    86 00000AAD 89465C              <1> 	mov	dword ptr [esi+REGISTER+WDATA], eax
    87 00000AB0 895D10              <1> 	mov	dword ptr [ebp+A], ebx
    88 00000AB3 C3                  <1> 	ret
    89                              <1> 
    90                              <1> stream_read:
    91 00000AB4 51                  <1> 	push	ecx
    92 00000AB5 50                  <1> 	push	eax
    93 00000AB6 8B4534              <1> 	mov	eax, dword ptr [ebp+Q]
    94 00000AB9 83453401            <1> 	add	dword ptr [ebp+Q], 1
    95 00000ABD 30C9                <1> 	xor	cl, cl
    96 00000ABF E88DF8FFFF          <1> 	call	_operand_read
    97 00000AC4 89C3                <1> 	mov	ebx, eax
    98 00000AC6 58                  <1> 	pop	eax
    99 00000AC7 59                  <1> 	pop	ecx
   100 00000AC8 C3                  <1> 	ret
   101                              <1> 
   102                              <1> stream_write:
   103 00000AC9 51                  <1> 	push	ecx
   104 00000ACA 53                  <1> 	push	ebx
   105 00000ACB 89C3                <1> 	mov	ebx, eax
   106 00000ACD 8B4530              <1> 	mov	eax, dword ptr [ebp+P]
   107 00000AD0 83453001            <1> 	add	dword ptr [ebp+P], 1
   108 00000AD4 30C9                <1> 	xor	cl, cl
   109 00000AD6 E808FAFFFF          <1> 	call	_operand_write
   110 00000ADB 5B                  <1> 	pop	ebx
   111 00000ADC 59                  <1> 	pop	ecx
   112 00000ADD C3                  <1> 	ret
   113                              <1> 
    33                                  	%include	"io.msm"
     1 00000ADE 8B9C86D0040000      <1> _inA:	mov	ebx, dword ptr [esi+IO_PORT+eax*4]
     2 00000AE5 895D10              <1> 	mov	dword ptr [ebp+A], ebx
     3 00000AE8 C3                  <1> _inA_:	ret
     4                              <1> 
     5 00000AE9 8B9C86D0040000      <1> _inB:	mov	ebx, dword ptr [esi+IO_PORT+eax*4]
     6 00000AF0 895D14              <1> 	mov	dword ptr [ebp+B], ebx
     7 00000AF3 C3                  <1> _inB_:	ret
     8                              <1> 
     9 00000AF4 8B5D10              <1> _outA:	mov	ebx, dword ptr [ebp+A]
    10 00000AF7 E9AF010000          <1> 	jmp	oport
    11                              <1> 
    12 00000AFC 8B5D14              <1> _outB:	mov	ebx, dword ptr [ebp+B]
    13 00000AFF E9A7010000          <1> 	jmp	oport
    14                              <1> 
    15                              <1> 
    16                              <1> ISR_ONLY equ	8
    17                              <1> MEMTYPE	equ	1
    18                              <1> MEMZERONLY equ	2
    19                              <1> EXTERNAL_IO equ	4
    20                              <1> BROADCAST equ	16
    21                              <1> 
    22                              <1> B_1	equ	MEMTYPE
    23                              <1> B_TCB	equ	MEMTYPE+ISR_ONLY
    24                              <1> B_KERN	equ	MEMTYPE+ISR_ONLY
    25                              <1> A_THREP	equ	MEMZERONLY+ISR_ONLY
    26                              <1> I_PORT	equ	EXTERNAL_IO
    27                              <1> O_PORT	equ	EXTERNAL_IO
    28                              <1> O_INDICA equ	EXTERNAL_IO
    29                              <1> O_CHILL	equ	EXTERNAL_IO
    30                              <1> I_TZONE	equ	EXTERNAL_IO
    31                              <1> RAM_THRESH equ	ISR_ONLY+MEMZERONLY
    32                              <1> XI_ACK	equ	ISR_ONLY+EXTERNAL_IO
    33                              <1> O_LEDS	equ	EXTERNAL_IO
    34                              <1> O_SYSSWCH equ	EXTERNAL_IO
    35                              <1> O_INC	equ	ISR_ONLY+EXTERNAL_IO
    36                              <1> O_MCAST	equ	ISR_ONLY+BROADCAST
    37                              <1> 
    38                              <1> 
    39                              <1> mask_port_outAB:
    40 00000B04 000100000000000000- <1> 	db    0,B_1,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    40 00000B0D 00000000000000      <1>
    41 00000B14 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    41 00000B1D 00000000000000      <1>
    42                              <1> 
    43 00000B24 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    43 00000B2D 00000000000000      <1>
    44 00000B34 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    44 00000B3D 00000000000000      <1>
    45                              <1> 
    46 00000B44 0009090909090909    <1> 	db	0,B_TCB,B_KERN,B_KERN,  B_KERN,B_KERN,B_KERN,B_KERN
    47 00000B4C 0A00000C0C000018    <1> 	db	A_THREP,0,0,XI_ACK,     O_INC,0,0,O_MCAST
    48                              <1> 
    49 00000B54 0404040404040404    <1> 	db	I_PORT,I_PORT,I_PORT,I_PORT,  I_PORT,I_PORT,I_PORT,I_PORT
    50 00000B5C 0404040404040404    <1> 	db	O_PORT,O_PORT,O_PORT,O_PORT,  O_PORT,O_PORT,O_PORT,O_PORT
    51                              <1> 
    52 00000B64 0000000000040404    <1> 	db	0,0,0,0,  0,I_TZONE,O_INDICA,O_CHILL
    53 00000B6C 0000000000000000    <1> 	db	0,0,0,0,  0,0,0,0
    54 00000B74 0000000000000000    <1> 	db	0,0,0,0,  0,0,0,0
    55 00000B7C 0000000000000404    <1> 	db	0,0,0,0,  0,0,O_SYSSWCH,O_LEDS
    56                              <1> 
    57 00000B84 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    57 00000B8D 00000000000000      <1>
    58 00000B94 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    58 00000B9D 00000000000000      <1>
    59 00000BA4 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    59 00000BAD 00000000000000      <1>
    60 00000BB4 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    60 00000BBD 00000000000000      <1>
    61                              <1> 
    62                              <1> 					; outA|B rules flags per I/O port
    63                              <1> 
    64                              <1> _reload:
    65 00000BC4 50                  <1> 	push	eax
    66 00000BC5 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
    67 00000BC8 83451002            <1> 	add	dword ptr [ebp+A], 2
    68 00000BCC E83EF7FFFF          <1> 	call	_burst_read2
    69 00000BD1 5F                  <1> 	pop	edi
    70 00000BD2 8984BED0040000      <1> 	mov	dword ptr [esi+IO_PORT+edi*4], eax
    71 00000BD9 899CBED4040000      <1> 	mov	dword ptr [esi+IO_PORT+edi*4+4], ebx
    72 00000BE0 C3                  <1> 	ret
    34                                  	%include	"sabr.msm"
     1                              <1> ;	check and write to I/O port <- storage base index in range [ 2..63 ]
     2                              <1> ;	write a copy to reload base table in thread control block
     3                              <1> ;	values out of memory range are replaced with trap device C00001
     4                              <1> ;	which causes GUARD$ exception if the sindow is accessed
     5                              <1> 
     6                              <1> ;	anauthorised actions
     7                              <1> ;
     8                              <1> ;		attempt to write window base < 2 or > 63
     9                              <1> ;		application selecting ISR space
    10                              <1> ;		application selecting NVRAM
    11                              <1> ;
    12                              <1> ;	are not carried out and a GUARD$ exception is raised
    13                              <1> ;	ISRs write the trap device C00001 to close memory windows
    14                              <1> 
    15                              <1> _sabr_guard:
    16 00000BE1 E904030000          <1> 	jmp	guard_ii_authority
    17                              <1> 
    18 00000BE6 A93E000000          <1> _sabr:	test	eax, 03Eh		; ea not < 2
    19 00000BEB 74F4                <1> 	jz	_sabr_guard
    20 00000BED A9C0FFFF00          <1> 	test	eax, 0FFFFC0h		; ea not > 63
    21 00000BF2 75ED                <1> 	jnz	_sabr_guard
    22                              <1> 
    23 00000BF4 8B4D10              <1> 	mov	ecx, dword ptr [ebp+A]
    24                              <1> 
    25 00000BF7 F7C100004000        <1> 	test	ecx, 00400000h
    26 00000BFD 7463                <1> 	jz	memory_page
    27 00000BFF F7C13F000000        <1> 	test	ecx, 63
    28 00000C05 7455                <1> 	jz	large_memory_page
    29                              <1> 
    30 00000C07 F7C100008000        <1> 	test	ecx, 00800000h
    31 00000C0D 740B                <1> 	jz	array_attribute
    32                              <1> 
    33 00000C0F F686A204000080      <1> 	test	byte ptr [esi+PSR+2], 128
    34 00000C16 74C9                <1> 	jz	_sabr_guard
    35 00000C18 EB70                <1> 	jmp	unthru			; ISR write illegal device thru
    36                              <1> 					; closes the address space window
    37                              <1> 
    38                              <1> 					; application may not write device
    39                              <1> 					; but may zero -> sabr  with same effect
    40                              <1> array_attribute:
    41                              <1> 
    42 00000C1A C1E102              <1> 	shl	ecx, 2
    43 00000C1D 0FB6D9              <1> 	movzx	ebx, cl			; cl = device * 4
    44                              <1> 
    45                              <1> 	%if	0
    46                              <1> 	mov	edi, dword ptr [_devices+ebx]
    47                              <1> 	%endif
    48                              <1> 
    49 00000C20 8B9C33D0060000      <1> 	mov	ebx, dword ptr [esi+ebx+IO_PORT+_DEVICE]
    50                              <1> 					; platform address + device descriptor
    51                              <1> 
    52                              <1> 
    53                              <1> 	%if	0
    54                              <1> 	mov	dword ptr [esi+eax*8+DATAFRAME], ebx	; rapid recall
    55                              <1> 	mov	dword ptr [esi+eax*8+DATAFRAME+4], edi	; device information
    56                              <1> 	%endif						; via window tag
    57                              <1> 
    58 00000C27 C1E908              <1> 	shr	ecx, 6+2		; lose previous shift + device code
    59 00000C2A F7C300004000        <1> 	test	ebx, 00400000h
    60 00000C30 750A                <1> 	jnz	peripheral_array
    61 00000C32 F7C300008000        <1> 	test	ebx, 00800000h
    62 00000C38 751D                <1> 	jnz	memory_array
    63                              <1> 
    64 00000C3A EBA5                <1> 	jmp	_sabr_guard		; no device code
    65                              <1> 
    66                              <1> peripheral_array:			; device types 00C00000 00400000
    67 00000C3C F686A204000080      <1> 	test	byte ptr [esi+PSR+2], 128
    68 00000C43 749C                <1> 	jz	_sabr_guard
    69                              <1> 
    70 00000C45 81E1FFFF0000        <1> 	and	ecx, 0000FFFFh		; have # large blocks in low 16 bits
    71 00000C4B 81E3FFFF0000        <1> 	and	ebx, 0000FFFFh
    72 00000C51 29CB                <1> 	sub	ebx, ecx
    73 00000C53 7932                <1> 	jns	thru
    74 00000C55 EB29                <1> 	jmp	_sabr_safeguard
    75                              <1> 
    76                              <1> memory_array:
    77 00000C57 C1E106              <1> 	shl	ecx, 6			; block * 64
    78 00000C5A EB14                <1> 	jmp	memory_array_bound?
    79                              <1> 
    80                              <1> large_memory_page:
    81 00000C5C 81E1FFFFBF00        <1> 	and	ecx, 00BFFFFFh		; remove 00400000 bit for lower bound check
    82                              <1> 
    83                              <1> memory_page:
    84 00000C62 8B9ED0060000        <1> 	mov	ebx, dword ptr [esi+IO_PORT+_DEVICE]	; device zero memory attribute
    85 00000C68 3B8EF0050000        <1> 	cmp	ecx, dword ptr [esi+IO_PORT+_APP_THRESHOLD]	; ISR / application boundary
    86 00000C6E 7210                <1> 	jb	_sabr_safeguard
    87                              <1> 
    88                              <1> memory_array_bound?:
    89 00000C70 81E1FFFFBF00        <1> 	and	ecx, 00BFFFFFh		; bit 00800000 is a bad accident
    90 00000C76 81E3FFFF3F00        <1> 	and	ebx, 003FFFFFh		; stop it here
    91 00000C7C 29CB                <1> 	sub	ebx, ecx
    92 00000C7E 7907                <1> 	jns	thru
    93                              <1> 
    94                              <1> _sabr_safeguard:
    95 00000C80 B90100C000          <1> 	mov	ecx, 00C00001h
    96 00000C85 EB03                <1> 	jmp	unthru
    97                              <1> 
    98 00000C87 8B4D10              <1> thru:	mov	ecx, dword ptr [ebp+A]		; i.e. correct as supplied
    99 00000C8A 898C86D0040000      <1> unthru:	mov	dword ptr [esi+eax*4+IO_PORT], ecx
   100                              <1> 
   101 00000C91 BF[00000000]        <1> 	mov	edi, _memory
   102 00000C96 8B9ED4050000        <1> 	mov	ebx, dword ptr [esi+IO_PORT+65*4] ; thread control block
   103                              <1> 
   104 00000C9C C1E30C              <1> 	shl	ebx, 12			; multiply to TCB size
   105 00000C9F 01C3                <1> 	add	ebx, eax		; ea is target base index
   106 00000CA1 0FC9                <1> 	bswap	ecx			; for this is a big endian memory write
   107 00000CA3 898C9F00010000      <1> 	mov	dword ptr [edi+ebx*4+64*4], ecx
   108 00000CAA C3                  <1> 	ret				; save TCB reload copy of loaded pointer
    35                                  	%include	"oport.msm"
     1                              <1> 
     2                              <1> OOO_TRACE	equ	0
     3                              <1> 
     4                              <1> 							; static void oport(int ea, int value, smp *xcore)
     5                              <1> 							; {
     6                              <1> oport:		; write I / O port			;    int		 rule,
     7                              <1> 		; RTA instructions outA outB		;			 device;
     8                              <1> 							; 
     9                              <1> 		; ports which are memory pointers	;    int		 mask,
    10                              <1> 		; must have a block that exists		;			 from,
    11                              <1> 		; ISRs can write trap value C00001 	;                 	 index;
    12                              <1> 		; = device 400001 | illegal 800000	; 
    13                              <1> 		; port # = effective address = eax	;    int		 device_index = 0;
    14                              <1> 		; write value in ebx			; 
    15                              <1> 		; multicast bits in RTA register k	;    smp		*ascor;
    16                              <1> 		 					;    unsigned	*register_set = xcore->register_set;
    17 00000CAB 3DC0000000          <1> 	cmp	eax, IO_PORTS				; 
    18 00000CB0 0F8393000000        <1> 	jnb	near no_port				;    if (ea < IO_PORTS)
    19                              <1> 							;    {
    20 00000CB6 8A88[040B0000]      <1> 	mov	cl, byte ptr [eax+mask_port_outAB]	;       rule = mask_port_outAB[ea];
    21 00000CBC 20C9                <1> 	and	cl, cl					; 
    22 00000CBE 0F8485000000        <1> 	jz	near no_rule				;       if (rule)
    23 00000CC4 F6C108              <1> 	test	cl, ISR_ONLY				;       {
    24 00000CC7 740D                <1> 	jz	application_plus_isr_rule		;          if (((rule & ISR_ONLY) == 0) || (psr & 0x00800000))
    25 00000CC9 F686A204000080      <1> 	test	byte ptr [esi+PSR+2], 128		;          {
    26 00000CD0 0F8473000000        <1> 	jz	near no_authority				;
    27                              <1> 							;
    28                              <1> application_plus_isr_rule:				;
    29 00000CD6 F6C104              <1> 	test	cl, EXTERNAL_IO				;             if (rule & EXTERNAL_IO)
    30 00000CD9 7423                <1> 	jz	broadcast_rule?				;             {
    31 00000CDB 899C86D0040000      <1> 	mov	dword ptr [esi+IO_PORT+eax*4], ebx	;                base[ea] = value;
    32 00000CE2 83F866              <1> 	cmp	eax, 102	; INDICATION$		;                if (ea == 102) indication |= value;
    33 00000CE5 7506                <1> 	jne	xi_ack?		 			;
    34 00000CE7 099E94040000        <1> 	or	dword ptr [esi+INDICATION], ebx		;
    35                              <1>  							;
    36                              <1> xi_ack?:							;
    37 00000CED 83F84B              <1> 	cmp	eax, 75					;                if (ea == 75)
    38 00000CF0 750B                <1> 	jne	xi_no_ack				;                {
    39 00000CF2 F6D3                <1> 	not	bl					;                    base[74] &= (value & 255) ^ 255;
    40 00000CF4 0FB6DB              <1> 	movzx	ebx, bl					;                    // indication |= (value & 255) << 8;
    41                              <1> 							;                }
    42 00000CF7 219EF8050000        <1> 	and	dword ptr [esi+IO_PORT+_XI_PENDING], ebx	; 
    43                              <1> xi_no_ack:						; //               if ((ea == 79) && (value & 1)) indication |= ATTENTION;
    44 00000CFD C3                  <1> 	ret						;                return;
    45                              <1> 							;             }
    46                              <1> 							; 
    47                              <1> broadcast_rule?:					;             if (rule & BROADCAST)
    48 00000CFE F6C110              <1> 	test	cl, BROADCAST				;             {
    49 00000D01 744B                <1> 	jz	memory_rule?				;                mask = k;
    50                              <1> 
    51                              <1> 	%if	OOO_TRACE
    52                              <1> 	inc	dword ptr [esi+REGISTER+282*4]
    53                              <1> 	%endif
    54                              <1> 
    55 00000D03 52                  <1> 	push	edx	; borrow the program counter	;
    56                              <1> 
    57                              <1> 	%if	1
    58 00000D04 8B96F4050000        <1> 	mov	edx, dword ptr [esi+IO_PORT+_CORE_PIN]	;
    59                              <1> 	%else
    60                              <1> 	mov	ecx, dword ptr [esi+IO_PORT+_CORE_SOCKET] ;
    61                              <1> 	mov	edx, 1					;
    62                              <1> 	shl	edx, cl		; source identifier bit	;
    63                              <1> 	%endif
    64                              <1> 							;
    65 00000D0A BF[00000000]        <1> 	mov	edi, _core				;
    66 00000D0F 8B4D04              <1> 	mov	ecx, dword ptr [ebp+REGISTER+K]		;
    67 00000D12 238EC4060000        <1> 	and	ecx, dword ptr [esi+IO_PORT+_CORES_MASK] ;
    68                              <1> 							;
    69                              <1> multicast_select:					;
    70 00000D18 D1E9                <1> 	shr	ecx, 1					;                from = base[77];
    71 00000D1A 7321                <1> 	jnc	multicast_next				; 
    72                              <1> 
    73 00000D1C 21DB                <1> 	and	ebx, ebx	; if all of it is zero
    74 00000D1E 7416                <1> 	jz	multicast_time
    75                              <1> 
    76                              <1> ;	write the port unless this is a dayclock update	;  
    77                              <1> 
    78 00000D20 899C86D0040000      <1> 	mov	dword ptr [esi+IO_PORT+eax*4], ebx	;                for (index = 0; index < RTA_SMP; index++)
    79 00000D27 099708060000        <1>         or      dword ptr [edi+IO_PORT+_MCAST_PENDING], edx ;            {
    80 00000D2D 808F9404000080      <1>         or      byte ptr [edi+INDICATION], ATTENTION    ;                   if (mask & 1)
    81 00000D34 EB07                <1> 	jmp	multicast_next
    82                              <1> 
    83                              <1> multicast_time:
    84 00000D36 808F9404000020      <1> 	or	byte ptr [edi+INDICATION], TPULSE
    85                              <1> 							;                   {
    86                              <1> multicast_next:						;                      ascor = core + index;
    87 00000D3D 81C7D0070000        <1> 	add	edi, CORE_SIZE				;                      ascor->BASE[78] |= 1 << from;
    88                              <1> ;	shr	ecx, 1					;                      ascor->INDICATION |= ATTENTION;
    89 00000D43 21C9                <1> 	and	ecx, ecx				;                   }
    90 00000D45 75D1                <1> 	jnz	multicast_select			; 
    91 00000D47 5A                  <1> 	pop	edx	; give back the program counter	;
    92 00000D48 C3                  <1> 	ret						;                   mask >>= 1;
    93                              <1> 							;                }
    94                              <1> no_port:						; 
    95                              <1> no_rule:						;                /**************************************************
    96                              <1> no_authority:						; 			keep these on the sending side
    97                              <1> 							; 			until constructing interrupt frame
    98 00000D49 E99C010000          <1> 	jmp	guard_ii_authority			; 			between instructions at target core
    99                              <1> 							;                         to avoid overwrites from other cores
   100                              <1> 							;                **************************************************/
   101                              <1> 							; 
   102                              <1> 							;                base[ea] = value;	/* latent parameter	*/
   103                              <1> 							;                return;
   104                              <1> 							;             }
   105                              <1> 							; 
   106                              <1> memory_rule?:	; system memory type only		;             else if (rule & MEMTYPE)
   107                              <1> 
   108 00000D4E F6C101              <1> 	test	cl, MEMTYPE				;             {
   109 00000D51 7459                <1> 	jz	page_pointer?				;                if (value & 0x00400000) device_index = value & 63;
   110 00000D53 F7C300004000        <1> 	test	ebx, 0400000h	; bank sized?		; 
   111 00000D59 745E                <1> 	jz	memory_page_pointer			;                if (device_index)
   112                              <1> 							;                {
   113 00000D5B F7C33F000000        <1> 	test	ebx, 63					;                   if (value & 0x00800000)
   114 00000D61 7419                <1> 	jz	device_is_pointed			;                   {
   115 00000D63 F7C300008000        <1> 	test	ebx, 0800000h	; the trap device?	;                      if (psr & 0x00800000)
   116 00000D69 7411                <1> 	jz	device_is_pointed			;                      {
   117 00000D6B F686A204000080      <1> 	test	byte ptr [esi+PSR+2], 128	; ISR?		;                         base[ea] = value;
   118 00000D72 74D5                <1> 	jz	no_authority				;                         return;
   119 00000D74 899C86D0040000      <1> 	mov	[esi+IO_PORT+eax*4], ebx		;                      }
   120 00000D7B C3                  <1> 	ret						; 
   121                              <1> 							;                      GUARD_AUTHORITY
   122                              <1> device_is_pointed:					;                      return;
   123 00000D7C 8B8ED0060000        <1> 	mov	ecx, dword ptr [esi+IO_PORT+_DEVICE]	;                   }
   124 00000D82 F7C100008000        <1> 	test	ecx, 00800000h				;                }
   125 00000D88 74BF                <1> 	jz	no_authority				; 
   126 00000D8A F7C100004000        <1> 	test	ecx, 00400000h				;                device = base[128+device_index];
   127 00000D90 75B7                <1> 	jnz	no_authority				;            
   128 00000D92 81E1FFFF3F00        <1> 	and	ecx, 003FFFFFh				;                if ((device & 0x00C00000) == 0x00800000)
   129 00000D98 89DF                <1> 	mov	edi, ebx				;                {
   130 00000D9A 81E7FFFF3F00        <1> 	and	edi, 003FFFFFh	; catch any 00800000	;                   if ((value & 0x003FFFC0) > (device & 0x003FFFFF))
   131 00000DA0 39F9                <1> 	cmp	ecx, edi				;                   {
   132 00000DA2 7233                <1> 	jb	outwith		; beyond memory		;                   }
   133 00000DA4 899C86D0040000      <1> 	mov	[esi+IO_PORT+eax*4], ebx		;                   else
   134 00000DAB C3                  <1> 	ret						;                   {
   135                              <1> 							;                      base[ea] = value;
   136                              <1> 							;                      return;
   137                              <1> 							;                   }
   138                              <1> 							;                }
   139                              <1> 							;             }
   140                              <1> 							;             else
   141                              <1> 							;             {
   142                              <1> 							;                /*******************************************
   143                              <1> ;	only a device zero page index will do		; 			page pointer to system memory
   144                              <1> 							;                *******************************************/
   145                              <1> page_pointer?:						; 
   146 00000DAC F6C102              <1> 	test	cl, MEMZERONLY				;                if ((value & 0x00400000) == 0)
   147 00000DAF 7498                <1> 	jz	no_rule					;                {
   148 00000DB1 F7C30000C000        <1> 	test	ebx, 00C00000h				;                   if (value > (base[128] & 0x003FFFFF))
   149 00000DB7 7590                <1> 	jnz	no_authority				;                   {
   150                              <1> 							;                   }
   151                              <1> memory_page_pointer:					;                   else
   152 00000DB9 8B8ED0060000        <1> 	mov	ecx, dword ptr [esi+IO_PORT+_DEVICE]	;                   {
   153 00000DBF 81E1FFFF3F00        <1> 	and	ecx, 003FFFFFh				;                      base[ea] = value;
   154 00000DC5 81E3FFFFFF00        <1> 	and	ebx, 00FFFFFFh				;                      return;
   155 00000DCB 39D9                <1> 	cmp	ecx, ebx				;                   }
   156 00000DCD 7208                <1> 	jb	outwith					;                }
   157 00000DCF 899C86D0040000      <1> 	mov	dword ptr [esi+IO_PORT+eax*4], ebx		;             }
   158 00000DD6 C3                  <1> 	ret						;          }
   159                              <1> 							;       }
   160                              <1> 							;    }
   161                              <1> outwith:							; 
   162 00000DD7 B90E000000          <1> 	mov	ecx, LP_ADDRESS				;    GUARD_AUTHORITY;
   163 00000DDC E90E010000          <1> 	jmp	guard_ii_escape				; }							; 
    36                                  	%include	"ii.msm"
     1 00000DE1 660986A0040000      <1> _on:	or	word ptr [esi+PSR], ax	; only touch low-order 16 bits
     2 00000DE8 C3                  <1> 	ret
     3                              <1> 
     4 00000DE9 6683F0FF            <1> _off:	xor	ax, 0000FFFFh
     5 00000DED 662186A0040000      <1> 	and	word ptr [esi+PSR], ax	; only touch low-order 16 bits
     6 00000DF4 C3                  <1> 	ret
     7                              <1> 
     8                              <1> RELOAD_SMPP	equ	1
     9                              <1> III_TRACE	equ	0
    10                              <1> 
    11                              <1> _xi:
    12                              <1> 	%if	RELOAD_SMPP
    13                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
    14 00000DF5 0F7EFE              <1> 	movd	esi, mm7
    15                              <1> 	%endif
    16                              <1> 
    17 00000DF8 20E4                <1> 	and	ah, ah				; 8 external interrupts?
    18 00000DFA 741B                <1> 	jz	_xix_beat?			; nane
    19                              <1> 
    20 00000DFC 30C9                <1> 	xor	cl, cl
    21                              <1> 
    22                              <1> _xi_next:					; external interrupt pending signals[8]
    23 00000DFE 88A6F8050000        <1> 	mov	byte ptr [esi+IO_PORT+_XI_PENDING], ah	; position for inA|B from port XI_PENDING$	LL.mm.hh.zz
    24 00000E04 C6869504000000      <1> 	mov	byte ptr [esi+INDICATION+1], 0	; clear from platform indications fabric	ll.MM.hh.zz
    25 00000E0B 31C9                <1> 	xor	ecx, ecx			; clear latent param
    26 00000E0D B802000000          <1> 	mov	eax, II_XINT			; select external interrupt
    27                              <1> 
    28 00000E12 E902010000          <1> 	jmp	_ii_
    29                              <1> 
    30                              <1> _xix_beat?:
    31 00000E17 A820                <1> 	test	al, TPULSE
    32 00000E19 7438                <1> 	jz	_xix
    33                              <1> 
    34 00000E1B BF[00000000]        <1> 	mov	edi, _core					; always core zero so far
    35                              <1> 
    36                              <1> _xi_atn_dayclock:
    37 00000E20 8B8F58020000        <1>         mov     ecx, dword ptr [edi+REGISTER+DAYCLOCK_U]
    38 00000E26 8B9F5C020000        <1>         mov     ebx, dword ptr [edi+REGISTER+DAYCLOCK]
    39 00000E2C 3B8F58020000        <1>         cmp     ecx, dword ptr [edi+REGISTER+DAYCLOCK_U]
    40 00000E32 75EC                <1>         jnz     _xi_atn_dayclock
    41 00000E34 899E5C020000        <1>         mov     dword ptr [esi+REGISTER+DAYCLOCK], ebx
    42 00000E3A 898E58020000        <1>         mov     dword ptr [esi+REGISTER+DAYCLOCK_U], ecx
    43                              <1> 
    44 00000E40 8B9F64060000        <1>         mov     ebx, dword ptr [edi+IO_PORT+_TZONE]
    45 00000E46 899E64060000        <1>         mov     dword ptr [esi+IO_PORT+_TZONE], ebx
    46                              <1> 
    47 00000E4C 80A694040000DF      <1> 	and	byte ptr [esi+INDICATION], TPULSE^255
    48                              <1> 	
    49 00000E53 A880                <1> _xix:	test	al, ATTENTION					; core2core interrupt
    50 00000E55 0F8452000000        <1> 	jz	near _xiy
    51                              <1> 
    52 00000E5B 8B9E08060000        <1> 	mov	ebx, [esi+IO_PORT+_MCAST_PENDING]
    53 00000E61 BF[00000000]        <1> 	mov	edi, _core					; test bit progressing
    54 00000E66 52                  <1> 	push	edx
    55 00000E67 BAFEFFFFFF          <1> 	mov	edx, -2
    56 00000E6C 239EC4060000        <1> 	and	ebx, dword ptr [esi+IO_PORT+_CORES_MASK]
    57                              <1> 
    58                              <1> _xi_atn_sources:
    59 00000E72 D1EB                <1> 	shr	ebx, 1						; this source pending?
    60 00000E74 7317                <1> 	jnc	_xi_atn_source_next				; no
    61                              <1> 
    62 00000E76 219608060000        <1> 	and	dword ptr [esi+IO_PORT+_MCAST_PENDING], edx	; unpend
    63 00000E7C 8B8F0C060000        <1> 	mov	ecx, dword ptr [edi+IO_PORT+_MCAST_TO]		; latent parameter from sending side
    64                              <1> 
    65 00000E82 B805000000          <1> 	mov	eax, II_ATTENTION				; no
    66 00000E87 5A                  <1> 	pop	edx						; ragged but working ***
    67 00000E88 E98C000000          <1> 	jmp	_ii_						; _ii_ takes ecx for
    68                              <1> 								; interrupt latent parameter
    69                              <1> _xi_atn_source_next:
    70 00000E8D 81C7D0070000        <1> 	add	edi, CORE_SIZE
    71                              <1> ;	shr	ebx, 1						; MCAST_PENDING in line with edi -> core
    72 00000E93 D1C2                <1> 	rol	edx, 1						; MCAST_PENDING flag-off mask
    73 00000E95 21DB                <1> 	and	ebx, ebx					; no bits left = no more pending
    74 00000E97 75D9                <1> 	jnz	_xi_atn_sources					; expect from new interrupts
    75                              <1> 
    76                              <1> _xi_atn_sources_all:
    77                              <1> 
    78 00000E99 5A                  <1> 	pop	edx						; also popped if jump to _ii_ ***
    79                              <1> 
    80 00000E9A F78608060000FFFFFF- <1> 	test	dword ptr [esi+IO_PORT+_MCAST_PENDING], 00FFFFFFh
    80 00000EA3 00                  <1>
    81 00000EA4 7507                <1> 	jnz	_xi_atn_new_sources				; new interrupts flagged up, keep ATTENTION
    82 00000EA6 80A6940400007F      <1> 	and	byte ptr [esi+INDICATION], ATTENTION^255
    83                              <1> _xi_atn_new_sources:
    84                              <1> 
    85                              <1> 	%if	III_TRACE
    86                              <1> 	mov	eax, dword ptr [esi+IO_PORT+_MCAST_PENDING]
    87                              <1> 	mov	dword ptr [esi+REGISTER+281*4], eax
    88                              <1> 	%endif
    89                              <1> 
    90                              <1> _xiy:
    91                              <1> 	%if	1
    92                              <1> 
    93 00000EAD 8B8694040000        <1> 	mov	eax, dword ptr [esi+INDICATION]			; case we did _xix in the same sweep
    94 00000EB3 F6869404000040      <1> 	test	byte ptr [esi+INDICATION], INCREMENTER_CARRY	; nanosecond or other counter 
    95 00000EBA 7410                <1> 	jz	_xiz						; from minus to carrry on zero
    96                              <1> 								; to feed millisecond dayclock
    97 00000EBC 80A694040000BF      <1> 	and	byte ptr [esi+INDICATION], INCREMENTER_CARRY^255
    98 00000EC3 B804000000          <1> 	mov	eax, II_MSECOND
    99 00000EC8 31C9                <1> 	xor	ecx, ecx
   100 00000ECA EB4D                <1> 	jmp	_ii_
   101                              <1> 
   102                              <1> 	%endif
   103                              <1> 
   104 00000ECC C3                  <1> _xiz:	ret
   105                              <1> 
   106                              <1> _ii_instruction:
   107 00000ECD 89C3                <1> 	mov	ebx, eax
   108 00000ECF C1EB06              <1> 	shr	ebx, 6
   109 00000ED2 2B9EF0050000        <1> 	sub	ebx, dword ptr [esi+IO_PORT+_APP_THRESHOLD]	; application threshold
   110 00000ED8 7910                <1> 	jns	guard_ii_authority	; must have executed a character string
   111                              <1> 					; like 757575
   112 00000EDA A9C0FFFFFF          <1> 	test	eax, -64
   113 00000EDF 751C                <1> 	jnz	_ii			; not in restart page OK
   114 00000EE1 F686A204000080      <1> 	test	byte ptr [esi+PSR+2], 128	; psr + 1 in BE-speak LE:L_M_H_Z
   115 00000EE8 7513                <1> 	jnz	_ii			; ISR may interrupt to restart page
   116                              <1> 
   117                              <1> 		; service call application to restart page not allowed
   118                              <1> 		; most likely to be an accident
   119                              <1> 		; drop thru and be quelled
   120                              <1> 
   121                              <1> guard_ii_authority:
   122 00000EEA B901000000          <1> 	mov	ecx, LP_AUTHORITY
   123                              <1> guard_ii_escape:
   124 00000EEF B85F000000          <1> 	mov	eax, II_GUARD
   125                              <1> _ii_escape:
   126                              <1> 	%if	RELOAD_SMPP
   127                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]		; read register 152 or 280
   128 00000EF4 0F7EFE              <1> 	movd	esi, mm7
   129                              <1> 	%endif						; depending ebp -> application / ISR registers
   130                              <1> 
   131 00000EF7 8BA67C040000        <1> 	mov	esp, dword ptr [esi+REGISTER+287*4]	; read esp at start of _execute
   132                              <1> 
   133 00000EFD 83F85F              <1> _ii:	cmp	eax, II_GUARD
   134 00000F00 7517                <1> 	jnz	_ii_
   135 00000F02 F605[19000000]01    <1> 	test	byte ptr [_uflag+'Z'-'A'], 1		; break to debug console?
   136 00000F09 740E                <1> 	jz	_ii_					; not if not opted
   137 00000F0B 808E9404000002      <1> 	or	byte ptr [esi+INDICATION], LOCKSTEP
   138 00000F12 800D[00000000]02    <1> 	or	byte ptr [_general_indication], LOCKSTEP
   139                              <1> 	
   140 00000F19 8DAE00020000        <1> _ii_:	lea	ebp, [esi+128*4] 
   141                              <1> 
   142 00000F1F 89AE8C040000        <1> 	mov	dword ptr [esi+REGISTER_SET], ebp
   143 00000F25 C7869C040000800000- <1> 	mov	dword ptr [esi+ISELECT], 128
   143 00000F2E 00                  <1>
   144                              <1> 
   145 00000F2F 8B5D3C              <1> 	mov	ebx, dword ptr [ebp+S_P]
   146 00000F32 81FB00010000        <1> 	cmp	ebx, 256
   147 00000F38 0F87B9010000        <1> 	ja	near guard_stack
   148 00000F3E 83C3FC              <1> 	add	ebx, -4
   149                              <1> 
   150 00000F41 81FB9A000000        <1> 	cmp	ebx, 128+24+2
   151 00000F47 0F82AA010000        <1> 	jb	near guard_stack
   152 00000F4D 895D3C              <1> 	mov	dword ptr [ebp+S_P], ebx
   153                              <1> 
   154 00000F50 2B9688040000        <1> 	sub	edx, dword ptr [esi+B0P]
   155 00000F56 C1EA02              <1> 	shr	edx, 2
   156 00000F59 89549E0C            <1> 	mov	dword ptr [esi+ebx*4+REGISTER+3*4], edx	; save PC offset
   157 00000F5D 8B96A4040000        <1> 	mov	edx, dword ptr [esi+B0_NAME]
   158 00000F63 89549E08            <1> 	mov	dword ptr [esi+ebx*4+REGISTER+2*4], edx	; save bank ID
   159 00000F67 8B96A0040000        <1> 	mov	edx, dword ptr [esi+PSR]
   160 00000F6D 89549E04            <1> 	mov	dword ptr [esi+ebx*4+REGISTER+4], edx	; saved PSR
   161 00000F71 890C9E              <1> 	mov	dword ptr [esi+ebx*4+REGISTER], ecx	; latent parameter
   162 00000F74 F7C200008000        <1> 	test	edx, 00800000h				; nested interrupt ?
   163 00000F7A 7503                <1> 	jnz	_ii_ii
   164 00000F7C 895D38              <1> 	mov	dword ptr [ebp+FP], ebx			; if not, mark interrupted
   165                              <1> 							; application stack frame
   166                              <1> _ii_ii:
   167 00000F7F 81CA00008000        <1> 	or	edx, 00800000h				; ISR active
   168 00000F85 8996A0040000        <1> 	mov	dword ptr [esi+PSR], edx
   169                              <1> 
   170 00000F8B 89C2                <1> 	mov	edx, eax				; get to the operand
   171 00000F8D 83E23F              <1> 	and	edx, 63					; address from interrupt vector
   172 00000F90 C1E806              <1> 	shr	eax, 6
   173 00000F93 25FF030000          <1> 	and	eax, 000003FFh				; eax -> page containing ISR ; edx  -> vector
   174 00000F98 31DB                <1> 	xor	ebx, ebx				; single page ISR
   175 00000F9A E954060000          <1> 	jmp	_go2_frame
   176                              <1> 
   177                              <1> ;	_ir	sign extended ea is in eax
   178                              <1> 
   179 00000F9F F686A204000080      <1> _ir:	test	byte ptr [esi+PSR+2], 128		; eax = EA = variation on return offset
   180 00000FA6 0F843EFFFFFF        <1> 	jz	guard_ii_authority		; not good to do Interrupt Return from application space
   181 00000FAC 89D7                <1> 	mov	edi, edx			; save in case the operation interrupts itself
   182 00000FAE 89C2                <1> 	mov	edx, eax			; +- displacement operand, offset in stack added later
   183                              <1> 
   184 00000FB0 E879010000          <1> 	call	stack_read4			; [ebp+ebx*4] -> interrupt stack frame
   185                              <1> 						; interrupt stack pointer is already updated ebx+4
   186                              <1> 
   187 00000FB5 8B449E08            <1> 	mov	eax, dword ptr [esi+ebx*4+2*4]		; interrupted b0_name
   188                              <1> 
   189 00000FB9 8B4C9E04            <1> 	mov	ecx, dword ptr [esi+ebx*4+1*4]		; interrupted psr
   190                              <1> 
   191 00000FBD 03549E0C            <1> 	add	edx, dword ptr [esi+ebx*4+3*4]		; add interrupted iframe offset to EA
   192                              <1> 
   193 00000FC1 31DB                <1> 	xor	ebx, ebx				; iframe default page high index  
   194 00000FC3 A900008000          <1> 	test	eax, 00800000h
   195 00000FC8 7410                <1> 	jz	ir_4k_iframe				; 1-page iframe return target
   196                              <1> 
   197 00000FCA 89C3                <1> 	mov	ebx, eax				; iframe page high index
   198 00000FCC C1E30C              <1> 	shl	ebx, 12					; from 6 bits at front of table
   199 00000FCF 0FB61C9D[01010000]  <1> 	movzx	ebx, byte ptr [_memory+ebx*4+64*4+1]	; at iframe + 64 words
   200 00000FD7 C1EB02              <1> 	shr	ebx, 2					; shift 6 bits into 8 bits
   201                              <1> 
   202                              <1> ir_4k_iframe:
   203 00000FDA 898EA0040000        <1> 	mov	dword ptr [esi+PSR], ecx
   204 00000FE0 F7C100008000        <1> 	test	ecx, 00800000h				; returning ISR -> ISR ?
   205 00000FE6 741B                <1> 	jz	ir_application				; no
   206                              <1> 
   207 00000FE8 8DAE00020000        <1> 	lea	ebp, [esi+REGISTER+128*4]		; for nested interrupts
   208 00000FEE 89AE8C040000        <1> 	mov	dword ptr [esi+REGISTER_SET], ebp	; interrupt register set
   209 00000FF4 C7869C040000800000- <1> 	mov	dword ptr [esi+ISELECT], 128		; interrupt register set
   209 00000FFD 00                  <1>
   210 00000FFE E9F0050000          <1> 	jmp	_go2_frame				; yes
   211                              <1> 
   212                              <1> ir_application:
   213 00001003 89F5                <1> 	mov	ebp, esi				; application register set
   214 00001005 89AE8C040000        <1> 	mov	dword ptr [esi+REGISTER_SET], ebp
   215 0000100B C7869C040000000000- <1> 	mov	dword ptr [esi+ISELECT], 0
   215 00001014 00                  <1>
   216 00001015 E9D9050000          <1> 	jmp	_go2_frame
   217                              <1> 
    37                                  	%include	"stack.msm"
     1                              <1> ;	stack operations call these to add or subract stack
     2                              <1> ;	limits are checked here
     3                              <1> ;	these routines always leave epb -> all registers 0..255
     4                              <1> ;	because both  interrupt internal stack pointer register 128 + 15
     5                              <1> ;		and application internal stack pointer register 15
     6                              <1> 
     7                              <1> ;	are absolute pointers to the entire register stack
     8                              <1> 
     9                              <1> ;	therefore instructions calling here must afterwards
    10                              <1> 
    11                              <1> ;		mov	ebp, dword ptr [_register_set]
    12                              <1> 
    13                              <1> ;	to get ebp back to application registers 0..127
    14                              <1> ;			or interrupt registers 128..255
    15                              <1> 
    16                              <1> ;	ebp governs which r k x y a b mantissa2 mantissa3 fp sp is implied in the instruction opcode
    17                              <1> ;	registers addressed as operand are always absolute in the range 0..255
    18                              <1> 
    19                              <1> ;	these don't move any data but leave [ebp+ebx*4] pointing to the required stack frame
    20                              <1> ;	and update the stack pointer
    21                              <1> 
    22                              <1> ;	although applications can and must read interrupt registers with load instructions
    23                              <1> ;	they can't read interrupt registers with runaway pop instructions
    24                              <1> ;	because the problem is easier to find with an interrupt as soon as 128+ gets popped
    25                              <1> 
    26                              <1> 
    27                              <1> 
    28                              <1> stack1:
    29                              <1> 	%if	0
    30                              <1> 	mov	ebx, dword ptr [ebp+S_P]
    31                              <1> 	dec	ebx
    32                              <1> 	mov	dword ptr [ebp+S_P], ebx
    33                              <1> 	ret
    34                              <1> 	%endif
    35                              <1> 
    36                              <1> 
    37 0000101A 8B5D3C              <1> 	mov	ebx, dword ptr [ebp+S_P]	; read whichever internal sp
    38 0000101D F686A204000080      <1> 	test	byte ptr [esi+PSR+2], 128	; ISR ?
    39 00001024 742B                <1> 	jz	stack1_a			; no ?
    40 00001026 81FB00010000        <1> 	cmp	ebx, 256			; in upper range ?
    41 0000102C 0F87C5000000        <1> 	ja	near guard_stack		; no ?
    42 00001032 4B                  <1> 	dec	ebx				; decrement
    43 00001033 0F88BE000000        <1> 	js	near guard_stack		; < 0 ?
    44 00001039 81FB98000000        <1> 	cmp	ebx, 128+24	; +2		; in clock registers?
    45 0000103F 730C                <1> 	jnb	stack1_j			;
    46 00001041 81FB80000000        <1> 	cmp	ebx, 128			; in app stack? Allowed for thread switch
    47 00001047 0F83AA000000        <1> 	jnb	near guard_stack		; in working registers page
    48                              <1> stack1_j:
    49 0000104D 895D3C              <1> 	mov	dword ptr [ebp+S_P], ebx	; new frame
    50 00001050 C3                  <1> 	ret
    51                              <1> 
    52                              <1> stack1_a:					; this is application
    53 00001051 81FB80000000        <1> 	cmp	ebx, 128			; > interrupt register range start
    54 00001057 0F879A000000        <1> 	ja	near guard_stack		; not allowed
    55 0000105D 4B                  <1> 	dec	ebx				; decrement
    56 0000105E 0F8893000000        <1> 	js	near guard_stack		; < 0 ?
    57 00001064 83FB18              <1> 	cmp	ebx, 24				; in control registers ?
    58 00001067 0F828A000000        <1> 	jb	near guard_stack		; not allowed
    59 0000106D 895D3C              <1> 	mov	dword ptr [ebp+S_P], ebx	; new frame
    60 00001070 C3                  <1> 	ret
    61                              <1> 
    62                              <1> stack2:
    63                              <1> 	%if	0
    64                              <1> 	mov	ebx, dword ptr [ebp+S_P]
    65                              <1> 	add	ebx, -2
    66                              <1> 	mov	dword ptr [ebp+S_P], ebx
    67                              <1> 	ret
    68                              <1> 	%endif
    69                              <1> 
    70 00001071 8B5D3C              <1> 	mov	ebx, dword ptr [ebp+S_P]
    71 00001074 F686A204000080      <1> 	test	byte ptr [esi+PSR+2], 128
    72 0000107B 742A                <1> 	jz	stack2_a
    73 0000107D 81FB00010000        <1> 	cmp	ebx, 256
    74 00001083 0F876E000000        <1> 	ja	near guard_stack
    75 00001089 83C3FE              <1> 	add	ebx, -2
    76 0000108C 0F8865000000        <1> 	js	near guard_stack
    77 00001092 81FB98000000        <1> 	cmp	ebx, 128+24
    78 00001098 7309                <1> 	jnb	stack2_j
    79 0000109A 83FB7E              <1> 	cmp	ebx, 128-2
    80 0000109D 0F8754000000        <1> 	ja	near guard_stack
    81                              <1> 
    82                              <1> stack2_j:
    83 000010A3 895D3C              <1> 	mov	dword ptr [ebp+S_P], ebx
    84 000010A6 C3                  <1> 	ret
    85                              <1> 
    86                              <1> stack2_a:
    87 000010A7 81FB80000000        <1> 	cmp	ebx, 128			; application push high limit 128,  ISR 256
    88 000010AD 7748                <1> 	ja	guard_stack
    89 000010AF 83C3FE              <1> 	add	ebx, -2
    90 000010B2 7843                <1> 	js	guard_stack
    91 000010B4 83FB18              <1> 	cmp	ebx, 24
    92 000010B7 723E                <1> 	jb	guard_stack			; stack top limit zero ISR and application
    93 000010B9 895D3C              <1> 	mov	dword ptr [ebp+S_P], ebx
    94 000010BC C3                  <1> 	ret
    95                              <1> 
    96                              <1> stack4:
    97                              <1> 	%if	0
    98                              <1> 	mov	ebx, dword ptr [ebp+S_P]
    99                              <1> 	add	ebx, -4
   100                              <1> 	mov	dword ptr [ebp+S_P], ebx
   101                              <1> 	ret
   102                              <1> 	%endif
   103                              <1> 
   104 000010BD 8B5D3C              <1> 	mov	ebx, dword ptr [ebp+S_P]
   105 000010C0 F686A204000080      <1> 	test	byte ptr [esi+PSR+2], 128	; read psr interrupt bit
   106 000010C7 741B                <1> 	jz	stack4_a			; stack is registers 24..127
   107 000010C9 81FB00010000        <1> 	cmp	ebx, 256			; stack is registers  0..255
   108 000010CF 7726                <1> 	ja	guard_stack
   109 000010D1 83C3FC              <1> 	add	ebx, -4				; proposed frame
   110 000010D4 7821                <1> 	js	guard_stack			; not lower than register zero
   111 000010D6 81FB98000000        <1> 	cmp	ebx, 128+24
   112 000010DC 7305                <1> 	jnb	stack4_j
   113 000010DE 83FB7C              <1> 	cmp	ebx, 128-4			; in working registers page
   114 000010E1 7714                <1> 	ja	guard_stack
   115                              <1> 
   116                              <1> stack4_j:
   117                              <1> ;	mov	dword ptr [ebp+S_P], ebx	; caller does this
   118 000010E3 C3                  <1> 	ret					; both sp are absolute pointers
   119                              <1> 
   120                              <1> stack4_a:
   121 000010E4 81FB80000000        <1> 	cmp	ebx, 128			; don't push into a higher register than 127
   122 000010EA 770B                <1> 	ja	guard_stack
   123 000010EC 83C3FC              <1> 	add	ebx, -4
   124 000010EF 7806                <1> 	js	guard_stack
   125 000010F1 83FB18              <1> 	cmp	ebx, 24				; dont push lower than 24
   126 000010F4 7201                <1> 	jb	guard_stack
   127                              <1> ;	mov	dword ptr [ebp+S_P], ebx	; caller does this
   128 000010F6 C3                  <1> 	ret					; return new frame
   129                              <1> 
   130                              <1> guard_stack:
   131                              <1> stack_underflow:
   132 000010F7 8BAE8C040000        <1> 	mov	ebp, dword ptr [esi+REGISTER_SET] ; esi -> core.REGISTER
   133 000010FD F786A0040000000080- <1> 	test	dword ptr [esi+PSR], 00800000h	; interrupt mode?
   133 00001106 00                  <1>
   134 00001107 0F84DDFDFFFF        <1> 	jz	guard_ii_authority		; sideline the application
   135 0000110D C7453C00010000      <1> 	mov	dword ptr [ebp+S_P], 256	; restart the interrupt stack
   136 00001114 B801000000          <1> 	mov	eax, 1				; so the interrupt can be interrupted
   137 00001119 F605[19000000]01    <1> 	test	byte ptr [_uflag+'Z'-'A'], 1
   138 00001120 7407                <1> 	jz	gsago
   139 00001122 808E9404000002      <1> 	or	byte ptr [esi+INDICATION], LOCKSTEP
   140 00001129 E9C6FDFFFF          <1> gsago:	jmp	_ii_escape
   141                              <1> 
   142                              <1> stack_read4:
   143 0000112E BB04000000          <1> 	mov	ebx, 4
   144 00001133 035D3C              <1> 	add	ebx, dword ptr [ebp+S_P]
   145 00001136 81FB80000000        <1> 	cmp	ebx, 128			; you can have stack locations up to here
   146 0000113C 7611                <1> 	jna	stack_r4			; whoever you are
   147 0000113E F686A204000080      <1> 	test	byte ptr [esi+PSR+2], 128	; any higher you have to be an ISR
   148 00001145 74B0                <1> 	jz	stack_underflow
   149 00001147 81FB00010000        <1> 	cmp	ebx, 256			; and then not any higher than this
   150 0000114D 77A8                <1> 	ja	stack_underflow
   151                              <1> 
   152                              <1> stack_r4:
   153 0000114F 875D3C              <1> 	xchg	ebx, dword ptr [ebp+S_P]	; write new stack top
   154 00001152 C3                  <1> 	ret					; return old stack top
   155                              <1> 
   156                              <1> stack_read2:
   157 00001153 BB02000000          <1> 	mov	ebx, 2
   158 00001158 035D3C              <1> 	add	ebx, dword ptr [ebp+S_P]
   159 0000115B 81FB80000000        <1> 	cmp	ebx, 128			; you can have stack locations up to here
   160 00001161 7611                <1> 	jna	stack_r2			; whoever you are
   161 00001163 F686A204000080      <1> 	test	byte ptr [esi+PSR+2], 128	; any higher you have to be an ISR
   162 0000116A 748B                <1> 	jz	stack_underflow
   163 0000116C 81FB00010000        <1> 	cmp	ebx, 256			; and then not any higher than this
   164 00001172 7783                <1> 	ja	stack_underflow
   165                              <1> 
   166                              <1> stack_r2:
   167 00001174 875D3C              <1> 	xchg	ebx, dword ptr [ebp+S_P]	; write new stack top
   168 00001177 C3                  <1> 	ret					; return old stack top
   169                              <1> 
   170                              <1> stack_read1:
   171 00001178 BB01000000          <1> 	mov	ebx, 1				; calculate
   172 0000117D 035D3C              <1> 	add	ebx, dword ptr [ebp+S_P]	; new stack top
   173 00001180 81FB80000000        <1> 	cmp	ebx, 128			; you can have stack locations up to here
   174 00001186 7619                <1> 	jna	stack_r1			; whoever you are
   175 00001188 F686A204000080      <1> 	test	byte ptr [esi+PSR+2], 128	; any higher you have to be an ISR
   176 0000118F 0F8462FFFFFF        <1> 	jz	stack_underflow
   177 00001195 81FB00010000        <1> 	cmp	ebx, 256			; and then not any higher than this
   178 0000119B 0F8756FFFFFF        <1> 	ja	stack_underflow
   179                              <1> 
   180                              <1> stack_r1:
   181 000011A1 875D3C              <1> 	xchg	ebx, dword ptr [ebp+S_P]	; write new stack top
   182 000011A4 C3                  <1> 	ret					; return old stack top
   183                              <1> 
    38                                  	%include	"return.msm"
     1                              <1> _autoexit:
     2 000011A5 B846000000          <1> 	mov	eax, II_EXIT
     3 000011AA B90B000000          <1> 	mov	ecx, LP_AUTOEXIT
     4 000011AF E940FDFFFF          <1> 	jmp	_ii_escape
     5                              <1> 
     6 000011B4 F786A0040000000080- <1> _lret:	test	dword ptr [esi+PSR], 00800000h
     6 000011BD 00                  <1>
     7 000011BE 7509                <1> 	jnz	_lret_
     8                              <1> 
     9 000011C0 817D3C80000000      <1> 	cmp	dword ptr [ebp+S_P], 128
    10 000011C7 74DC                <1> 	jz	_autoexit
    11                              <1> 
    12 000011C9 E8AAFFFFFF          <1> _lret_:	call	stack_read1
    13 000011CE 03049E              <1> 	add	eax, dword ptr [esi+ebx*4]
    14 000011D1 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
    15 000011D6 E921020000          <1> 	jmp	_j
    16                              <1> 
    17 000011DB F786A0040000000080- <1> _fret:	test	dword ptr [esi+PSR], 00800000h
    17 000011E4 00                  <1>
    18 000011E5 7509                <1> 	jnz	_fret_
    19                              <1> 
    20 000011E7 817D3C80000000      <1> 	cmp	dword ptr [ebp+S_P], 128
    21 000011EE 74B5                <1> 	jz	_autoexit
    22                              <1> 
    23 000011F0 E85EFFFFFF          <1> _fret_:	call	stack_read2
    24 000011F5 899680040000        <1> 	mov	dword ptr [esi+APC], edx
    25 000011FB 89C2                <1> 	mov	edx, eax
    26 000011FD 03549E04            <1> 	add	edx, dword ptr [esi+ebx*4+1*4]	; add EA as displacement to offset on stack
    27 00001201 8B049E              <1> 	mov	eax, dword ptr [esi+ebx*4]
    28 00001204 31DB                <1> 	xor	ebx, ebx			; 1-page frame?
    29 00001206 A900008000          <1> 	test	eax, 00800000h			; multipages frame?
    30 0000120B 7410                <1> 	jz	_fret_1page
    31 0000120D 89C3                <1> 	mov	ebx, eax
    32 0000120F C1E30C              <1> 	shl	ebx, 12
    33 00001212 0FB61C9D[01010000]  <1> 	movzx	ebx, byte ptr [_memory+ebx*4+64*4+1]
    34 0000121A C1EB02              <1> 	shr	ebx, 2
    35                              <1> 
    36                              <1> _fret_1page:
    37 0000121D E9D1030000          <1> 	jmp	_go2_frame
    38                              <1> 
    39                              <1> _fpxpo_low_order:				; $residue exponent out of range
    40 00001222 8B5C240C            <1>         mov     ebx, dword ptr [esp+3*4]        ; tell ISR which accumulator
    41                              <1> 
    42                              <1> 	%if 1
    43 00001226 891D[00000000]      <1>         mov     dword ptr [_ultra], ebx         ; tell developer if that is true
    44                              <1> 	%endif
    45                              <1> 
    46 0000122C B803000000          <1> _fpxpo:	mov	eax, II_FPXPO
    47 00001231 89D9                <1> 	mov	ecx, ebx			; tell ISR which accumulator
    48 00001233 E9BCFCFFFF          <1> 	jmp	_ii_escape			; in latent parameter
    49                              <1> 
    39                                  	%include	"rta.msm"
     1                              <1> 
     2 00001238 80F904              <1> _sr:	cmp	cl, I
     3 0000123B 0F849DF8FFFF        <1> 	jz	_inA
     4 00001241 80F905              <1> 	cmp	cl, XI
     5 00001244 0F8497FBFFFF        <1> 	jz	_on
     6                              <1> 
     7 0000124A 8B5D00              <1> 	mov	ebx, dword ptr [ebp+R]
     8 0000124D E991F2FFFF          <1> 	jmp	_operand_write
     9                              <1> 
    10 00001252 80F904              <1> _sk:	cmp	cl, I
    11 00001255 0F848EF8FFFF        <1> 	jz	_inB
    12 0000125B 80F905              <1> 	cmp	cl, XI
    13 0000125E 0F8485FBFFFF        <1> 	jz	_off
    14                              <1> 
    15 00001264 8B5D04              <1> 	mov	ebx, dword ptr [ebp+K]
    16 00001267 E977F2FFFF          <1> 	jmp	_operand_write
    17                              <1> 
    18 0000126C 80F904              <1> _sx:	cmp	cl, I
    19 0000126F 0F847FF8FFFF        <1> 	jz	_outA
    20 00001275 80F905              <1> 	cmp	cl, XI
    21 00001278 0F846BF7FFFF        <1> 	jz	_rsr
    22                              <1> 
    23 0000127E 8B5D08              <1> 	mov	ebx, dword ptr [ebp+X]
    24 00001281 E95DF2FFFF          <1> 	jmp	_operand_write
    25                              <1> 
    26 00001286 80F904              <1> _sy:	cmp	cl, I
    27 00001289 0F846DF8FFFF        <1> 	jz	_outB
    28 0000128F 80F905              <1> 	cmp	cl, XI
    29 00001292 0F84C1F7FFFF        <1> 	jz	_wsr
    30                              <1> 
    31 00001298 8B5D0C              <1> 	mov	ebx, dword ptr [ebp+Y]
    32 0000129B E943F2FFFF          <1> 	jmp	_operand_write;
    33                              <1> 
    34 000012A0 80F904              <1> _sa:	cmp	cl, I
    35 000012A3 0F841BF9FFFF        <1> 	jz	_reload
    36 000012A9 80F905              <1> 	cmp	cl, XI
    37 000012AC 744E                <1> 	jz	escape
    38                              <1> 
    39 000012AE 8B5D10              <1> 	mov	ebx, dword ptr [ebp+A]
    40 000012B1 E92DF2FFFF          <1> 	jmp	_operand_write
    41                              <1> 
    42 000012B6 80F904              <1> _sb:	cmp	cl, I
    43 000012B9 7441                <1> 	jz	escape
    44 000012BB 80F905              <1> 	cmp	cl, XI
    45 000012BE 743C                <1> 	jz	escape
    46                              <1> 
    47 000012C0 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]
    48 000012C3 E91BF2FFFF          <1> 	jmp	_operand_write
    49                              <1> 
    50 000012C8 80F904              <1> _z:	cmp	cl, I
    51 000012CB 0F8415F9FFFF        <1> 	jz	_sabr
    52 000012D1 80F905              <1> 	cmp	cl, XI
    53 000012D4 0F84DAFEFFFF        <1> 	jz	_lret
    54 000012DA 31DB                <1> 	xor	ebx, ebx
    55 000012DC E902F2FFFF          <1> 	jmp	_operand_write
    56                              <1> 
    57 000012E1 80F904              <1> _pop:	cmp	cl, I
    58 000012E4 7416                <1> 	jz	escape
    59 000012E6 80F905              <1> 	cmp	cl, XI
    60 000012E9 0F84ECFEFFFF        <1> 	jz	_fret
    61                              <1> 
    62 000012EF E884FEFFFF          <1> 	call	stack_read1
    63 000012F4 8B1C9E              <1> 	mov	ebx, dword ptr [esi+ebx*4]
    64 000012F7 E9E7F1FFFF          <1> 	jmp	_operand_write
    65                              <1> 
    66 000012FC C3                  <1> escape	ret
    67                              <1> 
    68 000012FD E84FF0FFFF          <1> _lr:	call	_operand_read
    69 00001302 894500              <1> 	mov	dword ptr [ebp+R], eax
    70 00001305 C3                  <1> 	ret
    71                              <1> 
    72 00001306 E846F0FFFF          <1> _lk:	call	_operand_read
    73 0000130B 894504              <1> 	mov	dword ptr [ebp+K], eax
    74 0000130E C3                  <1> 	ret
    75 0000130F E83DF0FFFF          <1> _lx:	call	_operand_read
    76 00001314 894508              <1> 	mov	dword ptr [ebp+X], eax
    77 00001317 C3                  <1> 	ret
    78                              <1> 
    79 00001318 E834F0FFFF          <1> _ly:	call	_operand_read
    80 0000131D 89450C              <1> 	mov	dword ptr [ebp+Y], eax
    81 00001320 C3                  <1> 	ret
    82                              <1> 
    83 00001321 E82BF0FFFF          <1> _la:	call	_operand_read
    84 00001326 894510              <1> 	mov	dword ptr [ebp+A], eax
    85 00001329 C3                  <1> 	ret
    86                              <1> 
    87 0000132A E822F0FFFF          <1> _lb:	call	_operand_read
    88 0000132F 894514              <1> 	mov	dword ptr [ebp+B], eax
    89 00001332 C3                  <1> 	ret
    90                              <1> 
    91 00001333 80F904              <1> _tz:	cmp	cl, I
    92 00001336 0F844E140000        <1> 	jz	near _rex
    93 0000133C 80F905              <1> 	cmp	cl, XI
    94 0000133F B900000000          <1> 	mov	ecx, 0
    95 00001344 0F8483FBFFFF        <1> 	jz	_ii_instruction
    96                              <1> 
    97 0000134A E802F0FFFF          <1> 	call	_operand_read
    98 0000134F A9FFFFFF00          <1> 	test	eax, 00FFFFFFh
    99 00001354 7503                <1> 	jnz	_tz_
   100 00001356 83C204              <1> 	add	edx, 4
   101 00001359 C3                  <1> _tz_:	ret
   102                              <1> 
   103 0000135A 80F904              <1> _tp:	cmp	cl, I
   104 0000135D 742A                <1> 	jz	_jdz
   105 0000135F 80F905              <1> 	cmp	cl, XI
   106 00001362 0F8437FCFFFF        <1> 	jz	_ir
   107                              <1> 
   108 00001368 E8E4EFFFFF          <1> 	call	_operand_read
   109 0000136D A900008000          <1> 	test	eax, 00800000h
   110 00001372 7503                <1> 	jnz	_tp_
   111 00001374 83C204              <1> 	add	edx, 4
   112 00001377 C3                  <1> _tp_:	ret
   113                              <1> 
   114 00001378 E8D4EFFFFF          <1> _push:	call	_operand_read
   115                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
   116 0000137D 0F7EFE              <1> 	movd	esi, mm7
   117                              <1> 
   118 00001380 E895FCFFFF          <1> 	call	stack1
   119 00001385 89049E              <1> 	mov	dword ptr [esi+ebx*4], eax
   120 00001388 C3                  <1> 	ret
   121                              <1> 
   122 00001389 8B5D14              <1> _jdz:	mov	ebx, dword ptr [ebp+B]
   123 0000138C 0B5D10              <1> 	or	ebx, dword ptr [ebp+A]
   124 0000138F 0F8467000000        <1> 	jz	near _j
   125 00001395 C3                  <1> 	ret
   126                              <1> 
   127 00001396 8B5D00              <1> _jdr:	mov	ebx, dword ptr [ebp+R]	; dec r and jump if it passed from zero to -1
   128 00001399 81C3FFFFFF00        <1> 	add	ebx, 00FFFFFFh
   129 0000139F C1C308              <1> 	rol	ebx, 8
   130 000013A2 88D9                <1> 	mov	cl, bl
   131 000013A4 C1EB08              <1> 	shr	ebx, 8			; write back to registers only 00000000 thru 00FFFFFF
   132 000013A7 895D00              <1> 	mov	dword ptr [ebp+R], ebx
   133 000013AA F6C101              <1> 	test	cl, 1
   134 000013AD 754D                <1> 	jnz	_j
   135 000013AF C3                  <1> 	ret
   136                              <1> 
   137 000013B0 E865FCFFFF          <1> _lcal:	call	stack1
   138 000013B5 2B9688040000        <1> 	sub	edx, dword ptr [esi+B0P]
   139 000013BB C1EA02              <1> 	shr	edx, 2
   140 000013BE 89149E              <1> 	mov	dword ptr [esi+ebx*4], edx
   141 000013C1 EB39                <1> 	jmp	_j			; EA is in eax
   142 000013C3 C3                  <1> 	ret
   143                              <1> 
   144 000013C4 F786A0040000010000- <1> _jnc:	test	dword ptr [esi+PSR], 1
   144 000013CD 00                  <1>
   145 000013CE 742C                <1> 	jz	_j
   146 000013D0 C3                  <1> 	ret
   147                              <1> 
   148 000013D1 F786A0040000010000- <1> _jc:	test	dword ptr [esi+PSR], 1
   148 000013DA 00                  <1>
   149 000013DB 751F                <1> 	jnz	_j
   150 000013DD C3                  <1> 	ret
   151                              <1> 
   152 000013DE F7451001000000      <1> _jao:	test	dword ptr [ebp+A], 1
   153 000013E5 7515                <1> 	jnz	_j
   154 000013E7 C3                  <1> 	ret
   155                              <1> 
   156 000013E8 F7451000008000      <1> _jpa:	test	dword ptr [ebp+A], 00800000h
   157 000013EF 740B                <1> 	jz	_j
   158 000013F1 C3                  <1> 	ret
   159                              <1> 
   160 000013F2 F7451400008000      <1> _jpb:	test	dword ptr [ebp+B], 00800000h
   161 000013F9 7401                <1> 	jz	_j
   162 000013FB C3                  <1> 	ret
   163                              <1> 
   164 000013FC 89D7                <1> _j:	mov	edi, edx			; save position for error handling
   165 000013FE 8B9688040000        <1> 	mov	edx, dword ptr [esi+B0P]
   166                              <1> 
   167 00001404 C1E002              <1> 	shl	eax, 2
   168 00001407 01C2                <1> 	add	edx, eax
   169 00001409 3B9684040000        <1> 	cmp	edx, dword ptr [esi+APCZ]
   170 0000140F 7701                <1> 	ja	_j_check
   171 00001411 C3                  <1> 	ret
   172                              <1> 
   173                              <1> _j_check:
   174 00001412 89FA                <1> 	mov	edx, edi			; restore updated apc
   175 00001414 B90E000000          <1> 	mov	ecx, LP_ADDRESS
   176 00001419 E9D1FAFFFF          <1> 	jmp	guard_ii_escape			; for interrupt come-from
   177                              <1> 
   178 0000141E E80B110000          <1> _jpo:	call	NEAR _get_parity
   179 00001423 7BD7                <1> 	jpo	_j
   180 00001425 C3                  <1> 	ret
   181                              <1> 
   182 00001426 816510FFFFFF00      <1> _jza:	and	dword ptr [ebp+A], 00FFFFFFh
   183 0000142D 74CD                <1> 	jz	_j
   184 0000142F C3                  <1> 	ret
   185                              <1> 
   186 00001430 816514FFFFFF00      <1> _jzb:	and	dword ptr [ebp+B], 00FFFFFFh
   187 00001437 74C3                <1> 	jz	_j
   188 00001439 C3                  <1> 	ret
   189                              <1> 
   190 0000143A 816510FFFFFF00      <1> _jnza:	and	dword ptr [ebp+A], 00FFFFFFh
   191 00001441 75B9                <1> 	jnz	_j
   192 00001443 C3                  <1> 	ret
   193                              <1> 
   194 00001444 816514FFFFFF00      <1> _jnzb:	and	dword ptr [ebp+B], 00FFFFFFh
   195 0000144B 75AF                <1> 	jnz	_j
   196 0000144D C3                  <1> 	ret
   197                              <1> 
   198 0000144E F7451000008000      <1> _jna:	test	dword ptr [ebp+A], 00800000h
   199 00001455 75A5                <1> 	jnz	_j
   200 00001457 C3                  <1> 	ret
   201                              <1> 
   202 00001458 F7451400008000      <1> _jnb:	test	dword ptr [ebp+B], 00800000h
   203 0000145F 759B                <1> 	jnz	_j
   204 00001461 C3                  <1> 	ret
   205                              <1> 
   206 00001462 8B5D08              <1> _jxge:	mov	ebx, dword ptr [ebp+X]
   207 00001465 2B5D00              <1> 	sub	ebx, dword ptr [ebp+R]
   208 00001468 F7C300000001        <1> 	test	ebx, 01000000h		; microcarry?
   209 0000146E 748C                <1> 	jz	_j			; no:  x <  r,    jump
   210 00001470 C3                  <1> 	ret				; yes: x >= r, no jump
   211                              <1> 
   212 00001471 8B5D0C              <1> _jyge:	mov	ebx, dword ptr [ebp+Y]
   213 00001474 2B5D00              <1> 	sub	ebx, dword ptr [ebp+R]
   214 00001477 F7C300000001        <1> 	test	ebx, 01000000h		; microcarry?
   215 0000147D 0F8479FFFFFF        <1> 	jz	_j			; no:  y <  r,    jump
   216 00001483 C3                  <1> 	ret				; yes: y >= r, no jump
   217                              <1> 
   218 00001484 BB04000000          <1> _qs:	mov	ebx, a
   219 00001489 E9DFEFFFFF          <1> 	jmp	_burst_write4
   220                              <1> 
   221 0000148E BB04000000          <1> _ql:	mov	ebx, a
   222 00001493 E98CEEFFFF          <1> 	jmp	_burst_read4
   223                              <1> 
   224 00001498 E891FCFFFF          <1> _qpop:	call	stack_read4			; places 4 stack registers in the scope of burst write
   225 0000149D 55                  <1> 	push	ebp
   226                              <1> ;	mov	ebp, dword ptr [ebp+CORE_INDEX1] 
   227 0000149E 0F7EFD              <1> 	movd	ebp, mm7
   228                              <1> 
   229 000014A1 E8C7EFFFFF          <1> 	call	_burst_write4
   230 000014A6 5D                  <1> 	pop	ebp
   231 000014A7 C3                  <1> 	ret					; stack pointers are absolute
   232                              <1> 
   233 000014A8 E810FCFFFF          <1> _qpush: call	stack4
   234 000014AD 55                  <1> 	push	ebp
   235                              <1> ;	mov	ebp, dword ptr [ebp+CORE_INDEX1]
   236 000014AE 0F7EFD              <1> 	movd	ebp, mm7
   237                              <1> 
   238 000014B1 E86EEEFFFF          <1> 	call	_burst_read4
   239 000014B6 5D                  <1> 	pop	ebp
   240 000014B7 895D3C              <1> 	mov	dword ptr [ebp+S_P], ebx	; update RTA1 sp after writing stack frame
   241 000014BA C3                  <1> 	ret					; not done until this point
   242                              <1> 
   243 000014BB E893FCFFFF          <1> _dpop:	call	stack_read2
   244 000014C0 55                  <1> 	push	ebp
   245                              <1> ;	mov	ebp, dword ptr [ebp+CORE_INDEX1]
   246 000014C1 0F7EFD              <1> 	movd	ebp, mm7
   247                              <1> 
   248 000014C4 E8E9EFFFFF          <1> 	call	_burst_write2
   249 000014C9 5D                  <1> 	pop	ebp
   250 000014CA C3                  <1> 	ret
   251                              <1> 
   252 000014CB E83FEEFFFF          <1> _dpush:	call	_burst_read2
   253                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
   254 000014D0 0F7EFE              <1> 	movd	esi, mm7
   255                              <1> 
   256 000014D3 89D9                <1> 	mov	ecx, ebx
   257 000014D5 E897FBFFFF          <1> 	call	stack2				; RTA1 sp updated at this point
   258 000014DA 894C9E04            <1> 	mov	dword ptr [esi+ebx*4+4], ecx
   259 000014DE 89049E              <1> 	mov	dword ptr [esi+ebx*4], eax
   260 000014E1 C3                  <1> 	ret
   261                              <1> 
   262 000014E2 E86AEEFFFF          <1> _mta:	call	_operand_read
   263 000014E7 334510              <1> 	xor	eax, dword ptr [ebp+A]
   264 000014EA 234504              <1> 	and	eax, dword ptr [ebp+K]
   265 000014ED 7503                <1> 	jnz	_mta_
   266 000014EF 83C204              <1> 	add	edx, 4		; k AND (a XOR operand) = 0, skip 1 instruction
   267 000014F2 C3                  <1> _mta_:	ret
   268                              <1> 
   269 000014F3 E817EEFFFF          <1> _dte:	call	_burst_read2
   270 000014F8 334510              <1> 	xor	eax, dword ptr [ebp+A]
   271 000014FB 7508                <1> 	jnz	_dte_
   272 000014FD 335D14              <1> 	xor	ebx, dword ptr [ebp+B]
   273 00001500 7503                <1> 	jnz	_dte_
   274 00001502 83C204              <1> 	add	edx, 4
   275 00001505 C3                  <1> _dte_:	ret	
   276                              <1> 
   277 00001506 8B9EA0040000        <1> _sc:	mov	ebx, dword ptr [esi+PSR]
   278 0000150C 83E301              <1> 	and	ebx, 1		; store carry 
   279 0000150F E9CFEFFFFF          <1> 	jmp	_operand_write
   280                              <1> 
   281 00001514 E838EEFFFF          <1> _mlb:	call	_operand_read
   282 00001519 8B5D04              <1> 	mov	ebx, dword ptr [ebp+K]
   283 0000151C 21D8                <1> 	and	eax, ebx
   284 0000151E 81F3FFFFFF00        <1> 	xor	ebx, 00FFFFFFh
   285 00001524 235D14              <1> 	and	ebx, dword ptr [ebp+B]
   286 00001527 09C3                <1> 	or	ebx, eax
   287 00001529 895D14              <1> 	mov	dword ptr [ebp+B], ebx	; b = (b AND (NOT k)) OR (operand AND k)
   288 0000152C C3                  <1> 	ret
   289                              <1> 
   290 0000152D BB04000000          <1> _ds:	mov	ebx, a
   291 00001532 E97BEFFFFF          <1> 	jmp	_burst_write2
   292                              <1> 
   293 00001537 E8D3EDFFFF          <1> _dl:	call	_burst_read2
   294 0000153C 895D14              <1> 	mov	dword ptr [ebp+B], ebx
   295 0000153F 894510              <1> 	mov	dword ptr [ebp+A], eax
   296 00001542 C3                  <1> 	ret
   297                              <1> 
   298 00001543 C3                  <1> _spare:	ret
   299                              <1> 
   300 00001544 E8F1F0FFFF          <1> _ex:	call	memory_read
   301                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
   302 00001549 0F7EFE              <1> 	movd	esi, mm7
   303                              <1> 
   304 0000154C E904ECFFFF          <1> 	jmp	_execute
   305                              <1> 
   306 00001551 E81BF1FFFF          <1> _ts:	call	memory_lock			; edi + esi -> memory word
   307 00001556 66B80080            <1> 	mov	ax, 08000h
   308 0000155A 668704B7            <1> 	xchg	ax, word ptr [edi+esi*4]	; swap -> t1 for 080 under lock
   309 0000155E 6621C0              <1> 	and	ax, ax
   310 00001561 7803                <1> 	js	_ts___				; no action if already locked
   311                              <1> 
   312 00001563 83C204              <1> 	add	edx, 4				; skip if ms bit was clear before
   313                              <1> 
   314 00001566 C3                  <1> _ts___:	ret
   315                              <1> 
   316                              <1> 
   317 00001567 E8D9F0FFFF          <1> _sim:	call	memoreg				; edi -> device		edi <- NULL
   318                              <1> 						; esi -> word	OR	ebx -> register
   319                              <1> 						; eax <- data
   320                              <1> ;	mov	ecx, dword ptr [ebp+CORE_INDEX1]
   321 0000156C 0F7EF9              <1> 	movd	ecx, mm7
   322                              <1> 
   323 0000156F 66C1E008            <1> 	shl	ax, 8
   324 00001573 8A81A2040000        <1> 	mov	al, byte ptr [ecx+PSR+2]
   325 00001579 C1C803              <1> 	ror	eax, 3
   326 0000157C C0C003              <1> 	rol	al, 3
   327 0000157F 8881A2040000        <1> 	mov	byte ptr [ecx+PSR+2], al
   328 00001585 C1E81D              <1> 	shr	eax, 32-3
   329                              <1> 
   330 00001588 E998F0FFFF          <1> 	jmp	memoreg_writeback
   331                              <1> 
   332 0000158D 52                  <1> _call:	push	edx
   333 0000158E E8DEFAFFFF          <1> 	call	stack2
   334 00001593 2B9688040000        <1> 	sub	edx, dword ptr [esi+B0P]
   335 00001599 C1EA02              <1> 	shr	edx, 2
   336 0000159C 89549E04            <1> 	mov	dword ptr [esi+ebx*4+1*4], edx
   337 000015A0 8B96A4040000        <1> 	mov	edx, dword ptr [esi+B0_NAME]
   338 000015A6 89149E              <1> 	mov	dword ptr [esi+ebx*4], edx
   339 000015A9 5A                  <1> 	pop	edx		; in case the jump goes wrong
   340                              <1> 				; and an interrupt frame needs constructed
   341                              <1> 
   342 000015AA 899680040000        <1> _go:	mov	dword ptr [esi+APC], edx
   343 000015B0 E89CEDFFFF          <1> 	call	_operand_read	; may be memory or register
   344                              <1> 
   345                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
   346 000015B5 0F7EFE              <1> 	movd	esi, mm7
   347                              <1> 
   348 000015B8 89C2                <1> 	mov	edx, eax	; lookaside to calculate the vector
   349 000015BA A900008000          <1> 	test	eax, 00800000h	; gate?
   350 000015BF 7425                <1> 	jz	_go2_4k_frame
   351                              <1> 
   352 000015C1 25FFFF7F00          <1> 	and	eax, 007FFFFFh	; read the gate constant
   353 000015C6 E844EDFFFF          <1> 	call	_burst_read2	;
   354                              <1> 
   355                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
   356 000015CB 0F7EFE              <1> 	movd	esi, mm7
   357                              <1> 
   358 000015CE 89C2                <1> 	mov	edx, eax	; page high index ++ word offset
   359 000015D0 89D8                <1> 	mov	eax, ebx	; storage block base page index
   360 000015D2 C1C20E              <1> 	rol	edx, 6+8
   361 000015D5 89D3                <1> 	mov	ebx, edx	; instruction frame page high index
   362 000015D7 83E33F              <1> 	and	ebx, 63
   363 000015DA 7405                <1> 	jz	_go_gate	; one page iframe
   364 000015DC 0D00008000          <1> 	or	eax, 00800000h	; two+ page iframe
   365                              <1> 
   366                              <1> _go_gate:
   367 000015E1 C1EA0E              <1> 	shr	edx, 6+8	; net word offset
   368                              <1> 
   369 000015E4 EB0D                <1> 	jmp	_go2_frame
   370                              <1> 	
   371                              <1> _go2_4k_frame:
   372 000015E6 83E23F              <1> 	and	edx, 63		; target is in 4k block, 64 vectors
   373 000015E9 C1E806              <1> 	shr	eax, 6		; new b0_name
   374 000015EC 25FFFF0000          <1> 	and	eax, 0000FFFFh	; bit 22 of GO / CALL word reserved
   375 000015F1 31DB                <1> 	xor	ebx, ebx	; frame high page index
   376                              <1> 
   377                              <1> _go2_frame:
   378 000015F3 F686A204000080      <1> 	test	byte ptr [esi+PSR+2], 128	; already in interrupt code?
   379 000015FA 751B                <1> 	jnz	_go2_base_frame	; 	; may branch into interrupt code
   380                              <1> 					; because he is interrupt code
   381 000015FC 89C1                <1> 	mov	ecx, eax
   382 000015FE 81E1FFFF3F00        <1> 	and	ecx, 03FFFFFh
   383 00001604 2B8EF0050000        <1> 	sub	ecx, dword ptr [esi+IO_PORT+_APP_THRESHOLD]	; applications lower limit
   384 0000160A 7D0B                <1> 	jnl	_go2_base_frame
   385                              <1> 
   386 0000160C 8B9680040000        <1> 	mov	edx, dword ptr [esi+APC]
   387 00001612 E9D3F8FFFF          <1> 	jmp	guard_ii_authority
   388                              <1> 
   389                              <1> _go2_base_frame:
   390                              <1> 
   391 00001617 8986A4040000        <1> 	mov	dword ptr [esi+B0_NAME], eax	; with flags
   392 0000161D 25FFFF3F00          <1> 	and	eax, 003FFFFFh			; base page index only
   393 00001622 01C3                <1> 	add	ebx, eax
   394 00001624 899ED0050000        <1> 	mov	dword ptr [esi+IO_PORT+_IFRAME_U], ebx
   395                              <1> 
   396                              <1> 	%if	1
   397 0000162A 8B8ED0060000        <1> 	mov	ecx, dword ptr [esi+IO_PORT+_DEVICE]	; memory page high index
   398 00001630 81E1FFFF3F00        <1> 	and	ecx, 003FFFFFh			; strip memory type bits
   399 00001636 29D9                <1> 	sub	ecx, ebx			; iframe high page may be = not >
   400 00001638 7910                <1> 	jns	_go2_frame_in_range
   401                              <1> 
   402 0000163A B90E000000          <1> 	mov	ecx, LP_ADDRESS
   403 0000163F 8B9680040000        <1> 	mov	edx, dword ptr [esi+APC]
   404 00001645 E9A5F8FFFF          <1> 	jmp	guard_ii_escape
   405                              <1> 
   406                              <1> _go2_frame_in_range:
   407                              <1> 
   408                              <1> 	%else
   409                              <1> 	PATH NOT IN USE
   410                              <1> 	mov	ecx, dword ptr [esi+IO_PORT+_DEVICE]	; have we the highest frame page?
   411                              <1> 	and	ecx, 003FFFFFh			; read highest page index
   412                              <1> ; NO!	mov	esi, LP_ADDRESS			; trim off flags
   413                              <1> 	sub	ecx, ebx			; compare
   414                              <1> 	xchg	edx, dword ptr [esi+APC]
   415                              <1> 	js	guard_ii_escape			; if negative that should catch it
   416                              <1> 	xchg	edx, dword ptr [esi+APC]
   417                              <1> 	%endif
   418                              <1> 
   419 0000164A C1E30C              <1> 	shl	ebx, 12
   420 0000164D 8D1C9D[FC3F0000]    <1> 	lea	ebx, [_memory+ebx*4+4095*4]	; last instruction word in iframe
   421                              <1> 						; higher = wrong
   422 00001654 899E84040000        <1> 	mov	dword ptr [esi+APCZ], ebx	; set execution limit pointer
   423                              <1> 
   424 0000165A 8986D0040000        <1> 	mov	dword ptr [esi+IO_PORT], eax
   425 00001660 C1E00E              <1> 	shl	eax, 12+2	; 4kword block multiplied by 4 for word
   426 00001663 05[00000000]        <1> 	add	eax, _memory	; add the platform location of executable space
   427 00001668 898688040000        <1> 	mov	dword ptr [esi+B0P], eax
   428 0000166E C1E202              <1> 	shl	edx, 2		; add the vector offset * 4 for word
   429 00001671 01C2                <1> 	add	edx, eax
   430 00001673 C3                  <1> _go_:	ret
   431                              <1> 
    40                                  	%include	"alu.msm"
     1                              <1> 
     2                              <1> 
     3 00001674 E8D8ECFFFF          <1> _ax:	call	_operand_read
     4 00001679 034508              <1> 	add	eax, dword ptr [ebp+X]
     5 0000167C 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
     6 00001681 894508              <1> 	mov	dword ptr [ebp+X], eax
     7 00001684 C3                  <1> 	ret
     8                              <1> 
     9 00001685 E8C7ECFFFF          <1> _ay:	call	_operand_read
    10 0000168A 03450C              <1> 	add	eax, dword ptr [ebp+Y]
    11 0000168D 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
    12 00001692 89450C              <1> 	mov	dword ptr [ebp+Y], eax
    13 00001695 C3                  <1> 	ret
    14                              <1> 
    15 00001696 E8B6ECFFFF          <1> _or:	call	_operand_read
    16 0000169B 094510              <1> 	or	dword ptr [ebp+A], eax
    17 0000169E C3                  <1> 	ret
    18                              <1> 
    19 0000169F E8ADECFFFF          <1> _orB:	call	_operand_read
    20 000016A4 094514              <1> 	or	dword ptr [ebp+B], eax
    21 000016A7 C3                  <1> 	ret
    22                              <1> 
    23 000016A8 E8A4ECFFFF          <1> _and:	call	_operand_read
    24 000016AD 214510              <1> 	and	dword ptr [ebp+A], eax
    25 000016B0 C3                  <1> 	ret
    26                              <1> 
    27 000016B1 E89BECFFFF          <1> _andB:	call	_operand_read
    28 000016B6 214514              <1> 	and	dword ptr [ebp+B], eax
    29 000016B9 C3                  <1> 	ret
    30                              <1> 
    31 000016BA E892ECFFFF          <1> _xor:	call	_operand_read
    32 000016BF 314510              <1> 	xor	dword ptr [ebp+A], eax
    33 000016C2 C3                  <1> 	ret
    34                              <1> 
    35 000016C3 E889ECFFFF          <1> _xorB:	call	_operand_read
    36 000016C8 314514              <1> 	xor	dword ptr [ebp+B], eax
    37 000016CB C3                  <1> 	ret
    38                              <1> 
    39 000016CC E880ECFFFF          <1> _aa:	call	_operand_read
    40 000016D1 EB0D                <1> 	jmp	_aa_
    41                              <1> 
    42 000016D3 E879ECFFFF          <1> _ana:	call	_operand_read
    43 000016D8 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
    44 000016DD 83C001              <1> 	add	eax, 1
    45                              <1> 
    46 000016E0 034510              <1> _aa_:	add	eax, dword ptr [ebp+A]
    47 000016E3 E8B9040000          <1> 	call	_alu_carry
    48                              <1> 
    49 000016E8 894510              <1> 	mov	dword ptr [ebp+A], eax
    50 000016EB C3                  <1> 	ret
    51                              <1> 
    52 000016EC E860ECFFFF          <1> _ab:	call	_operand_read
    53 000016F1 EB0D                <1> 	jmp	_ab_
    54                              <1> 
    55 000016F3 E859ECFFFF          <1> _anb:	call	_operand_read
    56 000016F8 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
    57 000016FD 83C001              <1> 	add	eax, 1
    58                              <1> 
    59 00001700 034514              <1> _ab_:	add	eax, dword ptr [ebp+B]
    60 00001703 E899040000          <1> 	call	_alu_carry
    61                              <1> 
    62 00001708 894514              <1> 	mov	dword ptr [ebp+B], eax
    63 0000170B C3                  <1> 	ret
    64                              <1> 
    65 0000170C 52                  <1> _m:	push	edx			; 80386 platform has it ready made, so
    66 0000170D E83FECFFFF          <1> 	call	_operand_read
    67 00001712 C1E008              <1> 	shl	eax, 8			; prepare multiplier to be multiplicand 
    68 00001715 C1F808              <1> 	sar	eax, 8			; sign it in eax
    69 00001718 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]	; this is register side multiplicand but
    70                              <1> 					; it makes no difference which is which
    71 0000171B C1E308              <1> 	shl	ebx, 8			; so use it as multiplier if that is OK
    72 0000171E C1FB08              <1> 	sar	ebx, 8			; sign it first
    73                              <1> 
    74 00001721 F7EB                <1> 	imul	ebx
    75                              <1> 
    76 00001723 C1C008              <1> 	rol	eax, 8			; move 8 bits up from eax to edx
    77 00001726 C1E208              <1> 	shl	edx, 8
    78 00001729 88C2                <1> 	mov	dl, al
    79 0000172B C1E808              <1> 	shr	eax, 8
    80 0000172E 894514              <1> 	mov	dword ptr [ebp+B], eax	; product bits 23..0
    81 00001731 C1E208              <1> 	shl	edx, 8
    82 00001734 C1EA08              <1> 	shr	edx, 8
    83 00001737 895510              <1> 	mov	dword ptr [ebp+A], edx	; product high order bits
    84 0000173A 5A                  <1> 	pop	edx
    85 0000173B C3                  <1> 	ret
    86                              <1> 
    87 0000173C 52                  <1> _mf:	push	edx		; the multiplier is signed the multiplicand unsigned
    88 0000173D E80FECFFFF          <1> 	call	_operand_read
    89 00001742 89C1                <1> 	mov	ecx, eax	; just to remember the multiplier sign
    90 00001744 A900008000          <1> 	test	eax, 00800000h
    91 00001749 7408                <1> 	jz	_mfplusplus
    92 0000174B 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
    93 00001750 83C001              <1> 	add	eax, 1
    94                              <1> _mfplusplus:
    95 00001753 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]	; this is the multiplicand, unsigned
    96 00001756 F7E3                <1> 	mul	ebx		; two 24-bit unsigned values should be OK here
    97 00001758 C1C008              <1> 	rol	eax, 8
    98 0000175B C1E208              <1> 	shl	edx, 8
    99 0000175E 88C2                <1> 	mov	dl, al
   100 00001760 C1E808              <1> 	shr	eax, 8
   101 00001763 C1E208              <1> 	shl	edx, 8
   102 00001766 C1EA08              <1> 	shr	edx, 8
   103 00001769 F7C100008000        <1> 	test	ecx, 00800000h	; was the multiplier signed?
   104 0000176F 741F                <1> 	jz	_mfstore
   105 00001771 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   106 00001776 81F2FFFFFF00        <1> 	xor	edx, 00FFFFFFh
   107 0000177C 83C001              <1> 	add	eax, 1
   108 0000177F C1C008              <1> 	rol	eax, 8
   109 00001782 0FB6C8              <1> 	movzx	ecx, al
   110 00001785 C1E808              <1> 	shr	eax, 8
   111 00001788 01CA                <1> 	add	edx, ecx
   112 0000178A 81E2FFFFFF00        <1> 	and	edx, 00FFFFFFh
   113                              <1> _mfstore:
   114 00001790 894514              <1> 	mov	dword ptr [ebp+B], eax
   115 00001793 895510              <1> 	mov	dword ptr [ebp+A], edx
   116 00001796 5A                  <1> 	pop	edx
   117 00001797 C3                  <1> 	ret
   118                              <1> 
   119 00001798 BF04000000          <1> _d:	mov	edi, a
   120 0000179D E80A000000          <1> 	call	_divide
   121 000017A2 895D10              <1> 	mov	dword ptr [ebp+A], ebx
   122 000017A5 894518              <1> 	mov	dword ptr [ebp+MANTISSA2], eax
   123 000017A8 894D14              <1> 	mov	dword ptr [ebp+B], ecx
   124 000017AB C3                  <1> 	ret
   125                              <1> 
   126                              <1> 	%if	1
   127                              <1> 
   128                              <1> ;	this divide made from 2 Intel divides should be a better method
   129                              <1> ;	than the procession of 1-bit shifts and test subtracts
   130                              <1> ;	which is the %else which it replaces. That also works
   131                              <1> 
   132                              <1> ;	this converts to and from positive magnitude
   133                              <1> ;	because zoning the 2nd divide with a zero 1st remainder
   134                              <1> ;	can't tell +0 from -0 in platform 2s complement
   135                              <1> 
   136                              <1> ;	polarity conversions before and after need no explanation
   137                              <1> 
   138                              <1> ;	1st dividend is 48 zero bits and high order 16 data bits
   139                              <1> ;	of the the 48-bit RTA1 dividend
   140                              <1> 
   141                              <1> ;	2nd dividend is 1st remainder and the remaining 32 bits
   142                              <1> ;	the the RTA1 dividend
   143                              <1> 
   144                              <1> ;	input is compressed from 24-bit words and output unpacked
   145                              <1> ;	to 24-bit words
   146                              <1> 
   147                              <1> ;	64-bit dividend in 386 mode is high order bits in edx, low in eax
   148                              <1> ;	platform faults if quotient carries from eax. Remainder in edx
   149                              <1> 
   150                              <1> ;	RTA1 quotient is 48 bits so it takes 2 divides in 32-bit mode
   151                              <1> 
   152                              <1> _divide:
   153 000017AC 52                  <1> 	push	edx
   154 000017AD 57                  <1> 	push	edi
   155 000017AE E89EEBFFFF          <1> 	call	_operand_read	; read divisor
   156 000017B3 5F                  <1> 	pop	edi
   157 000017B4 31C9                <1> 	xor	ecx, ecx	; final sign
   158 000017B6 A900008000          <1> 	test	eax, 00800000h
   159 000017BB 7408                <1> 	jz	_dsig?
   160 000017BD 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   161 000017C2 F7D1                <1> 	not	ecx		; reverse final sign
   162 000017C4 40                  <1> 	inc	eax
   163 000017C5 25FFFFFF00          <1> _dsig?:	and	eax, 00FFFFFFh	; check zerodiv here mebbes
   164 000017CA 89C3                <1> 	mov	ebx, eax	; eax will be used twice as divisor LS word
   165 000017CC 746D                <1> 	jz	_d_ont		; zero results in eax ebx already
   166                              <1> 
   167 000017CE 8B44BD04            <1> 	mov	eax, dword ptr [ebp+edi*4+4]
   168 000017D2 8B54BD00            <1> 	mov	edx, dword ptr [ebp+edi*4]
   169 000017D6 C1E008              <1> 	shl	eax, 8		; pack two 24-bit words to 64 bits 
   170 000017D9 88D0                <1> 	mov	al, dl
   171 000017DB C1C808              <1> 	ror	eax, 8
   172 000017DE C1E208              <1> 	shl	edx, 8
   173 000017E1 C1EA10              <1> 	shr	edx, 16
   174 000017E4 6689D1              <1> 	mov	cx, dx		; save dividend sign
   175 000017E7 6621D2              <1> 	and	dx, dx		; bit 47 on?
   176 000017EA 7912                <1> 	jns	_dive_in
   177                              <1> 
   178 000017EC 81F10000FFFF        <1> 	xor	ecx, 0FFFF0000h	; reverse final sign
   179 000017F2 F7D0                <1> 	not	eax
   180 000017F4 66F7D2              <1> 	not	dx
   181 000017F7 83C001              <1> 	add	eax, 1
   182 000017FA 6683D200            <1> 	adc	dx, 0
   183                              <1> 
   184                              <1> _dive_in:
   185 000017FE 89C6                <1> 	mov	esi, eax	; reserve 2nd dividend
   186 00001800 89D0                <1> 	mov	eax, edx	; position 1st dividend
   187 00001802 31D2                <1> 	xor	edx, edx	; with leading zero
   188 00001804 F7F3                <1> 	div	ebx
   189 00001806 96                  <1> 	xchg	eax, esi	; save 1st quotient
   190 00001807 F7F3                <1> 	div	ebx		; generate 2nd quotient
   191                              <1> 
   192 00001809 6621C9              <1> 	and	cx, cx		; dividend negative?
   193 0000180C 7903                <1> 	jns	_d_remainder_plus
   194 0000180E F7D2                <1> 	not	edx
   195 00001810 42                  <1> 	inc	edx
   196                              <1> 
   197                              <1> _d_remainder_plus:
   198 00001811 81E2FFFFFF00        <1> 	and	edx, 00FFFFFFh
   199 00001817 87D1                <1> 	xchg	edx, ecx	; remainder -> ecx / final sign -> edx
   200                              <1> 
   201 00001819 89C3                <1> 	mov	ebx, eax	; low order quotient
   202 0000181B 89F0                <1> 	mov	eax, esi	; high order quotient
   203                              <1> 
   204 0000181D 21D2                <1> 	and	edx, edx	; final sign?
   205 0000181F 790C                <1> 	jns	_d_quotient_plus
   206                              <1> 
   207 00001821 F7D3                <1> 	not	ebx		; invert + increment quotient
   208 00001823 66F7D0              <1> 	not	ax		; RTA1 integer is also 2s complement
   209 00001826 83C301              <1> 	add	ebx, 1
   210 00001829 6683D000            <1> 	adc	ax, 0
   211                              <1> 
   212                              <1> _d_quotient_plus:
   213 0000182D 0FB7C0              <1> 	movzx	eax, ax		; unpack from 32-bit words to 24-bit words
   214 00001830 C1E008              <1> 	shl	eax, 8		; move 8 bits up
   215 00001833 C1C308              <1> 	rol	ebx, 8
   216 00001836 88D8                <1> 	mov	al, bl
   217 00001838 C1EB08              <1> 	shr	ebx, 8		; quotient in eax:ebx
   218                              <1> 
   219 0000183B 5A                  <1> _d_ont:	pop	edx		; give back the emulated program counter
   220 0000183C C3                  <1> 	ret
   221                              <1> 
   222                              <1> 	%else
   223                              <1> 
   224                              <1> _divide:
   225                              <1> 	xor	ebx, ebx
   226                              <1> 	push	ebx		;
   227                              <1> 	push	ebx		; quotient
   228                              <1> 	push	ebx		; dividend[b]
   229                              <1> 	push	ebx		; dividend[a]
   230                              <1> 	push	ebx		; trailing divisor
   231                              <1> 	push	ebx		; divisor
   232                              <1> 	push	ebx		; signs2 
   233                              <1> 	push	ebx		; signs1
   234                              <1> 	mov	ebx, 24
   235                              <1> 	push	ebx		; beats
   236                              <1> 
   237                              <1> 
   238                              <1> _D_BEATS	equ	0
   239                              <1> _D_SIGNS1	equ	1*4
   240                              <1> _D_SIGNS2	equ	2*4
   241                              <1> _D_DIVISORU	equ	3*4
   242                              <1> _D_DIVISORL	equ	4*4
   243                              <1> _D_DIVIDENDU	equ	5*4
   244                              <1> _D_DIVIDENDL	equ	6*4
   245                              <1> _D_QUOTIENTU	equ	7*4
   246                              <1> _D_QUOTIENTL	equ	8*4
   247                              <1> 
   248                              <1> 	push	edi
   249                              <1> 	call	_operand_read
   250                              <1> 	pop	edi
   251                              <1> 
   252                              <1> 	test	eax, 00800000h
   253                              <1> 	jnz	_d_nmagnitude1			; must be stored negative
   254                              <1> 	xor	eax, 00FFFFFFh
   255                              <1> 	jmp	_d_nmagnitude2
   256                              <1> _d_nmagnitude1:
   257                              <1> 	add	eax, -1				; if it's already negative
   258                              <1> 	mov	dword ptr [esp+_D_SIGNS2], 0FFFFFFFFh
   259                              <1> _d_nmagnitude2:
   260                              <1> 	call	qscale
   261                              <1> 	cmp	bl, 24
   262                              <1> 	jz	_d_allsigns
   263                              <1> 	add	dword ptr [esp+_D_BEATS], ebx
   264                              <1> _d_allsigns:
   265                              <1> 	mov	ebx, 00FFFFFF00h ; make the divisor 48 bits contiguous	
   266                              <1> 	mov	bl, al
   267                              <1> 	ror	ebx, 8
   268                              <1> 	shl	eax, 8
   269                              <1> 	mov	ax, 65535
   270                              <1> 	ror	eax, 16
   271                              <1> 
   272                              <1> 	mov	dword ptr [esp+_D_DIVISORL], ebx
   273                              <1> 	mov	dword ptr [esp+_D_DIVISORU], eax
   274                              <1> 
   275                              <1> 	mov	ecx, 1				; precarry
   276                              <1> 
   277                              <1> ;	mov	ebx, dword ptr [ebp+B]	; dividend
   278                              <1> ;	mov	eax, dword ptr [ebp+A]
   279                              <1> 
   280                              <1> 	mov	ebx, dword ptr [ebp+edi*4+4]
   281                              <1> 	mov	eax, dword ptr [ebp+edi*4] 
   282                              <1> 
   283                              <1> 	test	eax, 00800000h
   284                              <1> 	jz	_d_pmagnitude			; must be stored positive
   285                              <1> 	mov	dword ptr [esp+_D_SIGNS1], 00FFFFFFFFh
   286                              <1> 	xor	ebx, 00FFFFFFh
   287                              <1> 	xor	eax, 00FFFFFFh
   288                              <1> 	add	ecx, ebx
   289                              <1> 	mov	ebx, ecx
   290                              <1> 	and	ebx, 00FFFFFFh
   291                              <1> 	shr	ecx, 24
   292                              <1> 	add	eax, ecx
   293                              <1> 	and	eax, 00FFFFFFh
   294                              <1> 
   295                              <1> _d_pmagnitude:
   296                              <1> 	shl	ebx, 8
   297                              <1> 	mov	bl, al
   298                              <1> 	ror	ebx, 8
   299                              <1> 	shl	eax, 8
   300                              <1> 	shr	eax, 16
   301                              <1> 	mov	dword ptr [esp+_D_DIVIDENDL], ebx
   302                              <1> 	mov	dword ptr [esp+_D_DIVIDENDU], eax
   303                              <1> 
   304                              <1> 	mov	ecx, dword ptr [esp+_D_BEATS]
   305                              <1> 
   306                              <1> 	add	ecx, -1
   307                              <1> _d_beat:			; iterative part as quick as possible
   308                              <1> 				; could study doing a pair of Intel divides here
   309                              <1> 	stc
   310                              <1> 	rcr	dword ptr [esp+_D_DIVISORU], 1
   311                              <1> 	rcr	dword ptr [esp+_D_DIVISORL], 1
   312                              <1> 
   313                              <1> 	stc
   314                              <1> 	adc	ebx, dword ptr [esp+_D_DIVISORL]
   315                              <1> 	adc	eax, dword ptr [esp+_D_DIVISORU]
   316                              <1> 
   317                              <1> 	jc	_d_carried
   318                              <1> 	mov	ebx, dword ptr [esp+_D_DIVIDENDL]
   319                              <1> 	mov	eax, dword ptr [esp+_D_DIVIDENDU]
   320                              <1> 	jmp	_d_carried_or_not
   321                              <1> 
   322                              <1> _d_carried:
   323                              <1> 	mov	dword ptr [esp+_D_DIVIDENDL], ebx
   324                              <1> 	mov	dword ptr [esp+_D_DIVIDENDU], eax
   325                              <1> 
   326                              <1> _d_carried_or_not:
   327                              <1> 	rcl	dword ptr [esp+_D_QUOTIENTL], 1
   328                              <1> 	rcl	dword ptr [esp+_D_QUOTIENTU], 1
   329                              <1> 	
   330                              <1> 	add	ecx, -1
   331                              <1> 	jc	_d_beat
   332                              <1> 
   333                              <1> 	pop	ecx		; BEATS
   334                              <1> 	pop	ecx		; SIGNS1
   335                              <1> 	pop	eax		; SIGNS2
   336                              <1> 	pop	ebx		; DIVISORU
   337                              <1> 	pop	ebx		; DIVISORL
   338                              <1> 	pop	ebx		; DIVIDENDU
   339                              <1> 	pop	ebx		; DIVIDENDL
   340                              <1> 
   341                              <1> 	xor	ebx, ecx	; set remainder to sign of dividend
   342                              <1> 	jns	_d_remplus
   343                              <1> 	inc	ebx		; set -remainder 2s complement
   344                              <1> 
   345                              <1> _d_remplus:
   346                              <1> 	and	ebx, 00FFFFFFh	; store remainder
   347                              <1> ;	mov	dword ptr [ebp+B], ebx
   348                              <1> 
   349                              <1> 	xor	ecx, eax	; set sign of quotient to difference of signs
   350                              <1> 	mov	ecx, ebx	; remainder for return
   351                              <1> 	pop	eax		; QUOTIENTU
   352                              <1> 	pop	ebx		; QUOTIENTL
   353                              <1> 
   354                              <1> 	jns	_d_quotient_plus		; cc set from xor of signy
   355                              <1> 
   356                              <1> 	not	eax
   357                              <1> 	not	ebx
   358                              <1> 	add	ebx, 1
   359                              <1> 	adc	eax, 0
   360                              <1> 
   361                              <1> _d_quotient_plus:
   362                              <1> 	shl	eax, 8
   363                              <1> 	rol	ebx, 8
   364                              <1> 	mov	al, bl
   365                              <1> 	shr	ebx, 8
   366                              <1> 	shl	eax, 8
   367                              <1> 	shr	eax, 8
   368                              <1> 
   369                              <1> ;	mov	dword ptr [ebp+A], ebx
   370                              <1> ;	mov	dword ptr [ebp+MANTISSA2], eax
   371                              <1> 	ret
   372                              <1> 
   373                              <1> 	%endif
   374                              <1> 
   375                              <1> 
   376 0000183D 88C1                <1> _sar:	mov	cl, al			; eax shift radix is 31
   377 0000183F 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
   378 00001842 F6C1E0              <1> 	test	cl, -32
   379 00001845 7402                <1> 	jz	_sardo
   380 00001847 31C0                <1> 	xor	eax, eax		; shift 32+ clears same as 24+
   381 00001849 D3E8                <1> _sardo:	shr	eax, cl
   382 0000184B 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   383 00001850 894510              <1> 	mov	dword ptr [ebp+A], eax
   384 00001853 C3                  <1> 	ret
   385                              <1> 
   386 00001854 88C1                <1> _sbr:	mov	cl, al
   387 00001856 8B4514              <1> 	mov	eax, dword ptr [ebp+B]
   388 00001859 F6C1E0              <1> 	test	cl, -32
   389 0000185C 7402                <1> 	jz	_sbrdo
   390 0000185E 31C0                <1> 	xor	eax, eax		; shift 32+ clears same as 24+
   391 00001860 D3E8                <1> _sbrdo:	shr	eax, cl
   392 00001862 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   393 00001867 894514              <1> 	mov	dword ptr [ebp+B], eax
   394 0000186A C3                  <1> 	ret
   395                              <1> 
   396                              <1> 
   397 0000186B 88C1                <1> _dsr:	mov	cl, al
   398 0000186D 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]
   399 00001870 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
   400 00001873 E875000000          <1> 	call	dsr
   401 00001878 895D14              <1> 	mov	dword ptr [ebp+B], ebx
   402 0000187B 894510              <1> 	mov	dword ptr [ebp+A], eax
   403 0000187E C3                  <1> 	ret
   404                              <1> 
   405 0000187F 88C1                <1> _sal:	mov	cl, al			; shift radix eax is 31
   406 00001881 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
   407 00001884 F6C1E0              <1> 	test	cl, -32
   408 00001887 7402                <1> 	jz	_saldo
   409 00001889 31C0                <1> 	xor	eax, eax		; shift 32+ clears same as 24+
   410 0000188B D3E0                <1> _saldo:	shl	eax, cl
   411 0000188D 25FFFFFF00          <1> 	and	eax, 00FFFFFFh		; write back to registers only 00000000 thru 00FFFFFF
   412 00001892 894510              <1> 	mov	dword ptr [ebp+A], eax
   413 00001895 C3                  <1> 	ret
   414                              <1> 
   415 00001896 88C1                <1> _sbl:	mov	cl, al
   416 00001898 8B4514              <1> 	mov	eax, dword ptr [ebp+B]
   417 0000189B F6C1E0              <1> 	test	cl,-32
   418 0000189E 7402                <1> 	jz	_sbldo
   419 000018A0 31C0                <1> 	xor	eax, eax		; shift 32+ clears same as 24+
   420 000018A2 D3E0                <1> _sbldo:	shl	eax, cl
   421 000018A4 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   422 000018A9 894514              <1> 	mov	dword ptr [ebp+B], eax
   423 000018AC C3                  <1> 	ret
   424                              <1> 
   425 000018AD 88C1                <1> _dsl	mov	cl, al
   426 000018AF 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]
   427 000018B2 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
   428 000018B5 E868000000          <1> 	call	dsl
   429 000018BA 895D14              <1> 	mov	dword ptr [ebp+B], ebx
   430 000018BD 894510              <1> 	mov	dword ptr [ebp+A], eax
   431 000018C0 C3                  <1> 	ret
   432                              <1> 
   433 000018C1 8B5D10              <1> _rar:	mov	ebx, dword ptr [ebp+A]
   434 000018C4 E8C6000000          <1> 	call	rr
   435 000018C9 895D10              <1> 	mov	dword ptr [ebp+A], ebx
   436 000018CC C3                  <1> 	ret
   437                              <1> 
   438 000018CD 8B5D14              <1> _rbr:	mov	ebx, dword ptr [ebp+B]
   439 000018D0 E8BA000000          <1> 	call	rr
   440 000018D5 895D14              <1> 	mov	dword ptr [ebp+B], ebx
   441 000018D8 C3                  <1> 	ret
   442                              <1> 
   443 000018D9 88C1                <1> _drr:	mov	cl, al
   444 000018DB 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]
   445 000018DE 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
   446 000018E1 E8F7000000          <1> 	call	drr
   447 000018E6 895D14              <1> 	mov	dword ptr [ebp+B], ebx
   448 000018E9 894510              <1> 	mov	dword ptr [ebp+A], eax
   449 000018EC C3                  <1> 	ret
   450                              <1> 
   451                              <1> 
   452 000018ED C1E008              <1> dsr:	shl	eax, 8
   453 000018F0 C1E308              <1> 	shl	ebx, 8
   454 000018F3 80C1E8              <1> dsru:	add	cl, -24
   455 000018F6 7306                <1> 	jnc	dsrl
   456 000018F8 89C3                <1> 	mov	ebx, eax
   457 000018FA 31C0                <1> 	xor	eax, eax
   458 000018FC EBF5                <1> 	jmp	dsru
   459 000018FE 80C110              <1> dsrl:	add	cl, 16
   460 00001901 730D                <1> 	jnc	dsr7
   461 00001903 C1E808              <1> dsr8:	shr	eax, 8
   462 00001906 88C3                <1> 	mov	bl, al
   463 00001908 C1CB08              <1> 	ror	ebx, 8
   464 0000190B 80C1F8              <1> 	add	cl,-8
   465 0000190E 72F3                <1> 	jc	dsr8
   466 00001910 80E107              <1> dsr7:	and	cl, 7
   467 00001913 D3E8                <1> 	shr	eax, cl
   468 00001915 88C3                <1> 	mov	bl, al		; bits from al in high-order positions bl
   469 00001917 D2C3                <1> 	rol	bl, cl		; roll them to low-order positions
   470 00001919 D3CB                <1> 	ror	ebx, cl
   471 0000191B C1EB08              <1> 	shr	ebx, 8
   472 0000191E C1E808              <1> 	shr	eax, 8
   473 00001921 C3                  <1> 	ret
   474                              <1> 
   475 00001922 C1E008              <1> dsl:	shl	eax, 8
   476 00001925 C1E308              <1> 	shl	ebx, 8
   477 00001928 80C1E8              <1> dslu:	add	cl, -24
   478 0000192B 7306                <1> 	jnc	dsll
   479 0000192D 89D8                <1> 	mov	eax, ebx
   480 0000192F 31DB                <1> 	xor	ebx, ebx
   481 00001931 EBF5                <1> 	jmp	dslu
   482 00001933 80C110              <1> dsll:	add	cl, 16
   483 00001936 730F                <1> 	jnc	dsl7
   484 00001938 C1C308              <1> dsl8:	rol	ebx, 8
   485 0000193B 88D8                <1> 	mov	al, bl
   486 0000193D 30DB                <1> 	xor	bl, bl
   487 0000193F C1E008              <1> 	shl	eax, 8
   488 00001942 80C1F8              <1> 	add	cl, -8
   489 00001945 72F1                <1> 	jc	dsl8
   490 00001947 80E107              <1> dsl7:	and	cl, 7
   491 0000194A D3C3                <1> 	rol	ebx, cl
   492 0000194C 88D8                <1> 	mov	al, bl		; bits from bl in low-order positions al
   493 0000194E D2C8                <1> 	ror	al, cl		; roll them to high-order positions
   494 00001950 D3E0                <1> 	shl	eax, cl
   495 00001952 C1EB08              <1> 	shr	ebx, 8
   496 00001955 C1E808              <1> 	shr	eax, 8
   497 00001958 C3                  <1> 	ret
   498                              <1> 
   499 00001959 C1E008              <1> dsa:	shl	eax, 8
   500 0000195C C1E308              <1> 	shl	ebx, 8
   501 0000195F 80C1E8              <1> dsa24:	add	cl, -24
   502 00001962 7307                <1> 	jnc	dsa16
   503 00001964 89C3                <1> 	mov	ebx, eax
   504 00001966 C1F818              <1> 	sar	eax, 24
   505 00001969 EBF4                <1> 	jmp	dsa24
   506 0000196B 80C110              <1> dsa16:	add	cl, 16
   507 0000196E 730D                <1> 	jnc	dsa7
   508 00001970 C1F808              <1> dsa8:	sar	eax, 8
   509 00001973 88C3                <1> 	mov	bl, al
   510 00001975 C1CB08              <1> 	ror	ebx, 8
   511 00001978 80C1F8              <1> 	add	cl, -8
   512 0000197B 72F3                <1> 	jc	dsa8
   513 0000197D 80E107              <1> dsa7:	and	cl, 7
   514 00001980 D3F8                <1> 	sar	eax, cl
   515 00001982 88C3                <1> 	mov	bl, al		; bits from al in high-order positions bl
   516 00001984 D2C3                <1> 	rol	bl, cl		; roll them to low-order positions
   517 00001986 D3CB                <1> 	ror	ebx, cl
   518 00001988 C1E808              <1> 	shr	eax, 8
   519 0000198B C1EB08              <1> 	shr	ebx, 8
   520 0000198E C3                  <1> 	ret	
   521                              <1> 
   522                              <1> 
   523 0000198F 88C1                <1> rr:	mov	cl, al
   524 00001991 C1E308              <1> 	shl	ebx, 8
   525 00001994 F6C118              <1> 	test	cl, 24		; bits 16:8 are self-cancelling
   526 00001997 7A11                <1> 	jpe	rr7
   527 00001999 F6C110              <1> 	test	cl, 16
   528 0000199C 7407                <1> 	jz	rr8		; 16 is off so 8 is on
   529 0000199E C1C308              <1> 	rol	ebx, 8		; 8 left in 24-bit ring = 16 right
   530 000019A1 88DF                <1> 	mov	bh, bl		; compress 32-bit ring to 24-bit
   531 000019A3 EB05                <1> 	jmp	short rr7
   532 000019A5 88FB                <1> rr8:	mov	bl, bh		; extend 24-bit ring to 32-bit
   533 000019A7 C1CB08              <1> 	ror	ebx, 8
   534 000019AA 80E107              <1> rr7:	and	cl, 7		; isolate remaining count bits
   535 000019AD 88FB                <1> 	mov	bl, bh		; don't ask, just do it
   536 000019AF D3CB                <1> 	ror	ebx, cl
   537 000019B1 C1EB08              <1> 	shr	ebx, 8
   538 000019B4 C3                  <1> 	ret
   539                              <1> 
   540 000019B5 88C1                <1> rl:	mov	cl, al
   541 000019B7 C1E308              <1> 	shl	ebx, 8
   542 000019BA F6C118              <1> 	test	cl, 24		; bits 16:8 are self-cancelling
   543 000019BD 7A11                <1> 	jpe	rl7
   544 000019BF F6C110              <1> 	test	cl, 16
   545 000019C2 7407                <1> 	jz	rl8		; 16 is off so 8 is on
   546 000019C4 88FB                <1> 	mov	bl, bh		; extend 24-bit ring to 32-bit
   547 000019C6 C1CB08              <1> 	ror	ebx, 8		; 8 right in 24-bit ring = 16 left
   548 000019C9 EB05                <1> 	jmp	short rl7
   549 000019CB C1C308              <1> rl8:	rol	ebx, 8
   550 000019CE 88DF                <1> 	mov	bh, bl		; compress 32-bit ring to 24-bit	
   551 000019D0 80E107              <1> rl7:	and	cl, 7
   552 000019D3 30DB                <1> 	xor	bl, bl
   553 000019D5 D3C3                <1> 	rol	ebx, cl
   554 000019D7 08DF                <1> 	or	bh, bl
   555 000019D9 C1EB08              <1> 	shr	ebx, 8
   556 000019DC C3                  <1> 	ret
   557                              <1> 
   558 000019DD C1E008              <1> drr:	shl	eax, 8
   559 000019E0 C1E308              <1> 	shl	ebx, 8
   560                              <1> 
   561 000019E3 F6C130              <1> 	test	cl, 48		; bits 32:16 are self-cancelling
   562 000019E6 7B07                <1> 	jpo	drr24		; rotate 48 = zero or 56 = 8 positions
   563 000019E8 F6C108              <1> 	test	cl, 8		; parity = pe dans le pays d'Intel
   564 000019EB 741C                <1> 	jz	drr7
   565 000019ED EB15                <1> 	jmp	drr_cdrr8
   566                              <1> 
   567 000019EF 93                  <1> drr24:	xchg	eax, ebx	; rotate 24 right or left as you wish
   568 000019F0 F6C118              <1> 	test	cl, 24
   569 000019F3 7A0D                <1> 	jpe	drr24_32	; pattern is 100xxx or 011xxx
   570 000019F5 F6C108              <1> 	test	cl, 8		; pattern is 010xxx or 101xxx
   571 000019F8 7401                <1> 	jz	drrl8		; pattern is 010
   572 000019FA 93                  <1> 	xchg	eax, ebx	; swap back, pattern 101 = 40 right = 8 left 
   573 000019FB E828000000          <1> drrl8:	call	near drl8	; pattern is 010
   574 00001A00 EB07                <1> 	jmp	short drr7 	; already rotated 24 right, now 8 left
   575                              <1> 
   576                              <1> drr24_32:
   577 00001A02 7505                <1> 	jnz	drr7		; pattern is 011 = rotate 24. We did
   578                              <1> drr_cdrr8:
   579 00001A04 E814000000          <1> 	call	near drr8	; pattern is 100 = rotate 32
   580 00001A09 80E107              <1> drr7:	and	cl, 7
   581 00001A0C 7408                <1> 	jz	drrx
   582 00001A0E 88E3                <1> 	mov	bl, ah		; rotate low bits ebx 31:8 to eax high positions
   583 00001A10 88F8                <1> 	mov	al, bh		; rotate low bits eax 31:8 to ebx high positions
   584 00001A12 D3C8                <1> 	ror	eax, cl		; bits from bh in low order positions al
   585 00001A14 D3CB                <1> 	ror	ebx, cl		; bits from ah in low order positions bl
   586 00001A16 C1E808              <1> drrx:	shr	eax, 8
   587 00001A19 C1EB08              <1> 	shr	ebx, 8
   588 00001A1C C3                  <1> 	ret
   589                              <1> 
   590 00001A1D 88E3                <1> drr8:   mov     bl, ah          ; cross 8 bits from one 32-bit ring to another
   591 00001A1F 88F8                <1>         mov     al, bh		
   592 00001A21 C1C808              <1>         ror     eax, 8
   593 00001A24 C1CB08              <1>         ror     ebx, 8
   594 00001A27 C3                  <1>         ret
   595                              <1> 
   596 00001A28 C1C008              <1> drl8:   rol     eax, 8
   597 00001A2B C1C308              <1>         rol     ebx, 8
   598 00001A2E 88DC                <1>         mov     ah, bl          ; cross 8 bits from one 32-bit ring to another
   599 00001A30 88C7                <1>         mov     bh, al
   600 00001A32 C3                  <1>         ret
   601                              <1> 
   602 00001A33 C1E008              <1> drl:	shl	eax, 8
   603 00001A36 C1E308              <1> 	shl	ebx, 8
   604 00001A39 F6C130              <1> 	test	cl, 48		; values 32:16 cancel each other
   605 00001A3C 7B07                <1> 	jpo	drl24
   606 00001A3E F6C108              <1> 	test	cl, 8
   607 00001A41 741C                <1> 	jz	drl7
   608 00001A43 EB15                <1> 	jmp	short drl_cdrl8
   609                              <1> 
   610 00001A45 93                  <1> drl24:	xchg	eax, ebx
   611 00001A46 F6C118              <1> 	test	cl, 24
   612 00001A49 7A0D                <1> 	jpe	drl24_32	; pattern is 011xxx or 100xxx
   613 00001A4B F6C108              <1> 	test	cl, 8		; pattern is 010xxx or 101xxx
   614 00001A4E 7401                <1> 	jz	drlr8		; pattern is 010 = 16 left = 8 right
   615 00001A50 93                  <1> 	xchg	eax, ebx	; swap back, pattern = 101 = 40 left = 8 right
   616 00001A51 E8C7FFFFFF          <1> drlr8:	call	drr8
   617 00001A56 EB07                <1> 	jmp	short drl7
   618                              <1> 
   619                              <1> drl24_32:
   620 00001A58 7505                <1> 	jnz	drl7		; pattern is 011 = rotate24. We did
   621                              <1> drl_cdrl8:			; pattern = 100xxx or 001xxx, rotate 8 more
   622 00001A5A E8C9FFFFFF          <1> 	call	drl8
   623 00001A5F 80E107              <1> drl7:	and	cl, 7		; rotate positions 0..7
   624 00001A62 30C0                <1> 	xor	al, al
   625 00001A64 30DB                <1> 	xor	bl, bl
   626 00001A66 D3C0                <1> 	rol	eax, cl
   627 00001A68 D3C3                <1> 	rol	ebx, cl
   628 00001A6A 08DC                <1> 	or	ah, bl
   629 00001A6C 08C7                <1> 	or	bh, al
   630 00001A6E C1E808              <1> 	shr	eax, 8
   631 00001A71 C1EB08              <1> 	shr	ebx, 8
   632 00001A74 C3                  <1> 	ret
   633                              <1> 
   634 00001A75 8B5D10              <1> _ral:	mov	ebx, dword ptr [ebp+A]
   635 00001A78 E838FFFFFF          <1> 	call	rl
   636 00001A7D 895D10              <1> 	mov	dword ptr [ebp+A], ebx
   637 00001A80 C3                  <1> 	ret
   638                              <1> 
   639 00001A81 8B5D14              <1> _rbl:	mov	ebx, dword ptr [ebp+B]
   640 00001A84 E82CFFFFFF          <1> 	call	rl
   641 00001A89 895D14              <1> 	mov	dword ptr [ebp+B], ebx
   642 00001A8C C3                  <1> 	ret	
   643                              <1> 
   644 00001A8D 88C1                <1> _drl:	mov	cl, al
   645 00001A8F 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
   646 00001A92 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]
   647 00001A95 E899FFFFFF          <1> 	call	drl
   648 00001A9A 895D14              <1> 	mov	dword ptr [ebp+B], ebx
   649 00001A9D 894510              <1> 	mov	dword ptr [ebp+A], eax
   650 00001AA0 C3                  <1> 	ret
   651                              <1> 
   652 00001AA1 88C1                <1> _saa:	mov	cl, al
   653 00001AA3 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
   654 00001AA6 C1E008              <1> 	shl	eax, 8
   655 00001AA9 D3F8                <1> 	sar	eax, cl
   656 00001AAB C1E808              <1> 	shr	eax, 8
   657 00001AAE 894510              <1> 	mov	dword ptr [ebp+A], eax
   658 00001AB1 C3                  <1> 	ret
   659                              <1> 
   660 00001AB2 88C1                <1> _sba:	mov	cl, al
   661 00001AB4 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]
   662 00001AB7 C1E308              <1> 	shl	ebx, 8
   663 00001ABA D3FB                <1> 	sar	ebx, cl
   664 00001ABC C1EB08              <1> 	shr	ebx, 8
   665 00001ABF 895D14              <1> 	mov	dword ptr [ebp+B], ebx
   666 00001AC2 C3                  <1> 	ret
   667                              <1> 
   668 00001AC3 88C1                <1> _dsa:	mov	cl, al
   669 00001AC5 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]
   670 00001AC8 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
   671 00001ACB E889FEFFFF          <1> 	call	dsa
   672 00001AD0 895D14              <1> 	mov	dword ptr [ebp+B], ebx
   673 00001AD3 894510              <1> 	mov	dword ptr [ebp+A], eax
   674 00001AD6 C3                  <1> 	ret
   675                              <1> 
   676 00001AD7 E869EBFFFF          <1> _n:	call	memoreg
   677 00001ADC 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   678 00001AE1 E93FEBFFFF          <1> 	jmp	memoreg_writeback
   679                              <1> 
   680 00001AE6 E85AEBFFFF          <1> _inc:	call	memoreg
   681 00001AEB 40                  <1> 	inc	eax
   682 00001AEC E934EBFFFF          <1> 	jmp	memoreg_writeback
   683                              <1> 
   684 00001AF1 E84FEBFFFF          <1> _dec:	call	memoreg
   685 00001AF6 48                  <1> 	dec	eax
   686 00001AF7 E929EBFFFF          <1> 	jmp	memoreg_writeback
   687                              <1> 
   688 00001AFC E844EBFFFF          <1> _src:	call	memoreg
   689 00001B01 C1E008              <1> 	shl	eax, 8
   690 00001B04 8A86A0040000        <1> 	mov	al, byte ptr [esi+PSR]
   691 00001B0A D1C8                <1> 	ror	eax, 1
   692 00001B0C D0C0                <1> 	rol	al, 1
   693 00001B0E 8886A0040000        <1> 	mov	byte ptr [esi+PSR], al
   694 00001B14 C1E808              <1> 	shr	eax, 8
   695 00001B17 E909EBFFFF          <1> 	jmp	memoreg_writeback
   696                              <1> 
   697 00001B1C E824EBFFFF          <1> _slc:	call	memoreg
   698 00001B21 C1E008              <1> 	shl	eax, 8
   699 00001B24 8A86A0040000        <1> 	mov	al, byte ptr [esi+PSR]
   700 00001B2A D0C8                <1> 	ror	al, 1
   701 00001B2C D1C0                <1> 	rol	eax, 1
   702 00001B2E 8886A0040000        <1> 	mov	byte ptr [esi+PSR], al
   703 00001B34 C1E808              <1> 	shr	eax, 8
   704 00001B37 E9E9EAFFFF          <1> 	jmp	memoreg_writeback
   705                              <1> 
   706                              <1> 	%if	0
   707                              <1> _popA:	call	stack_read1				; ebx <- stack pointer
   708                              <1> 	mov	ebx, dword ptr [esi+ebx*4+REGISTER]	; stack word
   709                              <1> 
   710                              <1> 	mov	ecx, esi				; keep core.REGISTER *
   711                              <1> 	push	ebx
   712                              <1> 	call	memoreg					; reply is memory edi + esi ->
   713                              <1> 							;     or register esi + ebx ->
   714                              <1> 	add	eax, dword ptr [esp]
   715                              <1> 	add	esp, 4
   716                              <1> 
   717                              <1> 	rol	eax, 8					; carry -> LS bit
   718                              <1> 	and	al, 1
   719                              <1> 
   720                              <1> 	and	byte ptr [ecx+PSR], 254
   721                              <1> 	or	byte ptr [ecx+PSR], al
   722                              <1> 	shr	eax, 8					; resulting value without carry
   723                              <1> 	jmp	memoreg_writeback			; eax -> target
   724                              <1> 							; [ edi ] + esi -> memory / register
   725                              <1> 	%else
   726                              <1> 
   727 00001B3C E804EBFFFF          <1> _popA:	call	memoreg					; eax <- addend for update
   728 00001B41 53                  <1> 	push	ebx					; ebx -> writeback register
   729 00001B42 56                  <1> 	push	esi					; or [ edi esi ] -> writeback memory word
   730                              <1> 
   731 00001B43 0F7EFE              <1> 	movd	esi, mm7
   732                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]	; get back the smp core for PSR and...
   733                              <1> 							; total register array and...
   734                              <1> 							; whichever of [ 2 * RTA1 sp ] is in ebx *
   735                              <1> 							; that is simple position in register list
   736                              <1> 							; not application / ISR relative as in ebp
   737                              <1> 							; although each (RTA1 sp) MOSTLY operates
   738                              <1> 							; its own portions of the register array
   739                              <1> 							; CORE_INDEX is in both scopes of ebp :-)
   740                              <1> 
   741 00001B46 E82DF6FFFF          <1> 	call	stack_read1				; ebx -> old (RTA1 internal stack) sp
   742 00001B4B 03049E              <1> 	add	eax, dword ptr [esi+ebx*4+REGISTER]	; add word from internal stack
   743                              <1> 
   744 00001B4E C1C008              <1> 	rol	eax, 8					; isolate carry out of bit 23
   745 00001B51 2401                <1> 	and	al, 1
   746 00001B53 8B9EA0040000        <1> 	mov	ebx, dword ptr [esi+PSR]		; platform memory read then write MIGHT
   747 00001B59 80E3FE              <1> 	and	bl, 254					; be better than 2 * read : write cycle
   748 00001B5C 08C3                <1> 	or	bl, al
   749 00001B5E 899EA0040000        <1> 	mov	dword ptr [esi+PSR], ebx		; write PSR back
   750                              <1> 
   751 00001B64 C1E808              <1> 	shr	eax, 8					; reposition and clean result
   752                              <1> 
   753 00001B67 5E                  <1> 	pop	esi					; retrieve possible storage offset
   754 00001B68 5B                  <1> 	pop	ebx					; retrieve possible register writeback
   755 00001B69 E9B7EAFFFF          <1> 	jmp	memoreg_writeback
   756                              <1> 
   757                              <1> 	%endif
   758                              <1> 	
   759 00001B6E E89CE7FFFF          <1> _da:	call	_burst_read2
   760 00001B73 EB11                <1> 	jmp	_da_
   761                              <1> 
   762 00001B75 E895E7FFFF          <1> _dan:	call	_burst_read2
   763 00001B7A 81F3FFFFFF00        <1> 	xor	ebx, 00FFFFFFh
   764 00001B80 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   765 00001B85 43                  <1> 	inc	ebx			; carry from bit 23 
   766                              <1> 					; remains in bit 24 for now
   767                              <1> 
   768 00001B86 035D14              <1> _da_:	add	ebx, [ebp+B]
   769 00001B89 C1E308              <1> 	shl	ebx, 8
   770 00001B8C 83D000              <1> 	adc	eax, 0
   771 00001B8F C1EB08              <1> 	shr	ebx, 8
   772 00001B92 895D14              <1> 	mov	[ebp+B], ebx
   773 00001B95 034510              <1> 	add	eax, [ebp+A]
   774 00001B98 E804000000          <1> 	call	_alu_carry
   775 00001B9D 894510              <1> 	mov	[ebp+A], eax
   776 00001BA0 C3                  <1> 	ret
   777                              <1> 
   778                              <1> _alu_carry:
   779                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
   780 00001BA1 0F7EFE              <1> 	movd	esi, mm7
   781                              <1> 
   782 00001BA4 C1C008              <1> 	rol	eax, 8
   783 00001BA7 2401                <1> 	and	al, 1
   784 00001BA9 80A6A0040000FE      <1> 	and	byte ptr [esi+PSR], 254
   785 00001BB0 0886A0040000        <1> 	or	byte ptr [esi+PSR], al
   786 00001BB6 C1E808              <1> 	shr	eax, 8
   787 00001BB9 C3                  <1> 	ret
   788                              <1> 
   789 00001BBA 040302020101010100- <1> scalex	db	4,3,2,2, 1,1,1,1, 0,0,0,0, 0,0,0,0
   789 00001BC3 00000000000000      <1>
   790                              <1> 
   791                              <1> field_scale:			; examine 24-bit integer in 8-position steps
   792 00001BCA C1C008              <1> 	rol	eax, 8		; until high-order 8 bits are not all signs
   793 00001BCD 88C4                <1> 	mov	ah, al
   794 00001BCF 30E8                <1> 	xor	al, ch
   795 00001BD1 7509                <1> 	jnz	not8signs
   796 00001BD3 80C108              <1> 	add	cl, 8
   797 00001BD6 80F918              <1> 	cmp	cl, 24
   798 00001BD9 72EF                <1> 	jb	field_scale
   799 00001BDB C3                  <1> 	ret			; 24 signs = the RTA1 computer word
   800                              <1> not8signs:			; al = 0 indicates it
   801 00001BDC A8F0                <1> 	test	al, 240		; move back some positions but keep counting up
   802 00001BDE 7506                <1> 	jnz	scale_u
   803 00001BE0 80C104              <1> 	add	cl, 4
   804 00001BE3 C0C004              <1> 	rol	al, 4
   805                              <1> scale_u:
   806 00001BE6 C0E804              <1> 	shr	al, 4
   807 00001BE9 0FB6F0              <1> 	movzx	esi, al		; add to count-up 1..7
   808 00001BEC 2E028E[BA1B0000]    <1> 	add	cl, [cs:esi+scalex]
   809 00001BF3 6651                <1> 	push	cx		; roll back 7..1 positions
   810 00001BF5 80E107              <1> 	and	cl, 7
   811 00001BF8 80F107              <1> 	xor	cl, 7
   812 00001BFB 80C101              <1> 	add	cl, 1
   813 00001BFE 88E0                <1> 	mov	al, ah
   814 00001C00 D3C8                <1> 	ror	eax, cl
   815 00001C02 6659                <1> 	pop	cx
   816 00001C04 C3                  <1> 	ret
   817                              <1> 
   818 00001C05 C1E008              <1> qscale:	shl	eax, 8		; 1.2.3
   819 00001C08 C1F808              <1> 	sar	eax, 8		; s.1.2.3
   820 00001C0B C1C008              <1> 	rol	eax, 8		; 1.2.3.s
   821 00001C0E 6631C9              <1> 	xor	cx, cx
   822 00001C11 88C5                <1> 	mov	ch, al		; keep 8 sign bits
   823 00001C13 E8B2FFFFFF          <1> 	call	field_scale
   824                              <1> 
   825 00001C18 0FB6D9              <1> 	movzx	ebx, cl
   826                              <1> 
   827 00001C1B C1E808              <1> 	shr	eax, 8
   828 00001C1E C3                  <1> 	ret
   829                              <1> 
   830 00001C1F E82DE7FFFF          <1> _lsc:	call	_operand_read
   831 00001C24 E8DCFFFFFF          <1> 	call	qscale
   832 00001C29 895D14              <1> 	mov	dword ptr [ebp+B], ebx	; store the scale
   833 00001C2C 894510              <1> 	mov	dword ptr [ebp+A], eax	; store the rotated value
   834 00001C2F C3                  <1> 	ret
   835                              <1> 
   836 00001C30 E8DAE6FFFF          <1> _dlsc:	call	_burst_read2
   837 00001C35 894510              <1> 	mov	dword ptr [ebp+A], eax		; keep original 1st word
   838 00001C38 C1E008              <1> 	shl	eax, 8
   839 00001C3B C1F808              <1> 	sar	eax, 8
   840 00001C3E C1C008              <1> 	rol	eax, 8
   841 00001C41 6631C9              <1> 	xor	cx, cx
   842 00001C44 88C5                <1> 	mov	ch, al				; keep 8 sign bits
   843 00001C46 E87FFFFFFF          <1> 	call	field_scale
   844 00001C4B 20C0                <1> 	and	al, al
   845 00001C4D 7415                <1> 	jz	_dlsc24				; if the first word is all signs
   846                              <1> 
   847 00001C4F 0FB6C1              <1> 	movzx	eax, cl
   848 00001C52 894518              <1> 	mov	dword ptr [ebp+MANTISSA2], eax	; store the scale
   849 00001C55 8B4510              <1> 	mov	eax, dword ptr [ebp+A]		; retrieve the input high order word
   850 00001C58 E8D6FDFFFF          <1> 	call	drl				; scale the two input words per cl
   851 00001C5D 895D14              <1> 	mov	dword ptr [ebp+B], ebx
   852 00001C60 894510              <1> 	mov	dword ptr [ebp+A], eax  	; store the rotated value
   853 00001C63 C3                  <1> 	ret
   854                              <1> 
   855                              <1> _dlsc24:				; different when high order word is all signs
   856 00001C64 C1E808              <1> 	shr	eax, 8			; one result word of signs
   857 00001C67 894514              <1> 	mov	dword ptr [ebp+B], eax	; into the low-order result word
   858 00001C6A 89D8                <1> 	mov	eax, ebx		; scale the low-order input
   859 00001C6C C1E008              <1> 	shl	eax, 8
   860 00001C6F 30C9                <1> 	xor	cl, cl			; restart the scale count-up
   861 00001C71 E854FFFFFF          <1> 	call	field_scale
   862 00001C76 80C118              <1> 	add	cl, 24			; restore the early part of the count-up
   863                              <1> 
   864 00001C79 0FB6D9              <1> 	movzx	ebx, cl
   865 00001C7C 895D18              <1> 	mov	dword ptr [ebp+MANTISSA2], ebx	; store the scale
   866                              <1> 
   867 00001C7F C1E808              <1> 	shr	eax, 8
   868 00001C82 894510              <1> 	mov	dword ptr [ebp+A], eax	; store the rotated value
   869 00001C85 C3                  <1> 	ret
   870                              <1> 
   871                              <1> 	%if	0
   872                              <1> 
   873                              <1> _fpx:	call	_burst_read2		; data read in eax ebx
   874                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
   875                              <1> 	movd	esi, mm7
   876                              <1> 
   877                              <1> 	push	ebx			; ebx is used in RTA1 stack frame
   878                              <1> 	call	stack4			; construct RTA1 stack frame
   879                              <1> 
   880                              <1> 	shl	eax, 4			; move 12 mantissa bits out of eax
   881                              <1> 	movsx	ecx, ax			; and extend the normalising bit
   882                              <1> 
   883                              <1> 	rol	eax, 4+1		; shelter sign in eax bit 0
   884                              <1> 	shl	ax, 12			; better still in eax bit 12
   885                              <1> 	sar	eax, 12			; propagate the value at midpoint position
   886                              <1> 	ror	eax, 1			; have the sign back
   887                              <1> 	shr	eax, 8			; clear eax 31..24
   888                              <1> 	xor	eax, 003ffc00h		; reverse the 12 copies of midpoint bit
   889                              <1> 					; yon's ra complicated bit done
   890                              <1> 	mov	dword ptr [ebp+ebx*4], eax
   891                              <1> 
   892                              <1> 	xor	eax, ecx		; is the normalising bit opposite to signs ?
   893                              <1> 	test	eax, 00800000h
   894                              <1> 	jz	_fpx_allsigns		; no so unnormalised = zero
   895                              <1> 
   896                              <1> 	pop	eax			; the 2nd operand word, ya remember?
   897                              <1> 	shl	eax, 4			; get them 2 halves over the centre
   898                              <1> 
   899                              <1> 	shr	cx, 4			; zero quartets at high order of 16 bits
   900                              <1> 	shr	ax, 4
   901                              <1> 
   902                              <1> 	xchg	ax, cx			; low-order mantissa bits with unsigns in ecx
   903                              <1> 					; high-order mantissa bits with middle part in eax
   904                              <1> 
   905                              <1> 	shl	eax, 4			; LLLz | HHHz
   906                              <1> 	shr	ax, 4			; LLLz | zHHH
   907                              <1> 	rol	eax, 12			; zzHH | HLLL
   908                              <1> 
   909                              <1> 	mov	dword ptr [ebp+ebx*4+1*4], eax
   910                              <1> 	rol	ecx, 12
   911                              <1> 	xor	ecx, 0FFFh		; 12 normalising bits = 12 inverted signs
   912                              <1> 	mov	dword ptr [ebp+ebx*4+2*4], ecx
   913                              <1> 	not	ecx			; convert high order quartet to signs
   914                              <1> 	sar	ecx, 20			; 24 of them
   915                              <1> 	shr	ecx, 8
   916                              <1> 	mov	dword ptr [ebp+ebx*4+3*4], ecx
   917                              <1> ;	mov	ebp, dword ptr [esi+REGISTER_SET]
   918                              <1> 	mov	dword ptr [ebp+S_P], ebx	; update whichever sp that is
   919                              <1> 	ret
   920                              <1> 
   921                              <1> _fpx_allsigns:
   922                              <1> 	add	esp, 4			; take saved operand word back from stack
   923                              <1> 	sar	ecx, 8			; 16 unnormalised normalising bits
   924                              <1> 	shr	ecx, 8			; = 24 sign bits
   925                              <1> 
   926                              <1> 	mov	dword ptr [ebp+ebx*4], ecx
   927                              <1> 	mov	dword ptr [ebp+ebx*4+1*4], ecx
   928                              <1> 	mov	dword ptr [ebp+ebx*4+2*4], ecx
   929                              <1> 	mov	dword ptr [ebp+ebx*4+3*4], ecx
   930                              <1> 
   931                              <1> ;	mov	ebp, dword ptr [_register_set]
   932                              <1> 	mov	dword ptr [ebp+S_P], ebx	; update whichever sp that is
   933                              <1> 	ret
   934                              <1> 
   935                              <1> _fpp:	call	stack_read4
   936                              <1> 	push	eax				; thats EA
   937                              <1> 
   938                              <1> 	mov	eax, dword ptr [ebp+ebx*4]	; s + 23 exponent bits
   939                              <1> 	rol	eax, 8+2			; save sign and midpoint
   940                              <1> 	shl	eax, 12				; squeeze out 12 exponent bits
   941                              <1> 	shr	ax, 12				; bring sign + midpoint back
   942                              <1> 	ror	eax, 2				; and roll them back in
   943                              <1> 	shr	eax, 4				; position 12 bits low in 16 bits
   944                              <1> 	mov	ecx, dword ptr [ebp+ebx*4+1*4]	; take 1st mantissa word from the stack
   945                              <1> 	ror	ecx, 12				; rotate 12 bits down
   946                              <1> 	shl	cx, 4				; position 12 bits high in 16 bits
   947                              <1> 	mov	ax, cx				; merge
   948                              <1> 	shr	eax, 4				; position 24 bits low in 32 bits
   949                              <1> 	mov	dword ptr [ebp+ebx*4], eax	; place back in RTA1 stack frame
   950                              <1> 						; next 12 mantissa bits in ecx 31..20
   951                              <1> 
   952                              <1> 	mov	eax, dword ptr [ebp+ebx*4+2*4]	; read 24 more
   953                              <1> 	shr	eax, 12-4			; position 12 bits at ax 15..4
   954                              <1> 	shr	ecx, 4				;				
   955                              <1> 	mov	cx, ax				; juxtapose with mantissa 23..12
   956                              <1> 	shr	ecx, 4				; wirraff
   957                              <1> 
   958                              <1> 	mov	dword ptr [ebp+ebx*4+1*4], ecx	; making 2nd and final output word
   959                              <1> 
   960                              <1> 	pop	eax				; recover EA
   961                              <1> 	jmp	_burst_write2
   962                              <1> 
   963                              <1> 	%endif
    41                                  	%include	"fpu.msm"
     1                              <1> 
     2                              <1> compress4to8:			; readout floating operand
     3                              <1> 				; and pack to 32-bit words
     4                              <1> 				; for 1 bit-distance shifting
     5                              <1> 				; acquired operand is in 1st half of 
     6                              <1> 				; 8-register block [edi]
     7                              <1> 
     8 00001C86 8B07                <1> 	mov	eax, dword ptr [edi]	; 1s-complement scale field
     9 00001C88 C1E008              <1> 	shl	eax, 8			; 1st data bit reveals sign
    10 00001C8B C1F808              <1> 	sar	eax, 8			; propagate that sign some
    11 00001C8E 89C3                <1> 	mov	ebx, eax
    12 00001C90 C1F818              <1> 	sar	eax, 24			; propagate signs to 32 bits
    13 00001C93 31C3                <1> 	xor	ebx, eax		; change scale to unsigned magnitude
    14 00001C95 891F                <1> 	mov	dword ptr [edi], ebx	; position scale magnitude in 1st register
    15 00001C97 89471C              <1> 	mov	dword ptr [edi+7*4], eax	; 96 trailing signs
    16 00001C9A 894718              <1> 	mov	dword ptr [edi+6*4], eax
    17 00001C9D 894714              <1> 	mov	dword ptr [edi+5*4], eax
    18 00001CA0 8B5F0C              <1> 	mov	ebx, dword ptr [edi+3*4]	; read low-order mantissa word
    19 00001CA3 88D8                <1> 	mov	al, bl				; low-order octet
    20 00001CA5 C1C808              <1> 	ror	eax, 8				; is followed by 24 signs
    21 00001CA8 894710              <1> 	mov	dword ptr [edi+4*4], eax	; ebx also contains mantissa 23..8
    22                              <1> 						; in positions 23..8
    23                              <1> 
    24 00001CAB 8B4708              <1> 	mov	eax, dword ptr [edi+2*4]	; eax now contains mantissa 47..24
    25 00001CAE C1E308              <1> 	shl	ebx, 8
    26 00001CB1 6689C3              <1> 	mov	bx, ax				; mantissa 39..24 -> ebx
    27 00001CB4 C1C310              <1> 	rol	ebx, 16				; ebx now contains mantissa 40..8
    28 00001CB7 895F0C              <1> 	mov	dword ptr [edi+3*4], ebx
    29 00001CBA 8B5F04              <1> 	mov	ebx, dword ptr [edi+1*4]	; mantissa 71..48
    30 00001CBD C1E308              <1> 	shl	ebx, 8
    31 00001CC0 C1E810              <1> 	shr	eax, 16				; mantissa 47..40
    32 00001CC3 88C3                <1> 	mov	bl, al
    33 00001CC5 895F08              <1> 	mov	dword ptr [edi+2*4], ebx	; mantissa 71..40
    34 00001CC8 8B4714              <1> 	mov	eax, dword ptr [edi+5*4]	; copy 32 signs
    35 00001CCB 894704              <1> 	mov	dword ptr [edi+1*4], eax	; to 2nd word of register block
    36 00001CCE C3                  <1> 	ret
    37                              <1> 
    38                              <1> 
    39                              <1> ;	___________________________________
    40                              <1> ;	| magnitude scale|     32 signs   |
    41                              <1> ;	|________________|________________|
    42                              <1> ;	| platform word 7| platform word 6|
    43                              <1> 
    44                              <1> 
    45                              <1> ;	<------------ 168-bit mantissa 167..72-------------|
    46                              <1> ;	<------------  72-bit mantissa ------>
    47                              <1> ;	_____________|___________|____________|____________________________
    48                              <1> ;	|      24    | 8 |   16  |   16   | 8 |    24 signs|96 more signs for
    49                              <1> ;	|____________|___|______ |________|___|____________|residue calculation
    50                              <1> ;	| platform word 5| platform word 4|   +rounding <--- @  96-bit operation
    51                              <1> 
    52                              <1> ;	                 <---------------------------------[ platform words 2..0
    53                              <1> ;	                 :
    54                              <1> ;	                 [                                                  ]
    55                              <1> 
    56                              <1> ;	                 |--- 168-bit mantissa 71:0   -------->
    57                              <1> ;	                      rounding @ 192-bit operation --->+
    58                              <1> ;      	                 _________________________|____________|_____________
    59                              <1> ;	                 |      24    | 8 |   16  |   16   | 8 |    24 signs|
    60                              <1> ;	                 |____________|___|_______|________|___|____________|
    61                              <1> ;	                 | platform word 2| platform word 1| platform word 0|
    62                              <1> 
    63                              <1> ;	                 |    residue rounding -->+
    64                              <1> ;	                 |--- 144-bit mantissa -->	                                    
    65                              <1> 
    66                              <1> _deliver_:
    67                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
    68 00001CCF 0F7EFE              <1> 	movd	esi, mm7
    69                              <1> 
    70 00001CD2 F786A0040000080000- <1> 	test	dword ptr [esi+PSR], FP_R
    70 00001CDB 00                  <1>
    71 00001CDC 0F847E000000        <1> 	jz	near _deliver
    72 00001CE2 53                  <1> 	push	ebx		; save result register index
    73 00001CE3 8B1F                <1> 	mov	ebx, dword ptr [edi]		; read scale unsigned magnitude
    74                              <1> 						; not yet signed
    75                              <1> 
    76                              <1> 				; all results except scale have been polarised
    77                              <1> 				; ebx = positive magnitude of major exponent
    78                              <1> 				; deliver floating residue
    79 00001CE5 83C3B8              <1> 	add	ebx, -72	; calculate exponent of residue
    80 00001CE8 B148                <1> 	mov	cl, 72
    81                              <1> 
    82 00001CEA 8B4710              <1> 	mov	eax, dword ptr [edi+4*4]	; mantissa */ 64 bits
    83 00001CED C1E008              <1> 	shl	eax, 8		; separate residual mantissa
    84 00001CF0 C1E808              <1> 	shr	eax, 8
    85 00001CF3 50                  <1> 	push	eax
    86 00001CF4 8B4714              <1> 	mov	eax, dword ptr [edi+5*4]	; mantissa */ 96 bits
    87 00001CF7 50                  <1> 	push	eax
    88 00001CF8 8B4718              <1> 	mov	eax, dword ptr [edi+6*4]	; mantissa */ 128 bits
    89 00001CFB 668B4704            <1> 	mov	ax, word ptr [edi+1*4]		; change low-order half trailing word to signs
    90 00001CFF 50                  <1> 	push	eax				; before normalising
    91                              <1> 
    92                              <1> _normalise_residue:
    93 00001D00 8B442408            <1> 	mov	eax, dword ptr [esp+2*4]	; residual mantissa high-order word
    94 00001D04 334704              <1> 	xor	eax, dword ptr [edi+1*4]	; signs
    95 00001D07 2500008000          <1> 	and	eax, 00800000h			; normalising position
    96 00001D0C 751A                <1> 	jnz	_residue_normalised
    97 00001D0E 8B4704              <1> 	mov	eax, dword ptr [edi+1*4]	; signs again
    98 00001D11 D1D0                <1> 	rcl	eax, 1				; place a sign in carry				
    99 00001D13 D11424              <1> 	rcl	dword ptr [esp], 1		; rotate 96 bits residual mantissa
   100 00001D16 D1542404            <1> 	rcl	dword ptr [esp+1*4], 1
   101 00001D1A D1542408            <1> 	rcl	dword ptr [esp+2*4], 1		; thirdly the high-order word
   102 00001D1E 83C3FF              <1> 	add	ebx, -1
   103 00001D21 80C1FF              <1> 	add	cl, -1
   104 00001D24 72DA                <1> 	jc	_normalise_residue
   105 00001D26 31DB                <1> 	xor	ebx, ebx			; residue all signs zero -> scale
   106                              <1> _residue_normalised:
   107 00001D28 F7C3000080FF        <1> 	test	ebx, 0FF800000h
   108                              <1> 						; likeliest $residue underflow
   109 00001D2E 0F85EEF4FFFF        <1> 	jnz	_fpxpo_low_order		; nonzero mantissa
   110                              <1> 						; and exponent underflow / overflow
   111                              <1> 						
   112                              <1> ;			residual mantissa on the stack now is
   113                              <1> ;			______________________________________________
   114                              <1> ;	sp------------->| mantissa bits 15..0 | 16 sign bits discard |
   115                              <1> ;			|_____________________|______________________|
   116                              <1> ;			|            mantissa bits 47..16            |
   117                              <1> ;			|____________________________________________| 
   118                              <1> ;			| 0000 0000  mantissa bits 71..48            |
   119                              <1> ;			|____________________________________________|
   120                              <1> ;			|	     result register indication      |
   121                              <1> ;			|____________________________________________|
   122                              <1> 
   123 00001D34 8B4704              <1> 	mov	eax, dword ptr [edi+1*4]	; signs
   124 00001D37 31D8                <1> 	xor	eax, ebx			; sign residue exponent now
   125 00001D39 C1E008              <1> 	shl	eax, 8				; trim characteristic to RTA1 24-bit word
   126 00001D3C C1E808              <1> 	shr	eax, 8
   127 00001D3F 894520              <1> 	mov	dword ptr [ebp+8*4], eax	; scale XOR signs -> residue characteristic
   128                              <1> 
   129 00001D42 5B                  <1> 	pop	ebx				; low order mantissa part
   130 00001D43 58                  <1> 	pop	eax				; middle order mantissa part
   131 00001D44 88C3                <1> 	mov	bl, al				; donate 8 bits
   132 00001D46 C1CB08              <1> 	ror	ebx, 8				; distribute as RTA1 24-bit words
   133 00001D49 C1EB08              <1> 	shr	ebx, 8				; mantissa 23..0
   134 00001D4C C1E808              <1> 	shr	eax, 8				; mantissa 47..24
   135 00001D4F 895D2C              <1> 	mov	dword ptr [ebp+11*4], ebx
   136 00001D52 894528              <1> 	mov	dword ptr [ebp+10*4], eax
   137 00001D55 58                  <1> 	pop	eax				; high order residual mantissa part
   138 00001D56 5B                  <1> 	pop	ebx				; saved result register index
   139 00001D57 C1E008              <1> 	shl	eax, 8
   140 00001D5A C1E808              <1> 	shr	eax, 8				; normalising position is bit 23
   141 00001D5D 894524              <1> 	mov	dword ptr [ebp+9*4], eax	; mantissa 71..48
   142                              <1> 
   143                              <1> _deliver:					; deliver floating result
   144                              <1> 						; ebx = target register index
   145                              <1> 						; result register index [ebp+]ebx*4
   146 00001D60 8B07                <1> 	mov	eax, dword ptr [edi]		; unsigned scale magnitude
   147 00001D62 A9000080FF          <1> 	test	eax, 0FF800000h
   148 00001D67 0F85BFF4FFFF        <1> 	jnz	_fpxpo				; exponent underflow / overflow
   149 00001D6D 334704              <1> 	xor	eax, dword ptr [edi+1*4]	; sign it
   150 00001D70 C1E008              <1> 	shl	eax, 8
   151 00001D73 C1E808              <1> 	shr	eax, 8
   152                              <1> 
   153                              <1> _store_float:
   154 00001D76 89449D00            <1>         mov     dword ptr [ebp+ebx*4], eax      ; store characteristic = scale XOR signs
   155 00001D7A 8B4708              <1>         mov     eax, dword ptr [edi+2*4]	; read bits 71..40 major mantissa
   156 00001D7D 0FB6C8              <1>         movzx   ecx, al
   157 00001D80 C1E808              <1>         shr     eax, 8
   158 00001D83 89449D04            <1>         mov     dword ptr [ebp+ebx*4+4], eax	; store mantissa bits 71..48
   159 00001D87 8B470C              <1>         mov     eax, dword ptr [edi+3*4]	; read mantissa bits 39..8
   160 00001D8A C1E110              <1>         shl     ecx, 16				; position mantissa bits 47..40
   161 00001D8D C1C810              <1>         ror     eax, 16
   162 00001D90 6689C1              <1>         mov     cx, ax				; position mantissa bits 39..24
   163 00001D93 894C9D08            <1>         mov     dword ptr [ebp+ebx*4+8], ecx	; store mantissa bits 47..24
   164 00001D97 8B4F10              <1>         mov     ecx, dword ptr [edi+4*4]	; read mantissa bits 7..0 plus 24 trailing bits
   165 00001D9A C1E910              <1>         shr     ecx, 16				; position after mantissa 23..8
   166 00001D9D 6689C8              <1>         mov     ax, cx
   167 00001DA0 C1E808              <1>         shr     eax, 8				; store mantissa bits 23..0
   168 00001DA3 89449D0C            <1>         mov     dword ptr [ebp+ebx*4+12], eax
   169 00001DA7 C3                  <1> 	ret
   170                              <1> 
   171                              <1> ;	_output equ	272
   172                              <1> ;	_inputr equ	264
   173                              <1> ;	_input2 equ	256
   174                              <1> 
   175                              <1> ;	_OUTPUT	equ	__register+_output*4
   176                              <1> ;	_INPUTR equ	__register+_inputr*4
   177                              <1> ;	_INPUT2 equ	__register+_input2*4
   178                              <1> ;	_BIAS	equ	_OUTPUT
   179                              <1> 
   180                              <1> zoutput:
   181 00001DA8 31C0                <1> 	xor	eax, eax
   182 00001DAA 8907                <1> 	mov	dword ptr [edi], eax
   183 00001DAC 894704              <1> 	mov	dword ptr [edi+1*4], eax
   184 00001DAF 894708              <1> 	mov	dword ptr [edi+2*4], eax
   185 00001DB2 89470C              <1> 	mov	dword ptr [edi+3*4], eax
   186 00001DB5 894710              <1> 	mov	dword ptr [edi+4*4], eax
   187 00001DB8 894714              <1> 	mov	dword ptr [edi+5*4], eax
   188 00001DBB 894718              <1> 	mov	dword ptr [edi+6*4], eax
   189 00001DBE 89471C              <1> 	mov	dword ptr [edi+7*4], eax
   190 00001DC1 C3                  <1> 	ret
   191                              <1> 
   192                              <1> 
   193                              <1> ;	round before add or divide
   194                              <1> ;	XOR rounding pattern to guard field
   195                              <1> 
   196 00001DC2 0F7EFB              <1> round1	movd	ebx, mm7
   197 00001DC5 8B834C020000        <1> 	mov	eax, dword ptr [ebx+REGISTER+FP_GUARD]	; register 147 = guard bits
   198 00001DCB D3E8                <1> 	shr	eax, cl
   199 00001DCD C1E008              <1> 	shl	eax, 8
   200                              <1> 
   201 00001DD0 0FB6DD              <1> 	movzx	ebx, ch
   202 00001DD3 31449F08            <1> 	xor	dword ptr [edi+ebx*4+2*4], eax
   203 00001DD7 C3                  <1> 	ret
   204                              <1> 
   205 00001DD8 0FB6DD              <1> round2:	movzx	ebx, ch
   206                              <1> ;	mov	eax, dword ptr [ebp+CORE_INDEX1]	; ? can't have mattered
   207 00001DDB 0F7EFE              <1> 	movd	esi, mm7			; 
   208                              <1> 
   209 00001DDE 8B864C020000        <1> 	mov	eax, dword ptr [esi+REGISTER+FP_GUARD]
   210 00001DE4 D3E8                <1> 	shr	eax, cl
   211 00001DE6 C1E008              <1> 	shl	eax, 8
   212 00001DE9 01449F08            <1> 	add	dword ptr [edi+ebx*4+2*4], eax
   213                              <1> round2more:
   214 00001DED 83549F0400          <1> 	adc	dword ptr [edi+ebx*4+1*4], 0
   215 00001DF2 4B                  <1> 	dec	ebx
   216 00001DF3 75F8                <1> 	jnz	round2more
   217 00001DF5 C3                  <1> 	ret
   218                              <1> 
   219                              <1> end_around_carry:
   220                              <1> 
   221 00001DF6 F75608              <1> 	not	dword ptr [esi+2*4]		; seems to vary or be vaguely documented
   222 00001DF9 0FB64604            <1> 	movzx	eax, byte ptr [esi+1*4]		; what size the call return stack frame is
   223                              <1> 						; so we push ei and copy esp to it
   224                              <1> 						; to see stuff near the stack top
   225                              <1> 
   226 00001DFD F6460880            <1> 	test	byte ptr dword ptr [esi+2*4], 128
   227 00001E01 790B                <1> 	jns	end_around_carry_plus		; updated signs +
   228                              <1> 
   229 00001E03 B8FFFFFFFF          <1> 	mov	eax, -1				; 1 -> -1 in 1s complement
   230 00001E08 D3E8                <1> 	shr	eax, cl
   231 00001E0A F7D0                <1> 	not	eax
   232 00001E0C EB06                <1> 	jmp	eoc1
   233                              <1> 
   234                              <1> end_around_carry_plus:
   235 00001E0E 21C0                <1> ?	and	eax, eax
   236 00001E10 7415                <1> 	jz	eox1				; ? don't call this if there is no carry
   237 00001E12 D3C8                <1> 	ror	eax, cl
   238                              <1> 
   239 00001E14 0FB6DD              <1> eoc1:	movzx	ebx, ch
   240 00001E17 01449F08            <1> 	add	dword ptr [edi+ebx*4+2*4], eax
   241                              <1> 
   242 00001E1B 9C                  <1> 	pushf
   243 00001E1C C1F81F              <1> 	sar	eax, 31				; shift leave carry alone
   244 00001E1F 9D                  <1> 	popfd
   245                              <1> 
   246 00001E20 43                  <1> 	inc	ebx				; but reference displacements - 2
   247                              <1> 
   248 00001E21 11049F              <1> eoc:	adc	dword ptr [edi+ebx*4], eax	; referencing displacements - 2
   249 00001E24 4B                  <1> 	dec	ebx
   250 00001E25 75FA                <1> 	jnz	eoc
   251 00001E27 C3                  <1> eox1:	ret
   252                              <1> 
   253                              <1> restore_trailing_signs:
   254 00001E28 0FB6DD              <1> 	movzx	ebx, ch
   255 00001E2B 8B4704              <1> 	mov	eax, dword ptr [edi+1*4]
   256                              <1> 
   257 00001E2E 89471C              <1> 	mov	dword ptr [edi+7*4], eax
   258                              <1> 
   259 00001E31 21C0                <1> 	and	eax, eax
   260 00001E33 780B                <1> 	js	restore_trailing_ones
   261 00001E35 F7D0                <1> 	not	eax
   262 00001E37 D3E8                <1> 	shr	eax, cl
   263 00001E39 F7D0                <1> 	not	eax
   264 00001E3B 21449F08            <1> 	and	dword ptr [edi+ebx*4+2*4], eax
   265                              <1> 
   266 00001E3F C3                  <1> 	ret
   267                              <1> restore_trailing_ones:
   268 00001E40 D3E8                <1> 	shr	eax, cl
   269 00001E42 09449F08            <1> 	or	dword ptr [edi+ebx*4+2*4], eax
   270                              <1> 
   271 00001E46 C3                  <1> 	ret
   272                              <1> 	
   273                              <1> BIAS_FIELD	equ	8
   274                              <1> 
   275                              <1> bias_addend:					; input mantissa [esi] is biased into location _BIAS
   276 00001E47 57                  <1> 	push	edi
   277 00001E48 89F7                <1> 	mov	edi, esi
   278                              <1> 
   279                              <1> ;	mov	esi, dword ptr[ebp+CORE_INDEX1]
   280 00001E4A 0F7EFE              <1> 	movd	esi, mm7
   281 00001E4D 8DB640040000        <1> 	lea	esi, [esi+_BIAS]
   282                              <1> 
   283 00001E53 56                  <1> 	push	esi
   284 00001E54 E803000000          <1> 	call	biasfp
   285                              <1> 
   286 00001E59 5E                  <1> 	pop	esi
   287 00001E5A 5F                  <1> 	pop	edi
   288 00001E5B C3                  <1> 	ret
   289                              <1> 
   290 00001E5C 52                  <1> biasfp:	push	edx
   291 00001E5D 51                  <1> 	push	ecx
   292                              <1> 
   293 00001E5E BB01000000          <1> 	mov	ebx, 1				; output index
   294 00001E63 66C1E003            <1> 	shl	ax, 3				; words sign fill
   295 00001E67 C0E803              <1> 	shr	al, 3				; bits sign fill
   296 00001E6A 6689C1              <1> 	mov	cx, ax
   297 00001E6D 83C704              <1> 	add	edi, 4				; input pointer
   298 00001E70 8B07                <1> 	mov	eax, dword ptr [edi]		; there shall be this word of signs at least
   299                              <1> 
   300 00001E72 89049E              <1> bias32:	mov	dword ptr [esi+ebx*4], eax	; write 1 word of signs
   301 00001E75 43                  <1> 	inc	ebx				; consider the next output word
   302 00001E76 FECD                <1> 	dec	ch				; any more words of signs?
   303 00001E78 79F8                <1> 	jns	bias32
   304                              <1> 
   305 00001E7A 20C9                <1> 	and	cl, cl
   306 00001E7C 7422                <1> 	jz	bias_fast			; there is no 32-bit shift
   307                              <1> 
   308 00001E7E B520                <1> 	mov	ch, 32				; demonstrate the missing advantage
   309 00001E80 28CD                <1> 	sub	ch, cl				; of instruction architectures
   310                              <1> 						; with 2-register shifts
   311                              <1> biasup2:
   312 00001E82 83FB08              <1> 	cmp	ebx, BIAS_FIELD
   313 00001E85 742B                <1> 	jz	bias_addx
   314 00001E87 83C704              <1> 	add	edi, 4				; read new mantissa word
   315 00001E8A 8B17                <1> 	mov	edx, dword ptr [edi]		; it becomes word # new in edx
   316 00001E8C 86E9                <1> 	xchg	ch, cl
   317 00001E8E D3E0                <1> 	shl	eax, cl				; shift buffered word left 32 - bit offset
   318 00001E90 86E9                <1> 	xchg	ch, cl
   319 00001E92 D3EA                <1> 	shr	edx, cl				; shift new mantissa word right bit offset
   320 00001E94 09D0                <1> 	or	eax, edx
   321 00001E96 89049E              <1> 	mov	dword ptr [esi+ebx*4], eax	; write 1 merged word
   322 00001E99 8B07                <1> 	mov	eax, dword ptr [edi]		; read the same mantissa word again
   323 00001E9B 83C301              <1> 	add	ebx, 1				; it becomes word # previous in eax
   324 00001E9E EBE2                <1> 	jmp	biasup2
   325                              <1> 
   326                              <1> bias_fast:
   327 00001EA0 83FB08              <1> 	cmp	ebx, BIAS_FIELD
   328 00001EA3 740D                <1> 	jz	bias_addx
   329 00001EA5 83C704              <1> 	add	edi, 4
   330 00001EA8 8B07                <1> 	mov	eax, dword ptr [edi]
   331 00001EAA 89049E              <1> 	mov	dword ptr [esi+ebx*4], eax
   332 00001EAD 83C301              <1> 	add	ebx, 1
   333 00001EB0 EBEE                <1> 	jmp	bias_fast
   334                              <1> 
   335                              <1> bias_addx:
   336 00001EB2 59                  <1> 	pop	ecx
   337 00001EB3 5A                  <1> 	pop	edx				; restore the program counter
   338 00001EB4 C3                  <1> 	ret
   339                              <1> 
   340                              <1> frame_mantissa:
   341                              <1> ;	ror	ecx, 16				; words count is up, beats index down
   342 00001EB5 80C501              <1> 	add	ch, 1				; up the beats index to beats count
   343 00001EB8 66C1E905            <1> 	shr	cx, 5				; positions / 32 in ch
   344 00001EBC C0E903              <1> 	shr	cl, 3				; positions /// 32 in cl
   345 00001EBF 0FB6DD              <1> 	movzx	ebx, ch				; derive platform words rounded down
   346 00001EC2 C3                  <1> 	ret
   347                              <1> 
   348                              <1> renormalise:					; rule 1: restore sign fill in
   349                              <1> 						; low-order containing platform word
   350                              <1> ; done before end-around-carry, and saved
   351                              <1> ;;	call	frame_mantissa			; it was mashed by rounding and adding
   352 00001EC3 E860FFFFFF          <1> 	call	restore_trailing_signs
   353 00001EC8 C1C910              <1> 	ror	ecx, 16				; the governing parameter is now
   354                              <1> 						; the containing words count in cx
   355                              <1> renormalise32:
   356 00001ECB 8B4708              <1> 	mov	eax, dword ptr [edi+2*4]	; sample 32 mantissa bits
   357 00001ECE 3B4704              <1> 	cmp	eax, dword ptr [edi+1*4]	; compare it with 32 signs
   358 00001ED1 750C                <1> 	jnz	renormalise8
   359 00001ED3 E83E000000          <1> 	call	rotate32left			; this also discovers if it's ALL signs = 0
   360 00001ED8 21C0                <1> 	and	eax, eax			; and is the only place that needs examined
   361 00001EDA 75EF                <1> 	jnz	renormalise32
   362                              <1> 
   363 00001EDC 8907                <1> 	mov	dword ptr [edi], eax		; mantissa is signed zero, +0 -> scale
   364                              <1> renormalised:
   365 00001EDE C3                  <1> 	ret
   366                              <1> 
   367                              <1> renormalise8:					; from this point on the value is nonzero
   368 00001EDF C1C008              <1> 	rol	eax, 8				; are there 8 signs at head of mantissa?
   369 00001EE2 3A4707              <1> 	cmp	al, byte ptr [edi+1*4+3]	; this is Intel and the 4th byte is high-order
   370 00001EE5 750A                <1> 	jnz	renormalise1			; you have found the 8 bits containing the
   371                              <1> 						; normalising bit
   372 00001EE7 E849000000          <1> 	call	rotate8left			; or else you haven't
   373 00001EEC 8B4708              <1> 	mov     eax, dword ptr [edi+2*4]	; sample the moved mantissa
   374 00001EEF EBEE                <1> 	jmp	renormalise8
   375                              <1> 
   376                              <1> renormalise1:
   377                              <1> ;	movzx	ebx, cx	
   378 00001EF1 8B4704              <1> 	mov	eax, dword ptr [edi+1*4]		
   379                              <1> ;	mov	dword ptr [edi+ebx*4+1*4], eax	; in case polarity has changed
   380 00001EF4 334708              <1> 	xor	eax, dword ptr [edi+2*4]	; normalising bit opposite polarity to sign?
   381 00001EF7 78E5                <1> 	js	renormalised			; arrived
   382 00001EF9 E802000000          <1> 	call	bitwise_scale			; almost arrived
   383 00001EFE EBF1                <1> 	jmp	renormalise1
   384                              <1> 
   385                              <1> 
   386                              <1> bitwise_scale:
   387 00001F00 D1571C              <1> 	rcl	dword ptr [edi+7*4], 1	; so it doesn't matter whether 0 or 1
   388 00001F03 D15718              <1> 	rcl	dword ptr [edi+6*4], 1	; gets shifted into the 192nd bit
   389 00001F06 D15714              <1> 	rcl	dword ptr [edi+5*4], 1
   390 00001F09 D15710              <1> 	rcl	dword ptr [edi+4*4], 1	; it's quicker to shift 6 words
   391 00001F0C D1570C              <1> 	rcl	dword ptr [edi+3*4], 1	; than a counted loop of 4 or 5 or 6 words
   392 00001F0F D15708              <1> 	rcl	dword ptr [edi+2*4], 1
   393                              <1> 
   394 00001F12 8307FF              <1> 	add	dword ptr [edi], -1	; scale down
   395 00001F15 C3                  <1> 	ret
   396                              <1> 
   397                              <1> rotate32left:				; rotate all containing platform words of mantissa
   398 00001F16 52                  <1> 	push	edx			; 32 bit positions left and report if all signs
   399 00001F17 51                  <1> 	push	ecx
   400 00001F18 0FB7D9              <1> 	movzx	ebx, cx
   401 00001F1B 31D2                <1> 	xor	edx, edx		; initialise equality = all signs
   402                              <1> 
   403                              <1> rotate32next:				; the word initially loaded in eax is all signs
   404 00001F1D 4B                  <1> 	dec	ebx
   405 00001F1E 87449F08            <1> 	xchg	eax, dword ptr [edi+ebx*4+2*4]
   406 00001F22 89C1                <1> 	mov	ecx, eax
   407 00001F24 334F04              <1> 	xor	ecx, dword ptr [edi+1*4] ; difference between this word and signs
   408 00001F27 09CA                <1> 	or	edx, ecx		; sum of differences
   409 00001F29 21DB                <1> 	and	ebx, ebx
   410 00001F2B 75F0                <1> 	jnz	rotate32next
   411 00001F2D 8307E0              <1> 	add	dword ptr [edi], -32	; scale down
   412 00001F30 89D0                <1> 	mov	eax, edx
   413 00001F32 59                  <1> 	pop	ecx
   414 00001F33 5A                  <1> 	pop	edx
   415 00001F34 C3                  <1> 	ret
   416                              <1> 
   417                              <1> rotate8left:				; rotate all containing platform words of mantissa
   418 00001F35 51                  <1> 	push	ecx			; 8 bit positions left. 1st word is rotated already
   419 00001F36 0FB7D9              <1> 	movzx	ebx, cx			; and contains signs in 8 low-order bit positions
   420                              <1> rotate8next:
   421 00001F39 8B4C9F08            <1> 	mov	ecx, dword ptr [edi+ebx*4+2*4]
   422 00001F3D C1C108              <1> 	rol	ecx, 8
   423 00001F40 86C1                <1> 	xchg	al, cl
   424 00001F42 894C9F08            <1> 	mov	dword ptr [edi+ebx*4+2*4], ecx
   425 00001F46 83C3FF              <1> 	add	ebx, -1
   426 00001F49 72EE                <1> 	jc	rotate8next
   427 00001F4B 8307F8              <1> 	add	dword ptr [edi], -8	; scale down
   428 00001F4E 59                  <1> 	pop	ecx
   429 00001F4F C3                  <1> 	ret
   430                              <1> 
   431 00001F50 F75708              <1> zover:	not	dword ptr [edi+2*4]
   432 00001F53 F7570C              <1> 	not	dword ptr [edi+3*4]
   433 00001F56 F75710              <1> 	not	dword ptr [edi+4*4]
   434 00001F59 F75714              <1> 	not	dword ptr [edi+5*4]
   435 00001F5C F75718              <1> 	not	dword ptr [edi+6*4]
   436 00001F5F F7571C              <1> 	not	dword ptr [edi+7*4]
   437 00001F62 C3                  <1> 	ret
   438                              <1> 
   439                              <1> _add_low:
   440 00001F63 8B961C040000        <1>         mov     edx, dword ptr [esi+_INPUT2+7*4]
   441 00001F69 13963C040000        <1>         adc     edx, dword ptr [esi+_INPUTR+7*4]
   442 00001F6F 8B9E18040000        <1>         mov     ebx, dword ptr [esi+_INPUT2+6*4]
   443 00001F75 139E38040000        <1>         adc     ebx, dword ptr [esi+_INPUTR+6*4]
   444 00001F7B 8B8614040000        <1>         mov     eax, dword ptr [esi+_INPUT2+5*4]
   445 00001F81 138634040000        <1>         adc     eax, dword ptr [esi+_INPUTR+5*4]
   446 00001F87 C3                  <1>         ret
   447                              <1> 
   448                              <1> _add_high:
   449 00001F88 8B9610040000        <1>         mov     edx, dword ptr [esi+_INPUT2+4*4]
   450 00001F8E 139630040000        <1>         adc     edx, dword ptr [esi+_INPUTR+4*4]
   451 00001F94 8B9E0C040000        <1>         mov     ebx, dword ptr [esi+_INPUT2+3*4]
   452 00001F9A 139E2C040000        <1>         adc     ebx, dword ptr [esi+_INPUTR+3*4]
   453 00001FA0 8B8608040000        <1>         mov     eax, dword ptr [esi+_INPUT2+2*4]
   454 00001FA6 138628040000        <1>         adc     eax, dword ptr [esi+_INPUTR+2*4]
   455 00001FAC C3                  <1>         ret
   456                              <1> 
   457 00001FAD 8DBE00040000        <1> fan:	lea	edi, [esi+_INPUT2]
   458 00001FB3 E898FFFFFF          <1> 	call	zover				; mantissa
   459 00001FB8 F79604040000        <1> 	not	dword ptr [esi+_INPUT2+1*4]	; 32 signs
   460                              <1> 
   461 00001FBE 8DBE20040000        <1> fa:	lea	edi, [esi+_INPUTR]
   462 00001FC4 8DB600040000        <1> 	lea	esi, [esi+_INPUT2]
   463                              <1> 
   464 00001FCA 8B4604              <1> 	mov	eax, dword ptr [esi+1*4]	; normalised?
   465 00001FCD 334608              <1> 	xor	eax, dword ptr [esi+2*4]	; normalising bit must ^ signs
   466 00001FD0 7801                <1> 	js	fa_addend_normalised		; yes
   467 00001FD2 C3                  <1> fa_nop:	ret					; accumulator block unchanged
   468                              <1> 
   469                              <1> fa_addend_normalised:
   470 00001FD3 8B4704              <1> 	mov	eax, dword ptr [edi+1*4]	; register side operand normalised?
   471 00001FD6 334708              <1> 	xor	eax, dword ptr [edi+2*4]	; normalising bit must ^ signs
   472 00001FD9 7803                <1> 	js	fa_promote_magnitude		; normalised, get on with it
   473 00001FDB 89F7                <1> 	mov	edi, esi			; accumulator block is not normalised
   474 00001FDD C3                  <1> 	ret					; storage addend zero-added
   475                              <1> 
   476                              <1> fa_promote_magnitude:
   477 00001FDE 8B07                <1> 	mov	eax, dword ptr [edi]
   478 00001FE0 2B06                <1> 	sub	eax, dword ptr [esi]
   479                              <1> 
   480 00001FE2 7904                <1> 	jns	fa_add				; register-side operand is not lower
   481                              <1> 
   482 00001FE4 87F7                <1> 	xchg	esi, edi			;
   483 00001FE6 F7D8                <1> 	neg	eax
   484                              <1> 
   485                              <1> fa_add:	;	call	frame_mantissa
   486 00001FE8 50                  <1> 	push	eax				; exponent difference
   487 00001FE9 E8D4FDFFFF          <1> 	call	round1
   488                              <1> 
   489 00001FEE 58                  <1> 	pop	eax				; exponent difference
   490 00001FEF 21C0                <1> 	and	eax, eax			; is + and either zero or not
   491 00001FF1 740C                <1> 	jz	fa_addfast
   492                              <1> 
   493 00001FF3 3DA7000000          <1> 	cmp	eax, 167			; do they touch?
   494 00001FF8 77D8                <1> 	ja	fa_nop
   495                              <1> 
   496 00001FFA E848FEFFFF          <1> 	call	bias_addend
   497                              <1> 
   498                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1] ; done inside bias_addend
   499                              <1> ;	anyway movd	esi, mm7
   500                              <1> ;	lea	esi, [esi+_BIAS]		; shifted added
   501                              <1> 
   502                              <1> fa_addfast:
   503 00001FFF 8B4704              <1> 	mov	eax, dword ptr [edi+1*4]	; before look signs
   504 00002002 50                  <1> 	push	eax				; near stack top until fa_normalised
   505                              <1> 
   506 00002003 C1C910              <1> 	ror	ecx, 16				; get containing compute words
   507 00002006 0FB7D9              <1> 	movzx	ebx, cx				; index / count
   508 00002009 C1C910              <1> 	ror	ecx, 16
   509                              <1> 
   510                              <1> 	%if	BIAS_FIELD=8
   511 0000200C 81671C000000FF      <1> 	and	dword ptr [edi+7*4], 0FF000000h
   512 00002013 81661C000000FF      <1> 	and	dword ptr [esi+7*4], 0FF000000h
   513                              <1> 	%endif
   514                              <1> 
   515                              <1> ; call ultrate
   516                              <1> 	%if	0
   517                              <1> 	mov	eax, dword ptr [esi+1*4]	; signs word in _OUTPUT 
   518                              <1> 
   519                              <1> 	rol	eax, 1
   520                              <1> 
   521                              <1> 	%else
   522 0000201A F8                  <1> 	clc
   523                              <1> 	%endif
   524                              <1> 
   525                              <1> fa_action:
   526 0000201B 8B049E              <1> 	mov	eax, dword ptr [esi+ebx*4]
   527 0000201E 11049F              <1> 	adc	dword ptr [edi+ebx*4], eax
   528 00002021 4B                  <1> 	dec	ebx				; process word 1
   529 00002022 75F7                <1> 	jnz	fa_action			; leave word 0 alone
   530                              <1> 
   531                              <1> ; call ultrate
   532                              <1> 
   533 00002024 0F92C3              <1> 	setc	bl				; boolean instructions following
   534 00002027 53                  <1> 	push	ebx				; should not change carry but
   535                              <1> 
   536                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
   537 00002028 0F7EFE              <1> 	movd	esi, mm7
   538                              <1> 	
   539 0000202B 8B4704              <1> 	mov	eax, dword ptr [edi+1*4]	; has sign switched ?
   540 0000202E 33442404            <1> 	xor	eax, dword ptr [esp+1*4]
   541                              <1> 	
   542 00002032 7918                <1> 	jns	fa_testcarry
   543                              <1> 
   544                              <1> ;	not	dword ptr [esi+7*4]
   545                              <1> 
   546 00002034 F686A004000008      <1> 	test	byte ptr [esi+PSR], FP_R	; flag 8 = store residue
   547 0000203B 7506                <1> 	jnz	switch_long
   548                              <1> 
   549 0000203D F75718              <1> 	not	dword ptr [edi+6*4]		; if double size (+ residue)
   550 00002040 F75714              <1> 	not	dword ptr [edi+5*4]		; these are written in the add loop
   551                              <1> switch_long:
   552                              <1> 
   553                              <1> ;	not	dword ptr [edi+7*4]		; thru zero
   554                              <1> 
   555 00002043 56                  <1> 	push	esi				; have a clear expectation
   556 00002044 89E6                <1> 	mov	esi, esp			; where the first stack words are
   557 00002046 E8ABFDFFFF          <1> 	call	end_around_carry
   558 0000204B 5E                  <1> 	pop	esi
   559                              <1> 
   560                              <1> fa_testcarry:
   561                              <1> 
   562 0000204C 8B442404            <1> 	mov	eax, dword ptr [esp+1*4]		; [ esp + 1L ] -> updated signs
   563 00002050 334704              <1> 	xor	eax, dword ptr [edi+1*4]		; carry from normalising position?
   564                              <1> 
   565 00002053 2401                <1> 	and	al, 1
   566 00002055 7422                <1> 	jz	fa_normalise
   567                              <1> 
   568 00002057 FF07                <1> 	inc	dword ptr [edi]				; exponent magnitude++
   569                              <1> 
   570 00002059 8B442404            <1> 	mov	eax, dword ptr [esp+1*4]	 	; read 32 signs
   571 0000205D D1C8                <1> 	ror	eax, 1					; move a sign to carry	
   572                              <1> 
   573 0000205F D15F04              <1> 	rcr	dword ptr [edi+1*4], 1			; shift from signs word
   574 00002062 D15F08              <1> 	rcr	dword ptr [edi+2*4], 1			; to normalising position
   575 00002065 D15F0C              <1> 	rcr	dword ptr [edi+3*4], 1			; keep going
   576 00002068 D15F10              <1> 	rcr	dword ptr [edi+4*4], 1
   577 0000206B D15F14              <1> 	rcr	dword ptr [edi+5*4], 1
   578 0000206E D15F18              <1> 	rcr	dword ptr [edi+6*4], 1
   579 00002071 D15F1C              <1> 	rcr	dword ptr [edi+7*4], 1
   580                              <1> 
   581 00002074 894704              <1> 	mov	dword ptr [edi+1*4], eax		; write all signs back to signs word
   582                              <1> 
   583 00002077 EB0A                <1> 	jmp	fa_normalised
   584                              <1> 
   585                              <1> fa_normalise:
   586                              <1> 	%if	BIAS_FIELD=8
   587 00002079 E80D040000          <1> 	call	fp_registers_m
   588                              <1> 	%endif
   589                              <1> 
   590 0000207E E840FEFFFF          <1> 	call	renormalise				; in case the sum is plenty positions
   591                              <1> 
   592                              <1> fa_normalised:
   593 00002083 5B                  <1> 	pop	ebx
   594 00002084 58                  <1> 	pop	eax					; below the fractional point
   595 00002085 C3                  <1> 	ret
   596                              <1> 	
   597 00002086 8DBE40040000        <1> fm:	lea	edi, [esi+_OUTPUT]			; initialise final accumulation
   598 0000208C E817FDFFFF          <1> 	call	zoutput
   599                              <1> 
   600 00002091 8B9E24040000        <1> 	mov	ebx, dword ptr [esi+_INPUTR+1*4]	; read register-side signs
   601 00002097 8B8628040000        <1> 	mov	eax, dword ptr [esi+_INPUTR+2*4]	; and high-end mantissa
   602 0000209D 31D8                <1> 	xor	eax, ebx	 			; cache if-normalised in eax
   603 0000209F 339E04040000        <1> 	xor	ebx, dword ptr [esi+_INPUT2+1*4]	; multiply signs
   604 000020A5 899E44040000        <1> 	mov	dword ptr [esi+_OUTPUT+1*4], ebx	; save the output sign
   605 000020AB 21C0                <1> 	and	eax, eax				; test the cached if-normalised
   606 000020AD 790E                <1> 	jns	fmdont
   607                              <1> 
   608 000020AF 8B8604040000        <1> 	mov	eax, dword ptr [esi+_INPUT2+1*4]	; is the multiplier normalised?
   609 000020B5 338608040000        <1> 	xor	eax, dword ptr [esi+_INPUT2+2*4]	; sign XOR normalising bit?
   610 000020BB 782F                <1> 	js	fmgo					; yes, proceed
   611                              <1> 
   612 000020BD 899E48040000        <1> fmdont:	mov	dword ptr [esi+_OUTPUT+2*4], ebx
   613 000020C3 899E4C040000        <1> 	mov	dword ptr [esi+_OUTPUT+3*4], ebx
   614 000020C9 899E50040000        <1> 	mov	dword ptr [esi+_OUTPUT+4*4], ebx
   615 000020CF 899E54040000        <1> 	mov	dword ptr [esi+_OUTPUT+5*4], ebx
   616 000020D5 899E58040000        <1> 	mov	dword ptr [esi+_OUTPUT+6*4], ebx
   617 000020DB 899E5C040000        <1> 	mov	dword ptr [esi+_OUTPUT+7*4], ebx
   618 000020E1 C78640040000000000- <1> 	mov	dword ptr [esi+_OUTPUT], 0		; mantissa to go
   618 000020EA 00                  <1>
   619                              <1> 
   620 000020EB C3                  <1> 	ret					; no, effective zero multiplier
   621                              <1> 
   622 000020EC 51                  <1> fmgo:	push	ecx
   623 000020ED 8B8624040000        <1> 	mov	eax, dword ptr [esi+_INPUTR+1*4]
   624 000020F3 B148                <1> 	mov	cl, 72				; beats count exactly 72
   625 000020F5 21C0                <1> 	and	eax, eax
   626                              <1> 
   627 000020F7 790B                <1> 	jns	fmp1
   628 000020F9 8DBE20040000        <1> 	lea	edi, [esi+_INPUTR]
   629 000020FF E84CFEFFFF          <1> 	call	zover
   630                              <1> 
   631 00002104 8B8604040000        <1> fmp1:	mov	eax, dword ptr [esi+_INPUT2+1*4]
   632 0000210A 21C0                <1> 	and	eax, eax
   633 0000210C 790B                <1> 	jns	fmadd
   634 0000210E 8DBE00040000        <1> 	lea	edi, [esi+_INPUT2]
   635 00002114 E837FEFFFF          <1> 	call	zover
   636                              <1> 
   637 00002119 F8                  <1> fmadd:	clc
   638                              <1> 
   639 0000211A 8DBE20040000        <1> 	lea	edi, [esi+_INPUTR]
   640 00002120 D15F08              <1> 	rcr	dword ptr [edi+2*4], 1		; addend shift right
   641 00002123 D15F0C              <1> 	rcr	dword ptr [edi+3*4], 1
   642 00002126 D15F10              <1> 	rcr	dword ptr [edi+4*4], 1
   643 00002129 D15F14              <1> 	rcr	dword ptr [edi+5*4], 1
   644 0000212C D15F18              <1> 	rcr	dword ptr [edi+6*4], 1
   645 0000212F D15F1C              <1> 	rcr	dword ptr [edi+7*4], 1
   646                              <1> 
   647 00002132 8DBE00040000        <1> 	lea	edi, [esi+_INPUT2]
   648                              <1> 
   649                              <1> 	%if	0
   650                              <1> 	rcl	dword ptr [edi+7*4], 1		; multiplier shift left
   651                              <1> 	rcl	dword ptr [edi+6*4], 1
   652                              <1> 	rcl	dword ptr [edi+5*4], 1		; multiplier mantissa is only 72 bits
   653                              <1> 	%endif
   654                              <1> 
   655 00002138 D15710              <1> 	rcl	dword ptr [edi+4*4], 1
   656 0000213B D1570C              <1> 	rcl	dword ptr [edi+3*4], 1
   657 0000213E D15708              <1> 	rcl	dword ptr [edi+2*4], 1
   658                              <1> 
   659 00002141 8DBE40040000        <1> 	lea	edi, [esi+_OUTPUT]
   660 00002147 7336                <1> 	jnc	fmadx
   661                              <1> 						; 1 shifted from multiplier
   662 00002149 8B863C040000        <1> fmadc:	mov	eax, dword ptr [esi+_INPUTR+7*4]	
   663 0000214F 01471C              <1> 	add	dword ptr [edi+7*4], eax	; do not use carry
   664 00002152 8B8638040000        <1> 	mov	eax, dword ptr [esi+_INPUTR+6*4]
   665 00002158 114718              <1> 	adc	dword ptr [edi+6*4], eax	; start using carry
   666 0000215B 8B8634040000        <1> 	mov	eax, dword ptr [esi+_INPUTR+5*4]
   667 00002161 114714              <1> 	adc	dword ptr [edi+5*4], eax
   668 00002164 8B8630040000        <1> 	mov	eax, dword ptr [esi+_INPUTR+4*4]
   669 0000216A 114710              <1> 	adc	dword ptr [edi+4*4], eax
   670 0000216D 8B862C040000        <1> 	mov	eax, dword ptr [esi+_INPUTR+3*4]
   671 00002173 11470C              <1> 	adc	dword ptr [edi+3*4], eax
   672 00002176 8B8628040000        <1> 	mov	eax, dword ptr [esi+_INPUTR+2*4]
   673 0000217C 114708              <1> 	adc	dword ptr [edi+2*4], eax
   674                              <1> 
   675 0000217F FEC9                <1> fmadx:	dec	cl
   676 00002181 7596                <1> 	jnz	fmadd
   677                              <1> 
   678 00002183 59                  <1> fmadz:	pop	ecx
   679                              <1> 
   680 00002184 8B4708              <1> 	mov	eax, dword ptr [edi+2*4] 	; normalised?
   681 00002187 D1D0                <1> 	rcl	eax, 1
   682 00002189 721B                <1> 	jc	fm_normalised
   683                              <1> 
   684 0000218B 838620040000FF      <1> 	add	dword ptr [esi+_INPUTR], -1		; take 1 from scale
   685 00002192 D1571C              <1> 	rcl	dword ptr [edi+7*4], 1
   686 00002195 D15718              <1> 	rcl	dword ptr [edi+6*4], 1
   687 00002198 D15714              <1> 	rcl	dword ptr [edi+5*4], 1
   688 0000219B D15710              <1> 	rcl	dword ptr [edi+4*4], 1
   689 0000219E D1570C              <1> 	rcl	dword ptr [edi+3*4], 1
   690 000021A1 D15708              <1> 	rcl	dword ptr [edi+2*4], 1
   691                              <1> 
   692 000021A4 EB26                <1> 	jmp	fm_inrange
   693                              <1> 
   694                              <1> fm_normalised:
   695 000021A6 8DBE40040000        <1> 	lea	edi, [esi+_OUTPUT]
   696 000021AC E827FCFFFF          <1> 	call	round2
   697 000021B1 7319                <1> 	jnc	fm_inrange
   698                              <1> 
   699 000021B3 D15F08              <1> 	rcr	dword ptr [edi+2*4], 1
   700 000021B6 D15F0C              <1> 	rcr	dword ptr [edi+3*4], 1
   701 000021B9 D15F10              <1> 	rcr	dword ptr [edi+4*4], 1
   702 000021BC D15F14              <1> 	rcr	dword ptr [edi+5*4], 1
   703 000021BF D15F18              <1> 	rcr	dword ptr [edi+6*4], 1
   704 000021C2 D15F1C              <1> 	rcr	dword ptr [edi+7*4], 1
   705 000021C5 83862004000001      <1> 	add	dword ptr [esi+_INPUTR], 1
   706                              <1> 
   707                              <1> fm_inrange:
   708 000021CC 8B8620040000        <1> 	mov	eax, dword ptr [esi+_INPUTR]
   709 000021D2 038600040000        <1> 	add	eax, dword ptr [esi+_INPUT2]
   710 000021D8 050000C0FF          <1> 	add	eax, -00400000h
   711 000021DD 8907                <1> 	mov	dword ptr [edi], eax		; insert unsigned magnitude product scale
   712 000021DF 8B4704              <1> 	mov	eax, dword ptr [edi+1*4]
   713 000021E2 314708              <1> 	xor	dword ptr [edi+2*4], eax	; the mantissa gets polarised here
   714 000021E5 31470C              <1> 	xor	dword ptr [edi+3*4], eax
   715 000021E8 314710              <1> 	xor	dword ptr [edi+4*4], eax
   716 000021EB 314714              <1> 	xor	dword ptr [edi+5*4], eax
   717 000021EE 314718              <1> 	xor	dword ptr [edi+6*4], eax
   718 000021F1 31471C              <1> 	xor	dword ptr [edi+7*4], eax
   719 000021F4 C3                  <1> 	ret
   720                              <1> 
   721 000021F5 8DBE40040000        <1> fd:	lea	edi, [esi+_OUTPUT]
   722 000021FB E8A8FBFFFF          <1> 	call	zoutput				; result which may stay zero
   723 00002200 8B8604040000        <1> 	mov	eax, dword ptr [esi+_INPUT2+1*4]	; signs
   724 00002206 89C3                <1> 	mov	ebx, eax
   725 00002208 338608040000        <1> 	xor	eax, dword ptr [esi+_INPUT2+2*4]	; normalising bit 31
   726 0000220E 780C                <1> 	js	fdgo
   727 00002210 F79644040000        <1> 	not	dword ptr [esi+_OUTPUT+1*4]		; divisor 0 or otherwise unnormalised
   728 00002216 E835FDFFFF          <1> 	call	zover				; return -0.0
   729 0000221B C3                  <1> fdnop:	ret					; not normalised = zero divisor
   730                              <1> 
   731 0000221C 8B8624040000        <1> fdgo:	mov     eax, dword ptr [esi+_INPUTR+1*4]	; make sure the dividend is present
   732 00002222 338628040000        <1> 	xor	eax, dword ptr [esi+_INPUTR+2*4]	; normalising bit must be not sign
   733 00002228 783B                <1> 	js	fdop				; go after all
   734                              <1> 						; unnormalised = 0 = unnormalised
   735 0000222A 8B8624040000        <1> 	mov	eax, dword ptr [esi+_INPUTR+1*4]	; read the signs I tell you
   736 00002230 C78640040000000000- <1> 	mov	dword ptr [esi+_OUTPUT], 0		; exponent magnitude of nowhere
   736 00002239 00                  <1>
   737 0000223A 898644040000        <1> 	mov	dword ptr [esi+_OUTPUT+1*4], eax	; signs
   738 00002240 898648040000        <1> 	mov	dword ptr [esi+_OUTPUT+2*4], eax	; and as much mantissa as you like
   739 00002246 89864C040000        <1> 	mov	dword ptr [esi+_OUTPUT+3*4], eax
   740 0000224C 898650040000        <1> 	mov	dword ptr [esi+_OUTPUT+4*4], eax
   741 00002252 898654040000        <1> 	mov	dword ptr [esi+_OUTPUT+5*4], eax
   742 00002258 898658040000        <1> 	mov	dword ptr [esi+_OUTPUT+6*4], eax
   743 0000225E 89865C040000        <1> 	mov	dword ptr [esi+_OUTPUT+7*4], eax
   744 00002264 C3                  <1> 	ret
   745                              <1> 
   746 00002265 21DB                <1> fdop:	and	ebx, ebx				; divisor either is negative magnitude
   747 00002267 780B                <1> 	js	fd_comp1	
   748 00002269 8DBE00040000        <1> 	lea	edi, [esi+_INPUT2]			; or shall be
   749 0000226F E8DCFCFFFF          <1> 	call	zover
   750                              <1> fd_comp1:
   751 00002274 F78624040000000000- <1> 	test	dword ptr [esi+_INPUTR+1*4], 080000000h
   751 0000227D 80                  <1>
   752 0000227E 740B                <1> 	jz	fd_upright			; dividend must be positive magnitude
   753 00002280 8DBE20040000        <1> 	lea	edi, [esi+_INPUTR]
   754 00002286 E8C5FCFFFF          <1> 	call	zover
   755                              <1> fd_upright:
   756 0000228B 8DBE20040000        <1> 	lea	edi, [esi+_INPUTR]
   757                              <1> 
   758 00002291 E82CFBFFFF          <1> 	call	round1				; this also sets counters
   759                              <1> 
   760 00002296 52                  <1> 	push	edx
   761 00002297 51                  <1> 	push	ecx
   762                              <1> 
   763                              <1> ;	add	cx, 01818h		; a divide needs 24 more beats
   764                              <1> 					; than a multiply
   765                              <1> 
   766 00002298 89C8                <1> 	mov	eax, ecx		; save words count in add range
   767 0000229A B15F                <1> 	mov	cl, 95
   768                              <1> 
   769 0000229C C1E810              <1> 	shr	eax, 16			; isolate words count in add range
   770 0000229F 6683C0FA            <1> 	add	ax, -6			; is it big?
   771 000022A3 0F8391000000        <1> 	jnc	near fd_72
   772                              <1> 
   773                              <1> ;	test	ch, 128
   774                              <1> ;	jz	near fd_72
   775                              <1> 
   776 000022A9 89E7                <1> 	mov	edi, esp
   777                              <1> 
   778 000022AB B1BF                <1> 	mov	cl, 191			;
   779                              <1> 
   780 000022AD F9                  <1> fd_144:	stc				; add negative mantissa
   781 000022AE E8B0FCFFFF          <1> 	call	_add_low		; to positive dividend
   782 000022B3 52                  <1> 	push	edx			; save the low half in the stack
   783 000022B4 53                  <1> 	push	ebx
   784 000022B5 50                  <1> 	push	eax
   785 000022B6 E8CDFCFFFF          <1> 	call	_add_high			; add the high half in eax edx ebx
   786                              <1> 
   787 000022BB 7327                <1> 	jnc	fd_144level			; no carry = drop the result
   788                              <1> 
   789 000022BD 898628040000        <1> 	mov	dword ptr [esi+_INPUTR+2*4], eax	; carry = update the dividend
   790 000022C3 899E2C040000        <1> 	mov	dword ptr [esi+_INPUTR+3*4], ebx
   791 000022C9 899630040000        <1> 	mov	dword ptr [esi+_INPUTR+4*4], edx
   792                              <1> 
   793 000022CF 58                  <1> 	pop	eax
   794 000022D0 898634040000        <1> 	mov	dword ptr [esi+_INPUTR+5*4], eax
   795 000022D6 58                  <1> 	pop	eax
   796 000022D7 898638040000        <1> 	mov	dword ptr [esi+_INPUTR+6*4], eax
   797 000022DD 58                  <1> 	pop	eax
   798 000022DE 89863C040000        <1> 	mov	dword ptr [esi+_INPUTR+7*4], eax
   799                              <1> fd_144level:
   800 000022E4 89FC                <1> 	mov	esp, edi	; clear stack whether popped or not
   801 000022E6 D1965C040000        <1> 	rcl	dword ptr [esi+_OUTPUT+7*4], 1	; shift value of carry into quotient
   802 000022EC D19658040000        <1> 	rcl	dword ptr [esi+_OUTPUT+6*4], 1
   803 000022F2 D19654040000        <1> 	rcl	dword ptr [esi+_OUTPUT+5*4], 1
   804 000022F8 D19650040000        <1> 	rcl	dword ptr [esi+_OUTPUT+4*4], 1
   805 000022FE D1964C040000        <1> 	rcl	dword ptr [esi+_OUTPUT+3*4], 1
   806 00002304 D19648040000        <1> 	rcl	dword ptr [esi+_OUTPUT+2*4], 1
   807                              <1> 
   808 0000230A F9                  <1> 	stc
   809 0000230B D19E08040000        <1> 	rcr	dword ptr [esi+_INPUT2+2*4], 1	; shift negative addend
   810 00002311 D19E0C040000        <1> 	rcr	dword ptr [esi+_INPUT2+3*4], 1	; 1 position starboard
   811 00002317 D19E10040000        <1> 	rcr	dword ptr [esi+_INPUT2+4*4], 1
   812 0000231D D19E14040000        <1> 	rcr	dword ptr [esi+_INPUT2+5*4], 1
   813 00002323 D19E18040000        <1> 	rcr	dword ptr [esi+_INPUT2+6*4], 1
   814 00002329 D19E1C040000        <1> 	rcr	dword ptr [esi+_INPUT2+7*4], 1
   815                              <1> 
   816 0000232F 80C1FF              <1> 	add	cl, -1
   817 00002332 0F8275FFFFFF        <1> 	jc	fd_144
   818 00002338 EB44                <1> 	jmp	fd_restore	
   819                              <1> 
   820 0000233A F9                  <1> fd_72:	stc					; add negative mantissa
   821 0000233B E848FCFFFF          <1> 	call	_add_high			; to positive dividend
   822 00002340 7312                <1> 	jnc	fd_72level			; no carry = drop the result
   823                              <1> 
   824 00002342 898628040000        <1> 	mov	dword ptr [esi+_INPUTR+2*4], eax	; carry = update the dividend
   825 00002348 899E2C040000        <1> 	mov	dword ptr [esi+_INPUTR+3*4], ebx
   826 0000234E 899630040000        <1> 	mov	dword ptr [esi+_INPUTR+4*4], edx
   827                              <1> fd_72level:
   828 00002354 D19650040000        <1> 	rcl	dword ptr [esi+_OUTPUT+4*4], 1	; shift value of carry into quotient
   829 0000235A D1964C040000        <1> 	rcl	dword ptr [esi+_OUTPUT+3*4], 1
   830 00002360 D19648040000        <1> 	rcl	dword ptr [esi+_OUTPUT+2*4], 1
   831                              <1> 
   832 00002366 F9                  <1> 	stc
   833 00002367 D19E08040000        <1> 	rcr	dword ptr [esi+_INPUT2+2*4], 1	; shift negative addend
   834 0000236D D19E0C040000        <1> 	rcr	dword ptr [esi+_INPUT2+3*4], 1	; 1 position starboard
   835 00002373 D19E10040000        <1> 	rcr	dword ptr [esi+_INPUT2+4*4], 1	;
   836                              <1> 
   837 00002379 80C1FF              <1> 	add	cl, -1
   838 0000237C 72BC                <1> 	jc	fd_72
   839                              <1> 
   840 0000237E 59                  <1> fd_restore:	pop	ecx
   841 0000237F 5A                  <1> 		pop	edx				; hand the program counter back
   842                              <1> 
   843                              <1> 
   844                              <1> ;		mov	esi, dword ptr [ebp+CORE_INDEX1] ; fd kept esi -> core state
   845                              <1> ;	mm7	anyway
   846                              <1> 
   847 00002380 8B8620040000        <1> 		mov	eax, dword ptr [esi+_INPUTR]	; + magnitude dividend exponent
   848 00002386 2B8600040000        <1> 		sub	eax, dword ptr [esi+_INPUT2]	; + magnitude divisor exponent
   849 0000238C 0501004000          <1> 		add	eax, 00400001h			; midpoint + 1
   850 00002391 898640040000        <1> 		mov	dword ptr [esi+_OUTPUT], eax	; magnitude of quotient scale
   851                              <1> 							; -> front of delivery string
   852 00002397 8DBE40040000        <1> 		lea	edi, [esi+_OUTPUT]
   853                              <1> 
   854 0000239D E821FBFFFF          <1> 		call	renormalise
   855                              <1> 
   856 000023A2 8DBE40040000        <1> 		lea	edi, [esi+_OUTPUT]			; tell rewrite where it is
   857 000023A8 8B8624040000        <1> 		mov	eax, dword ptr [esi+_INPUTR+1*4]	; determine sign of quotient
   858 000023AE 338604040000        <1> 		xor	eax, dword ptr [esi+_INPUT2+1*4]
   859 000023B4 894704              <1> 		mov	[edi+1*4], eax			; output 32 signs
   860                              <1> 							; _deliver_ polarises the quotient scale
   861 000023B7 314708              <1> 		xor	dword ptr [edi+2*4], eax	; switch quotient mantissa
   862 000023BA 31470C              <1> 		xor	dword ptr [edi+3*4], eax
   863 000023BD 314710              <1> 		xor	dword ptr [edi+4*4], eax
   864 000023C0 314714              <1> 		xor	dword ptr [edi+5*4], eax	; switch the long mantissa
   865 000023C3 314718              <1> 		xor	dword ptr [edi+6*4], eax
   866 000023C6 31471C              <1> 		xor	dword ptr [edi+7*4], eax
   867                              <1> 
   868 000023C9 C3                  <1> fd_z:		ret
   869                              <1> 
   870                              <1> 	;	these instructions take the left-side + target as
   871                              <1> 	;	[register_set]->a:b:mantissa2:mantissa3
   872                              <1> 	;	and the right side as [ea]
   873                              <1> 
   874                              <1> 	;	after acquisition and before delivery they call modules
   875                              <1> ;	fa fan fm fd
   876                              <1> ;	which may be used in extended instruction sets
   877                              <1> ;	using source and target registers in the internal stack
   878                              <1> ;	with maximum mantissa size 168 bits
   879                              <1> 
   880                              <1> 
   881                              <1> ;	esi -> core state but must also be used dynamically a lot
   882                              <1> ;	ebp -> always points at either one of two locations
   883                              <1> 
   884                              <1> ;		RTA1 application registers [ 0..127 ] modeled in 128 integers
   885                              <1> ;		RTA1 interrupt registers [ 128..255 ] modeled in 128 integers
   886                              <1> ;
   887                              <1> ;	there is always a copy of esi for retrieval at [ ebp + 152 integers ] ->
   888                              <1> 
   889                              <1> ;	_________________________.------ esi and ebp in application mode
   890                              <1> ;	|  RTA1 register 0	|					|
   891                              <1> ;	|_______________________|					|
   892                              <1> ;									|
   893                              <1> ;	________________________.------- ebp in ISR mode		|
   894                              <1> ;	|  RTA1 register 128	|			|		|
   895                              <1> ;	|_______________________|			|		|
   896                              <1> ;							|		|
   897                              <1> ;							|		|
   898                              <1> ;							|		|
   899                              <1> ;	_________________________.______________________|_______________|
   900                              <1> ;	| 64-bit mm7 = esi save + refresh 
   901                              <1> ;	|_______________________|
   902                              <1> 
   903                              <1> 
   904                              <1> 	%if	BIAS_FIELD=8
   905                              <1> BIAS_POINTERS	equ	fp_registers_a
   906                              <1> 	%else
   907                              <1> BIAS_POINTERS	equ	fp_registers_m
   908                              <1> 	%endif
   909                              <1> 
   910 000023CA BB04000000          <1> _fa:	mov 	ebx, a
   911 000023CF 53                  <1> _far:	push	ebx
   912 000023D0 E86D000000          <1> 	call	fp_operands
   913 000023D5 E897000000          <1> 	call	BIAS_POINTERS
   914 000023DA E8DFFBFFFF          <1> 	call	fa
   915 000023DF 5B                  <1> 	pop	ebx
   916 000023E0 E9EAF8FFFF          <1> 	jmp	_deliver_
   917                              <1> 
   918 000023E5 BB04000000          <1> _fan:	mov	ebx, a
   919 000023EA 53                  <1> _fanr:	push	ebx
   920 000023EB E852000000          <1> 	call	fp_operands
   921 000023F0 E87C000000          <1> 	call	BIAS_POINTERS
   922 000023F5 E8B3FBFFFF          <1> 	call	fan
   923 000023FA 5B                  <1> 	pop	ebx
   924 000023FB E9CFF8FFFF          <1> 	jmp	_deliver_
   925                              <1> 
   926 00002400 BB04000000          <1> _fm:	mov	ebx, a
   927 00002405 53                  <1> _fmr:	push	ebx
   928 00002406 E837000000          <1> 	call	fp_operands
   929 0000240B E87B000000          <1> 	call	fp_registers_m
   930 00002410 E871FCFFFF          <1> 	call	fm
   931 00002415 5B                  <1> 	pop	ebx
   932 00002416 8DBE40040000        <1> 	lea	edi, [esi+_OUTPUT]
   933 0000241C E9AEF8FFFF          <1> 	jmp	 _deliver_
   934                              <1> 
   935 00002421 BB04000000          <1> _fd:	mov	ebx, a				; default target register
   936 00002426 53                  <1> _fdr:	push	ebx
   937 00002427 E816000000          <1> 	call	fp_operands
   938 0000242C E85A000000          <1> 	call	fp_registers_m
   939 00002431 E8BFFDFFFF          <1> 	call	fd
   940 00002436 5B                  <1> 	pop	ebx
   941 00002437 8DBE40040000        <1> 	lea	edi, [esi+_OUTPUT]
   942 0000243D E98DF8FFFF          <1> 	jmp	_deliver_
   943                              <1> 
   944                              <1> fp_operands:
   945 00002442 8DBE20040000        <1> 	lea	edi, [esi+_INPUTR]
   946 00002448 50                  <1> 	push	eax				; save effective address
   947 00002449 E857000000          <1> 	call	_load_quad
   948 0000244E E833F8FFFF          <1> 	call	compress4to8
   949 00002453 58                  <1> 	pop	eax				; restore effective address
   950                              <1> 
   951 00002454 55                  <1> 	push	ebp				; ebp must momentarily
   952 00002455 89F5                <1> 	mov	ebp, esi			; -> start of all register list
   953 00002457 BB00010000          <1> 	mov	ebx, _input2			; into starboard buffer
   954 0000245C E8C3DEFFFF          <1> 	call	_burst_read4			; memory or registers @ ea
   955 00002461 5D                  <1> 	pop	ebp				; App / Int register context
   956                              <1> 
   957                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
   958 00002462 0F7EFE              <1> 	movd	esi, mm7
   959                              <1> 
   960 00002465 8DBE00040000        <1> 	lea	edi, [esi+_INPUT2]		; but still in ebp
   961 0000246B E816F8FFFF          <1> 	call	compress4to8
   962 00002470 C3                  <1> 	ret
   963                              <1> 
   964                              <1> fp_registers_a:
   965                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
   966 00002471 0F7EFE              <1> 	movd	esi, mm7
   967                              <1> 
   968 00002474 B908020400          <1> 	mov	ecx, 00040208h
   969 00002479 F786A0040000080000- <1> 	test	dword ptr [esi+PSR], FP_R
   969 00002482 00                  <1>
   970 00002483 7405                <1> 	jz	fp_registers_x
   971 00002485 B910040700          <1> 	mov	ecx, 00070410h
   972                              <1> fp_registers_x:
   973 0000248A C3                  <1> 	ret
   974                              <1> 
   975                              <1> fp_registers_m:
   976                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
   977 0000248B 0F7EFE              <1> 	movd	esi, mm7
   978                              <1> 
   979 0000248E B908020400          <1> 	mov	ecx, 00040208h
   980 00002493 F786A0040000080000- <1> 	test	dword ptr [esi+PSR], FP_R
   980 0000249C 00                  <1>
   981 0000249D 7405                <1> 	jz	fp_registers_z
   982 0000249F B910040600          <1> 	mov	ecx, 00060410h
   983                              <1> fp_registers_z:
   984 000024A4 C3                  <1> 	ret
   985                              <1> 
   986                              <1> _load_quad:
   987 000024A5 8B449D0C            <1> 	mov	eax, dword ptr[ebp+ebx*4+3*4]
   988 000024A9 89470C              <1> 	mov	dword ptr [edi+3*4], eax
   989 000024AC 8B449D08            <1> 	mov	eax, dword ptr  [ebp+ebx*4+2*4]
   990 000024B0 894708              <1> 	mov	dword ptr [edi+2*4], eax
   991 000024B3 8B449D04            <1> 	mov	eax, dword ptr [ebp+ebx*4+1*4]
   992 000024B7 894704              <1> 	mov	dword ptr [edi+1*4], eax
   993 000024BA 8B449D00            <1> 	mov	eax, dword ptr [ebp+ebx*4]
   994 000024BE 8907                <1> 	mov	dword ptr [edi], eax
   995 000024C0 C3                  <1> 	ret
   996                              <1> 
   997                              <1> 	%if	1
   998                              <1> ultrate:
   999 000024C1 8B07                <1> 	mov	eax, dword ptr [edi]
  1000 000024C3 A3[00000000]        <1> 	mov	dword ptr [_ultra], eax
  1001                              <1>  
  1002 000024C8 8B4704              <1> 	mov     eax, dword ptr [edi+1*4]
  1003 000024CB A3[00000000]        <1> 	mov     dword ptr [_ultra1], eax
  1004                              <1> 
  1005 000024D0 8B4708              <1>         mov     eax, dword ptr [edi+2*4]
  1006 000024D3 A3[00000000]        <1>         mov     dword ptr [_ultra2], eax
  1007                              <1> 
  1008 000024D8 8B470C              <1>         mov     eax, dword ptr [edi+3*4]
  1009 000024DB A3[00000000]        <1>         mov     dword ptr [_ultra3], eax
  1010                              <1> 
  1011 000024E0 8B4710              <1>         mov     eax, dword ptr [edi+4*4]
  1012 000024E3 A3[00000000]        <1>         mov     dword ptr [_ultra4], eax
  1013                              <1> 
  1014 000024E8 8B4714              <1>         mov     eax, dword ptr [edi+5*4]
  1015 000024EB A3[00000000]        <1>         mov     dword ptr [_ultra5], eax
  1016                              <1> 
  1017 000024F0 8B4718              <1>         mov     eax, dword ptr [edi+6*4]
  1018 000024F3 A3[00000000]        <1>         mov     dword ptr [_ultra6], eax
  1019                              <1> 
  1020 000024F8 8B471C              <1>         mov     eax, dword ptr [edi+7*4]
  1021 000024FB A3[00000000]        <1>         mov     dword ptr [_ultra7], eax
  1022                              <1> 
  1023 00002500 C3                  <1> 	ret
  1024                              <1> 
  1025                              <1> zultrate:
  1026 00002501 57                  <1> 	push	edi
  1027 00002502 BF[0E250000]        <1> 	mov	edi, __ZERO
  1028 00002507 E8B5FFFFFF          <1> 	call	ultrate
  1029 0000250C 5F                  <1> 	pop	edi
  1030 0000250D C3                  <1> 	ret
  1031                              <1> 
  1032 0000250E 000000000000000000- <1> __ZERO	dd	0, 0, 0, 0, 0, 0, 0, 0
  1032 00002517 000000000000000000- <1>
  1032 00002520 000000000000000000- <1>
  1032 00002529 0000000000          <1>
  1033                              <1> 	%endif
    42                                  	%include	"parity.msm"
     1                              <1> _get_parity:
     2 0000252E 8B5D10              <1>         mov     ebx, dword ptr [ebp+A]
     3 00002531 235D04              <1>         and     ebx, dword ptr [ebp+K]
     4                              <1> _fold_parity:
     5 00002534 30DF                <1>         xor     bh, bl
     6 00002536 C1EB08              <1>         shr     ebx, 8
     7 00002539 30FB                <1>         xor     bl, bh
     8 0000253B C3                  <1>         ret
     9                              <1> 
    43                                  	%include	"margin.msm"
     1                              <1> read_straddle_12b?:
     2                              <1> 
     3 0000253C F6C101              <1> 	test	cl, 1				; 4 words? You are here because
     4 0000253F 7534                <1> 	jnz	split_read4w			; offset is within last 3 of page
     5                              <1> 						; 2 words then
     6 00002541 81FEFF0F0000        <1> 	cmp	esi, 0FFFh			; starting @ last word of page?
     7 00002547 722B                <1> 	jb	readout				; not so, go ahead with burst read
     8                              <1> 
     9                              <1> split_read2w:
    10                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
    11 00002549 0F7EFE              <1> 	movd	esi, mm7
    12                              <1> 
    13 0000254C 893C24              <1> 	mov	dword ptr [esp], edi		; delete 1st return address + save EA
    14 0000254F 89F8                <1> 	mov	eax, edi			; recover EA
    15 00002551 30C9                <1> 	xor	cl, cl				; request 1 word
    16 00002553 E811DEFFFF          <1> 	call	_bus_read			;
    17 00002558 870424              <1> 	xchg	eax, dword ptr [esp]		; save 1st word read + load updated EA
    18 0000255B 40                  <1> 	inc	eax				; advance EA onto next page
    19 0000255C 30C9                <1> 	xor	cl, cl				; request 1 word
    20 0000255E E806DEFFFF          <1> 	call	_bus_read			; read new page or block
    21 00002563 89C3                <1> 	mov	ebx, eax
    22 00002565 58                  <1> 	pop	eax				; recover 1st read word
    23 00002566 C3                  <1> 	ret					; return to caller of operand_read
    24                              <1> 
    25                              <1> read_straddle_18b?:
    26 00002567 F6C101              <1> 	test	cl, 1				; 4 words? You are here because 
    27 0000256A 7509                <1> 	jnz	split_read4w			; offset is within last 3 of of bank
    28                              <1> 						; 2 words then
    29 0000256C 81FEFFFF0300        <1> 	cmp	esi, 0003FFFFh			; starting @ last word of bank?
    30 00002572 73D5                <1> 	jnb	split_read2w			; otherwise fall thru to burst read
    31                              <1> 
    32                              <1> readout:
    33 00002574 C3                  <1> 	ret					; burst read in order
    34                              <1> 
    35                              <1> split_read4w:					; write EA over stack top return address
    36                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
    37 00002575 0F7EFE              <1> 	movd	esi, mm7
    38                              <1> 
    39 00002578 893C24              <1> 	mov	dword ptr [esp], edi		; one or other of these 2-word reads
    40 0000257B 89F8                <1> 	mov	eax, edi			; splits down to 1-word reads
    41 0000257D E807000000          <1> 	call	read2				; when offset is [3F]FFD
    42 00002582 E802000000          <1> 	call	read2				;             or [3F]FFF
    43 00002587 58                  <1> 	pop	eax				;   but not when [3F]FFE
    44 00002588 C3                  <1> 	ret					; return to caller of caller
    45                              <1> 	
    46 00002589 50                  <1> read2:	push	eax				; EA
    47 0000258A 53                  <1> 	push	ebx				; destination index on stack top
    48 0000258B B106                <1> 	mov	cl, 6				; ask bus for 2 words
    49 0000258D E8D7DDFFFF          <1> 	call	_bus_read			; replaces eax and ebx
    50 00002592 871C24              <1> 	xchg	ebx, dword ptr [esp]		; get destination index up again
    51 00002595 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax	; write 1st result word
    52 00002599 58                  <1> 	pop	eax				; recover 2nd result word
    53 0000259A 89449D04            <1> 	mov	dword ptr [ebp+ebx*4+1*4], eax	; write 2nd result word
    54 0000259E 58                  <1> 	pop	eax				; EA
    55 0000259F 83C002              <1> 	add	eax, 2
    56 000025A2 83C302              <1> 	add	ebx, 2
    57 000025A5 C3                  <1> 	ret	
    58                              <1> 
    44                                  	%include	"margin_w.msm"
     1                              <1> write_straddle_12b?:				; multiword write request
     2                              <1> write_straddle12b?:				; in last 3 words of block
     3 000025A6 F6C101              <1> 	test	cl, 1				; 4-word write request?
     4 000025A9 7539                <1> 	jnz	split_write4w			;
     5 000025AB 81FEFF0F0000        <1> 	cmp	esi, 0FFFH			; 2 words then. In last word?
     6 000025B1 7230                <1> 	jb	writeout			; no
     7                              <1> 						; yes
     8                              <1> split_write2w:
     9                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
    10 000025B3 0F7EFE              <1> 	movd	esi, mm7
    11                              <1> 
    12 000025B6 891C24              <1> 	mov	dword ptr [esp], ebx		; not returning to there
    13 000025B9 57                  <1> 	push	edi				; esp -> saved eax [ea], saved ebx
    14 000025BA 89F8                <1> 	mov	eax, edi			; place ea in eax
    15 000025BC 30C9                <1> 	xor	cl, cl				; request 1-word write
    16 000025BE 8B5C9D00            <1> 	mov	ebx, dword ptr [ebp+ebx*4]	; data from register array
    17 000025C2 E83FDFFFFF          <1> 	call	bus_write
    18 000025C7 58                  <1> 	pop	eax				; retrieve ea from stack
    19 000025C8 5B                  <1> 	pop	ebx				; retrieve register index
    20 000025C9 40                  <1> 	inc	eax				; advance ea to next block
    21 000025CA 8B5C9D04            <1> 	mov	ebx, dword ptr [ebp+ebx*4+4]	; data from register array
    22 000025CE 30C9                <1> 	xor	cl, cl				; request 1-word write
    23 000025D0 E831DFFFFF          <1> 	call	bus_write
    24 000025D5 C3                  <1> 	ret					; return caller of caller
    25                              <1> 
    26                              <1> write_straddle_18b?:				; multiword write request
    27                              <1> write_straddle18b?:				; in last 3 words of block
    28 000025D6 F6C101              <1> 	test	cl, 1				; 4 words?
    29 000025D9 7509                <1> 	jnz	split_write4w
    30 000025DB 81FEFFFF0300        <1> 	cmp	esi, 0003FFFFh			; 2 words then. In last word?
    31 000025E1 73D0                <1> 	jnb	split_write2w			; yes
    32                              <1> 						; no
    33                              <1> writeout:
    34 000025E3 C3                  <1> 	ret					; return to burst write
    35                              <1> 
    36                              <1> split_write4w:
    37                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
    38 000025E4 0F7EFE              <1> 	movd	esi, mm7
    39                              <1> 
    40 000025E7 893C24              <1> 	mov	dword ptr [esp], edi		; return address at stack top not used
    41 000025EA 89F8                <1> 	mov	eax, edi			; copy ea
    42 000025EC E807000000          <1> 	call	write2				; request 2 writes word pairs
    43 000025F1 E802000000          <1> 	call	write2				; if 1 of them straddles it splits again
    44 000025F6 58                  <1> 	pop	eax				; this is ea
    45 000025F7 C3                  <1> 	ret					; return to caller of caller
    46                              <1> 
    47                              <1> 
    48 000025F8 B106                <1> write2:	mov	cl, 6				; request 2-word bus write
    49 000025FA 50                  <1> 	push	eax				; save ea
    50 000025FB 53                  <1> 	push	ebx				; save register array index
    51 000025FC E805DFFFFF          <1> 	call	bus_write			; send write pair request
    52 00002601 5B                  <1> 	pop	ebx				; retrieve register index
    53 00002602 58                  <1> 	pop	eax				; and ea
    54 00002603 83C302              <1> 	add	ebx, 2				; update register index
    55 00002606 83C002              <1> 	add	eax, 2				; and ea
    56 00002609 C3                  <1> 	ret
    45                                  	%include	"rex.msm"
     1                              <1> SIMD_192	equ	1
     2                              <1> 
     3                              <1> _rextable_1
     3          ******************  <1>  warning: label alone on a line without a colon might be in error [-w+orphan-labels]
     4 0000260A 000000000000000000- <1> 	dd	0, 0, 0, 0,		r_sa, r_sb, r_z, 0
     4 00002613 00000000000000-     <1>
     4 0000261A [8D290000]-         <1>
     4 0000261E [85290000]-         <1>
     4 00002622 [A6290000]00000000  <1>
     5 0000262A 000000000000000000- <1> 	dd	0, 0, 0, 0,		r_la, r_lb, r_tz, r_tp
     5 00002633 00000000000000-     <1>
     5 0000263A [C0290000]-         <1>
     5 0000263E [B8290000]-         <1>
     5 00002642 [4E290000]-         <1>
     5 00002646 [69290000]          <1>
     6 0000264A 0000000000000000-   <1> 	dd	0, 0, r_or, r_orB,	r_and, r_andB, r_xor, r_xorB
     6 00002652 [DD290000]-         <1>
     6 00002656 [D5290000]-         <1>
     6 0000265A [FE290000]-         <1>
     6 0000265E [F6290000]-         <1>
     6 00002662 [1F2A0000]-         <1>
     6 00002666 [172A0000]          <1>
     7 0000266A [402A0000]-         <1> 	dd	r_aa, r_ab, r_ana, r_anb, r_m, r_mf, r_d, 0
     7 0000266E [382A0000]-         <1>
     7 00002672 [5D2A0000]-         <1>
     7 00002676 [552A0000]-         <1>
     7 0000267A [992A0000]-         <1>
     7 0000267E [782A0000]-         <1>
     7 00002682 [3E2B0000]00000000  <1>
     8                              <1> 
     9                              <1> _rextable_6
     9          ******************  <1>  warning: label alone on a line without a colon might be in error [-w+orphan-labels]
    10 0000268A [7C2B0000]-         <1> 	dd	r_sar, r_sbr, r_dsr, 0, r_sal, r_sbl, r_dsl, 0
    10 0000268E [742B0000]-         <1>
    10 00002692 [972B0000]00000000- <1>
    10 0000269A [C22B0000]-         <1>
    10 0000269E [BA2B0000]-         <1>
    10 000026A2 [DD2B0000]00000000  <1>
    11 000026AA [082C0000]-         <1> 	dd	r_rar, r_rbr, r_drr, 0, r_ral, r_rbl, r_drl, 0
    11 000026AE [002C0000]-         <1>
    11 000026B2 [212C0000]00000000- <1>
    11 000026BA [4C2C0000]-         <1>
    11 000026BE [442C0000]-         <1>
    11 000026C2 [652C0000]00000000  <1>
    12 000026CA [902C0000]-         <1> 	dd	r_saa, r_sba, r_dsa, 0, 0, 0, 0, 0
    12 000026CE [882C0000]-         <1>
    12 000026D2 [AC2C0000]00000000- <1>
    12 000026DA 000000000000000000- <1>
    12 000026E3 00000000000000      <1>
    13 000026EA 000000000000000000- <1> 	dd	0, 0, 0, 0, 		0, 0, 0, 0
    13 000026F3 000000000000000000- <1>
    13 000026FC 000000000000000000- <1>
    13 00002705 0000000000          <1>
    14                              <1> 
    15                              <1> _rextable_7
    15          ******************  <1>  warning: label alone on a line without a colon might be in error [-w+orphan-labels]
    16 0000270A 000000000000000000- <1> 	dd	0, 0, 0, 0,		0, 0, 0, 0
    16 00002713 000000000000000000- <1>
    16 0000271C 000000000000000000- <1>
    16 00002725 0000000000          <1>
    17 0000272A [CF2C0000]-         <1> 	dd	r_qs, r_ql, r_dte, 0,	r_fa, r_fan, r_fm, r_fd
    17 0000272E [DE2C0000]-         <1>
    17 00002732 [ED2C0000]00000000- <1>
    17 0000273A [E4280000]-         <1>
    17 0000273E [FD280000]-         <1>
    17 00002742 [16290000]-         <1>
    17 00002746 [32290000]          <1>
    18 0000274A 000000000000000000- <1> 	dd	0, 0, 0, 0, 		0, r_mta, 0, 0
    18 00002753 000000000000000000- <1>
    18 0000275C 0000[032D0000]0000- <1>
    18 00002764 000000000000        <1>
    19 0000276A [212D0000]-         <1> 	dd	r_ds, r_dl, r_da, r_dan, 0, 0, 0, 0
    19 0000276E [302D0000]-         <1>
    19 00002772 [632D0000]-         <1>
    19 00002776 [492D0000]00000000- <1>
    19 0000277E 000000000000000000- <1>
    19 00002787 000000              <1>
    20                              <1> 
    21                              <1> 
    22 0000278A F686A204000080      <1> _rex:	test	byte ptr [esi+PSR+2], 128
    23 00002791 0F88D4000000        <1> 	js	near _rex_z				; ISRs can't do this
    24                              <1> 
    25 00002797 E89EDEFFFF          <1> 	call	memory_read				; ea -> instruction for repeat	
    26                              <1> 
    27                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]	; retrieve smp core ->
    28 0000279C 0F7EFE              <1> 	movd	esi, mm7
    29                              <1> 
    30 0000279F 898678040000        <1> 	mov	dword ptr [esi+REGISTER+286*4], eax	; save instruction word
    31 000027A5 E853D9FFFF          <1> 	call	__ea					; get initial ea of repeated  instruction
    32 000027AA 0FB6DD              <1> 	movzx	ebx, ch					; spin-off is opcode index in ch
    33                              <1> 							; and operand type in cl
    34 000027AD 80F906              <1> 	cmp	cl, 6
    35 000027B0 7214                <1> 	jb	_rex_itable1
    36 000027B2 7709                <1> 	ja	_rex_itable7
    37                              <1> 							; instruction list 6
    38 000027B4 8B1C9D[8A260000]    <1> 	mov	ebx, dword ptr [_rextable_6+ebx*4]	; shifts and jumps
    39 000027BB EB10                <1> 	jmp	_rex_evaluate
    40                              <1> 
    41                              <1> _rex_itable7:						; instruction list 7
    42 000027BD 8B1C9D[0A270000]    <1> 	mov	ebx, dword ptr [_rextable_7+ebx*4]	; large arithmetic
    43 000027C4 EB07                <1> 	jmp	_rex_evaluate
    44                              <1> 
    45                              <1> _rex_itable1:						; instruction list 1
    46 000027C6 8B1C9D[0A260000]    <1> 	mov	ebx, dword ptr [_rextable_1+ebx*4]	; single integer arithmetic
    47                              <1> 
    48                              <1> _rex_evaluate:
    49 000027CD 21DB                <1> 	and	ebx, ebx				; instruction for repeat execute?
    50 000027CF 0F8496000000        <1> 	jz	near _rex_z				; no
    51 000027D5 899E74040000        <1> 	mov	dword ptr [esi+REGISTER+285*4], ebx	; yes: save execution logic pointer
    52                              <1> 
    53                              <1> 							; if repeat instruction is indexed:
    54                              <1> 							; quick lookup tag for index increment
    55 000027DB C78670040000000000- <1> 	mov	dword ptr [esi+REGISTER+284*4], 0		; default no index register referenced
    55 000027E4 00                  <1>
    56 000027E5 8B9E78040000        <1> 	mov	ebx, dword ptr [esi+REGISTER+286*4]	; identify any index register tag
    57 000027EB 6621DB              <1> 	and	bx, bx					; in the instruction word
    58 000027EE 791A                <1> 	jns	_rex_ready				; by testing bit 15
    59 000027F0 66C1EB0C            <1> 	shr	bx, 12
    60                              <1> 							; must be > indirection tags *B0+ *B1+
    61 000027F4 80FB0A              <1> 	cmp	bl, 10					; pointers in storage not incremented
    62 000027F7 7211                <1> 	jb	_rex_ready				; index registers may increment
    63 000027F9 80FB0E              <1> 	cmp	bl, 14
    64 000027FC 7303                <1> 	jnb	_rex_indexed				; [   fp sp ]  registers   [ 14 15 ]
    65 000027FE 80E307              <1> 	and	bl, 7					; [ x y a b ]  registers [ 2 3 4 5 ]
    66                              <1> 
    67                              <1> _rex_indexed:
    68 00002801 83E30F              <1> 	and	ebx, 15					; make 32-bit index value
    69 00002804 899E70040000        <1> 	mov	dword ptr [esi+REGISTER+284*4], ebx	; write quick lookup
    70                              <1> 
    71                              <1> _rex_ready:
    72 0000280A 8B5E34              <1> 	mov	ebx, dword ptr [esi+REGISTER+Q]		; default target register [ q ] ->	
    73 0000280D FF9674040000        <1> 	call	dword ptr [esi+REGISTER+285*4]		; execute logic ->
    74                              <1> 
    75 00002813 8B8670040000        <1> 	mov	eax, dword ptr [esi+REGISTER+284*4]	; index register tag?
    76 00002819 6621C0              <1> 	and	ax, ax
    77 0000281C 7417                <1> 	jz	_rex_count				; no
    78                              <1> 
    79 0000281E 8B4E5C              <1> 	mov	ecx, dword ptr [esi+REGISTER+WDATA]
    80 00002821 81E1FFFFFF00        <1> 	and	ecx, 00FFFFFFh				; index register increment configured?
    81 00002827 740C                <1> 	jz	_rex_count				; no
    82                              <1> 
    83 00002829 030C86              <1> 	add	ecx, dword ptr [esi+REGISTER+eax*4]	; calculate index + increment
    84 0000282C 81E1FFFFFF00        <1> 	and	ecx, 00FFFFFFh				; 
    85 00002832 890C86              <1> 	mov	dword ptr [esi+REGISTER+eax*4], ecx	; write back to tagged index register
    86                              <1> 
    87                              <1> _rex_count:
    88 00002835 8B4650              <1> 	mov	eax, dword ptr [esi+REGISTER+RDATAC]
    89 00002838 48                  <1> 	dec	eax
    90 00002839 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
    91                              <1> 
    92 0000283E 894650              <1> 	mov	dword ptr [esi+REGISTER+RDATAC], eax
    93 00002841 A900008000          <1> 	test	eax, 00800000h
    94 00002846 7523                <1> 	jnz	_rex_z					; reached -1 end
    95                              <1> 
    96 00002848 66F78694040000E0FF  <1> 	test	word ptr [esi+INDICATION], EXTERNAL_INDICATIONS
    97 00002851 7405                <1> 	jz	_rex_along
    98                              <1> 
    99 00002853 83C2FC              <1> 	add	edx, -4					; restart after
   100 00002856 EB13                <1> 	jmp	_rex_z					; yielding to interrupt
   101                              <1> 
   102                              <1> _rex_along:
   103 00002858 8B8678040000        <1> 	mov	eax, [esi+REGISTER+286*4]			; instruction encoding
   104 0000285E E89AD8FFFF          <1> 	call	__ea
   105 00002863 8B9E74040000        <1> 	mov	ebx, [esi+REGISTER+285*4]			; command pointer
   106 00002869 EB9F                <1> 	jmp	_rex_ready
   107 0000286B C3                  <1> _rex_z:	ret
   108                              <1> 
   109                              <1> _rex_prime_final_count:
   110 0000286C F7455000008000      <1> 	test	dword ptr [ebp+RDATAC], 00800000h
   111 00002873 7422                <1> 	jz	_rex_primed
   112 00002875 8B5D58              <1> 	mov	ebx, dword ptr [ebp+WDATAC]
   113 00002878 895D50              <1> 	mov	dword ptr [ebp+RDATAC], ebx
   114 0000287B C3                  <1> 	ret
   115                              <1> 
   116                              <1> _rex_prime:
   117 0000287C F7455000008000      <1> 	test	dword ptr [ebp+RDATAC], 00800000h
   118 00002883 7412                <1> 	jz	_rex_primed
   119 00002885 8B5D58              <1> 	mov	ebx, dword ptr [ebp+WDATAC]
   120 00002888 895D50              <1> 	mov	dword ptr [ebp+RDATAC], ebx
   121 0000288B 8B5D3C              <1> 	mov	ebx, dword ptr [ebp+S_P]
   122 0000288E 81E3FFFFFF00        <1> 	and	ebx, 00FFFFFFh
   123 00002894 895D34              <1> 	mov	dword ptr [ebp+Q], ebx
   124                              <1> _rex_primed:
   125 00002897 C3                  <1> 	ret
   126                              <1> 
   127                              <1> _rex_accumulate:
   128                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
   129 00002898 0F7EFE              <1> 	movd	esi, mm7
   130                              <1> 
   131 0000289B 8B5E54              <1> 	mov	ebx, dword ptr [esi+RDATA]
   132 0000289E 035D34              <1> 	add	ebx, dword ptr [ebp+Q]
   133 000028A1 81E3FFFFFF00        <1> 	and	ebx, 00FFFFFFh
   134 000028A7 895D34              <1> 	mov	dword ptr [ebp+Q], ebx
   135 000028AA C3                  <1> 	ret
   136                              <1> 
   137                              <1> _rex_chex_127:
   138 000028AB E8CCFFFFFF          <1> 	call	_rex_prime
   139 000028B0 83FB7F              <1> 	cmp	ebx, 127
   140 000028B3 7624                <1> 	jna	_rex_chex_low
   141 000028B5 EB28                <1> 	jmp	_rex_chexit
   142                              <1> 
   143                              <1> _rex_chex_126:
   144 000028B7 E8C0FFFFFF          <1> 	call	_rex_prime
   145 000028BC 83FB7E              <1> 	cmp	ebx, 126
   146 000028BF 7618                <1> 	jna	_rex_chex_low
   147 000028C1 EB1C                <1> 	jmp	_rex_chexit
   148                              <1> 
   149                              <1> 	%if	SIMD_192
   150                              <1> _rex_chex_120:
   151 000028C3 E8B4FFFFFF          <1> 	call	_rex_prime
   152 000028C8 83FB78              <1> 	cmp	ebx, 120
   153 000028CB 760C                <1> 	jna	_rex_chex_low
   154 000028CD EB10                <1> 	jmp	_rex_chexit
   155                              <1> 	%endif
   156                              <1> 
   157                              <1> _rex_chex_124:
   158 000028CF E8A8FFFFFF          <1> 	call	_rex_prime
   159 000028D4 83FB7C              <1> 	cmp	ebx, 124
   160 000028D7 7706                <1> 	ja	_rex_chexit
   161                              <1> _rex_chex_low:
   162 000028D9 83FB18              <1> 	cmp	ebx, 24
   163 000028DC 7201                <1> 	jb	_rex_chexit
   164 000028DE C3                  <1> 	ret
   165                              <1> 
   166                              <1> _rex_chexit:
   167 000028DF E906E6FFFF          <1> 	jmp	guard_ii_authority
   168                              <1> 
   169                              <1> ;	eax = EA
   170                              <1> ;	q -> target register selected
   171                              <1> 
   172                              <1> r_fa:
   173                              <1> 	%if	SIMD_192
   174 000028E4 F686A004000008      <1> 	test	byte ptr [esi+PSR], FP_R
   175 000028EB 0F85A1040000        <1> 	jnz	r_fa_192
   176                              <1> 
   177                              <1> 	%endif
   178                              <1> 
   179 000028F1 E8D9FFFFFF          <1> 	call	_rex_chex_124
   180 000028F6 E8D4FAFFFF          <1> 	call	_far
   181 000028FB EB9B                <1> 	jmp	_rex_accumulate
   182                              <1> 
   183                              <1> r_fan:
   184                              <1> 	%if	SIMD_192
   185 000028FD F686A004000008      <1> 	test	byte ptr [esi+PSR], FP_R
   186 00002904 0F85A4040000        <1> 	jnz	r_fan_192
   187                              <1> 
   188                              <1> 	%endif
   189                              <1> 
   190 0000290A E8C0FFFFFF          <1> 	call	_rex_chex_124
   191 0000290F E8D6FAFFFF          <1> 	call	_fanr
   192 00002914 EB82                <1> 	jmp	_rex_accumulate
   193                              <1> 
   194                              <1> r_fm:
   195                              <1> 	%if	SIMD_192
   196 00002916 F686A004000008      <1> 	test	byte ptr [esi+PSR], FP_R	; 192-bit operation?
   197 0000291D 0F85A7040000        <1> 	jnz	r_fm_192			; yes
   198                              <1> 						; no
   199                              <1> 	%endif
   200                              <1> 
   201 00002923 E8A7FFFFFF          <1> 	call	_rex_chex_124
   202 00002928 E8D8FAFFFF          <1> 	call	_fmr
   203 0000292D E966FFFFFF          <1> 	jmp	_rex_accumulate
   204                              <1> 
   205                              <1> r_fd:
   206                              <1> 	%if	SIMD_192
   207 00002932 F686A004000008      <1> 	test	byte ptr [esi+PSR], FP_R	; 192-bit operation?
   208 00002939 0F85A4040000        <1> 	jnz	r_fd_192			; yes
   209                              <1> 						; no
   210                              <1> 	%endif
   211                              <1> 
   212 0000293F E88BFFFFFF          <1> 	call	_rex_chex_124
   213 00002944 E8DDFAFFFF          <1> 	call	_fdr
   214 00002949 E94AFFFFFF          <1> 	jmp	_rex_accumulate
   215                              <1> 
   216 0000294E E819FFFFFF          <1> r_tz:	call	_rex_prime_final_count
   217 00002953 80F904              <1> 	cmp	cl, 4				; may not be [ i xi ]
   218 00002956 732C                <1> 	jnb	r_noskip			; but pointers are updated on no_op
   219 00002958 E8F4D9FFFF          <1> 	call	_operand_read
   220 0000295D 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   221 00002962 7520                <1> 	jnz	r_noskip
   222                              <1> 
   223 00002964 E9AE030000          <1> 	jmp	r_skipout		; stop search repeat
   224                              <1> 
   225 00002969 E8FEFEFFFF          <1> r_tp:	call	_rex_prime_final_count
   226 0000296E 80F904              <1> 	cmp	cl, 4			; may not be [ i xi ]
   227 00002971 7311                <1> 	jnb	r_noskip		; but pointers are updated on no_op
   228 00002973 E8D9D9FFFF          <1> 	call	_operand_read
   229 00002978 A900008000          <1> 	test	eax, 00800000h
   230 0000297D 7505                <1> 	jnz	r_noskip
   231                              <1> 
   232 0000297F E993030000          <1> 	jmp	r_skipout		; stop search repeat
   233                              <1> 
   234 00002984 C3                  <1> r_noskip:	ret
   235                              <1> 
   236 00002985 E82DFFFFFF          <1> r_sb:	call	_rex_chex_126
   237 0000298A 43                  <1> 	inc	ebx			; starboard lane
   238 0000298B EB05                <1> 	jmp	r_s
   239 0000298D E819FFFFFF          <1> r_sa:	call	_rex_chex_127
   240 00002992 80F904              <1> r_s:	cmp	cl, 4			; may not be [ i xi ]
   241 00002995 7309                <1> 	jnb	r_no_op_s		; but pointers are updated 
   242 00002997 8B5C9D00            <1> 	mov	ebx, dword ptr [ebp+ebx*4]
   243 0000299B E843DBFFFF          <1> 	call	_operand_write
   244                              <1> r_no_op_s:
   245 000029A0 E9F3FEFFFF          <1> 	jmp	_rex_accumulate
   246 000029A5 C3                  <1> 	ret
   247                              <1> 
   248 000029A6 E8C1FEFFFF          <1> r_z:	call	_rex_prime_final_count
   249 000029AB 80F904              <1> 	cmp	cl, 4			; may not be [ i xi ]
   250 000029AE 7307                <1> 	jnb	r_no_op_z		; but pointers are updated
   251 000029B0 31DB                <1> 	xor	ebx, ebx
   252 000029B2 E92CDBFFFF          <1> 	jmp	_operand_write
   253                              <1> r_no_op_z:
   254 000029B7 C3                  <1> 	ret
   255                              <1> 
   256 000029B8 E8FAFEFFFF          <1> r_lb:	call	_rex_chex_126
   257 000029BD 43                  <1> 	inc	ebx			; starboard lane
   258 000029BE EB05                <1> 	jmp	r_l
   259 000029C0 E8E6FEFFFF          <1> r_la:	call	_rex_chex_127
   260 000029C5 53                  <1> r_l:	push	ebx
   261 000029C6 E886D9FFFF          <1> 	call	_operand_read
   262 000029CB 5B                  <1> 	pop	ebx
   263 000029CC 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   264 000029D0 E9C3FEFFFF          <1> 	jmp	_rex_accumulate
   265                              <1> 
   266 000029D5 E8DDFEFFFF          <1> r_orB:	call	_rex_chex_126
   267 000029DA 43                  <1> 	inc	ebx			; starboard lane
   268 000029DB EB05                <1> 	jmp	r_OR
   269 000029DD E8C9FEFFFF          <1> r_or:	call	_rex_chex_127
   270 000029E2 53                  <1> r_OR:	push	ebx
   271 000029E3 E869D9FFFF          <1> 	call	_operand_read
   272 000029E8 5B                  <1> 	pop	ebx
   273 000029E9 0B449D00            <1> 	or	eax, dword ptr [ebp+ebx*4]
   274 000029ED 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   275 000029F1 E9A2FEFFFF          <1> 	jmp	_rex_accumulate
   276                              <1> 
   277 000029F6 E8BCFEFFFF          <1> r_andB:	call	_rex_chex_126
   278 000029FB 43                  <1> 	inc	ebx		; starboard lane
   279 000029FC EB05                <1> 	jmp	r_AND
   280 000029FE E8A8FEFFFF          <1> r_and:	call	_rex_chex_127
   281 00002A03 53                  <1> r_AND:	push	ebx
   282 00002A04 E848D9FFFF          <1> 	call	_operand_read
   283 00002A09 5B                  <1> 	pop	ebx
   284 00002A0A 23449D00            <1> 	and	eax, dword ptr [ebp+ebx*4]
   285 00002A0E 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   286 00002A12 E981FEFFFF          <1> 	jmp	_rex_accumulate
   287                              <1> 
   288 00002A17 E89BFEFFFF          <1> r_xorB:	call	_rex_chex_126
   289 00002A1C 43                  <1> 	inc	ebx		; starboard lane
   290 00002A1D EB05                <1> 	jmp	r_XOR
   291 00002A1F E887FEFFFF          <1> r_xor:	call	_rex_chex_127
   292 00002A24 53                  <1> r_XOR:	push	ebx
   293 00002A25 E827D9FFFF          <1> 	call	_operand_read
   294 00002A2A 5B                  <1> 	pop	ebx
   295 00002A2B 33449D00            <1> 	xor	eax, dword ptr [ebp+ebx*4]
   296 00002A2F 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   297 00002A33 E960FEFFFF          <1> 	jmp	_rex_accumulate
   298                              <1> 
   299 00002A38 E87AFEFFFF          <1> r_ab:	call	_rex_chex_126
   300 00002A3D 43                  <1> 	inc	ebx		; starboard lane
   301 00002A3E EB05                <1> 	jmp	r_a
   302 00002A40 E866FEFFFF          <1> r_aa:	call	_rex_chex_127
   303 00002A45 53                  <1> r_a:	push	ebx
   304 00002A46 E806D9FFFF          <1> 	call	_operand_read
   305 00002A4B 5F                  <1> 	pop	edi
   306 00002A4C 0344BD00            <1> 	add	eax, dword ptr [ebp+edi*4]
   307 00002A50 E92F030000          <1> 	jmp	r_store_carry
   308                              <1> 
   309 00002A55 E85DFEFFFF          <1> r_anb:	call	_rex_chex_126
   310 00002A5A 43                  <1> 	inc	ebx		; starboard lane
   311 00002A5B EB05                <1> 	jmp	r_an
   312 00002A5D E849FEFFFF          <1> r_ana:	call	_rex_chex_127
   313 00002A62 53                  <1> r_an:	push	ebx
   314 00002A63 E8E9D8FFFF          <1> 	call	_operand_read
   315 00002A68 5F                  <1> 	pop	edi
   316 00002A69 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   317 00002A6E 40                  <1> 	inc	eax
   318 00002A6F 0344BD00            <1> 	add	eax, dword ptr [ebp+edi*4]
   319 00002A73 E90C030000          <1> 	jmp	r_store_carry
   320                              <1> 
   321 00002A78 E82EFEFFFF          <1> r_mf:	call    _rex_chex_127
   322 00002A7D 52                  <1> 	push	edx
   323 00002A7E 53                  <1> 	push	ebx
   324 00002A7F E8CDD8FFFF          <1> 	call	_operand_read
   325 00002A84 5F                  <1> 	pop	edi
   326 00002A85 0FAF44BD00          <1> 	imul	eax, dword ptr [ebp+edi*4]
   327 00002A8A 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   328 00002A8F 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
   329 00002A93 5A                  <1> 	pop	edx
   330 00002A94 E9FFFDFFFF          <1> 	jmp	_rex_accumulate
   331                              <1> 
   332                              <1> ; use the platform unsigned multiply
   333                              <1> ; work in positive magnitude
   334                              <1> ; adjust the final sign after offset-adding products
   335                              <1> 
   336 00002A99 E819FEFFFF          <1> r_m:	call	_rex_chex_126
   337 00002A9E 52                  <1> 	push	edx
   338 00002A9F 53                  <1> 	push	ebx			; register stack cursor
   339 00002AA0 E8ACD8FFFF          <1> 	call	_operand_read
   340 00002AA5 5F                  <1> 	pop	edi			; recover register stack cursor
   341                              <1> 
   342 00002AA6 31C9                <1> 	xor	ecx, ecx		; final sign
   343 00002AA8 A900008000          <1> 	test	eax, 00800000h		;
   344 00002AAD 740D                <1> 	jz	r_msigu?		; negative multiplier?
   345 00002AAF F7D1                <1> 	not	ecx			; final sign reverse
   346 00002AB1 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   347 00002AB6 40                  <1> 	inc	eax			; 2s complement
   348 00002AB7 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   349                              <1> 
   350                              <1> r_msigu?:
   351 00002ABC 89C3                <1> 	mov	ebx, eax		; multiplier 2b used twice
   352 00002ABE 8B44BD00            <1> 	mov	eax, dword ptr [ebp+edi*4]
   353 00002AC2 A900008000          <1> 	test	eax, 00800000h		; multiply high order part 1st
   354 00002AC7 7426                <1> 	jz	r_mgoferit_yall
   355                              <1> 
   356 00002AC9 F7D1                <1> 	not	ecx			; final sign reverse
   357 00002ACB 8B54BD04            <1> 	mov	edx, dword ptr [ebp+edi*4+4]
   358 00002ACF 81F2FFFFFF00        <1> 	xor	edx, 00FFFFFFh
   359 00002AD5 42                  <1> 	inc	edx			; 2s complement
   360 00002AD6 C1C208              <1> 	rol	edx, 8
   361 00002AD9 0FB6F2              <1> 	movzx	esi, dl
   362 00002ADC C1EA08              <1> 	shr	edx, 8
   363 00002ADF 8954BD04            <1> 	mov	dword ptr [ebp+edi*4+4], edx
   364 00002AE3 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh		; ms register long multiplicand
   365 00002AE8 01F0                <1> 	add	eax, esi
   366 00002AEA 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   367                              <1> 
   368                              <1> r_mgoferit_yall:
   369 00002AEF F7E3                <1> 	mul	ebx			; multiply high order part
   370 00002AF1 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax	; save lower half of product
   371 00002AF5 8B44BD04            <1> 	mov	eax, dword ptr [ebp+edi*4+4]	; multiply low order part
   372 00002AF9 F7E3                <1> 	mul	ebx
   373 00002AFB C1E208              <1> 	shl	edx, 8			; 8 bits of eax must shift up to edx
   374 00002AFE C1C008              <1> 	rol	eax, 8
   375 00002B01 88C2                <1> 	mov	dl, al
   376 00002B03 C1E808              <1> 	shr	eax, 8			; leaving 8 zeros in eax high end
   377 00002B06 0354BD00            <1> 	add	edx, dword ptr [ebp+edi*4]	; add2 lower half of 1st product
   378 00002B0A 21C9                <1> 	and	ecx, ecx		; final sign?
   379 00002B0C 7917                <1> 	jns	r_m_writeback
   380                              <1> 
   381 00002B0E 81F2FFFFFF00        <1> 	xor	edx, 00FFFFFFh
   382 00002B14 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   383 00002B19 40                  <1> 	inc	eax			; 2s complement
   384 00002B1A C1C008              <1> 	rol	eax, 8			; carried out single bit?
   385 00002B1D 0FB6F0              <1> 	movzx	esi, al			; must add to edx
   386 00002B20 C1E808              <1> 	shr	eax, 8
   387 00002B23 01F2                <1> 	add	edx, esi
   388                              <1> 
   389                              <1> r_m_writeback:
   390 00002B25 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   391 00002B2A 81E2FFFFFF00        <1> 	and	edx, 00FFFFFFh
   392 00002B30 8944BD04            <1> 	mov	dword ptr [ebp+edi*4+4], eax	
   393 00002B34 8954BD00            <1> 	mov	dword ptr [ebp+edi*4], edx
   394 00002B38 5A                  <1> 	pop	edx
   395 00002B39 E95AFDFFFF          <1> 	jmp	_rex_accumulate
   396                              <1> 
   397 00002B3E E874FDFFFF          <1> r_d:	call	_rex_chex_126
   398 00002B43 89DF                <1> 	mov	edi, ebx		; register cursor
   399 00002B45 E862ECFFFF          <1> 	call	_divide
   400 00002B4A 895CBD04            <1> 	mov	dword ptr [ebp+edi*4+4], ebx
   401 00002B4E 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
   402                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1]
   403 00002B52 0F7EFE              <1> 	movd	esi, mm7
   404                              <1> 
   405 00002B55 F686A004000008      <1> 	test	byte ptr [esi+PSR], FP_R
   406 00002B5C 0F8436FDFFFF        <1> 	jz	_rex_accumulate
   407 00002B62 83FF7D              <1> 	cmp	edi, 125
   408 00002B65 0F872DFDFFFF        <1> 	ja	_rex_accumulate
   409 00002B6B 894CBD08            <1> 	mov	dword ptr [ebp+edi*4+8], ecx
   410 00002B6F E924FDFFFF          <1> r_dnor:	jmp	_rex_accumulate
   411                              <1> 
   412 00002B74 E83EFDFFFF          <1> r_sbr:	call	_rex_chex_126
   413 00002B79 43                  <1> 	inc	ebx		; starboard lane
   414 00002B7A EB05                <1> 	jmp	r_lsr
   415 00002B7C E82AFDFFFF          <1> r_sar:	call	_rex_chex_127
   416 00002B81 88C1                <1> r_lsr	mov	cl, al
   417 00002B83 8B449D00            <1> 	mov	eax, dword ptr [ebp+ebx*4]
   418 00002B87 D3E8                <1> 	shr	eax, cl
   419 00002B89 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   420 00002B8E 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   421 00002B92 E901FDFFFF          <1> 	jmp	_rex_accumulate
   422                              <1> 
   423 00002B97 E81BFDFFFF          <1> r_dsr:	call	_rex_chex_126
   424 00002B9C 88C1                <1> 	mov	cl, al
   425 00002B9E 89DF                <1> 	mov	edi, ebx
   426 00002BA0 8B44BD00            <1> 	mov	eax, dword ptr [ebp+edi*4]
   427 00002BA4 8B5CBD04            <1> 	mov	ebx, dword ptr [ebp+edi*4+4]
   428 00002BA8 E840EDFFFF          <1> 	call	dsr
   429 00002BAD 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
   430 00002BB1 895CBD04            <1> 	mov	dword ptr [ebp+edi*4+4], ebx
   431 00002BB5 E9DEFCFFFF          <1> 	jmp	_rex_accumulate
   432                              <1> 
   433 00002BBA E8F8FCFFFF          <1> r_sbl:	call	_rex_chex_126
   434 00002BBF 43                  <1> 	inc	ebx		; starboard lane
   435 00002BC0 EB05                <1> 	jmp	r_lsl
   436 00002BC2 E8E4FCFFFF          <1> r_sal:	call	_rex_chex_127
   437 00002BC7 88C1                <1> r_lsl:	mov	cl, al
   438 00002BC9 8B449D00            <1> 	mov	eax, dword ptr [ebp+ebx*4]
   439 00002BCD D3E0                <1> 	shl	eax, cl
   440 00002BCF 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   441 00002BD4 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   442 00002BD8 E9BBFCFFFF          <1> 	jmp	_rex_accumulate
   443                              <1> 
   444 00002BDD E8D5FCFFFF          <1> r_dsl:	call	_rex_chex_126
   445 00002BE2 88C1                <1> 	mov	cl, al
   446 00002BE4 89DF                <1> 	mov	edi, ebx
   447 00002BE6 8B44BD00            <1> 	mov	eax, dword ptr [ebp+edi*4]
   448 00002BEA 8B5CBD04            <1> 	mov	ebx, dword ptr [ebp+edi*4+4]
   449 00002BEE E82FEDFFFF          <1> 	call	dsl
   450 00002BF3 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
   451 00002BF7 895CBD04            <1> 	mov	dword ptr [ebp+edi*4+4], ebx
   452 00002BFB E998FCFFFF          <1> 	jmp	_rex_accumulate
   453                              <1> 
   454 00002C00 E8B2FCFFFF          <1> r_rbr:	call	_rex_chex_126
   455 00002C05 43                  <1> 	inc	ebx		; starboard lane
   456 00002C06 EB05                <1> 	jmp	r_rr
   457 00002C08 E89EFCFFFF          <1> r_rar:	call	_rex_chex_127
   458 00002C0D 89DF                <1> r_rr:	mov	edi, ebx
   459 00002C0F 8B5CBD00            <1> 	mov	ebx, dword ptr [ebp+edi*4]
   460 00002C13 E877EDFFFF          <1> 	call	rr
   461 00002C18 895CBD00            <1> 	mov	dword ptr [ebp+edi*4], ebx
   462 00002C1C E977FCFFFF          <1> 	jmp	_rex_accumulate
   463                              <1> 
   464 00002C21 E891FCFFFF          <1> r_drr:	call	_rex_chex_126
   465 00002C26 88C1                <1> 	mov	cl, al
   466 00002C28 89DF                <1> 	mov	edi, ebx
   467 00002C2A 8B44BD00            <1> 	mov	eax, dword ptr [ebp+edi*4]
   468 00002C2E 8B5CBD04            <1> 	mov	ebx, dword ptr [ebp+edi*4+4]
   469 00002C32 E8A6EDFFFF          <1> 	call	drr
   470 00002C37 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
   471 00002C3B 895CBD04            <1> 	mov	dword ptr [ebp+edi*4+4], ebx
   472 00002C3F E954FCFFFF          <1> 	jmp	_rex_accumulate
   473                              <1> 
   474 00002C44 E86EFCFFFF          <1> r_rbl:	call	_rex_chex_126
   475 00002C49 43                  <1> 	inc	ebx		; starboard lane
   476 00002C4A EB05                <1> 	jmp	r_rl
   477 00002C4C E85AFCFFFF          <1> r_ral:	call	_rex_chex_127
   478 00002C51 89DF                <1> r_rl:	mov	edi, ebx
   479 00002C53 8B5CBD00            <1> 	mov	ebx, dword ptr [ebp+edi*4]
   480 00002C57 E859EDFFFF          <1> 	call	rl
   481 00002C5C 895CBD00            <1> 	mov	dword ptr [ebp+edi*4], ebx
   482 00002C60 E933FCFFFF          <1> 	jmp	_rex_accumulate
   483                              <1> 
   484 00002C65 E84DFCFFFF          <1> r_drl:	call	_rex_chex_126
   485 00002C6A 88C1                <1> 	mov	cl, al
   486 00002C6C 89DF                <1> 	mov	edi, ebx
   487 00002C6E 8B44BD00            <1> 	mov	eax, dword ptr [ebp+edi*4]
   488 00002C72 8B5CBD04            <1> 	mov	ebx, dword ptr [ebp+edi*4+4]
   489 00002C76 E8B8EDFFFF          <1> 	call	drl
   490 00002C7B 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
   491 00002C7F 895CBD04            <1> 	mov	dword ptr [ebp+edi*4+4], ebx
   492 00002C83 E910FCFFFF          <1> 	jmp	_rex_accumulate
   493                              <1> 
   494 00002C88 E82AFCFFFF          <1> r_sba:	call	_rex_chex_126
   495 00002C8D 43                  <1> 	inc	ebx		; starboard lane
   496 00002C8E EB05                <1> 	jmp	r_asr
   497 00002C90 E816FCFFFF          <1> r_saa:	call	_rex_chex_127
   498 00002C95 88C1                <1> r_asr:	mov	cl, al
   499 00002C97 8B449D00            <1> 	mov	eax, dword ptr [ebp+ebx*4]
   500 00002C9B C1E008              <1> 	shl	eax, 8
   501 00002C9E D3F8                <1> 	sar	eax, cl
   502 00002CA0 C1E808              <1> 	shr	eax, 8
   503 00002CA3 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   504 00002CA7 E9ECFBFFFF          <1> 	jmp	_rex_accumulate
   505                              <1> 
   506 00002CAC E806FCFFFF          <1> r_dsa:	call	_rex_chex_126
   507 00002CB1 88C1                <1> 	mov	cl, al
   508 00002CB3 89DF                <1> 	mov	edi, ebx
   509 00002CB5 8B44BD00            <1> 	mov	eax, dword ptr [ebp+edi*4]
   510 00002CB9 8B5CBD04            <1> 	mov	ebx, dword ptr [ebp+edi*4+4]
   511 00002CBD E897ECFFFF          <1> 	call	dsa
   512 00002CC2 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
   513 00002CC6 895CBD04            <1> 	mov	dword ptr [ebp+edi*4+4], ebx
   514 00002CCA E9C9FBFFFF          <1> 	jmp	_rex_accumulate
   515                              <1> 
   516 00002CCF E8FBFBFFFF          <1> r_qs:	call	_rex_chex_124
   517 00002CD4 E894D7FFFF          <1> 	call	_burst_write4	; eax -> ea / ebx -> register cursor
   518 00002CD9 E9BAFBFFFF          <1> 	jmp	_rex_accumulate
   519                              <1> 
   520 00002CDE E8ECFBFFFF          <1> r_ql:	call	_rex_chex_124
   521 00002CE3 E83CD6FFFF          <1> 	call	_burst_read4	; eax -> ea / ebx -> register cursor
   522 00002CE8 E9ABFBFFFF          <1> 	jmp	_rex_accumulate
   523                              <1> 
   524 00002CED E87AFBFFFF          <1> r_dte:	call	_rex_prime_final_count
   525 00002CF2 E818D6FFFF          <1> 	call	_burst_read2
   526 00002CF7 334510              <1> 	xor	eax, dword ptr [ebp+A]
   527 00002CFA 7524                <1> 	jnz	r_mtax
   528 00002CFC 335D14              <1> 	xor	ebx, dword ptr [ebp+B]
   529 00002CFF 751F                <1> 	jnz	r_mtax
   530 00002D01 EB14                <1> 	jmp	r_skipout		; stop search repeat
   531                              <1> 
   532 00002D03 E864FBFFFF          <1> r_mta:	call	_rex_prime_final_count
   533 00002D08 B100                <1> 	mov	cl, 0		; operand size 1 word
   534 00002D0A E842D6FFFF          <1> 	call	_operand_read
   535 00002D0F 334510              <1> 	xor	eax, dword ptr [ebp+A]
   536 00002D12 234504              <1> 	and	eax, dword ptr [ebp+K]
   537 00002D15 7509                <1> 	jnz	r_mtax
   538                              <1> 
   539                              <1> r_skipout:				; stop search repeat
   540 00002D17 83C204              <1> 	add	edx, 4
   541 00002D1A 8BA57C040000        <1> 	mov	esp, dword ptr [ebp+287*4]
   542 00002D20 C3                  <1> r_mtax:	ret
   543                              <1> 
   544 00002D21 E891FBFFFF          <1> r_ds:	call	_rex_chex_126
   545 00002D26 E887D7FFFF          <1> 	call	_burst_write2	; eax -> ea / ebx -> register cursor
   546 00002D2B E968FBFFFF          <1> 	jmp	_rex_accumulate
   547                              <1> 
   548 00002D30 E882FBFFFF          <1> r_dl:	call	 _rex_chex_126
   549 00002D35 53                  <1> 	push	ebx
   550 00002D36 E8D4D5FFFF          <1> 	call	_burst_read2
   551 00002D3B 5F                  <1> 	pop	edi
   552 00002D3C 895CBD04            <1> 	mov	dword ptr [ebp+edi*4+4], ebx
   553 00002D40 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
   554 00002D44 E94FFBFFFF          <1> 	jmp	_rex_accumulate
   555                              <1> 
   556 00002D49 E869FBFFFF          <1> r_dan:	call	 _rex_chex_126
   557 00002D4E 53                  <1> 	push	ebx
   558 00002D4F E8BBD5FFFF          <1> 	call	_burst_read2
   559 00002D54 5F                  <1> 	pop	edi
   560 00002D55 81F3FFFFFF00        <1> 	xor	ebx, 00FFFFFFh
   561 00002D5B 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   562 00002D60 43                  <1> 	inc	ebx
   563 00002D61 EB0C                <1> 	jmp	r_danad
   564                              <1> 
   565 00002D63 E84FFBFFFF          <1> r_da:	call	 _rex_chex_126
   566 00002D68 53                  <1> 	push	ebx
   567 00002D69 E8A1D5FFFF          <1> 	call	_burst_read2
   568 00002D6E 5F                  <1> 	pop	edi
   569                              <1> 
   570                              <1> r_danad:
   571 00002D6F 035CBD04            <1> 	add	ebx, dword ptr [ebp+edi*4+4]
   572 00002D73 C1E308              <1> 	shl	ebx, 8
   573 00002D76 83D000              <1> 	adc	eax, 0
   574 00002D79 C1EB08              <1> 	shr	ebx, 8
   575 00002D7C 895CBD04            <1> 	mov	dword ptr [ebp+edi*4+4], ebx
   576 00002D80 0344BD00            <1> 	add	eax, dword ptr [ebp+edi*4]
   577                              <1> 
   578                              <1> r_store_carry:
   579 00002D84 E818EEFFFF          <1> 	call	_alu_carry
   580 00002D89 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
   581 00002D8D E906FBFFFF          <1> 	jmp	_rex_accumulate
   582                              <1> 
    46                                  	%include	"144.msm"
     1                              <1> 	%if	SIMD_192
     2                              <1> 
     3                              <1> r_fa_192:
     4 00002D92 E865000000          <1> 	call	fp_192_concentrate
     5 00002D97 E8D5F6FFFF          <1> 	call	BIAS_POINTERS			; needs 1 octet of 8th platform word 
     6 00002D9C E81DF2FFFF          <1> 	call	fa
     7 00002DA1 0F7EFE              <1> 	movd	esi, mm7
     8 00002DA4 E8AA000000          <1> 	call	fp_192_store_left_right
     9 00002DA9 E9EAFAFFFF          <1> 	jmp	_rex_accumulate
    10                              <1> 
    11                              <1> r_fan_192:
    12 00002DAE E849000000          <1> 	call	fp_192_concentrate
    13 00002DB3 E8B9F6FFFF          <1> 	call	BIAS_POINTERS			; needs 1 octet of 8th platform word
    14 00002DB8 E8F0F1FFFF          <1> 	call	fan
    15 00002DBD 0F7EFE              <1> 	movd	esi, mm7
    16 00002DC0 E88E000000          <1> 	call	fp_192_store_left_right
    17 00002DC5 E9CEFAFFFF          <1> 	jmp	_rex_accumulate
    18                              <1> 
    19                              <1> r_fm_192:
    20 00002DCA E82D000000          <1> 	call	fp_192_concentrate
    21 00002DCF E8B7F6FFFF          <1> 	call	fp_registers_m
    22 00002DD4 E814010000          <1> 	call	_144_fm
    23 00002DD9 E86C000000          <1> 	call	fp_192_store
    24 00002DDE E9B5FAFFFF          <1> 	jmp	_rex_accumulate
    25                              <1> 
    26                              <1> r_fd_192:
    27 00002DE3 E814000000          <1> 	call	fp_192_concentrate
    28 00002DE8 E89EF6FFFF          <1> 	call	fp_registers_m
    29 00002DED E803F4FFFF          <1> 	call	fd
    30 00002DF2 E853000000          <1> 	call	fp_192_store
    31 00002DF7 E99CFAFFFF          <1> 	jmp	_rex_accumulate
    32                              <1> 
    33                              <1> fp_192_concentrate:
    34 00002DFC 50                  <1> 	push	eax
    35 00002DFD E8C1FAFFFF          <1> 	call	_rex_chex_120
    36 00002E02 8B0424              <1> 	mov	eax, dword ptr [esp]
    37 00002E05 E838F6FFFF          <1> 	call	fp_operands
    38 00002E0A 0F7EFE              <1> 	movd	esi, mm7
    39 00002E0D 8D7D20              <1> 	lea	edi, [ebp+8*4]
    40 00002E10 8B5D34              <1> 	mov	ebx, dword ptr [ebp+Q]
    41 00002E13 83C304              <1> 	add	ebx, 4				; starboard sum
    42 00002E16 E88AF6FFFF          <1> 	call	_load_quad
    43 00002E1B 8DBE20040000        <1> 	lea	edi, [esi+_INPUTR]
    44                              <1> 
    45 00002E21 E84B000000          <1> 	call	pack_144
    46                              <1> ; call ultrate
    47 00002E26 BB08000000          <1> 	mov	ebx, 8
    48 00002E2B 58                  <1> 	pop	eax				; ea
    49 00002E2C 83C004              <1> 	add	eax, 4				; +
    50 00002E2F E8F0D4FFFF          <1> 	call	_burst_read4
    51 00002E34 0F7EFE              <1> 	movd	esi, mm7
    52 00002E37 8DBE00040000        <1> 	lea	edi, [esi+_INPUT2]
    53 00002E3D E82F000000          <1> 	call	pack_144
    54                              <1> 
    55 00002E42 808EA004000008      <1> 	or	byte ptr [esi+PSR], FP_R
    56                              <1> ;	call	fp_registers_m			; moved to operations r_fa...
    57 00002E49 C3                  <1> 	ret
    58                              <1> 	
    59                              <1> fp_192_store:
    60 00002E4A 0F7EFE              <1> 	movd	esi, mm7
    61 00002E4D 8DBE40040000        <1> 	lea	edi, [esi+_OUTPUT]
    62                              <1> fp_192_store_left_right:			; fa / fan decide out-string ->
    63 00002E53 8B5D34              <1> 	mov	ebx, dword ptr [ebp+Q]
    64 00002E56 E874EEFFFF          <1> 	call	_deliver_
    65                              <1> 
    66 00002E5B 8B5D34              <1> 	mov	ebx, dword ptr [ebp+Q]
    67 00002E5E 0F6F7520            <1> 	movq	mm6, qword ptr [ebp+8*4]
    68 00002E62 0F7F749D10          <1> 	movq	qword ptr [ebp+ebx*4+4*4], mm6
    69 00002E67 0F6F7528            <1> 	movq	mm6, qword ptr [ebp+10*4]
    70 00002E6B 0F7F749D18          <1> 	movq	qword ptr [ebp+ebx*4+6*4], mm6
    71 00002E70 C3                  <1> 	ret
    72                              <1> 
    73                              <1> pack_144:
    74 00002E71 52                  <1> 	push	edx
    75 00002E72 51                  <1> 	push	ecx
    76 00002E73 53                  <1> 	push	ebx
    77 00002E74 50                  <1> 	push	eax
    78                              <1> 
    79 00002E75 8B4520              <1> 	mov	eax, [ebp+8*4]
    80 00002E78 334524              <1> 	xor	eax, [ebp+9*4]
    81 00002E7B A900008000          <1> 	test	eax, 00800000h			; is 2nd sum normalised?
    82 00002E80 7466                <1> 	jz	end_pack_144			; no? words 4..7 are alraady signs
    83                              <1> 
    84 00002E82 8B552C              <1> 	mov	edx, dword ptr [ebp+11*4]	; read starboard end 2nd value
    85 00002E85 C1C210              <1> 	rol	edx, 16				; move 8 bits up
    86 00002E88 8B5D28              <1> 	mov	ebx, dword ptr [ebp+10*4]	; to higher order word
    87 00002E8B C1E308              <1> 	shl	ebx, 8
    88 00002E8E 88D3                <1> 	mov	bl, dl
    89 00002E90 8B4704              <1> 	mov	eax, dword ptr [edi+1*4]	; do partial longs register:register
    90                              <1> 						; to avoid contemplating endianism
    91 00002E93 6689C2              <1> 	mov	dx, ax				; add 16 signs to low-order word
    92                              <1> 
    93 00002E96 8B4524              <1> 	mov	eax, dword ptr [ebp+9*4]	; starboard mantissa high-order word
    94                              <1> 
    95 00002E99 8B4D20              <1> 	mov	ecx, dword ptr [ebp+8*4]	; starboard exponent in register 8
    96                              <1> 						; loaded exponent is positive magnitude
    97 00002E9C 81E1FFFFFF00        <1> 	and	ecx, 00FFFFFFh			; should be impossible to need that...
    98 00002EA2 F7C100008000        <1> 	test	ecx, 00800000h			; this one may be 1s-complement
    99 00002EA8 7406                <1> 	jz	exponent_magnitude_difference
   100 00002EAA 81F1FFFFFF00        <1> 	xor	ecx, 00FFFFFFh			; 1s-complement RTA1 data word
   101                              <1> 						; still won't compute
   102                              <1> exponent_magnitude_difference:			; if component numbers are out of order
   103 00002EB0 F7D9                <1> 	neg	ecx				; 2s-complement platform integer
   104 00002EB2 030F                <1> 	add	ecx, dword ptr [edi]		; subtract it from
   105                              <1> 						; the exponent you first thought of
   106 00002EB4 83C1B8              <1> 	add	ecx, -72
   107 00002EB7 7418                <1> 	jz	_144_normalised			; net normalising count zero
   108 00002EB9 782D                <1> 	js	end_pack_144			; bad one, values in wrong order
   109                              <1> 						; just leave signs in bits 71..0
   110 00002EBB 83F947              <1> 	cmp	ecx, 71				; no use replacing 72+ signs
   111 00002EBE 7728                <1> 	ja	end_pack_144			; with signs
   112                              <1> 						; especially not millions of them
   113 00002EC0 C1E008              <1> 	shl	eax, 8
   114 00002EC3 88D0                <1> 	mov	al, dl				; 8 sign bits
   115 00002EC5 C1C808              <1> 	ror	eax, 8
   116                              <1> 
   117                              <1> insert_sign:
   118 00002EC8 D1F8                <1> 	sar	eax, 1				; normalising shift field <- signs
   119 00002ECA D1DB                <1> 	rcr	ebx, 1
   120 00002ECC D1DA                <1> 	rcr	edx, 1
   121                              <1> 
   122 00002ECE 49                  <1> 	dec	ecx
   123 00002ECF 75F7                <1> 	jnz	insert_sign
   124                              <1> 
   125                              <1> _144_normalised:
   126 00002ED1 895718              <1> 	mov	dword ptr [edi+6*4], edx	; mantissa 15..0 : 16 signs
   127 00002ED4 895F14              <1> 	mov	dword ptr [edi+5*4], ebx	; mantissa 47..16
   128 00002ED7 8B5F10              <1> 	mov	ebx, dword ptr [edi+4*4]	; mantissa bits 79..72 : unknown
   129 00002EDA C1E008              <1> 	shl	eax, 8				; mantissa bits 71..48
   130 00002EDD C1C308              <1> 	rol	ebx, 8
   131 00002EE0 88D8                <1> 	mov	al, bl				; mantissa bits 79..72
   132 00002EE2 C1C808              <1> 	ror	eax, 8				; mantissa bits 79..48
   133 00002EE5 894710              <1> 	mov	dword ptr [edi+4*4], eax
   134                              <1> 
   135                              <1> end_pack_144:
   136 00002EE8 58                  <1> 	pop	eax
   137 00002EE9 5B                  <1> 	pop	ebx
   138 00002EEA 59                  <1> 	pop	ecx
   139 00002EEB 5A                  <1> 	pop	edx
   140 00002EEC C3                  <1> 	ret
   141                              <1> 
   142                              <1> 	%endif
    47                                  	%include	"_144_fm.msm"
     1                              <1> ;	this is like fm: routine in fpu.msm
     2                              <1> ;	except it has uconditionally different radix and repeat count
     3                              <1> ;	and so exists separately to avoid condition jumps
     4                              <1> ;	and to avoid messing with the original for new parameters
     5                              <1> 
     6                              <1> _144_fm:
     7 00002EED 8DBE40040000        <1> 	lea	edi, [esi+_OUTPUT]			; initialise final accumulation
     8 00002EF3 E8B0EEFFFF          <1> 	call	zoutput
     9                              <1> 
    10 00002EF8 8B9E24040000        <1> 	mov	ebx, dword ptr [esi+_INPUTR+1*4]	; read register-side signs
    11 00002EFE 8B8628040000        <1> 	mov	eax, dword ptr [esi+_INPUTR+2*4]	; and high-end mantissa
    12 00002F04 31D8                <1> 	xor	eax, ebx	 			; cache if-normalised in eax
    13 00002F06 339E04040000        <1> 	xor	ebx, dword ptr [esi+_INPUT2+1*4]	; multiply signs
    14 00002F0C 899E44040000        <1> 	mov	dword ptr [esi+_OUTPUT+1*4], ebx	; save the output sign
    15 00002F12 21C0                <1> 	and	eax, eax				; test the cached if-normalised
    16 00002F14 790E                <1> 	jns	_144_fmdont
    17                              <1> 
    18 00002F16 8B8604040000        <1> 	mov	eax, dword ptr [esi+_INPUT2+1*4]	; is the multiplier normalised?
    19 00002F1C 338608040000        <1> 	xor	eax, dword ptr [esi+_INPUT2+2*4]	; sign XOR normalising bit?
    20 00002F22 782F                <1> 	js	_144_fmgo				; yes, proceed
    21                              <1> 
    22                              <1> _144_fmdont:
    23 00002F24 899E48040000        <1> 	mov	dword ptr [esi+_OUTPUT+2*4], ebx
    24 00002F2A 899E4C040000        <1> 	mov	dword ptr [esi+_OUTPUT+3*4], ebx
    25 00002F30 899E50040000        <1> 	mov	dword ptr [esi+_OUTPUT+4*4], ebx
    26 00002F36 899E54040000        <1> 	mov	dword ptr [esi+_OUTPUT+5*4], ebx
    27 00002F3C 899E58040000        <1> 	mov	dword ptr [esi+_OUTPUT+6*4], ebx
    28 00002F42 899E5C040000        <1> 	mov	dword ptr [esi+_OUTPUT+7*4], ebx
    29 00002F48 C78640040000000000- <1> 	mov	dword ptr [esi+_OUTPUT], 0		; mantissa to go
    29 00002F51 00                  <1>
    30                              <1> 
    31 00002F52 C3                  <1> 	ret					; no, effective zero multiplier
    32                              <1> 
    33                              <1> _144_fmgo:
    34 00002F53 51                  <1> 	push	ecx
    35 00002F54 8B8624040000        <1> 	mov	eax, dword ptr [esi+_INPUTR+1*4]
    36                              <1> 
    37 00002F5A B190                <1> 	mov	cl, 144				; beats count exactly mantissa size
    38                              <1> 
    39 00002F5C 21C0                <1> 	and	eax, eax
    40                              <1> 
    41 00002F5E 790B                <1> 	jns	_144_fmp1
    42 00002F60 8DBE20040000        <1> 	lea	edi, [esi+_INPUTR]
    43 00002F66 E8E5EFFFFF          <1> 	call	zover
    44                              <1> 
    45                              <1> _144_fmp1:
    46 00002F6B 8B8604040000        <1> 	mov	eax, dword ptr [esi+_INPUT2+1*4]
    47 00002F71 21C0                <1> 	and	eax, eax
    48 00002F73 790B                <1> 	jns	_144_fmadd
    49 00002F75 8DBE00040000        <1> 	lea	edi, [esi+_INPUT2]
    50 00002F7B E8D0EFFFFF          <1> 	call	zover
    51                              <1> 
    52                              <1> _144_fmadd:
    53 00002F80 F8                  <1> 	clc
    54                              <1> 
    55 00002F81 8DBE20040000        <1> 	lea	edi, [esi+_INPUTR]
    56 00002F87 D15F08              <1> 	rcr	dword ptr [edi+2*4], 1		; addend shift right
    57 00002F8A D15F0C              <1> 	rcr	dword ptr [edi+3*4], 1
    58 00002F8D D15F10              <1> 	rcr	dword ptr [edi+4*4], 1
    59 00002F90 D15F14              <1> 	rcr	dword ptr [edi+5*4], 1
    60 00002F93 D15F18              <1> 	rcr	dword ptr [edi+6*4], 1
    61 00002F96 D15F1C              <1> 	rcr	dword ptr [edi+7*4], 1
    62                              <1> 
    63 00002F99 8DBE00040000        <1> 	lea	edi, [esi+_INPUT2]
    64                              <1> 
    65                              <1> 	%if	1
    66 00002F9F D1571C              <1> 	rcl	dword ptr [edi+7*4], 1		; multiplier shift left
    67 00002FA2 D15718              <1> 	rcl	dword ptr [edi+6*4], 1
    68 00002FA5 D15714              <1> 	rcl	dword ptr [edi+5*4], 1		; multiplier mantissa is only 72 bits
    69                              <1> 	%endif
    70                              <1> 
    71 00002FA8 D15710              <1> 	rcl	dword ptr [edi+4*4], 1
    72 00002FAB D1570C              <1> 	rcl	dword ptr [edi+3*4], 1
    73 00002FAE D15708              <1> 	rcl	dword ptr [edi+2*4], 1
    74                              <1> 
    75 00002FB1 8DBE40040000        <1> 	lea	edi, [esi+_OUTPUT]
    76 00002FB7 7336                <1> 	jnc	_144_fmadx
    77                              <1> 						; 1 shifted from multiplier
    78                              <1> _144_fmadc:
    79 00002FB9 8B863C040000        <1> 	mov	eax, dword ptr [esi+_INPUTR+7*4]	
    80 00002FBF 01471C              <1> 	add	dword ptr [edi+7*4], eax	; do not use carry
    81 00002FC2 8B8638040000        <1> 	mov	eax, dword ptr [esi+_INPUTR+6*4]
    82 00002FC8 114718              <1> 	adc	dword ptr [edi+6*4], eax	; start using carry
    83 00002FCB 8B8634040000        <1> 	mov	eax, dword ptr [esi+_INPUTR+5*4]
    84 00002FD1 114714              <1> 	adc	dword ptr [edi+5*4], eax
    85 00002FD4 8B8630040000        <1> 	mov	eax, dword ptr [esi+_INPUTR+4*4]
    86 00002FDA 114710              <1> 	adc	dword ptr [edi+4*4], eax
    87 00002FDD 8B862C040000        <1> 	mov	eax, dword ptr [esi+_INPUTR+3*4]
    88 00002FE3 11470C              <1> 	adc	dword ptr [edi+3*4], eax
    89 00002FE6 8B8628040000        <1> 	mov	eax, dword ptr [esi+_INPUTR+2*4]
    90 00002FEC 114708              <1> 	adc	dword ptr [edi+2*4], eax
    91                              <1> 
    92                              <1> _144_fmadx:
    93 00002FEF FEC9                <1> 	dec	cl
    94 00002FF1 758D                <1> 	jnz	_144_fmadd
    95                              <1> 
    96                              <1> _144_fmadz:
    97 00002FF3 59                  <1> 	pop	ecx
    98                              <1> 
    99 00002FF4 8B4708              <1> 	mov	eax, dword ptr [edi+2*4] 	; normalised?
   100 00002FF7 D1D0                <1> 	rcl	eax, 1
   101 00002FF9 721B                <1> 	jc	_144_fm_normalised
   102                              <1> 
   103 00002FFB 838620040000FF      <1> 	add	dword ptr [esi+_INPUTR], -1		; take 1 from scale
   104 00003002 D1571C              <1> 	rcl	dword ptr [edi+7*4], 1
   105 00003005 D15718              <1> 	rcl	dword ptr [edi+6*4], 1
   106 00003008 D15714              <1> 	rcl	dword ptr [edi+5*4], 1
   107 0000300B D15710              <1> 	rcl	dword ptr [edi+4*4], 1
   108 0000300E D1570C              <1> 	rcl	dword ptr [edi+3*4], 1
   109 00003011 D15708              <1> 	rcl	dword ptr [edi+2*4], 1
   110                              <1> 
   111 00003014 EB26                <1> 	jmp	_144_fm_inrange
   112                              <1> 
   113                              <1> _144_fm_normalised:
   114 00003016 8DBE40040000        <1> 	lea	edi, [esi+_OUTPUT]
   115 0000301C E8B7EDFFFF          <1> 	call	round2
   116 00003021 7319                <1> 	jnc	_144_fm_inrange
   117                              <1> 
   118 00003023 D15F08              <1> 	rcr	dword ptr [edi+2*4], 1
   119 00003026 D15F0C              <1> 	rcr	dword ptr [edi+3*4], 1
   120 00003029 D15F10              <1> 	rcr	dword ptr [edi+4*4], 1
   121 0000302C D15F14              <1> 	rcr	dword ptr [edi+5*4], 1
   122 0000302F D15F18              <1> 	rcr	dword ptr [edi+6*4], 1
   123 00003032 D15F1C              <1> 	rcr	dword ptr [edi+7*4], 1
   124 00003035 83862004000001      <1> 	add	dword ptr [esi+_INPUTR], 1
   125                              <1> 
   126                              <1> _144_fm_inrange:
   127 0000303C 8B8620040000        <1> 	mov	eax, dword ptr [esi+_INPUTR]
   128 00003042 038600040000        <1> 	add	eax, dword ptr [esi+_INPUT2]
   129 00003048 050000C0FF          <1> 	add	eax, -00400000h
   130 0000304D 8907                <1> 	mov	dword ptr [edi], eax		; insert unsigned magnitude product scale
   131 0000304F 8B4704              <1> 	mov	eax, dword ptr [edi+1*4]
   132 00003052 314708              <1> 	xor	dword ptr [edi+2*4], eax	; the mantissa gets polarised here
   133 00003055 31470C              <1> 	xor	dword ptr [edi+3*4], eax
   134 00003058 314710              <1> 	xor	dword ptr [edi+4*4], eax
   135 0000305B 314714              <1> 	xor	dword ptr [edi+5*4], eax
   136 0000305E 314718              <1> 	xor	dword ptr [edi+6*4], eax
   137 00003061 31471C              <1> 	xor	dword ptr [edi+7*4], eax
   138 00003064 C3                  <1> 	ret
   139                              <1> 
    48                                  					; data follows here
    49                                  					; if it is in this assembly
    50                                  	%if	RTA_MBANKS
    51                                  
    52                                  	section		.data
    53                                  	%include	"rta_data.msm"
    54                                  
    55                                  	section		.bss
    56                                  _memory	resd	MEMORY
    57                                  
    58                                  	%endif
    59                                  
    60                                  	end
    60          ******************       warning: label alone on a line without a colon might be in error [-w+orphan-labels]
    61                                  
