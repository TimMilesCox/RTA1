     1                                  
     2                                  	%include	"rta_x86n.def"
     1                              <1> 
     2                              <1> __SMP		equ	8
     3                              <1> 
     4                              <1> TIME_UPDATE	equ     1
     5                              <1> LOCKSTEP	equ	2
     6                              <1> BREAKPOINT	equ	4
     7                              <1> CHILLDOWN	equ	8
     8                              <1> TOUCHPOINT	equ	16
     9                              <1> 
    10                              <1> EXTERNAL_INTERRUPT 	equ	00FF00h
    11                              <1> ATTENTION		equ	128
    12                              <1> INCREMENTER_CARRY	equ	64
    13                              <1> 
    14                              <1> 		%if	DRANG & 2
    15                              <1> INDICATIONS	equ	CHILLDOWN|TIME_UPDATE|LOCKSTEP
    16                              <1> 		%else
    17                              <1> INDICATIONS	equ	CHILLDOWN|TIME_UPDATE|LOCKSTEP|BREAKPOINT
    18                              <1> 		%endif
    19                              <1> 
    20                              <1> EXTERNAL_INDICATIONS equ EXTERNAL_INTERRUPT|ATTENTION|INCREMENTER_CARRY
    21                              <1> 
    22                              <1> IO_PORTS	equ	192
    23                              <1> 
    24                              <1> 	%if	RTA_MBANKS
    25                              <1> global	_metric
    26                              <1> global	_indication
    27                              <1> global	_iselect
    28                              <1> global	_iselectu
    29                              <1> global	_readout
    30                              <1> global	_readoutx
    31                              <1> global	_readoutp
    32                              <1> global	_psr
    33                              <1> global	_apc
    34                              <1> global	_apcz
    35                              <1> global	_breakpoint
    36                              <1> global	_b0_name
    37                              <1> global	_b0p
    38                              <1> global	_devices
    39                              <1> global	_base
    40                              <1> global	_register_set
    41                              <1> global	__register
    42                              <1> global	_memory
    43                              <1> 
    44                              <1> 	%if	RTA_MBANKS<1
    45                              <1> RTA_MPAGES	equ	32
    46                              <1> 	%else
    47                              <1> RTA_MPAGES	equ	RTA_MBANKS*64
    48                              <1> 	%endif
    49                              <1> 
    50                              <1> 	%else
    51                              <1> ;	extern	_metric
    52                              <1> extern	_general_indication
    53                              <1> ;	extern	_iselect
    54                              <1> ;	extern	_iselectu
    55                              <1> ;	extern	_psr
    56                              <1> ;	extern	_apc
    57                              <1> ;	extern	_apcu
    58                              <1> ;	extern	_apcz
    59                              <1> 
    60                              <1> extern	_breakpoint
    61                              <1> extern	_touchpoint
    62                              <1> extern	_touchpoint2
    63                              <1> 
    64                              <1> ;	extern	_b0_name
    65                              <1> ;	extern	_b0p
    66                              <1> extern	_devices
    67                              <1> ;	extern	_base
    68                              <1> ;	extern	_register_set
    69                              <1> ;	extern	__register
    70                              <1> extern	_memory
    71                              <1> 
    72                              <1> _output equ     272
    73                              <1> _inputr equ     264
    74                              <1> _input2 equ     256
    75                              <1> 
    76                              <1> _OUTPUT	equ	_output*4
    77                              <1> _INPUTR	equ	_inputr*4
    78                              <1> _INPUT2 equ	_input2*4
    79                              <1> _BIAS	equ	_OUTPUT
    80                              <1> 
    81                              <1> 	%endif
    82                              <1> 
    83                              <1> 	extern	_flag
    84                              <1> 	extern	_uflag
    85                              <1> 
    86                              <1> HALF_W	equ	128
    87                              <1> FP_R	equ	8
    88                              <1> B_STREAMZR  equ 64
    89                              <1> B_STREAM16R equ 32
    90                              <1> B_STREAM16W equ 16
    91                              <1> 
    92                              <1> r	equ	0
    93                              <1> k	equ	1
    94                              <1> x	equ	2
    95                              <1> y	equ	3
    96                              <1> a	equ	4
    97                              <1> b	equ	5
    98                              <1> mantissa2 equ	6
    99                              <1> mantissa3 equ	7
   100                              <1> residue	equ	8
   101                              <1> p	equ	12
   102                              <1> q	equ	13
   103                              <1> fp	equ	14
   104                              <1> s_p	equ	15
   105                              <1> 
   106                              <1> rdatac	equ	20
   107                              <1> rdata	equ	21
   108                              <1> wdatac	equ	22
   109                              <1> wdata	equ	23
   110                              <1> 
   111                              <1> 
   112                              <1> fp_guard equ	128+19
   113                              <1> 
   114                              <1> rt_clock equ	128+20
   115                              <1> priority equ	128+21
   116                              <1> dayclock_u equ	128+22
   117                              <1> dayclock equ	128+23
   118                              <1> 
   119                              <1> R	equ	r*4
   120                              <1> K	equ	k*4
   121                              <1> X	equ	x*4
   122                              <1> Y	equ	y*4
   123                              <1> A	equ	a*4
   124                              <1> B	equ	b*4
   125                              <1> MANTISSA2 equ	mantissa2*4
   126                              <1> MANTISSA3 equ	mantissa3*4
   127                              <1> RESIDUE	equ	residue*4
   128                              <1> 
   129                              <1> P	equ	p*4
   130                              <1> Q	equ	q*4
   131                              <1> FP	equ	fp*4
   132                              <1> S_P	equ	s_p*4
   133                              <1> 
   134                              <1> RDATAC	equ	rdatac*4
   135                              <1> RDATA	equ	rdata*4
   136                              <1> WDATAC	equ	wdatac*4
   137                              <1> WDATA	equ	wdata*4
   138                              <1> 
   139                              <1> FP_GUARD equ	fp_guard*4
   140                              <1> 
   141                              <1> RT_CLOCK equ	rt_clock*4
   142                              <1> PRIORITY equ	priority*4
   143                              <1> DAYCLOCK_U equ	dayclock_u*4
   144                              <1> DAYCLOCK equ	dayclock*4
   145                              <1> 
   146                              <1> I	equ	4
   147                              <1> XI	equ	5
   148                              <1> 
   149                              <1> DEVICE  equ	32768
   150                              <1> SYSMEM  equ	16384
   151                              <1> DATA16  equ	1
   152                              <1> FSYS24  equ	2
   153                              <1> 
   154                              <1> II_GUARD equ	64+31
   155                              <1> II_EXIT	equ	64+6
   156                              <1> II_YIELD equ	64+1
   157                              <1> II_SPAWN equ	64+2
   158                              <1> II_BANK equ	64+3
   159                              <1> II_ARRAY equ	64+4
   160                              <1> II_BANK_FREE equ 64+5
   161                              <1> II_TWAIT equ	64+27
   162                              <1> II_EVENT_WAIT equ 64+28
   163                              <1> II_FPXPO equ	0+3
   164                              <1> 
   165                              <1> II_XINT		equ	0+2
   166                              <1> II_MSECOND	equ	0+4
   167                              <1> II_ATTENTION	equ	0+5
   168                              <1> 
   169                              <1> LP_AUTHORITY	equ	1		; latent parameters GUARD$
   170                              <1> LP_ADDRESS	equ	14
   171                              <1> 
   172                              <1> LP_TIMESLICE	equ	10		; latent parameter timeslice -> yield
   173                              <1> LP_RANGE	equ	12		; latent parameter FP$XPO
   174                              <1> LP_AUTOEXIT	equ	11		; latent parameter return -> EXIT$
     3                                  	%include	"rta_smp.def"
     1                              <1> __POINTER	equ	4
     2                              <1> 
     3                              <1> REGISTER	equ	0
     4                              <1> APC		equ	REGISTER+288*4
     5                              <1> APCZ		equ	APC+__POINTER
     6                              <1> B0P		equ	APCZ+__POINTER
     7                              <1> RESTART_VECTOR	equ	B0P+__POINTER
     8                              <1> INDICATION	equ	RESTART_VECTOR+4
     9                              <1> LATENT_PARAMETER equ	INDICATION+4
    10                              <1> ISELECT		equ	LATENT_PARAMETER+4
    11                              <1> PSR		equ	ISELECT+4
    12                              <1> REGISTER_SET	equ	PSR+4
    13                              <1> B0_NAME		equ	REGISTER_SET+__POINTER
    14                              <1> B0_SCOPE	equ	B0_NAME+4
    15                              <1> DELTA		equ	B0_SCOPE+4
    16                              <1> __METRIC	equ	DELTA+4
    17                              <1> DELTA_BASE	equ	__METRIC+4
    18                              <1> TOTAL_DELTA	equ	DELTA_BASE+8
    19                              <1> TOTAL_METRIC	equ	TOTAL_DELTA+8
    20                              <1> IO_PORT		equ	TOTAL_METRIC+8
    21                              <1> DATAFRAME	equ	IO_PORT+192*4
    22                              <1> CORE_SIZE	equ	DATAFRAME+64*2*4
    23                              <1> 
    24                              <1> CORE_INDEX2	equ	4*280
    25                              <1> CORE_INDEX1	equ	4*(280-128)
     4                                  	%include	"io.def"
     1                              <1> 
     2                              <1> _MCAST_SUBVECTOR	equ	75*4	; writeable port to fan out multicast vector
     3                              <1> 					; not a read port
     4                              <1> _XI_PENDING		equ	74*4	; mask of external interrupt sources
     5                              <1> _XI_ACK			equ	75*4	; writeable ack to quench pending signals
     6                              <1> _INCREMENTER_RESTART	equ	76*4
     7                              <1> _CORE_SOCKET		equ	77*4	; socket index this core
     8                              <1> 
     9                              <1> _MCAST_PENDING		equ	78*4	; mask of cores which have multicast to here
    10                              <1> _MCAST_TO		equ	79*4	; -> latent parameter
    11                              <1> 					; destinations mask in register k
    12                              <1> _TZONE			equ	101*4
     5                                  
     6                                  ;	this is not PIC code
     7                                  ;	but does relative jumps for compactness
     8                                  
     9                                  %define ptr
    10                                  %define include
    11                                  %define .model
    12                                  %define .code
    13                                  
    14                                  SYSMEM_FLAG	equ	00800000h
    15                                  DATA16_FLAG	equ	00400000h
    16                                  FSYS24_FLAG	equ	00C00000h
    17                                  
    18                                  					; instruction code starts here
    19                                  	section		.text
    20                                  	global		_leloup
    21                                  	global		_execute
    22                                  	global		_device_readp
    23                                  	global		_bus_readp
    24                                  	global		_memory_read
    25                                  	global		_bus_read
    26                                  	global		_device_read
    27                                  
    28                                  	%include	"leloup.msm"
     1                              <1> 
     2                              <1> 	extern	_ultra
     3                              <1> 	extern	_ultra1
     4                              <1> 	extern	_ultra2
     5                              <1> 	extern	_ultra3
     6                              <1> 	extern	_ultra4
     7                              <1> 	extern	_ultra5
     8                              <1> 	extern	_ultra6
     9                              <1> 	extern	_ultra7
    10                              <1> 	extern	_core
    11                              <1> 
    12                              <1> _save_ebp	equ	0
    13                              <1> _save_return	equ	4
    14                              <1> _1st_param	equ	8
    15                              <1> 
    16                              <1> _leloup:
    17 00000000 55                  <1> 	push	ebp
    18 00000001 56                  <1> 	push	esi
    19 00000002 57                  <1> 	push	edi
    20                              <1> 
    21 00000003 50                  <1> 	push	eax
    22 00000004 51                  <1> 	push	ecx
    23 00000005 52                  <1> 	push	edx
    24                              <1> 
    25 00000006 53                  <1> 	push	ebx
    26                              <1> 
    27 00000007 8B7508              <1> 	mov	esi, dword ptr [ebp+8]	; structure smp ->
    28 0000000A 56                  <1> 	push	esi			; balanced on stack top
    29                              <1> 
    30 0000000B 8B9680040000        <1> 	mov	edx, dword ptr [esi+APC]
    31 00000011 8BAEA0040000        <1> 	mov	ebp, dword ptr [esi+REGISTER_SET]
    32                              <1> 
    33 00000017 3B9684040000        <1> loup:	cmp	edx, dword ptr [esi+APCZ]
    34 0000001D 7740                <1> 	ja	off_limits
    35                              <1> 
    36 0000001F 8B02                <1> 	mov	eax, dword ptr [edx]
    37 00000021 0FC8                <1> 	bswap	eax
    38 00000023 83C204              <1> 	add	edx, 4
    39                              <1> 
    40 00000026 E828010000          <1> 	call	_execute
    41                              <1> 
    42 0000002B 8B3424              <1> 	mov	esi, dword ptr [esp] 	; core pointer needed all the way round
    43                              <1> 
    44                              <1> 	%if	TSLICE
    45 0000002E F7869C040000000087- <1> 	test	dword ptr [esi+PSR], 00870000h	; not while ISR or interrupt mask
    45 00000037 00                  <1>
    46 00000038 752F                <1> 	jnz	louping
    47 0000003A F78650020000FFFFFF- <1> 	test	dword ptr [esi+RT_CLOCK], 00FFFFFFh
    47 00000043 00                  <1>
    48 00000044 7423                <1> 	jz	louping
    49                              <1> 
    50 00000046 FF8E50020000        <1> 	dec	dword ptr [esi+RT_CLOCK]
    51 0000004C 751B                <1> 	jnz	louping
    52                              <1> 
    53 0000004E B841000000          <1> 	mov	eax, II_YIELD
    54                              <1> 
    55 00000053 B90A000000          <1> 	mov	ecx, LP_TIMESLICE
    56 00000058 E8CC0E0000          <1> 	call	_ii
    57                              <1> 
    58                              <1> 	%endif
    59                              <1> 
    60 0000005D EB0A                <1> 	jmp	louping
    61                              <1> 
    62                              <1> off_limits:
    63 0000005F B85F000000          <1> 	mov	eax, II_GUARD
    64 00000064 E8C00E0000          <1> 	call	_ii
    65                              <1> 
    66                              <1> louping:
    67                              <1> 	%if	DRANG & 2
    68 00000069 8A0D[00000000]      <1> 	mov	cl, byte ptr [_general_indication]
    69 0000006F F6C104              <1> 	test	cl, BREAKPOINT
    70 00000072 7420                <1> 	jz	loup_count
    71 00000074 A1[00000000]        <1> 	mov	eax, dword ptr [_breakpoint]
    72 00000079 31D0                <1> 	xor	eax, edx
    73 0000007B 7517                <1> 	jnz	loup_count
    74 0000007D 800D[00000000]02    <1> 	or	byte ptr [_general_indication], LOCKSTEP
    75 00000084 808E9004000002      <1> 	or	byte ptr [esi+INDICATION], LOCKSTEP
    76 0000008B 800D[12000000]01    <1> 	or	byte ptr [_flag+'s'-'a'], 1
    77 00000092 EB4F                <1> 	jmp	indicated
    78                              <1> 
    79                              <1> 	%endif
    80                              <1> 
    81                              <1> 	%if	RATIO
    82                              <1> 
    83                              <1> loup_count:
    84 00000094 FF8E6C040000        <1> 	dec	dword ptr [esi+283*4]
    85 0000009A 7908                <1> 	jns	loup_away
    86 0000009C 66838E9004000001    <1> 	or	word ptr [esi+INDICATION], TIME_UPDATE
    87                              <1> loup_away:
    88                              <1> 	%endif
    89                              <1> 
    90 000000A4 668B8690040000      <1> 	mov	ax, word ptr [esi+INDICATION]
    91 000000AB 8A8E9E040000        <1> 	mov	cl, byte ptr [esi+PSR+2]
    92 000000B1 80E107              <1> 	and	cl, 7				; highest interrupt mask?
    93 000000B4 80F107              <1> 	xor	cl, 7
    94                              <1> 
    95 000000B7 7420                <1> 	jz	internal_indications?		; maskable interrupts are masked
    96                              <1> 
    97 000000B9 66A9CBFF            <1>         test	ax, INDICATIONS|EXTERNAL_INDICATIONS	; 1 or both of internal++external
    98 000000BD 0F8454FFFFFF        <1> 	jz	loup					; indications? No?
    99 000000C3 66A9C0FF            <1> 	test	ax, EXTERNAL_INDICATIONS	; external indications among the yes?
   100                              <1> 
   101 000000C7 741A                <1> 	jz	indicated			; external indications there are not
   102                              <1> 						; therefore internal indications there are
   103 000000C9 56                  <1> 	push	esi				; therefore raise their interrupts
   104 000000CA E8530D0000          <1> 	call	_xi
   105 000000CF 5E                  <1> 	pop	esi
   106                              <1> 
   107 000000D0 80A6900400007F      <1> 	and	byte ptr [esi+INDICATION], 127
   108 000000D7 EB90                <1> 	jmp	louping				; keep going intil pending flags are off
   109                              <1> 
   110                              <1> internal_indications?:
   111 000000D9 66A90B00            <1> 	test	ax, INDICATIONS			; just read from esi->INDICATION
   112 000000DD 0F8434FFFFFF        <1> 	jz	loup
   113                              <1> 
   114                              <1> indicated:
   115                              <1> ;	and	byte ptr [esi+INDICATION], LOCKSTEP^255
   116 000000E3 89AEA0040000        <1> 	mov	dword ptr [esi+REGISTER_SET], ebp
   117 000000E9 899680040000        <1> 	mov	dword ptr [esi+APC], edx
   118                              <1> 
   119 000000EF 5B                  <1> 	pop	ebx				; core  pointer
   120 000000F0 5B                  <1> 	pop	ebx				; caller values
   121                              <1> 
   122 000000F1 5A                  <1> 	pop	edx
   123 000000F2 59                  <1> 	pop	ecx
   124 000000F3 58                  <1> 	pop	eax
   125                              <1> 
   126 000000F4 5F                  <1> 	pop	edi
   127 000000F5 5E                  <1> 	pop	esi
   128 000000F6 5D                  <1> 	pop	ebp
   129 000000F7 C3                  <1> 	ret
   130                              <1> 
    29                                  	%include	"execute.msm"
     1                              <1> ;	include	rta_x86.h
     2                              <1> 	.model	small
     2          ******************  <1>  warning: label alone on a line without a colon might be in error [-w+orphan-labels]
     3                              <1> 	.code
     4                              <1> ;	_execute:
     5                              <1> ;        mov     dword ptr [__register+287*4], esp
     6                              <1> 
     7 000000F8 89C1                <1> __ea:	mov	ecx, eax
     8 000000FA C1E108              <1> 	shl	ecx, 8
     9 000000FD C1E913              <1> 	shr	ecx, 24-5		; instruction index in ch
    10 00000100 C0E905              <1> 	shr	cl, 5			; operand designator in cl
    11                              <1> 
    12 00000103 C1E010              <1> 	shl	eax, 16
    13 00000106 80F905              <1> 	cmp	cl, XI			; sign extended immediate?
    14 00000109 7508                <1> 	jnz	derive_ea
    15                              <1> 
    16 0000010B C1F808              <1> 	sar	eax, 8			; different from other EAs
    17 0000010E C1E808              <1> 	shr	eax, 8
    18 00000111 EB3F                <1> 	jmp	ea_derived
    19                              <1> 
    20                              <1> derive_ea:
    21 00000113 C1E810              <1> 	shr	eax, 16			; no sign of it
    22 00000116 6621C0              <1> 	and	ax, ax			; indexing / indirection ?
    23 00000119 7937                <1> 	jns	ea_derived		; no
    24                              <1> 
    25 0000011B 89C3                <1> 	mov	ebx, eax
    26 0000011D 80E47F              <1> 	and	ah, 127			; ie: and ax 32767
    27 00000120 66C1EB0C            <1> 	shr	bx, 12			; position index tag
    28 00000124 F6C306              <1> 	test	bl, 6			; indirect or indexed ?
    29 00000127 7415                <1> 	jz	indirect
    30                              <1> 					; pe = PF set
    31                              <1> 					; can only be tested on b7..0
    32 00000129 7A03                <1> 	jpe	indexed_4bit		; indexed fp / sp
    33                              <1> 					; indexed x / y / a / b
    34 0000012B 80E307              <1> 	and	bl, 7			; zero bit 3
    35                              <1> 
    36                              <1> indexed_4bit:
    37 0000012E 6625FF0F            <1> 	and	ax, 4095		; isolate address offset
    38 00000132 03449D00            <1> 	add	eax, dword ptr [ebp+ebx*4]
    39                              <1> 
    40 00000136 C1E008              <1> 	shl	eax, 8			; truncate any overflow
    41 00000139 C1E808              <1> 	shr	eax, 8
    42                              <1> 
    43 0000013C EB14                <1> 	jmp	ea_derived
    44                              <1> 
    45                              <1> indirect:				; indirect via page B0 / B1
    46 0000013E 6689CB              <1> 	mov	bx, cx
    47 00000141 6631C9              <1> 	xor	cx, cx			; cl <- zero to read 1-word indirection pointer
    48 00000144 E806020000          <1> 	call	_operand_read
    49 00000149 6689D9              <1> 	mov	cx, bx			; retrieve instruction:class into cx
    50 0000014C 8BB560020000        <1> 	mov	esi, dword ptr [ebp+CORE_INDEX1]	; retrieve smp core ->
    51                              <1> 
    52                              <1> ea_derived:
    53 00000152 C3                  <1> 	ret
    54                              <1> 
    55                              <1> _execute:
    56 00000153 89A67C040000        <1> 	mov	dword ptr [esi+REGISTER+287*4], esp
    57 00000159 E89AFFFFFF          <1> 	call	__ea
    58                              <1> 
    59 0000015E 0FB6DD              <1> 	movzx	ebx, ch			; instruction index
    60 00000161 80F906              <1> 	cmp	cl, 6
    61 00000164 0F848F000000        <1> 	jz	near shifts_jumps
    62 0000016A 0F8712010000        <1> 	ja	near large_operations
    63                              <1> 
    64                              <1> integer_operations:
    65 00000170 8B1C9D[79010000]    <1> 	mov	ebx, dword ptr [operations1+ebx*4]
    66 00000177 FFE3                <1> 	jmp	ebx
    67                              <1> 
    68                              <1> operations1:
    69 00000179 [63120000]          <1>         dd	_sr
    70 0000017D [7D120000]          <1>         dd	_sk
    71 00000181 [97120000]          <1>         dd	_sx
    72 00000185 [B1120000]          <1>         dd	_sy
    73 00000189 [CB120000]          <1>         dd	_sa
    74 0000018D [E1120000]          <1>         dd	_sb
    75 00000191 [F7120000]          <1>         dd	_z
    76 00000195 [10130000]          <1>         dd	_pop
    77                              <1> 
    78 00000199 [2C130000]          <1>         dd	_lr
    79 0000019D [35130000]          <1>         dd	_lk
    80 000001A1 [3E130000]          <1>         dd	_lx
    81 000001A5 [47130000]          <1>         dd	_ly
    82 000001A9 [50130000]          <1>         dd	_la
    83 000001AD [59130000]          <1>         dd	_lb
    84 000001B1 [62130000]          <1>         dd	_tz
    85 000001B5 [89130000]          <1>         dd	_tp
    86                              <1> 
    87 000001B9 [BC160000]          <1>         dd	_ax
    88 000001BD [CD160000]          <1>         dd	_ay
    89 000001C1 [DE160000]          <1>         dd	_or
    90 000001C5 [E7160000]          <1>         dd	_orB
    91 000001C9 [F0160000]          <1>         dd	_and
    92 000001CD [F9160000]          <1>         dd	_andB
    93 000001D1 [02170000]          <1>         dd	_xor
    94 000001D5 [0B170000]          <1>         dd	_xorB
    95                              <1> 
    96 000001D9 [14170000]          <1>         dd	_aa
    97 000001DD [34170000]          <1>         dd	_ab
    98 000001E1 [1B170000]          <1>         dd	_ana
    99 000001E5 [3B170000]          <1>         dd	_anb
   100 000001E9 [54170000]          <1>         dd	_m
   101 000001ED [84170000]          <1>         dd	_mf
   102 000001F1 [E0170000]          <1>         dd	_d
   103 000001F5 [A7130000]          <1>         dd	_push
   104                              <1> 
   105                              <1> shifts_jumps:
   106 000001F9 8B1C9D[02020000]    <1> 	mov	ebx, dword ptr [operations6+ebx*4]
   107 00000200 FFE3                <1> 	jmp	ebx
   108                              <1> 
   109                              <1> operations6:
   110 00000202 [85180000]          <1>         dd	_sar
   111 00000206 [9C180000]          <1>         dd	_sbr
   112 0000020A [B3180000]          <1>         dd	_dsr
   113 0000020E [C8130000]          <1>         dd	_jdr
   114 00000212 [C7180000]          <1>         dd	_sal
   115 00000216 [DE180000]          <1>         dd	_sbl
   116 0000021A [F5180000]          <1>         dd	_dsl
   117 0000021E [E2130000]          <1>         dd	_lcal
   118                              <1> 
   119 00000222 [09190000]          <1>         dd	_rar
   120 00000226 [15190000]          <1>         dd	_rbr
   121 0000022A [21190000]          <1>         dd	_drr
   122 0000022E [F6130000]          <1>         dd	_jnc
   123 00000232 [BD1A0000]          <1>         dd	_ral
   124 00000236 [C91A0000]          <1>         dd	_rbl
   125 0000023A [D51A0000]          <1>         dd	_drl
   126 0000023E [03140000]          <1>         dd	_jc
   127                              <1> 
   128 00000242 [E91A0000]          <1>         dd	_saa
   129 00000246 [FA1A0000]          <1>         dd	_sba
   130 0000024A [0B1B0000]          <1>         dd	_dsa
   131 0000024E [10140000]          <1>         dd	_jao
   132 00000252 [1A140000]          <1>         dd	_jpa
   133 00000256 [24140000]          <1>         dd	_jpb
   134 0000025A [2E140000]          <1>         dd	_j
   135 0000025E [50140000]          <1>         dd	_jpo
   136                              <1> 
   137 00000262 [58140000]          <1>         dd	_jza
   138 00000266 [62140000]          <1>         dd	_jzb
   139 0000026A [6C140000]          <1>         dd	_jnza
   140 0000026E [76140000]          <1>         dd	_jnzb
   141 00000272 [80140000]          <1>         dd	_jna
   142 00000276 [8A140000]          <1>         dd	_jnb
   143 0000027A [94140000]          <1>         dd	_jxge
   144 0000027E [A3140000]          <1>         dd	_jyge
   145                              <1> 
   146                              <1> 
   147                              <1> large_operations:
   148 00000282 8B1C9D[8D020000]    <1> 	mov	ebx, dword ptr [operations7+ebx*4]
   149 00000289 B100                <1> 	mov	cl, 0		; default size large operand
   150 0000028B FFE3                <1> 	jmp	ebx		; 1 word
   151                              <1> 
   152                              <1> operations7:
   153 0000028D [90150000]          <1>         dd	_ts
   154 00000291 [1F1B0000]          <1>         dd	_n
   155 00000295 [2E1B0000]          <1>         dd	_inc
   156 00000299 [391B0000]          <1>         dd	_dec
   157 0000029D [A6150000]          <1>         dd	_sim
   158 000002A1 [841B0000]          <1>         dd	_popA
   159 000002A5 [441B0000]          <1>         dd	_src
   160 000002A9 [641B0000]          <1>         dd	_slc
   161                              <1> 
   162 000002AD [B6140000]          <1>         dd	_qs
   163 000002B1 [C0140000]          <1>         dd	_ql
   164 000002B5 [2F150000]          <1>         dd	_dte
   165 000002B9 [F0140000]          <1>         dd	_dpop
   166 000002BD [14240000]          <1>         dd	_fa
   167 000002C1 [2F240000]          <1>         dd	_fan
   168 000002C5 [4A240000]          <1>         dd	_fm
   169 000002C9 [6B240000]          <1>         dd	_fd
   170                              <1> 
   171 000002CD [CA140000]          <1>         dd	_qpop
   172 000002D1 [DD140000]          <1>         dd	_qpush
   173 000002D5 [80150000]          <1>         dd	_ex
   174 000002D9 [03150000]          <1>         dd	_dpush
   175 000002DD [6D1C0000]          <1>         dd	_lsc
   176 000002E1 [1E150000]          <1>         dd	_mta
   177 000002E5 [42150000]          <1>         dd	_sc
   178 000002E9 [50150000]          <1>         dd	_mlb
   179                              <1> 
   180 000002ED [69150000]          <1>         dd	_ds
   181 000002F1 [73150000]          <1>         dd	_dl
   182 000002F5 [B91B0000]          <1>         dd	_da
   183 000002F9 [C01B0000]          <1>         dd	_dan
   184 000002FD [7E1C0000]          <1>         dd	_dlsc
   185 00000301 [7F150000]          <1>         dd	_spare
   186 00000305 [EC150000]          <1>         dd	_go
   187 00000309 [CF150000]          <1>         dd	_call
   188                              <1> 
    30                                  	%include	"rw.msm"
     1                              <1> 
     2                              <1> 
     3                              <1> ;	include	rta_x86.h
     4                              <1> ;	.model	large
     5                              <1> ;	.code
     6                              <1> 
     7                              <1> ;	this is the operand reader / writer
     8                              <1> ;	for emulated RTA1 on x86
     9                              <1> 
    10                              <1> ;	layout is
    11                              <1> 
    12                              <1> ;	RTA1 24-bit registers are modeled in an array of
    13                              <1> ;	platform-endian integers. In x86 these are 32-bit
    14                              <1> ;	little-endian integers
    15                              <1> 
    16                              <1> ;	platform-endian doesn't affect registers
    17                              <1> ;	because endianness is not at the CPU
    18                              <1> ;	side of the bus, but at the memory side
    19                              <1> 
    20                              <1> ;	when Intel circuitry in the x86 CPU staticises the value
    21                              <1> ;	of an emulated register, that value is big endian
    22                              <1> 
    23                              <1> ;	the stored integers where emulated registers are modeled
    24                              <1> ;	are platform-endian, with identical effect on big and
    25                              <1> ;	little endian emulator platforms
    26                              <1> 
    27                              <1> ;	RTA1 24-bit executable space storage words are modeled in
    28                              <1> ;	another array of platform-endian 32-bit integers. Emulation
    29                              <1> ;	on x86 swaps the byte order of storage words on read and
    30                              <1> ;	before write to conform with RTA1 canonical storage order
    31                              <1> 
    32                              <1> ;       RTA1 architecture has registers in the first 256 locations
    33                              <1> ;       of address space and access differentiates registers from
    34                              <1> ;       from memory according to effective address
    35                              <1> 
    36                              <1> ;	location of registers and storage are handed to read / write
    37                              <1> ;	routines as RTA1 word linear effective addresses
    38                              <1> 
    39                              <1> ;	These routines maintain the RTA1 linear addresses passed
    40                              <1> ;	in x86 registers and apply them with shifted scale plus
    41                              <1> ;	displacement, for example
    42                              <1> 
    43                              <1> ;		mov	eax, dword ptr [edi+esi*4+_memory]
    44                              <1> ;		bswap	eax
    45                              <1> ;		mov	dword_ptr [ebp+ebx*4], eax
    46                              <1> 
    47                              <1> ;	RTA1 register addresses are already absolute in terms of
    48                              <1> ;	the emulated RTA1 machine
    49                              <1> 
    50                              <1> ;	ebp points at the context register frame. There are two
    51                              <1> ;	register frames, application and interrupt. Registers
    52                              <1> ;	addressed as storage operand are in a single list
    53                              <1> 
    54                              <1> ;		mov	eax, dword ptr [esi*4+__register]
    55                              <1> 
    56                              <1> ;	RTA1 storage addresses are translated by RTA1 relocation
    57                              <1> ;	architecture before application. The updated linear addresses
    58                              <1> ;	of the emulated machine are in esi
    59                              <1> 
    60                              <1> ;	The operand routines in this file point edi to the x86 platform
    61                              <1> ;	storage array start of the storage device, most often emulated
    62                              <1> ;	RTA1 executable space
    63                              <1> 
    64                              <1> ;	instructions call these operand routines with RTA1 effective 
    65                              <1> ;	address in eax
    66                              <1> 
    67                              <1> ;	instructions receive load operand values in eax and ebx, or in
    68                              <1> ;	a list of RTA1 emulated register locations pointed by ebp+ebx
    69                              <1> 
    70                              <1> ;	store instructions submit a value in ebx, or values in list of
    71                              <1> ;	RTA1 emulated register locations pointed by ebp+ebx
    72                              <1> 
    73                              <1> ;	to preserve linear address consistency, application instruction
    74                              <1> ;	work areas, where needed in addition to x86 registers, are
    75                              <1> ;	implemented as sub-architectural extra RTA1 registers at the end
    76                              <1> ;	of the 256-longword register stack. x86 register ebp+ebx*4 identify
    77                              <1> ;	these locations by linear RTA1 word quantum as "registers"
    78                              <1> 
    79                              <1> ;	RTA1 registers and storage alike are in 24-bit word address quantum space
    80                              <1> 
    81                              <1> ;	emulated instructions loading or storing multiple hidden extra work
    82                              <1> ;	registers should unconditionally set ebp to the start or application
    83                              <1> ;	frame of the emulated register array, so that [ebp+ebx*4] accesses the
    84                              <1> ;	correct locations at register occurence 256+
    85                              <1> 
    86                              <1> ;               _floating_operand2 equ  256+12
    87                              <1> 
    88                              <1> ;		push	ebp
    89                              <1> ;		mov	ebp, __register	; point to application register frame[0]
    90                              <1> ;		mov	ebx, 256+_floating_operand2
    91                              <1> ;		call	_burst_read4
    92                              <1> 
    93                              <1> ;		pop	ebp		; return to previous register frame[0] application
    94                              <1> 					;                          or frame[1] interrupt
    95                              <1> 
    96                              <1> ;	Both internal stack pointers are also absolute, so for stack operations
    97                              <1> ;	ebp should be momentarily forced to the lower-addressed (application) stack
    98                              <1> ;	frame after being used to point the stack location of reference
    99                              <1> 
   100                              <1> ;		mov	ebx, dword ptr [ebp+S_P]	; read one of the two stack pointers
   101                              <1> ;		cmp	ebx, ebp+STACK_LOWER_LIMIT	; 24*4 within context of either stack
   102                              <1> ;		jl	II_GUARD
   103                              <1> ;		add	ebx, -1				; new stack top
   104                              <1> ;		mov	dword ptr [ebp+S_P], ebx
   105                              <1> ;		push	ebp				; which ever stack pointer it is, it points
   106                              <1> ;		mov	ebp,__register			; relative to all the register stack
   107                              <1> ;		call	_operand_read			; for I am the single-word push instruction
   108                              <1> ;		pop	ebp				;
   109                              <1> 
   110                              <1> ;	register identities supplied from emulated instructions to these routines
   111                              <1> ;	are their lowercase names equated to RTA1 word addresses
   112                              <1> 
   113                              <1> ;	There exist also uppercase spellings which instruction routines may
   114                              <1> ;	access internally. The uppercase names are four times in value the
   115                              <1> ;	equivalent lowercase ordinal names to give x86 platform offset values
   116                              <1> 
   117                              <1> ;       Assembly language equate is like parentheses! What's in a label
   118                              <1> ;       is not an expression but its value. Nothing like C preprocessor.
   119                              <1> ;       Just in case you're developing enhancements in assembly using
   120                              <1> ;       preprocessor and #define
   121                              <1> 
   122                              <1> ;		_floating_operand2 equ	256+12
   123                              <1> ;		FLOATING_OPERAND2 equ	_floating_operand2*4
   124                              <1> 
   125                              <1> 
   126                              <1> ;		a	equ	4
   127                              <1> ;		b	equ	5
   128                              <1> ;		mantissa2 equ	6
   129                              <1> 
   130                              <1> ;		A	equ	a*4
   131                              <1> ;		B	equ	b*4
   132                              <1> ;		MANTISSA2 equ	mantissa2*4
   133                              <1> 
   134                              <1> ;		mov	ebx, dword ptr [bp+MANTISSA2]	; the very same!
   135                              <1> ;		mov	ebx, dword ptr [bp+mantissa2*4]	; the very same
   136                              <1> 
   137                              <1> ;	but to identify an instruction-implied register to these operand routines
   138                              <1> 
   139                              <1> ;		mov	ebx, mantissa2		; bp already says which register set
   140                              <1> 
   141                              <1> ;	instruction evaluation supplies right-hand side operand EA in eax
   142                              <1> ;	Instruction implementation needs not examine EA. Call _operand_read
   143                              <1> ;	or _operand_write. eax must be as supplied to the instruction routine
   144                              <1> ;	on on operand retrieve and store
   145                              <1> 
   146                              <1> ;	simple instructions receive operand mode in cl from instruction
   147                              <1> ;	evaluation
   148                              <1> 
   149                              <1> ;	shifts and jumps use the ea which is already indexed or indirected
   150                              <1> ;	if necessary and make no operand call
   151                              <1> 
   152                              <1> ;	instructions call _burst_read2 or _burst_write2 for two-word operand cycles
   153                              <1> ;	instructions call _burst_read4 or _burst_write4 for four-word operand cycles
   154                              <1> 
   155                              <1> ;	operand reads of 1 or 2 words return values in eax:ebx
   156                              <1> 
   157                              <1> ;		call	_burst_read2
   158                              <1> ;		mov	dword ptr [ebp+A], eax
   159                              <1> ;		mov	dword ptr [ebp+B], ebx
   160                              <1> 
   161                              <1> ;	to store one operand word place it in ebx
   162                              <1> 
   163                              <1> ;	_sc	mov	ebx, dword ptr[_psr]	; I am the store carry instruction sc
   164                              <1> ;		and	ebx, 1			; CARRY
   165                              <1> ;		call	_operand_write
   166                              <1> 
   167                              <1> ;	to store two or four words or to load four words, point bx to register
   168                              <1> 
   169                              <1> ;	_qpop	mov	ebx, dword ptr [ebp+S_P] ; internal stack pointer
   170                              <1> ;						; either application sp or interrupt sp
   171                              <1> ;
   172                              <1> ;		add	dword ptr [ebp+S_P], 4	; internal stack+= 4
   173                              <1> ;		push	ebp			;
   174                              <1> ;		mov	ebp, __register		; in case context is interrupt registers
   175                              <1> ;		call	_burst_write4		; both internal stack pointers are absolute
   176                              <1> ;		pop	ebp			; point epb back to application registers
   177                              <1> ;						;                or interrupt registers
   178                              <1> 
   179                              <1> ;	more complex instructions do something to the registers after
   180                              <1> ;	acquiring operands
   181                              <1> 
   182                              <1> ;		call	_operand_read
   183                              <1> ;		add	eax, dword ptr [ebp+A]
   184                              <1> ;		rol	eax
   185                              <1> ;		and	al, CARRY		; 1
   186                              <1> ;		or	byte ptr [_psr], al	; low-order byte of longword _psr
   187                              <1> ;		shr	eax, 8
   188                              <1> ;		mov	dword ptr [ebp+A], eax
   189                              <1> 
   190                              <1> ;	emulated RTA1 instructions which both read and write (modify)
   191                              <1> ;	storage use the address in [edi+esi*4] to rewrite. edi is
   192                              <1> ;	NULL if it's not a suitable memory for a modify operation
   193                              <1> 
   194                              <1> ;	modify instructions which may have a register operand (not TS)
   195                              <1> ;	call _operand_write to rewrite a register. This guards aganst
   196                              <1> ;	applications writing interrupt registers.
   197                              <1>  
   198                              <1> ;	the effect of storage buses characteristically different
   199                              <1> ;	from RTA1 executable space is emulated in the routines
   200                              <1> ;	device_read and device_write
   201                              <1> 
   202                              <1> ;	Peripheral bus types implemented are
   203                              <1> 
   204                              <1> ;		filestore containing extents of up to 768K octets
   205                              <1> ;		accessible to RTA1 as up to 256K words in each extent.
   206                              <1> ;		The 3-octet words are in canonical order and packed
   207                              <1> 
   208                              <1> ;		network interface buffer store shared with the emulator
   209                              <1> ;		platform and reading out to RTA1 at 16 data bits per word
   210                              <1> ;		with eight high-order zero bits. RTA writes 16 data bits
   211                              <1> ;		to these locations from register low-order bit positions.
   212                              <1> ;		Storage byte order is canonical. These buffers are normal
   213                              <1> ;		and contiguous byte arrays of the emulator platform.
   214                              <1> ;		To RTA1 they are an attached device array of 16-bit words
   215                              <1> 
   216                              <1> ;	Device array types are
   217                              <1> 
   218                              <1> ;		executable space
   219                              <1> ;		24-bit filestore array
   220                              <1> ;		16-bit network interface array
   221                              <1> 
   222                              <1> ;	devices are identified in RTA1 memory relocation pointers and
   223                              <1> ;	tagged with device type. Executable space is device zero
   224                              <1> 
   225                              <1> ;	esi -> core.REGISTER
   226                              <1> 
   227                              <1> _burst_read2:
   228 0000030D 66B90600            <1> 	mov	cx, 6
   229 00000311 A900FFFF00          <1> 	test	eax, 00FFFF00h
   230 00000316 7402                <1> 	jz	read2_registers
   231 00000318 EB4D                <1> 	jmp	_bus_read
   232                              <1> 
   233                              <1> read2_registers:				; load registers from registers
   234 0000031A 8B5C8604            <1> 	mov	ebx, dword ptr [esi+eax*4+4]
   235 0000031E 8B0486              <1> 	mov	eax, dword ptr [esi+eax*4]
   236 00000321 C3                  <1> 	ret
   237                              <1> 	
   238                              <1> ;	esi -> core.REGISTER
   239                              <1> 
   240                              <1> _burst_read4:				; buffered read
   241 00000322 66B90700            <1> 	mov	cx, 7			; that will help the caller
   242 00000326 A900FFFF00          <1> 	test	eax, 00FFFF00h		; ebp+ebx contains a register number
   243 0000032B 7402                <1> 	jz	read4_registers		; may also identify extra
   244 0000032D EB38                <1> 	jmp	_bus_read
   245                              <1> 					; workspace registers
   246                              <1> read4_registers:			; at register stack tail
   247 0000032F 8B4C860C            <1> 	mov	ecx, dword ptr [esi+eax*4+3*4]
   248 00000333 894C9D0C            <1> 	mov	dword ptr [ebp+ebx*4+3*4], ecx
   249 00000337 8B4C8608            <1> 	mov	ecx, dword ptr [esi+eax*4+2*4]
   250 0000033B 894C9D08            <1> 	mov	dword ptr [ebp+ebx*4+2*4], ecx
   251 0000033F 8B4C8604            <1> 	mov	ecx, dword ptr [esi+eax*4+4]
   252 00000343 894C9D04            <1> 	mov	dword ptr [ebp+ebx*4+4], ecx
   253 00000347 8B0C86              <1> 	mov	ecx, dword ptr [esi+eax*4]
   254 0000034A 894C9D00            <1> 	mov	dword ptr [ebp+ebx*4], ecx
   255 0000034E C3                  <1> 	ret
   256                              <1> 
   257                              <1> ;	esi -> core.REGISTER
   258                              <1> 
   259                              <1> _operand_read:			; call here with designator coded in cx
   260 0000034F 80E107              <1> 	and	cl, 7		; and ea in eax
   261 00000352 80F904              <1> 	cmp	cl, 4
   262 00000355 740F                <1> 	je	immediate	; EA is operand
   263 00000357 80F905              <1> 	cmp	cl, 5
   264 0000035A 740A                <1> 	je	immediate_xi	; EA is operand
   265                              <1> 
   266 0000035C A900FFFF00          <1> 	test	eax, 00FFFF00h
   267 00000361 7504                <1> 	jnz	_bus_read	; ea does not point to registers
   268 00000363 8B0486              <1> 	mov	eax, dword ptr [esi+eax*4]
   269                              <1> 
   270                              <1> immediate:
   271                              <1> immediate_xi:
   272 00000366 C3                  <1> 	ret 
   273                              <1> 
   274                              <1> _bus_read:				; readout any memory
   275                              <1> 
   276 00000367 E8D2030000          <1> 	call	base_read_pointer	; returns eax <- storage block
   277                              <1> 					; 	  esi <- word offset
   278                              <1> 					;	  edi <- EA
   279                              <1> 
   280 0000036C A900004000          <1> 	test	eax, 00400000h		; big block?
   281 00000371 741B                <1> 	je	memory_read_4k_block
   282                              <1> 
   283 00000373 80F906              <1> 	cmp	cl, 6			; multiword operation?
   284 00000376 720D                <1> 	jb	_bus_read_256k_block
   285                              <1> 
   286 00000378 81FEFCFF0300        <1> 	cmp	esi, 03FFFCh		; near the edge?
   287 0000037E 7605                <1> 	jna	_bus_read_256k_block	; no
   288                              <1> 
   289 00000380 E8CB210000          <1> 	call	read_straddle_18b?
   290                              <1> 
   291                              <1> _bus_read_256k_block:
   292 00000385 A83F                <1> 	test	al, 63
   293 00000387 7429                <1> 	jz	memory_read_page
   294                              <1> 
   295 00000389 E9AA040000          <1> 	jmp	device_read
   296                              <1> 
   297                              <1> memory_read_4k_block:
   298 0000038E F7C600F00300        <1> 	test	esi, 0003F000h		; inside 4k block?
   299 00000394 740A                <1> 	jz	memory_read_thru
   300                              <1> 
   301 00000396 B90E000000          <1> 	mov	ecx, LP_ADDRESS
   302 0000039B E9780B0000          <1> 	jmp	guard_ii_escape		; no
   303                              <1> 
   304                              <1> memory_read_thru:
   305 000003A0 80F906              <1> 	cmp	cl, 6
   306 000003A3 720D                <1> 	jb	memory_read_page
   307                              <1> 
   308 000003A5 81FEFC0F0000        <1> 	cmp	esi, 0FFCh		; near the edge?
   309 000003AB 7605                <1> 	jna	memory_read_page	; no
   310                              <1> 
   311 000003AD E870210000          <1> 	call	read_straddle_12b?
   312                              <1> 
   313                              <1> memory_read_page:
   314 000003B2 C1E00C              <1> 	shl	eax, 12			; multiply by page and lose bit 00400000
   315 000003B5 01C6                <1> 	add	esi, eax
   316                              <1> ;	mov	ch, byte ptr [edi+PSR]	; field of PSR with byte options
   317 000003B7 BF[00000000]        <1> 	mov	edi, _memory		; byte address
   318                              <1> 
   319                              <1> memory_read_on:
   320 000003BC 8D3CB7              <1> 	lea	edi, [edi+esi*4]
   321 000003BF 8BB560020000        <1> 	mov	esi, dword ptr [ebp+CORE_INDEX1]
   322 000003C5 0FB6C1              <1> 	movzx	eax, cl
   323 000003C8 8B0485[D1030000]    <1> 	mov	eax, dword ptr [read_action+eax*4]
   324 000003CF FFE0                <1> 	jmp	eax
   325                              <1> 
   326                              <1> read_action:
   327 000003D1 [F1030000]          <1> 	dd	memory_read_w0
   328 000003D5 [32040000]          <1> 	dd	memory_t1
   329 000003D9 [39040000]          <1> 	dd	memory_t2	; or h1
   330 000003DD [49040000]          <1> 	dd	memory_t3	; or h2
   331 000003E1 [66030000]          <1> 	dd	immediate	; don't get here
   332 000003E5 [66030000]          <1> 	dd	immediate_xi	; don't get here
   333 000003E9 [F8030000]          <1> 	dd	memory_read2
   334 000003ED [06040000]          <1> 	dd	memory_read4
   335                              <1> 
   336                              <1> memory_read_w0:			; readout system memory 1 word
   337                              <1> ;	mov	dword ptr [esi+REGISTER+154*4], edi
   338                              <1> ;	mov	dword ptr [esi+REGISTER+155*4], esi
   339 000003F1 8B07                <1> 	mov	eax, dword ptr [edi]
   340 000003F3 B000                <1> 	mov	al, 0
   341 000003F5 0FC8                <1> 	bswap	eax
   342                              <1> ; immediate:
   343                              <1> ; immediate_xi:
   344 000003F7 C3                  <1>  	ret
   345                              <1> 
   346                              <1> memory_read2:			; readout system memory 2 words
   347 000003F8 8B5F04              <1> 	mov	ebx, dword ptr [edi+4]
   348 000003FB 8B07                <1> 	mov	eax, dword ptr [edi]
   349                              <1> 
   350 000003FD B000                <1> 	mov	al, 0
   351 000003FF B300                <1> 	mov	bl, 0
   352 00000401 0FC8                <1> 	bswap	eax
   353 00000403 0FCB                <1> 	bswap	ebx
   354 00000405 C3                  <1> 	ret
   355                              <1> 				; readout system memory 4 words
   356                              <1> memory_read4:			; store by pointer
   357                              <1> 				; this will be useful to the caller
   358                              <1> 
   359 00000406 8B07                <1> 	mov	eax, dword ptr [edi]
   360 00000408 B000                <1> 	mov	al, 0
   361 0000040A 0FC8                <1> 	bswap	eax
   362 0000040C 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   363 00000410 8B4704              <1> 	mov	eax, dword ptr [edi+4]
   364 00000413 B000                <1> 	mov	al, 0
   365 00000415 0FC8                <1> 	bswap	eax
   366 00000417 89449D04            <1> 	mov	dword ptr [ebp+ebx*4+4], eax
   367 0000041B 8B4708              <1> 	mov	eax, dword ptr [edi+2*4]
   368 0000041E B000                <1> 	mov	al, 0
   369 00000420 0FC8                <1> 	bswap	eax
   370 00000422 89449D08            <1> 	mov	dword ptr [ebp+ebx*4+2*4], eax
   371 00000426 8B470C              <1> 	mov	eax, dword ptr [edi+3*4]
   372 00000429 B000                <1> 	mov	al, 0
   373 0000042B 0FC8                <1> 	bswap	eax
   374 0000042D 89449D0C            <1> 	mov	dword ptr [ebp+ebx*4+3*4], eax
   375 00000431 C3                  <1> 	ret
   376                              <1> 
   377                              <1> memory_t1:
   378 00000432 8B07                <1> 	mov	eax, dword ptr [edi]
   379 00000434 C1E010              <1> 	shl	eax, 16		; t1 = 3.2.THIS.zero
   380 00000437 EB1B                <1> 	jmp	memory_tw
   381                              <1> 
   382                              <1> memory_t2:
   383 00000439 8B07                <1> 	mov	eax, dword ptr [edi]
   384 0000043B F6869C04000080      <1> 	test	byte ptr [esi+PSR], HALF_W
   385 00000442 7517                <1> 	jnz	memory_h1
   386 00000444 C1E008              <1> 	shl	eax, 8		; t2 = 3.THIS.1.zero
   387 00000447 EB0B                <1> 	jmp	memory_tw
   388                              <1> 
   389                              <1> memory_t3:
   390 00000449 8B07                <1> 	mov	eax, dword ptr [edi]
   391 0000044B F6869C04000080      <1> 	test	byte ptr [esi+PSR], HALF_W
   392 00000452 750E                <1> 	jnz	memory_h2
   393                              <1> memory_tw:
   394 00000454 C1F810              <1> 	sar	eax, 16		; t3 = THIS.2.1.zero
   395 00000457 C1E808              <1> 	shr	eax, 8
   396 0000045A C3                  <1> 	ret
   397                              <1> 
   398                              <1> memory_h1:
   399 0000045B 0FC8                <1> 	bswap	eax		; already loaded but not swapped
   400 0000045D C1E008              <1> 	shl	eax, 8		; h1 = zero.HERE.2.3
   401 00000460 EB05                <1> 	jmp	memory_hw
   402                              <1> 
   403                              <1> memory_h2:
   404 00000462 0FC8                <1> 	bswap	eax		; already loaded but not swapped
   405 00000464 C1E014              <1> 	shl	eax, 8+12
   406                              <1> memory_hw:
   407 00000467 C1F80C              <1> 	sar	eax, 12
   408 0000046A C1E808              <1> 	shr	eax, 8
   409 0000046D C3                  <1> 	ret
   410                              <1> 
   411                              <1> ;	esi -> core.REGISTER
   412                              <1> 				; store system memory
   413                              <1> _burst_write4:
   414 0000046E 66B90700            <1> 	mov	cx, 7
   415 00000472 A900FFFF00          <1> 	test	eax, 00FFFF00h
   416 00000477 0F858A000000        <1> 	jnz	NEAR bus_write
   417                              <1> 
   418                              <1> 	; store emulated registers to emulated registers
   419                              <1> 
   420 0000047D F7869C040000000080- <1> 	test	dword ptr [esi+PSR], 0800000h	; ISR ?
   420 00000486 00                  <1>
   421 00000487 750A                <1> 	jnz	write4_registers	; ISRs may write some spare registers
   422 00000489 83F87C              <1> 	cmp	eax, 124
   423 0000048C 7605                <1> 	jna	write4_registers
   424 0000048E E9800A0000          <1> 	jmp	guard_ii_authority	; but applications may not write
   425                              <1> 					; any interrupt registers
   426                              <1> 
   427                              <1> write4_registers:
   428                              <1> ;	mov	edi, eax		; eax can be freed
   429                              <1> 
   430 00000493 8B4C9D00            <1> 	mov	ecx, dword ptr [ebp+ebx*4]	; data for store
   431                              <1> 					; ebp+ebx is a register number
   432                              <1> 					; which can be extra register locations
   433                              <1> 					; serving as workspace at the tail of
   434                              <1> 					; the register stack
   435                              <1> 
   436 00000497 890C86              <1> 	mov	dword ptr [esi+eax*4], ecx
   437 0000049A 8B4C9D04            <1> 	mov	ecx, dword ptr [ebp+ebx*4+4]
   438 0000049E 894C8604            <1> 	mov	dword ptr [esi+eax*4+4], ecx
   439                              <1> 
   440 000004A2 8B4C9D08            <1> 	mov	ecx, dword ptr [ebp+ebx*4+2*4]
   441 000004A6 894C8608            <1> 	mov	dword ptr [esi+eax*4+2*4], ecx
   442 000004AA 8B4C9D0C            <1> 	mov	ecx, dword ptr [ebp+ebx*4+3*4]
   443 000004AE 894C860C            <1> 	mov	dword ptr [esi+eax*4+3*4], ecx
   444 000004B2 C3                  <1> 	ret
   445                              <1> 
   446                              <1> ;	esi -> core.REGISTER
   447                              <1> 
   448                              <1> _burst_write2:
   449 000004B3 66B90600            <1> 	mov	cx, 6
   450 000004B7 A900FFFF00          <1> 	test	eax, 00FFFF00h
   451 000004BC 7549                <1> 	jnz	bus_write
   452                              <1> 
   453                              <1> 	; store to emulated registers
   454                              <1> 
   455 000004BE F7869C040000000080- <1> 	test	dword ptr [esi+PSR], 0800000h	; ISR ?
   455 000004C7 00                  <1>
   456 000004C8 750A                <1> 	jnz	write2_registers	; there are spare registers at the end
   457 000004CA 83F87E              <1> 	cmp	eax, 126		; but applications may not write
   458 000004CD 7605                <1> 	jna	write2_registers	; any interrupt registers
   459 000004CF E93F0A0000          <1> 	jmp	guard_ii_authority
   460                              <1> 
   461                              <1> write2_registers:
   462                              <1> ;	mov	edi, eax			; time to free eax
   463 000004D4 8B4C9D00            <1> 	mov	ecx, dword ptr [ebp+ebx*4]
   464 000004D8 890C86              <1> 	mov	dword ptr [esi+eax*4], ecx
   465 000004DB 8B4C9D04            <1> 	mov	ecx, dword ptr [ebp+ebx*4+4]
   466 000004DF 894C8604            <1> 	mov	dword ptr [esi+eax*4++4], ecx
   467 000004E3 C3                  <1> 	ret
   468                              <1> 
   469                              <1> ;	esi -> core.REGISTER
   470                              <1> 
   471                              <1> _operand_write:
   472 000004E4 A900FFFF00          <1> 	test	eax, 00FFFF00h
   473 000004E9 751C                <1> 	jnz	bus_write
   474                              <1> 
   475                              <1> _operand_write_register:
   476 000004EB A980000000          <1> 	test	eax, 80h		; in the interrupt registers?
   477 000004F0 7411                <1> 	jz	write1_register
   478 000004F2 F7869C040000000080- <1> 	test	dword ptr [esi+PSR], 0800000h
   478 000004FB 00                  <1>
   479 000004FC 7505                <1> 	jnz	write1_register
   480 000004FE E9100A0000          <1> 	jmp	guard_ii_authority
   481                              <1> 
   482                              <1> write1_register:
   483 00000503 891C86              <1> 	mov	dword ptr [esi+eax*4], ebx
   484 00000506 C3                  <1> 	ret
   485                              <1> 
   486                              <1> bus_write:				; write any memory
   487                              <1> 					;	eax <- EA
   488                              <1> 					;	ebx <- data | [ ebp + ebx * 4] -> 1st data word
   489                              <1> 					;	cl  <- encoding [ word * 1 / 2 / 4 ] / byte
   490                              <1> 					;	esi <- core
   491                              <1> 
   492                              <1> 
   493 00000507 E8C6020000          <1> 	call	base_write_pointer	; returns eax <- block
   494                              <1> 					;         edi <- EA
   495                              <1> 					;	  esi <- word offset
   496                              <1> 
   497 0000050C A900004000          <1> 	test	eax, 00400000h		; big block?
   498 00000511 741E                <1> 	jz	memory_write_4k_block	; no
   499 00000513 80F906              <1> 	cmp	cl, 6			; multiword operation?
   500 00000516 720D                <1> 	jb	bus_write_256k_block	; no
   501                              <1> 
   502 00000518 81FEFCFF0300        <1> 	cmp	esi, 03FFFCh		; near the edge?
   503 0000051E 7605                <1> 	jna	bus_write_256k_block	; no
   504                              <1> 
   505 00000520 E8A0200000          <1> 	call	write_straddle_18b?
   506                              <1> 
   507                              <1> bus_write_256k_block:
   508 00000525 A93F000000          <1> 	test	eax, 63			; a device array?
   509 0000052A 7429                <1> 	jz	memory_write_page	; no. scaling shift will scrub bit 400000
   510 0000052C E90D040000          <1> 	jmp	_device_write		; yes a device array
   511                              <1> 
   512                              <1> memory_write_4k_block:
   513 00000531 F7C600F00300        <1> 	test	esi, 0003F000h		; inside a 4k page?
   514 00000537 740A                <1> 	jz	memory_write_thru
   515 00000539 B90E000000          <1> 	mov	ecx, LP_ADDRESS
   516 0000053E E9D5090000          <1> 	jmp	guard_ii_escape		; no
   517                              <1> 
   518                              <1> memory_write_thru:
   519 00000543 80F906              <1> 	cmp	cl, 6			; multiword operation?
   520 00000546 720D                <1> 	jb	memory_write_page	; no
   521                              <1> 
   522 00000548 81FEFC0F0000        <1> 	cmp	esi, 0FFCh		; near the edge?
   523 0000054E 7605                <1> 	jna	memory_write_page	; no
   524                              <1> 
   525 00000550 E83D200000          <1> 	call	write_straddle_12b?
   526                              <1> 
   527                              <1> memory_write_page:
   528 00000555 8BBD60020000        <1> 	mov	edi, dword ptr [ebp+CORE_INDEX1]
   529 0000055B 3B87BC060000        <1> 	cmp	eax, dword ptr [edi+IO_PORT+124*4] ; edi -> core registers
   530 00000561 0F88AC090000        <1> 	js	near guard_ii_authority	; guard the NVRAM whether real or emulated
   531                              <1> 
   532 00000567 C1E00C              <1> 	shl	eax, 12			; multiply by page and lose bit 00400000
   533 0000056A 01C6                <1> 	add	esi, eax		; add offset
   534                              <1> 
   535                              <1> ;	mov	ch, byte ptr [edi+PSR]	; field of PSR with byte options
   536 0000056C BF[00000000]        <1> 	mov	edi, _memory
   537                              <1> 
   538                              <1> memory_write_on:
   539 00000571 8D3CB7              <1> 	lea	edi, [edi+esi*4]
   540 00000574 8BB560020000        <1> 	mov	esi, dword ptr [ebp+CORE_INDEX1]
   541                              <1> 
   542 0000057A F705[00000000]1000- <1> 	test	dword ptr [_general_indication], TOUCHPOINT
   542 00000582 0000                <1>
   543 00000584 7415                <1> 	jz	memory_write_on_go
   544                              <1> 
   545 00000586 3B3D[00000000]      <1> 	cmp	edi, dword ptr [_touchpoint]
   546 0000058C 780D                <1> 	js	memory_write_on_go
   547 0000058E 3B3D[00000000]      <1> 	cmp	edi, dword ptr [_touchpoint2]
   548 00000594 7905                <1> 	jns	memory_write_on_go
   549 00000596 E978090000          <1> 	jmp	guard_ii_authority
   550                              <1> 
   551                              <1> memory_write_on_go:
   552 0000059B 0FB6C1              <1> 	movzx	eax, cl
   553 0000059E 8B0485[A7050000]    <1> 	mov	eax, dword ptr [write_action+eax*4]
   554 000005A5 FFE0                <1> 	jmp	eax
   555                              <1> 
   556                              <1> write_action:
   557 000005A7 [C7050000]          <1> 	dd	memory_write
   558 000005AB [CC050000]          <1> 	dd	write_t1
   559 000005AF [D0050000]          <1> 	dd	write_t2	; or h1
   560 000005B3 [DD050000]          <1> 	dd	write_t3	; or h2
   561 000005B7 [CB050000]          <1> 	dd	just_dont
   562 000005BB [CB050000]          <1> 	dd	just_dont
   563 000005BF [17060000]          <1> 	dd	memory_write2
   564 000005C3 [29060000]          <1> 	dd	memory_write4
   565                              <1> 
   566                              <1> memory_write:					; store system memory 1 word
   567 000005C7 0FCB                <1> 	bswap	ebx
   568 000005C9 891F                <1> 	mov	dword ptr [edi], ebx
   569                              <1> just_dont:
   570 000005CB C3                  <1> 	ret
   571                              <1> 
   572                              <1> write_t1:
   573 000005CC 885F01              <1> 	mov	byte ptr [edi+1], bl
   574 000005CF C3                  <1> 	ret
   575                              <1> 
   576                              <1> write_t2:
   577 000005D0 F6869C04000080      <1> 	test	byte ptr [esi+PSR], HALF_W
   578 000005D7 7511                <1> 	jnz	write_h1
   579 000005D9 885F02              <1> 	mov	byte ptr [edi+2], bl
   580 000005DC C3                  <1> 	ret
   581                              <1> 
   582                              <1> write_t3:
   583 000005DD F6869C04000080      <1> 	test	byte ptr [esi+PSR], HALF_W
   584 000005E4 751A                <1> 	jnz	write_h2
   585 000005E6 885F03              <1> 	mov	byte ptr [edi+3], bl
   586 000005E9 C3                  <1> 	ret
   587                              <1> 
   588                              <1> write_h1:
   589 000005EA 8B07                <1> 	mov	eax, dword ptr [edi]
   590 000005EC 0FC8                <1> 	bswap	eax
   591 000005EE 81E3FF0F0000        <1> 	and	ebx, 4095
   592 000005F4 C1E30C              <1> 	shl	ebx, 12
   593 000005F7 25FF0F0000          <1> 	and	eax, 4095
   594 000005FC 09D8                <1> 	or	eax, ebx
   595 000005FE EB12                <1> 	jmp	write_hw
   596                              <1> 
   597                              <1> write_h2:
   598 00000600 8B07                <1> 	mov	eax, dword ptr [edi]
   599 00000602 0FC8                <1> 	bswap	eax
   600 00000604 C1E80C              <1> 	shr	eax, 12
   601 00000607 C1E00C              <1> 	shl	eax, 12
   602 0000060A 81E3FF0F0000        <1> 	and	ebx, 4095
   603 00000610 09D8                <1> 	or	eax, ebx
   604                              <1> 
   605                              <1> write_hw:
   606 00000612 0FC8                <1> 	bswap	eax
   607 00000614 8907                <1> 	mov	dword ptr [edi], eax
   608 00000616 C3                  <1> 	ret
   609                              <1> 					; store system memory 2 words
   610                              <1> memory_write2:				; eax is already free
   611 00000617 8B449D00            <1> 	mov	eax, dword ptr [ebp+ebx*4]
   612 0000061B 0FC8                <1> 	bswap	eax
   613 0000061D 8907                <1> 	mov	dword ptr [edi], eax
   614                              <1> 
   615 0000061F 8B449D04            <1> 	mov	eax, dword ptr [ebp+ebx*4+4]
   616 00000623 0FC8                <1> 	bswap	eax
   617 00000625 894704              <1> 	mov	dword ptr [edi+4], eax
   618 00000628 C3                  <1> 	ret
   619                              <1> 
   620                              <1> memory_write4:					; store system memory 4 words
   621 00000629 8B449D00            <1> 	mov	eax, dword ptr [ebp+ebx*4]	; bx is a register number and may
   622                              <1> 						; identify extra workspace registers
   623                              <1> 						; at register stack tail
   624 0000062D 0FC8                <1> 	bswap	eax
   625 0000062F 8907                <1> 	mov	dword ptr [edi], eax
   626 00000631 8B449D04            <1> 	mov	eax, dword ptr [ebp+ebx*4+4]
   627 00000635 0FC8                <1> 	bswap	eax
   628 00000637 894704              <1> 	mov	dword ptr [edi+4], eax
   629 0000063A 8B449D08            <1> 	mov	eax, dword ptr [ebp+ebx*4+8]
   630 0000063E 0FC8                <1> 	bswap	eax
   631 00000640 894708              <1> 	mov	dword ptr [edi+2*4], eax
   632 00000643 8B449D0C            <1> 	mov	eax, dword ptr [ebp+ebx*4+12]
   633 00000647 0FC8                <1> 	bswap	eax
   634 00000649 89470C              <1> 	mov	dword ptr [edi+3*4], eax
   635 0000064C C3                  <1> 	ret
   636                              <1> 
   637                              <1> ;	modify instructions n inc dec src slc sim popA
   638                              <1> ;	rewrite here
   639                              <1> 
   640                              <1> 
   641                              <1> memoreg_writeback:
   642                              <1> 	%if	1
   643 0000064D 21FF                <1> 	and	edi, edi
   644 0000064F 7509                <1> 	jnz	memory_direct
   645 00000651 25FFFFFF00          <1> 	and	eax, 00FFFFFFh			; unchanged esi -> core.REGISTER	
   646 00000656 89049E              <1> 	mov	[esi+ebx*4+REGISTER], eax	; platform endian
   647                              <1> 						; register writeback index ebx ->
   648 00000659 C3                  <1> 	ret
   649                              <1> 	%else
   650                              <1> 
   651                              <1> 
   652                              <1> 	test	ebx, -256			; save EA is ?
   653                              <1> 	jnz	memory_direct			; a memory device
   654                              <1> 	xchg	eax, ebx			; a register
   655                              <1> 	and	ebx, 00FFFFFFh
   656                              <1> 	jmp	_operand_write_register		; esi -> core.REGISTER
   657                              <1> 
   658                              <1> ;	if not a register rewrite
   659                              <1> ;	n inc dec src slc sim popA
   660                              <1> ;	write RTA memory at its saved platform address
   661                              <1> 	%endif
   662                              <1> 
   663                              <1> memory_direct:					; esi <- memory_offset
   664 0000065A 0FC8                <1> 	bswap	eax				; write components edi esi kept from base_read
   665 0000065C 30C0                <1> 	xor	al, al				
   666 0000065E 8904B7              <1> 	mov	dword ptr [edi+esi*4], eax
   667 00000661 C3                  <1> 	ret
   668                              <1> 
   669                              <1> 
   670                              <1> ;	execute calls memory read
   671                              <1> ;	ea < 256 is not for execute a register
   672                              <1> ;	operand is at a readable address in system memory or array
   673                              <1> 
   674                              <1> memory_read:					; for execute and modify instructions:
   675 00000662 E86A000000          <1> 	call	memory_point			; read only executable space
   676 00000667 8B04B7              <1> 	mov	eax, dword ptr [edi+esi*4]	; and similar memory types
   677 0000066A 0FC8                <1> 	bswap	eax
   678 0000066C C3                  <1> 	ret
   679                              <1> 
   680                              <1> ;	modify instructions n inc dec src slc sim popA call here
   681                              <1> ;	ea < 256 is a register
   682                              <1> 
   683                              <1> memoreg:					; read-modify-write registers / system memory
   684 0000066D A900FFFFFF          <1> 	test	eax, -256			; but nothing marked as a peripheral bus
   685 00000672 751A                <1> 	jnz	memory_read_lock
   686 00000674 A880                <1> 	test	al, 128				; interrupt register?
   687 00000676 740E                <1> 	jz	register_read_for_write		; no, clear to update
   688 00000678 F6869E04000080      <1> 	test	byte ptr [esi+PSR+2], 128	; ISR ?
   689 0000067F 7505                <1> 	jnz	register_read_for_write
   690 00000681 E98D080000          <1> 	jmp	guard_ii_authority
   691                              <1> 
   692                              <1> register_read_for_write:			; unchanged esi -> core.REGISTER
   693 00000686 89C3                <1>         mov     ebx, eax                        ; copy of ea -> registers to memoreg_writeback
   694 00000688 31FF                <1>         xor     edi, edi                        ; tell memoreg->writeback that's how it is, no device
   695 0000068A 8B0486              <1>         mov     eax, dword ptr [esi+REGISTER+eax*4]
   696 0000068D C3                  <1>         ret					; register writeback index ebx ->
   697                              <1> 
   698                              <1> 
   699                              <1> ;	RAM boundary in port 124 defines the upper page limit
   700                              <1> ;	of a real or emulated NVRAM containing the fixed system image
   701                              <1> 
   702                              <1> ;	fixed system image may be kernel + loader in a dozen pages
   703                              <1> ;	or it may be the entire application
   704                              <1> 
   705                              <1> ;	emulated machine applies the update limit
   706                              <1> ;	whether NVRAM is emulated or real
   707                              <1> 
   708                              <1> ;	if not a register
   709                              <1> ;	n inc dec src slc sim popA read a memory word which is legal to write
   710                              <1> ;	and keep the platform address to write the modified value
   711                              <1> ;	modify instructions do not lock memory between read and rewrite
   712                              <1> 
   713                              <1> memory_read_lock:
   714 0000068E E806000000          <1> 	call	memory_lock
   715 00000693 8B04B7              <1> 	mov	eax, dword ptr [edi+esi*4]
   716 00000696 0FC8                <1> 	bswap	eax
   717 00000698 C3                  <1> 	ret
   718                              <1> 
   719                              <1> ;	memory_read_lock calls here for modify instructions if ea > registers
   720                              <1> ;	ts calls here with ea whatever range always -> memory
   721                              <1> 
   722                              <1> ;	ea must be a legally writable memory word
   723                              <1> ;	memory_lock does not lock but identifies a platform write address  
   724                              <1> ;	ts reads / unconditionally replaces word.t1
   725                              <1> ;	under platform locking protocol, xchg platform instruction
   726                              <1> 
   727                              <1> memory_lock:					; point for update
   728                              <1> 						; barred below RAM boundary as write is
   729 00000699 E834010000          <1> 	call	base_write_pointer		; resolve device:block:offset from EA
   730                              <1> 						; edi <- core.REGISTERS <- esi
   731                              <1> 						; eax <- memory block index
   732                              <1> 						; esi <- memory word offset
   733                              <1> 
   734 0000069E 8BBD60020000        <1> 	mov	edi, dword ptr [ebp+CORE_INDEX1]
   735 000006A4 A900004000          <1> 	test	eax, 00400000h			; update block name is a big bank ?
   736 000006A9 7419                <1> 	jz	memory_lock_page		; no
   737 000006AB A93F000000          <1> 	test	eax, 63				; a device outside executable space ?
   738 000006B0 754D                <1> 	jnz	_yspace_read			; yes
   739 000006B2 25FFFF3F00          <1> 	and	eax, 003FFFFFh			; bit 0400000 is gets stripped later anyway
   740 000006B7 3B87BC060000        <1> 	cmp	eax, dword ptr [edi+IO_PORT+124*4]	; below RAM boundary?
   741 000006BD 7339                <1> 	jnb	_xspace_read			; no, go ahead
   742 000006BF E94F080000          <1> 	jmp	guard_ii_authority
   743                              <1> 
   744                              <1> memory_lock_page:
   745 000006C4 3B87BC060000        <1> 	cmp	eax, dword ptr [edi+IO_PORT+124*4]	; below RAM boundary?
   746 000006CA 731A                <1> 	jnb	_xspace_read4K			; no, go head if offset < 1000 hex
   747 000006CC E942080000          <1> 	jmp	guard_ii_authority
   748                              <1> 
   749                              <1> 
   750                              <1> ;	memory_read calls here for execute
   751                              <1> ;	identify a platform read address of an RTA memory word
   752                              <1> 
   753                              <1> memory_point:
   754 000006D1 E868000000          <1> 	call	base_read_pointer		; edi <- core.REGISTERS <- esi
   755                              <1> 						; esi <- word offset in memory block
   756 000006D6 A900004000          <1> 	test	eax, 00400000h			; eax <- page index
   757 000006DB 7409                <1> 	jz	_xspace_read4K
   758                              <1> 
   759 000006DD A93F000000          <1> 	test	eax, 63
   760 000006E2 7414                <1> 	jz	_xspace_read
   761 000006E4 EB19                <1> 	jmp	_yspace_read			; ie a device either appropriate or not
   762                              <1> 
   763                              <1> _xspace_read4K:
   764 000006E6 F7C600F00300        <1> 	test	esi, 003F000h
   765 000006EC 740A                <1> 	jz	_xspace_read
   766 000006EE B90E000000          <1> 	mov	ecx, LP_ADDRESS
   767 000006F3 E920080000          <1> 	jmp	guard_ii_escape
   768                              <1> 
   769                              <1> _xspace_read:
   770 000006F8 BF[00000000]        <1> 	mov	edi, _memory
   771 000006FD EB34                <1> 	jmp	_memory_deliver			; device array zero
   772                              <1> 
   773                              <1> _yspace_read:
   774 000006FF A900008000          <1> 	test	eax, 00800000h			; a tripsy non-space?
   775 00000704 7533                <1> 	jnz	_zspace_read			; not allowed
   776                              <1> 
   777 00000706 89C7                <1> 	mov	edi, eax
   778 00000708 83E73F              <1> 	and	edi, 63
   779 0000070B 8BBCBECC060000      <1> 	mov	edi, dword ptr [esi+IO_PORT+128*4+edi*4]
   780 00000712 F7C700008000        <1> 	test	edi, SYSMEM_FLAG
   781 00000718 741F                <1> 	jz	_zspace_read
   782 0000071A F7C700004000        <1> 	test	edi, DATA16_FLAG
   783 00000720 7517                <1> 	jnz	_zspace_read
   784                              <1> 
   785 00000722 C1E002              <1> 	shl	eax, 2				; al = 4 * device index
   786 00000725 0FB6F8              <1> 	movzx	edi, al
   787                              <1> 
   788 00000728 8BBF[00000000]      <1> 	mov	edi, dword ptr [_devices+edi]
   789 0000072E 30C0                <1> 	xor	al, al				; necessary to lose the device bits now
   790 00000730 C1E802              <1> 	shr	eax, 2
   791                              <1> 
   792                              <1> _memory_deliver:
   793 00000733 C1E00C              <1> 	shl	eax, 12		; multiply by page and lose bit 00400000
   794 00000736 01C6                <1> 	add	esi, eax
   795                              <1> 
   796                              <1> 	%if	__SMP
   797                              <1> 	%else
   798                              <1> 	mov	eax, dword ptr [edi+esi*4]
   799                              <1> 	bswap	eax
   800                              <1> 	%endif
   801 00000738 C3                  <1> 	ret
   802                              <1> 
   803                              <1> _zspace_read:
   804 00000739 E9D5070000          <1> 	jmp	guard_ii_authority
   805                              <1> 
   806                              <1> ;	esi -> core
   807                              <1> 
   808                              <1> 	%if	1
   809                              <1> 
   810                              <1> 	%include	"base_map.msm"
     1                              <2> base_read_pointer:
     2 0000073E 89C7                <2> 	mov	edi, eax		; keep EA for +words reads
     3                              <2> 					; straddling storage blocks
     4 00000740 C1C910              <2> 	ror	ecx, 16			; conserve designator / word counts
     5                              <2> 
     6 00000743 C1C812              <2> 	ror	eax, 18
     7 00000746 A83F                <2> 	test	al, 63
     8 00000748 750C                <2> 	jnz	read_address18
     9 0000074A C1C006              <2> 	rol	eax, 6
    10 0000074D 660FB6C8            <2> 	movzx	cx, al
    11 00000751 C1E814              <2> 	shr	eax, 32-12
    12                              <2> 					; advise caller address 6.12
    13 00000754 EB07                <2> 	jmp	resolve_read_tag	; this path is  most storage reads
    14                              <2> 	
    15                              <2> read_address18:
    16 00000756 660FB6C8            <2> 	movzx	cx, al
    17 0000075A C1E80E              <2> 	shr	eax, 32-18
    18                              <2> 
    19                              <2> resolve_read_tag:
    20                              <2> 
    21 0000075D 80E13F              <2> 	and	cl, 63
    22 00000760 7418                <2> 	jz	read_window_clear	; everyone may read B0
    23 00000762 F6C138              <2> 	test	cl, 56
    24 00000765 7513                <2> 	jnz	read_window_clear
    25 00000767 80F10F              <2> 	xor	cl, 15			; [ 1 2 3 4 5 6 7 ] -> 8 + [ 6 5 4 3 2 1 0]
    26 0000076A 660FA38E9C040000    <2> 	bt	word ptr [esi+PSR], cx	; in memory bytes ffff f00c 0xxx xxxx
    27 00000772 7303                <2> 	jnc	read_application_window	; x86 bus read -> 0xxx xxxx ffff f00c
    28 00000774 80C940              <2> 	or	cl, 64
    29                              <2> 
    30                              <2> read_application_window:
    31 00000777 80F10F              <2> 	xor	cl, 15			; [ 1 2 3 4 5 6 7 ] <- 8 + [ 6 5 4 3 2 1 0]
    32                              <2> 
    33                              <2> read_window_clear:
    34 0000077A 50                  <2> 	push	eax
    35 0000077B 0FB6C1              <2> 	movzx	eax, cl
    36 0000077E 8B8486CC040000      <2> 	mov	eax, dword ptr [esi+eax*4+IO_PORT]
    37 00000785 5E                  <2> 	pop	esi
    38                              <2> 
    39 00000786 C1C910              <2> 	ror	ecx, 16
    40 00000789 C3                  <2> 	ret
    41                              <2> 
    42 0000078A FF00800000000000    <2> write_rule	db	255, 0, 128, 0, 0, 0, 0, 0
    43 00000792 0000000000000000    <2> 		db	0, 0, 0, 0, 0, 0, 0, 0
    44 0000079A 0000000000000000    <2> 		db	0, 0, 0, 0, 0, 0, 0, 0
    45 000007A2 0000000000000000    <2> 		db	0, 0, 0, 0, 0, 0, 0, 0
    46 000007AA 0000000000000000    <2> 		db	0, 0, 0, 0, 0, 0, 0, 0
    47 000007B2 0000000000000000    <2> 		db	0, 0, 0, 0, 0, 0, 0, 0
    48 000007BA 0000000000000000    <2> 		db	0, 0, 0, 0, 0, 0, 0, 0
    49 000007C2 0000000000000000    <2> 		db	0, 0, 0, 0, 0, 0, 0, 0
    50 000007CA FF80808080808080    <2> 		db	255, 128, 128, 128, 128, 128, 128, 128
    51                              <2> 
    52                              <2> base_write_pointer:
    53                              <2> 
    54 000007D2 89C7                <2> 	mov	edi, eax		; keep EA for +words writes
    55 000007D4 C1C910              <2> 	ror	ecx, 16			; straddling storage blocks
    56                              <2> 					; protect designators in ecx
    57 000007D7 C1C812              <2> 	ror	eax, 18			
    58                              <2> 
    59 000007DA A83F                <2> 	test	al, 63
    60 000007DC 750C                <2> 	jnz	write_address18
    61 000007DE C1C006              <2> 	rol	eax, 6
    62 000007E1 660FB6C8            <2> 	movzx	cx, al
    63 000007E5 C1E814              <2> 	shr	eax, 32-12
    64 000007E8 EB07                <2> 	jmp	resolve_write_tag	; this path is
    65                              <2> 					; most storge writes
    66                              <2> write_address18:
    67 000007EA 660FB6C8            <2> 	movzx	cx, al
    68 000007EE C1E80E              <2> 	shr	eax, 32-18
    69                              <2> 	
    70                              <2> resolve_write_tag:
    71                              <2> 
    72 000007F1 80E13F              <2> 	and	cl, 63
    73 000007F4 0F8419070000        <2> 	jz	near guard_ii_authority	; no-one may write B0
    74 000007FA F6C138              <2> 	test	cl, 56
    75 000007FD 7513                <2> 	jnz	write_window_known
    76 000007FF 80F10F              <2> 	xor	cl, 15			; [ 1 2 3 4 5 6 7 ] -> 8 + [ 6 5 4 3 2 1 0]
    77 00000802 660FA38E9C040000    <2> 	bt	word ptr [esi+PSR], cx		; in memory bytes ffff f00c 0xxx xxxx
    78 0000080A 7303                <2> 	jnc	write_application_window	; x86 bus read -> 0xxx xxxx ffff f00c
    79 0000080C 80C940              <2> 	or	cl, 64
    80                              <2> 
    81                              <2> write_application_window:
    82 0000080F 80F10F              <2> 	xor	cl, 15			; [ 1 2 3 4 5 6 7 ] <- 8 + [ 6 5 4 3 2 1 0]
    83                              <2> 
    84                              <2> write_window_known:
    85 00000812 50                  <2> 	push	eax
    86 00000813 0FB6C1              <2> 	movzx	eax, cl
    87 00000816 F680[8A070000]80    <2> 	test	byte ptr [eax+write_rule], 128
    88 0000081D 740D                <2> 	jz	write_window_free
    89 0000081F F6869E04000080      <2> 	test	byte ptr [esi+PSR+2], 128	; ISR ?
    90 00000826 0F84E7060000        <2> 	jz	near guard_ii_authority		; the unbalanced push is harmless
    91                              <2> 						; stack is reset on faults
    92                              <2> write_window_free:
    93 0000082C 8B8486CC040000      <2> 	mov	eax, dword ptr [esi+eax*4+IO_PORT]
    94 00000833 5E                  <2> 	pop	esi
    95                              <2> 
    96 00000834 C1C910              <2> 	ror	ecx, 16		; restore designator information
    97 00000837 C3                  <2> 	ret
   811                              <1> 
   812                              <1> 	%else
   813                              <1> 
   814                              <1> base_read_pointer:
   815                              <1> 
   816                              <1> 	mov	edi, eax	; set aside EA for split write operations
   817                              <1> 
   818                              <1> 	ror	ecx, 16		; save designator
   819                              <1> 	ror	eax, 18
   820                              <1> 	test	al, 63
   821                              <1> 	jz	page_read_pointer
   822                              <1> 	mov	cl, al
   823                              <1> 	shr	eax, 14
   824                              <1> 	jmp	read_pointer
   825                              <1> 
   826                              <1> page_read_pointer:
   827                              <1> 	rol	eax, 6
   828                              <1> 	mov	cl, al
   829                              <1> 	shr	eax, 20
   830                              <1> 
   831                              <1> read_pointer:
   832                              <1> 	mov	edi, esi	; edi -> core.REGISTER 
   833                              <1>         mov	esi, eax
   834                              <1> 	and	cl, 63
   835                              <1> 	jz	direct_pointer	; there is no alternate to B0
   836                              <1> 				; ROM constant reads clear from here
   837                              <1> 	test	cl, 56
   838                              <1> 	jnz	direct_pointer	; shift radix 8-1 might get slipped
   839                              <1> 				; high memory writes clear from here
   840                              <1> 	mov	eax, dword ptr [edi+PSR]		; now read out _psr
   841                              <1> 
   842                              <1> alternate_pointer?:		; only base_write_pointer may jump to here
   843                              <1> 	shl	ah, cl		; so long as radix 31 applies to 8-bit shifts
   844                              <1> 	shr	ah, 1		; any base-tag > 7 delivers zero
   845                              <1> 	and	ah, 64
   846                              <1> 	or	cl, ah
   847                              <1> 
   848                              <1> ;	esi -> core
   849                              <1> 
   850                              <1> direct_pointer:
   851                              <1> 	movzx	eax, cl		; deliver storage block name
   852                              <1> 	mov	eax, dword ptr [edi+eax*4+IO_PORT]
   853                              <1> 	ror	ecx, 16		; restore designator
   854                              <1> 
   855                              <1> 	ret
   856                              <1> 
   857                              <1> base_write_pointer:
   858                              <1> 
   859                              <1> 	mov	edi, eax	; set aside EA for split write operations
   860                              <1> 
   861                              <1> 	ror	ecx, 16		; save designator
   862                              <1> 	ror	eax, 18
   863                              <1> 	test	al, 63
   864                              <1> 	jz	page_write_pointer
   865                              <1> 	mov	cl, al
   866                              <1> 	shr	eax, 14
   867                              <1> 	jmp	write_pointer
   868                              <1> 
   869                              <1> page_write_pointer:
   870                              <1> 	rol	eax, 6
   871                              <1> 	mov	cl, al
   872                              <1> 	shr	eax, 20
   873                              <1> 
   874                              <1> write_pointer:
   875                              <1> 	mov	edi, esi	; edi -> core.REGISTER
   876                              <1> 	mov	esi, eax	; return word offset in storage block
   877                              <1> 
   878                              <1> 	and	cl, 63		; even if an ISR has reason to write its iframe
   879                              <1> 				; it can base it in a data window
   880                              <1> 	jz	NEAR guard_ii_authority	; so on attempted write in B0
   881                              <1> 				; application: thread gets withdrawn
   882                              <1> 				; ISR: forced to auto-restart the system
   883                              <1> 	test	cl, 56
   884                              <1> 	jnz	write_allowed	; shift radix 32-1 might get slipped
   885                              <1> 				; high memory operand writes clear from here
   886                              <1> 				; 386 shift radix on a byte is 7 anyway
   887                              <1> 
   888                              <1> 	mov	eax, dword ptr [edi+PSR]	; last of all read out the psr
   889                              <1> 	test	eax, 00800000h		; interrupt code?
   890                              <1> 	jnz	alternate_pointer?	; ISRs write anything
   891                              <1> 					; unless it isn't there
   892                              <1> 
   893                              <1> 	mov	al, ah		; gate windows [ 0 2 TCB kernel ]
   894                              <1> 	or	al, 128+32	; applications may not write them
   895                              <1> 	shl	al, cl
   896                              <1> 
   897                              <1> 	jns	write_allowed
   898                              <1> 
   899                              <1> 	jmp	guard_ii_authority	; not allowed
   900                              <1> 
   901                              <1> write_allowed:
   902                              <1> 	movzx	eax, cl		; return storage block name
   903                              <1> 	mov	eax, dword ptr [edi+eax*4+IO_PORT]
   904                              <1> 
   905                              <1> 	ror	ecx, 16		; restore designator
   906                              <1> 
   907                              <1> 	ret
   908                              <1> 
   909                              <1> 	%endif
   910                              <1> 
   911                              <1> ;	sub-architectural measure on sabr and reload instructions
   912                              <1> 
   913                              <1> ;	check the target memory block is in range and the bus characteristic
   914                              <1> ;	of the memory device when selecting blocks of memory, not when
   915                              <1> ;	accessing them. Use 8 spare bits in the word containing _base[]
   916                              <1> ;	for a quick recall of the emulated bus attribute on reference
   917                              <1> 
   918                              <1> ;	because this software emulation needs to act differently for
   919                              <1> 
   920                              <1> ;		executable space	rta1 24-bit words canonical memory
   921                              <1> ;					modeled in platform 32-bit words
   922                              <1> 
   923                              <1> ;		shared network buffers	16-bit words canonical in memory
   924                              <1> ;					and zero extend on readout to RTA1
   925                              <1> 
   926                              <1> ;		24-bit filestore array	3-octet words stored big-endian
   927                              <1> ;					in packed array
   928                              <1> 
   929                              <1> ;	concept RTA1 device arrays with bus behaviour differences are completely
   930                              <1> ;	emulated on PC emulations because device arrays are modeled in PC RAM.
   931                              <1> 
   932                              <1> ;	Various bus behaviours are emulated transparently to RTA1 target software
   933                              <1> ;	in anticipation	that different memories for different uses may be attached
   934                              <1> ;	on product boards, making core-emulated RTA1s much more efficient for not
   935                              <1> ;	needing this part of emulation
   936                              <1> 
   937                              <1> ;	devices
   938                              <1> 
   939                              <1> ;	device 0 is always executable space, but there may be more devices
   940                              <1> ;	with bus characteristics like device 0. The device descriptors are
   941                              <1> 
   942                              <1> ;		_________________________________________________________________
   943                              <1> ;		| 16 bits flags	| 16 bits banks	|       32 bits pointer		|
   944                              <1> ;		|_______________|____high index_|_______________________________|
   945                              <1> 
   946                              <1> 
   947                              <1> ;	[out]	sabr	[go]	[call]	reload instructions call here
   948                              <1> ;	go and call can probably check quicker themself
   949                              <1> ;	out can be trusted because applications don't out memory _base[] ports
   950                              <1> 
   951                              <1> ;	a big block in an RTA1 address window is 262144 words.
   952                              <1> ;	this checking concerns address windows tagged 2..63
   953                              <1> ;	a device is an array up to 65536 big blocks or banks
   954                              <1> 
   955                              <1> ;	you get here with the relocation handle in ebx
   956                              <1> ;	and the target window tag in eax, because that is the EA of a sabr instruction
   957                              <1> 
   958                              <1> device_read:				; readout device arrays
   959 00000838 A900008000          <1>         test    eax, 0800000h           ; the vilainous bank index?
   960 0000083D 753A                <1>         jnz     device_read_escape
   961                              <1> 
   962                              <1> 	%if	1
   963                              <1> 					; edi -> core.REGISTER
   964 0000083F C1E002              <1> 	shl	eax, 2			; al is device index * 4
   965 00000842 50                  <1> 	push	eax			; rest of eax is block index * 4
   966 00000843 0FB6C0              <1> 	movzx	eax, al			; extend device number
   967                              <1> 					; sense device descriptor
   968                              <1> 
   969 00000846 8BBD60020000        <1> 	mov	edi, dword ptr [ebp+CORE_INDEX1]
   970 0000084C F68438CE060000C0    <1> 	test	byte ptr [edi+eax+IO_PORT+128*4+2], 192
   971                              <1> 
   972 00000854 58                  <1> 	pop	eax			; recover storage block index
   973                              <1> 
   974 00000855 7422                <1> 	jz	device_read_escape	; neither type flag set
   975                              <1> 
   976 00000857 9C                  <1> 	pushfd				; sign is set for descriptor bit 23	
   977                              <1> 					; parity is set if both bits are
   978                              <1> 
   979 00000858 8AAF9C040000        <1> 	mov	ch, byte ptr [edi+PSR]	; flag field with byte options for memory read
   980 0000085E 0FB6F8              <1> 	movzx	edi, al			; device select
   981                              <1> 
   982 00000861 30C0                <1> 	xor	al, al			; add storage block to offset
   983 00000863 C1E00A              <1> 	shl	eax, 10			; block index * 64 * 4 now times 262144
   984 00000866 01C6                <1> 	add	esi, eax		; offset += <-
   985                              <1> 
   986 00000868 8BBF[00000000]      <1> 	mov	edi,  dword ptr [_devices+edi]
   987                              <1> 
   988                              <1> 					; known that one or two bits is set
   989 0000086E 58                  <1> 	pop	eax			; flags from test of device	
   990                              <1> 
   991 0000086F A804                <1> 	test	al, 4			; parity?
   992 00000871 755C                <1> 	jnz	device_read_array24	; parity -> 2 bits set -> FSYS24 bus
   993                              <1> 
   994 00000873 A880                <1> 	test	al, 128			; sign -> descriptor bit 23 -> SYSMEM
   995 00000875 7411                <1> 	jz	device_read_data16	; otherwise NET16 trunk
   996 00000877 EB0A                <1> 	jmp	device_read_sysmem	; system memory type if yes				
   997                              <1> 
   998                              <1> 	%else
   999                              <1> 
  1000                              <1> 	shl	eax, 2			;  al = device pointer * 4
  1001                              <1> 	movzx	edi, al			; edi = device pointer * 4
  1002                              <1> 	xor	al, al			; eax = memory block * 256
  1003                              <1> 	shl	eax, 10			; eax = memory block * 262144
  1004                              <1> 	add	esi, eax		; offset += base
  1005                              <1> 	mov	eax, edi
  1006                              <1> 	mov	edi, dword ptr [_devices+eax] ; physical array storage
  1007                              <1> 
  1008                              <1> 
  1009                              <1> _device_read_xpanded:
  1010                              <1> 	mov	eax, dword ptr [esi+IO_PORT+128*4]	; ????? eax
  1011                              <1> 
  1012                              <1> 	shr	eax, 22			; following conditions use parity
  1013                              <1> 					; parity only generated from LS octet
  1014                              <1> 					; how dumb can you get?
  1015                              <1> 
  1016                              <1> 	and	al, 3			; what sort of device array?
  1017                              <1> 
  1018                              <1> 	jz	device_read_escape	; that's double-checked option 00
  1019                              <1> 	jpe	device_read_array24	; and option 11 shorten
  1020                              <1> 	test	al, SYSMEM_FLAG>>22
  1021                              <1> 	jz	device_read_data16	; and option 01
  1022                              <1> 	jmp	device_read_sysmem	; and option 10
  1023                              <1> 	%endif
  1024                              <1> 	
  1025                              <1> device_read_escape:
  1026 00000879 B90E000000          <1> 	mov	ecx, LP_ADDRESS
  1027 0000087E E995060000          <1> 	jmp	guard_ii_escape
  1028                              <1> 
  1029                              <1> 
  1030                              <1> device_read_sysmem:			; readout system memory array
  1031 00000883 E934FBFFFF          <1> 	jmp	memory_read_on		; allow all variations partial word / multiword
  1032                              <1> 
  1033                              <1> device_read_data16:			; readout 16-bit array
  1034                              <1> 
  1035 00000888 80F907              <1> 	cmp	cl, 7
  1036 0000088B 741A                <1> 	jz	device_read_data16_4
  1037 0000088D 80F906              <1> 	cmp	cl, 6
  1038 00000890 7409                <1> 	jz	device_read_data16_2
  1039 00000892 EB00                <1> 	jmp	device_read_data16_1
  1040                              <1> 
  1041                              <1> device_read_data16_1:			; readout 1 word of 16-bit array
  1042 00000894 0FB70477            <1> 	movzx	eax, word ptr [edi+esi*2]
  1043 00000898 86E0                <1> 	xchg	ah, al
  1044 0000089A C3                  <1> 	ret
  1045                              <1> 
  1046                              <1> device_read_data16_2:			; readout 2 words of 16-bit array
  1047 0000089B 8B0477              <1> 	mov	eax, dword ptr [edi+esi*2]	; 4.3.2.1
  1048 0000089E 0FC8                <1> 	bswap	eax				; 1.2.3.4
  1049 000008A0 0FB7D8              <1> 	movzx	ebx, ax				; 0.0.3.4
  1050 000008A3 C1E810              <1> 	shr	eax, 16				; 0.0.1.2
  1051 000008A6 C3                  <1> 	ret
  1052                              <1> 
  1053                              <1> device_read_data16_4:			; readout 4 words of 16-bit array
  1054 000008A7 8B0477              <1> 	mov	eax, dword ptr [edi+esi*2]
  1055 000008AA 0FC8                <1> 	bswap	eax				; 1.2.3.4
  1056 000008AC 0FB7C8              <1> 	movzx	ecx, ax
  1057 000008AF C1E810              <1> 	shr	eax, 16
  1058 000008B2 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
  1059 000008B6 894C9D04            <1> 	mov	dword ptr [ebp+ebx*4+4], ecx
  1060                              <1> 
  1061 000008BA 8B447704            <1> 	mov     eax, dword ptr [edi+esi*2+4]
  1062 000008BE 0FC8                <1> 	bswap	eax				; 5.6.7.8
  1063 000008C0 0FB7C8              <1> 	movzx	ecx, ax
  1064 000008C3 C1E810              <1> 	shr	eax, 16
  1065 000008C6 89449D08            <1> 	mov	dword ptr [ebp+ebx*4+8], eax
  1066 000008CA 894C9D0C            <1> 	mov	dword ptr [ebp+ebx*4+12], ecx
  1067 000008CE C3                  <1> 	ret
  1068                              <1> 
  1069                              <1> device_read_array24:			; readout from packed 24-bit array
  1070 000008CF E83F010000          <1> 	call	device_array24_setpointer
  1071                              <1> 
  1072 000008D4 80F907              <1> 	cmp	cl, 7
  1073 000008D7 7440                <1> 	jz	device_read_array24_4
  1074 000008D9 80F906              <1> 	cmp	cl, 6
  1075 000008DC 7430                <1> 	jz	device_read_array24_2
  1076 000008DE EB00                <1> 	jmp	device_read_array24_1
  1077                              <1> 
  1078                              <1> device_read_array24_1:			; readout a word of packed 24-bit array
  1079 000008E0 660FB60437          <1> 	movzx	ax, byte ptr [edi+esi]
  1080 000008E5 C1E008              <1> 	shl	eax, 8
  1081 000008E8 8A443701            <1> 	mov	al, byte ptr [edi+esi+1]
  1082 000008EC C1E008              <1> 	shl	eax, 8
  1083 000008EF 8A443702            <1> 	mov	al, byte ptr [edi+esi+2]
  1084 000008F3 83C603              <1> 	add	esi, 3
  1085 000008F6 C3                  <1> 	ret
  1086                              <1> 
  1087                              <1> device_read_array24_1R:
  1088 000008F7 660FB61C37          <1> 	movzx	bx, byte ptr [edi+esi]
  1089 000008FC C1E308              <1> 	shl	ebx, 8
  1090 000008FF 8A5C3701            <1> 	mov	bl, byte ptr [edi+esi+1]
  1091 00000903 C1E308              <1> 	shl	ebx, 8
  1092 00000906 8A5C3702            <1> 	mov	bl, byte ptr [edi+esi+2]
  1093 0000090A 83C603              <1> 	add	esi, 3
  1094 0000090D C3                  <1> 	ret
  1095                              <1> 
  1096                              <1> device_read_array24_2:			; readout 2 words of packed 24-bit array
  1097 0000090E E8CDFFFFFF          <1> 	call	device_read_array24_1
  1098 00000913 E8DFFFFFFF          <1> 	call	device_read_array24_1R
  1099 00000918 C3                  <1> 	ret
  1100                              <1> 
  1101                              <1> device_read_array24_4:			; readout 4 words of packed 24-bit array
  1102 00000919 E8C2FFFFFF          <1> 	call	device_read_array24_1
  1103 0000091E 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
  1104 00000922 E8B9FFFFFF          <1> 	call	device_read_array24_1
  1105 00000927 89449D04            <1> 	mov	dword ptr [ebp+ebx*4+4], eax
  1106 0000092B E8B0FFFFFF          <1> 	call	device_read_array24_1
  1107 00000930 89449D08            <1> 	mov	dword ptr [ebp+ebx*4+8], eax
  1108 00000934 E8A7FFFFFF          <1> 	call	device_read_array24_1
  1109 00000939 89449D0C            <1> 	mov	dword ptr [ebp+ebx*4+12], eax
  1110 0000093D C3                  <1> 	ret
  1111                              <1> 
  1112                              <1> _device_write:				; store device arrays
  1113 0000093E A900008000          <1> 	test	eax, 0800000h		; the vilainous bank index?
  1114 00000943 753A                <1> 	jnz	device_write_escape
  1115                              <1> 
  1116                              <1> 	%if	1
  1117                              <1>                                         ; edi -> core.REGISTER
  1118 00000945 C1E002              <1>         shl     eax, 2                  ; al is device index * 4
  1119 00000948 50                  <1>         push    eax                     ; rest of eax is block index * 4
  1120 00000949 0FB6C0              <1>         movzx   eax, al                 ; extend device number
  1121                              <1>                                         ; sense device descriptor
  1122                              <1> 
  1123 0000094C 8BBD60020000        <1> 	mov	edi, dword ptr [ebp+CORE_INDEX1]
  1124 00000952 F68438CE060000C0    <1>         test    byte ptr [edi+eax+IO_PORT+128*4+2], 192
  1125                              <1> 
  1126 0000095A 58                  <1>         pop     eax                     ; recover storage block index
  1127                              <1> 
  1128 0000095B 7422                <1>         jz      device_write_escape      ; neither type flag set
  1129                              <1> 
  1130 0000095D 9C                  <1>         pushfd                          ; sign is set for descriptor bit 23     
  1131                              <1>                                         ; parity is set if both bits are
  1132                              <1> 
  1133 0000095E 8AAF9C040000        <1>         mov     ch, byte ptr [edi+PSR]  ; flag field with byte options for memory read
  1134 00000964 0FB6F8              <1>         movzx   edi, al                 ; device select
  1135                              <1> 
  1136 00000967 30C0                <1>         xor     al, al                  ; add storage block to offset
  1137 00000969 C1E00A              <1>         shl     eax, 10                 ; block index * 64 * 4 now times 262144
  1138 0000096C 01C6                <1>         add     esi, eax                ; offset += <-
  1139                              <1> 
  1140 0000096E 8BBF[00000000]      <1>         mov     edi,  dword ptr [_devices+edi]
  1141                              <1> 
  1142                              <1>                                         ; known that one or two bits is set
  1143 00000974 58                  <1>         pop     eax                     ; flags from test of device     
  1144                              <1> 
  1145 00000975 A804                <1>         test    al, 4                   ; parity?
  1146 00000977 754E                <1>         jnz     device_write_array24    ; parity -> 2 bits set -> FSYS24 bus
  1147 00000979 A880                <1>         test    al, 128                 ; sign -> descriptor bit 23 -> SYSMEM
  1148 0000097B 7411                <1>         jz      device_write_data16     ; otherwise NET16 trunk
  1149 0000097D EB0A                <1>         jmp     device_write_sysmem     ; system memory type if yes                     
  1150                              <1> 
  1151                              <1> 	%else
  1152                              <1> 
  1153                              <1> 	shl	eax, 2			;  al = device ID * 4
  1154                              <1> 	movzx	edi, al			; edi = device ID * 4
  1155                              <1> 	xor	al, al			; eax = 256 * block pointer
  1156                              <1> 	shl	eax, 10			; block pointer *= 262144
  1157                              <1> 	add	esi, eax
  1158                              <1> 	mov	eax, edi
  1159                              <1> 	mov	edi, dword ptr [eax+_devices]	; physical buffer device array
  1160                              <1> 	mov	eax, dword ptr [esi+IO_PORT+128*4] ; descriptor port of device
  1161                              <1> 
  1162                              <1> 	shr	eax, 22			; following conditions use parity
  1163                              <1> 					; which is only generated from LS octet
  1164                              <1> 
  1165                              <1> 	and	al, 3			; isolate the device type
  1166                              <1> 	jz	device_write_escape
  1167                              <1> 	jpe	device_write_array24
  1168                              <1> 	test	al, SYSMEM_FLAG>>22
  1169                              <1> 	jz	device_write_data16
  1170                              <1> 	jmp	device_write_sysmem
  1171                              <1> 
  1172                              <1> 	%endif
  1173                              <1> 
  1174                              <1> device_write_escape:
  1175 0000097F B90E000000          <1> 	mov	ecx, LP_ADDRESS
  1176 00000984 E98F050000          <1> 	jmp	guard_ii_escape
  1177                              <1> 
  1178                              <1> 
  1179                              <1> device_write_sysmem:
  1180 00000989 E9E3FBFFFF          <1> 	jmp	memory_write_on		; allow all variations partial word / multiword
  1181                              <1> 
  1182                              <1> device_write_data16:
  1183                              <1> 
  1184 0000098E 80F907              <1> 	cmp	cl, 7
  1185 00000991 740E                <1> 	jz	device_write_data16_4
  1186 00000993 80F906              <1> 	cmp	cl, 6
  1187 00000996 741C                <1> 	jz	device_write_data16_2
  1188 00000998 EB00                <1> 	jmp	device_write_data16_1
  1189                              <1> 
  1190                              <1> device_write_data16_1:			; store 16-bit array
  1191 0000099A 86FB                <1> 	xchg	bh, bl
  1192 0000099C 66891C77            <1> 	mov	word ptr [edi+esi*2], bx
  1193 000009A0 C3                  <1> 	ret
  1194                              <1> 
  1195                              <1> 
  1196                              <1> device_write_data16_4:			; store 4 words in 16-bit array
  1197                              <1> 					; low-order half is swapped on bus read
  1198                              <1> 					; and canonical in eax
  1199 000009A1 668B449D08          <1> 	mov	ax, word ptr [ebp+ebx*4+8]	; get low-order half 3rd register
  1200 000009A6 C1E010              <1> 	shl	eax, 16				; 5.6.0.0
  1201 000009A9 668B449D0C          <1> 	mov	ax, word ptr [ebp+ebx*4+12]	; 5.6.7.8
  1202 000009AE 0FC8                <1> 	bswap	eax				; it's correct so swap for bus write
  1203 000009B0 89447704            <1> 	mov	dword ptr [edi+esi*2+4], eax
  1204                              <1> 
  1205                              <1> 
  1206                              <1> device_write_data16_2:			; store 2 words in 16-bit array
  1207                              <1> 					; registers are modeled in storage
  1208                              <1> 					; so each bus read corrects an octet pair
  1209                              <1> 
  1210 000009B4 668B449D00          <1> 	mov	ax, word ptr [ebp+ebx*4]	; get low-order half 1st register
  1211 000009B9 C1E010              <1> 	shl	eax, 16				; 1.2.0.0
  1212 000009BC 668B449D04          <1> 	mov	ax, word ptr [ebp+ebx*4+4]	; 1.2.3.4
  1213 000009C1 0FC8                <1> 	bswap	eax				; it's correct, so swap for bus write
  1214 000009C3 890477              <1> 	mov	dword ptr [edi+esi*2], eax
  1215 000009C6 C3                  <1> 	ret
  1216                              <1> 
  1217                              <1> device_write_array24:			; store 24-bit packed array
  1218 000009C7 E847000000          <1> 	call	device_array24_setpointer
  1219                              <1> 
  1220 000009CC 80F907              <1> 	cmp	cl, 7
  1221 000009CF 7434                <1> 	jz	device_write_array24_4
  1222 000009D1 80F906              <1> 	cmp	cl, 6
  1223 000009D4 741C                <1> 	jz	device_write_array24_2
  1224 000009D6 EB00                <1> 	jmp	device_write_array24_1
  1225                              <1> 
  1226                              <1> device_write_array24_1:			; store 1 word in packed 24-bit array
  1227 000009D8 89D8                <1> 	mov	eax, ebx
  1228                              <1> device_write_array24_x:
  1229 000009DA C1C010              <1> 	rol	eax, 16
  1230 000009DD 880437              <1> 	mov	byte ptr [edi+esi], al
  1231 000009E0 C1C008              <1> 	rol	eax, 8
  1232 000009E3 88443701            <1> 	mov	byte ptr [edi+esi+1], al
  1233 000009E7 C1C008              <1> 	rol	eax, 8
  1234 000009EA 88443702            <1> 	mov	byte ptr [edi+esi+2], al
  1235 000009EE 83C603              <1> 	add	esi, 3
  1236 000009F1 C3                  <1> 	ret
  1237                              <1> 
  1238                              <1> device_write_array24_2:			; store 2 words in packed 24-bit array
  1239 000009F2 8B449D00            <1> 	mov	eax, [ebp+ebx*4]
  1240 000009F6 E8DFFFFFFF          <1> 	call	device_write_array24_x
  1241 000009FB 8B449D04            <1> 	mov	eax, [ebp+ebx*4+4]
  1242 000009FF E8D6FFFFFF          <1> 	call	device_write_array24_x
  1243                              <1> ;	add	ebx, 2
  1244 00000A04 C3                  <1> 	ret
  1245                              <1> 
  1246                              <1> device_write_array24_4:			; store 4 words in packed 24-bit array
  1247 00000A05 E8E8FFFFFF          <1> 	call	device_write_array24_2
  1248 00000A0A 83C302              <1> 	add	ebx, 2
  1249 00000A0D E8E0FFFFFF          <1> 	call	device_write_array24_2
  1250 00000A12 C3                  <1> 	ret
  1251                              <1> 
  1252                              <1> device_array24_setpointer:
  1253 00000A13 89F0                <1> 	mov	eax, esi			; think of a number
  1254 00000A15 D1E0                <1> 	shl	eax, 1				; double it
  1255 00000A17 01C6                <1> 	add	esi, eax			; add it to the number you first thought of...
  1256 00000A19 C3                  <1> 	ret
  1257                              <1> 
    31                                  	%include	"sr.msm"
     1                              <1> 
     2                              <1> ;	read staging register
     3                              <1> ;	read bits from a stream of bits
     4                              <1> 
     5 00000A1A 8B4E50              <1> _rsr:	mov	ecx, dword ptr [esi+RDATAC]
     6 00000A1D 88CD                <1> 	mov	ch, cl
     7 00000A1F 88C1                <1> 	mov	cl, al
     8                              <1> 
     9 00000A21 31C0                <1> 	xor	eax, eax
    10 00000A23 F7869C040000400000- <1> 	test	dword ptr [esi+PSR], B_STREAMZR
    10 00000A2C 00                  <1>
    11 00000A2D 7503                <1> 	jnz	_rsr_zadd
    12 00000A2F 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
    13                              <1> _rsr_zadd:
    14 00000A32 20C9                <1> 	and	cl, cl
    15 00000A34 7453                <1> 	jz	_rsr_x
    16 00000A36 8B5E54              <1> 	mov	ebx, dword ptr [esi+RDATA]
    17                              <1> 
    18 00000A39 20ED                <1> 	and	ch, ch			; any data loaded yet?
    19 00000A3B 740F                <1> 	jz	_rsr_read		; if not read first no question 
    20 00000A3D 38CD                <1> 	cmp	ch, cl			; otherwise, already enough for request?
    21 00000A3F 7333                <1> 	jnb	_rsr_draw		; if so deliver data
    22 00000A41 28E9                <1> 	sub	cl, ch			; if not trim the oustanding count
    23 00000A43 86CD                <1> 	xchg	cl, ch			
    24 00000A45 E8200F0000          <1> 	call	dsl			; and deliver available data
    25 00000A4A 86E9                <1> 	xchg	ch, cl			; before reading some more
    26                              <1> _rsr_read:
    27 00000A4C E89A000000          <1> 	call	stream_read
    28 00000A51 8BB560020000        <1> 	mov	esi, dword ptr [ebp+CORE_INDEX1]	; after call to operand_read
    29 00000A57 C7465018000000      <1> 	mov	dword ptr [esi+RDATAC], 24
    30 00000A5E F7869C040000200000- <1> 	test	dword ptr [esi+PSR], B_STREAM16R
    30 00000A67 00                  <1>
    31 00000A68 740A                <1> 	jz	_rsr_draw
    32 00000A6A C7465010000000      <1> 	mov	dword ptr [esi+RDATAC], 16
    33 00000A71 C1E308              <1> 	shl	ebx, 8
    34                              <1> _rsr_draw:
    35 00000A74 6651                <1> 	push	cx
    36 00000A76 E8EF0E0000          <1> 	call	dsl
    37 00000A7B 6659                <1> 	pop	cx
    38 00000A7D 81E1FF000000        <1> 	and	ecx, 255
    39 00000A83 294E50              <1> 	sub	dword ptr [esi+RDATAC], ecx
    40 00000A86 895E54              <1> 	mov	dword ptr [esi+RDATA], ebx
    41                              <1> _rsr_x:
    42 00000A89 894510              <1> 	mov	dword ptr [ebp+A], eax
    43 00000A8C C3                  <1> 	ret
    44                              <1> 
    45                              <1> 
    46                              <1> ;	write staging register
    47                              <1> ;	write bits to a stream of bits
    48                              <1> 
    49 00000A8D 8B4E58              <1> _wsr:	mov	ecx, dword ptr [esi+WDATAC]
    50 00000A90 88CD                <1> 	mov	ch, cl					; accumulated count
    51 00000A92 88C1                <1> 	mov	cl, al					; new request
    52                              <1> 
    53 00000A94 8B465C              <1> 	mov	eax, dword ptr [esi+WDATA]	; accumulated data
    54 00000A97 8B5D10              <1> 	mov	ebx, dword ptr [ebp+A]		; source new data
    55                              <1> 
    56 00000A9A 80C5E8              <1> 	add	ch, -24				; space for new data expressed negative
    57 00000A9D F7869C040000100000- <1> 	test	dword ptr [esi+PSR], B_STREAM16W	; 16 bits / word flag
    57 00000AA6 00                  <1>
    58 00000AA7 7403                <1> 	jz	_wsr24
    59 00000AA9 80C508              <1> 	add	ch, 8
    60                              <1> 
    61 00000AAC 00CD                <1> _wsr24:	add	ch, cl			; increment towards zero
    62 00000AAE 7404                <1> 	jz	_wsr_write		; accumulated word exactly full
    63 00000AB0 7320                <1> 	jnc	_wsr_add		; not yet full
    64                              <1> 
    65 00000AB2 28E9                <1> 	sub	cl, ch			; full + some more
    66                              <1> 
    67                              <1> _wsr_write:
    68 00000AB4 E8B10E0000          <1> 	call	dsl			; fill output word
    69 00000AB9 88E9                <1> 	mov	cl, ch			; position outstanding count
    70 00000ABB E840000000          <1> 	call	stream_write
    71 00000AC0 8BB560020000        <1> 	mov	esi, dword ptr [ebp+CORE_INDEX1]	; after call to operand_write
    72 00000AC6 B800000000          <1> 	mov	eax, 0
    73 00000ACB C7465800000000      <1> 	mov	dword ptr [esi+REGISTER+WDATAC], 0
    74                              <1> 
    75                              <1> _wsr_add:
    76 00000AD2 6651                <1> 	push	cx
    77 00000AD4 E8910E0000          <1> 	call	dsl			; add to output word
    78 00000AD9 6659                <1> 	pop	cx
    79 00000ADB 81E1FF000000        <1> 	and	ecx, 255		; format ecx for add to accumulated count 
    80 00000AE1 014E58              <1> 	add	dword ptr [esi+REGISTER+WDATAC], ecx
    81 00000AE4 89465C              <1> 	mov	dword ptr [esi+REGISTER+WDATA], eax
    82 00000AE7 895D10              <1> 	mov	dword ptr [ebp+A], ebx
    83 00000AEA C3                  <1> 	ret
    84                              <1> 
    85                              <1> stream_read:
    86 00000AEB 51                  <1> 	push	ecx
    87 00000AEC 50                  <1> 	push	eax
    88 00000AED 8B4534              <1> 	mov	eax, dword ptr [ebp+Q]
    89 00000AF0 83453401            <1> 	add	dword ptr [ebp+Q], 1
    90 00000AF4 30C9                <1> 	xor	cl, cl
    91 00000AF6 E854F8FFFF          <1> 	call	_operand_read
    92 00000AFB 89C3                <1> 	mov	ebx, eax
    93 00000AFD 58                  <1> 	pop	eax
    94 00000AFE 59                  <1> 	pop	ecx
    95 00000AFF C3                  <1> 	ret
    96                              <1> 
    97                              <1> stream_write:
    98 00000B00 51                  <1> 	push	ecx
    99 00000B01 53                  <1> 	push	ebx
   100 00000B02 89C3                <1> 	mov	ebx, eax
   101 00000B04 8B4530              <1> 	mov	eax, dword ptr [ebp+P]
   102 00000B07 83453001            <1> 	add	dword ptr [ebp+P], 1
   103 00000B0B 30C9                <1> 	xor	cl, cl
   104 00000B0D E8D2F9FFFF          <1> 	call	_operand_write
   105 00000B12 5B                  <1> 	pop	ebx
   106 00000B13 59                  <1> 	pop	ecx
   107 00000B14 C3                  <1> 	ret
   108                              <1> 
    32                                  	%include	"io.msm"
     1 00000B15 8B9C86CC040000      <1> _inA:	mov	ebx, dword ptr [esi+IO_PORT+eax*4]
     2 00000B1C 895D10              <1> 	mov	dword ptr [ebp+A], ebx
     3 00000B1F C3                  <1> _inA_:	ret
     4                              <1> 
     5 00000B20 8B9C86CC040000      <1> _inB:	mov	ebx, dword ptr [esi+IO_PORT+eax*4]
     6 00000B27 895D14              <1> 	mov	dword ptr [ebp+B], ebx
     7 00000B2A C3                  <1> _inB_:	ret
     8                              <1> 
     9 00000B2B 8B5D10              <1> _outA:	mov	ebx, dword ptr [ebp+A]
    10 00000B2E E9A8010000          <1> 	jmp	oport
    11                              <1> 
    12 00000B33 8B5D14              <1> _outB:	mov	ebx, dword ptr [ebp+B]
    13 00000B36 E9A0010000          <1> 	jmp	oport
    14                              <1> 
    15                              <1> 
    16                              <1> ISR_ONLY equ	8
    17                              <1> MEMTYPE	equ	1
    18                              <1> MEMZERONLY equ	2
    19                              <1> EXTERNAL_IO equ	4
    20                              <1> BROADCAST equ	16
    21                              <1> 
    22                              <1> B_1	equ	MEMTYPE
    23                              <1> B_TCB	equ	MEMTYPE+ISR_ONLY
    24                              <1> B_KERN	equ	MEMTYPE+ISR_ONLY
    25                              <1> A_THREP	equ	MEMZERONLY+ISR_ONLY
    26                              <1> I_PORT	equ	EXTERNAL_IO
    27                              <1> O_PORT	equ	EXTERNAL_IO
    28                              <1> O_INDICA equ	EXTERNAL_IO
    29                              <1> O_CHILL	equ	EXTERNAL_IO
    30                              <1> I_TZONE	equ	EXTERNAL_IO
    31                              <1> RAM_THRESH equ	ISR_ONLY+MEMZERONLY
    32                              <1> XI_ACK	equ	ISR_ONLY+EXTERNAL_IO
    33                              <1> O_LEDS	equ	EXTERNAL_IO
    34                              <1> O_INC	equ	ISR_ONLY+EXTERNAL_IO
    35                              <1> O_MCAST	equ	ISR_ONLY+BROADCAST
    36                              <1> 
    37                              <1> 
    38                              <1> mask_port_outAB:
    39 00000B3B 000100000000000000- <1> 	db	0, B_1, 0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    39 00000B44 00000000000000      <1>
    40 00000B4B 000000000000000000- <1> 	db	    0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    40 00000B54 00000000000000      <1>
    41                              <1> 
    42 00000B5B 000000000000000000- <1> 	db	    0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    42 00000B64 00000000000000      <1>
    43 00000B6B 000000000000000000- <1> 	db	    0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    43 00000B74 00000000000000      <1>
    44                              <1> 
    45 00000B7B 0009090909090909    <1> 	db	0,  B_TCB,B_KERN,B_KERN,B_KERN,B_KERN,B_KERN,B_KERN
    46 00000B83 0A00000C0C000018    <1> 	db	A_THREP, 0, 0, XI_ACK,  O_INC, 0,0, O_MCAST
    47                              <1> 
    48 00000B8B 0404040404040404    <1> 	db	I_PORT,I_PORT,I_PORT,I_PORT,I_PORT,I_PORT,I_PORT,I_PORT
    49 00000B93 0404040404040404    <1> 	db	O_PORT,O_PORT,O_PORT,O_PORT,O_PORT,O_PORT,O_PORT,O_PORT
    50                              <1> 
    51 00000B9B 0000000000040404    <1> 	db	0,0,0,0, 0, I_TZONE, O_INDICA, O_CHILL
    52 00000BA3 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  RAM_THRESH, 0,0, O_LEDS
    52 00000BAC 0000000A000004      <1>
    53                              <1> 
    54 00000BB3 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    54 00000BBC 00000000000000      <1>
    55 00000BC3 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    55 00000BCC 00000000000000      <1>
    56 00000BD3 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    56 00000BDC 00000000000000      <1>
    57 00000BE3 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    57 00000BEC 00000000000000      <1>
    58                              <1> 
    59                              <1> 					; outA|B rules flags per I/O port
    60                              <1> 
    61                              <1> _reload:
    62 00000BF3 50                  <1> 	push	eax
    63 00000BF4 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
    64 00000BF7 83451002            <1> 	add	dword ptr [ebp+A], 2
    65 00000BFB E80DF7FFFF          <1> 	call	_burst_read2
    66 00000C00 5F                  <1> 	pop	edi
    67 00000C01 8984BECC040000      <1> 	mov	dword ptr [esi+IO_PORT+edi*4], eax
    68 00000C08 899CBED0040000      <1> 	mov	dword ptr [esi+IO_PORT+edi*4+4], ebx
    69 00000C0F C3                  <1> 	ret
    70                              <1> 
    71 00000C10 C3                  <1> _emulator_cool: ret
    72                              <1> 
    73                              <1> ;	sabr checks what it places in operand space windows
    74                              <1> ;	there are no subsequent range checks on reference
    75                              <1> 
    76                              <1> 	%if	1
    77                              <1> 	%include	"sabr.msm"
     1                              <2> ;	check and write to I/O port <- storage base index in range [ 2..63 ]
     2                              <2> ;	write a copy to reload base table in thread control block
     3                              <2> ;	values out of memory range are replaced with trap device C00001
     4                              <2> ;	which causes GUARD$ exception if the sindow is accessed
     5                              <2> 
     6                              <2> ;	anauthorised actions
     7                              <2> ;
     8                              <2> ;		attempt to write window base < 2 or > 63
     9                              <2> ;		application selecting ISR space
    10                              <2> ;		application selecting NVRAM
    11                              <2> ;
    12                              <2> ;	are not carried out and a GUARD$ exception is raised
    13                              <2> ;	ISRs write the trap device C00001 to close memory windows
    14                              <2> 
    15                              <2> _sabr_guard:
    16 00000C11 E9FD020000          <2> 	jmp	guard_ii_authority
    17                              <2> 
    18 00000C16 A93E000000          <2> _sabr:	test	eax, 03Eh		; ea not < 2
    19 00000C1B 74F4                <2> 	jz	_sabr_guard
    20 00000C1D A9C0FFFF00          <2> 	test	eax, 0FFFFC0h		; ea not > 63
    21 00000C22 75ED                <2> 	jnz	_sabr_guard
    22                              <2> 
    23 00000C24 8B4D10              <2> 	mov	ecx, dword ptr [ebp+A]
    24                              <2> 
    25 00000C27 F7C100004000        <2> 	test	ecx, 00400000h
    26 00000C2D 7463                <2> 	jz	memory_page
    27 00000C2F F7C13F000000        <2> 	test	ecx, 63
    28 00000C35 7455                <2> 	jz	large_memory_page
    29                              <2> 
    30 00000C37 F7C100008000        <2> 	test	ecx, 00800000h
    31 00000C3D 740B                <2> 	jz	array_attribute
    32                              <2> 
    33 00000C3F F6869E04000080      <2> 	test	byte ptr [esi+PSR+2], 128
    34 00000C46 74C9                <2> 	jz	_sabr_guard
    35 00000C48 EB70                <2> 	jmp	unthru			; ISR write illegal device thru
    36                              <2> 					; closes the address space window
    37                              <2> 
    38                              <2> 					; application may not write device
    39                              <2> 					; but may zero -> sabr  with same effect
    40                              <2> array_attribute:
    41                              <2> 
    42 00000C4A C1E102              <2> 	shl	ecx, 2
    43 00000C4D 0FB6D9              <2> 	movzx	ebx, cl			; cl = device * 4
    44                              <2> 
    45                              <2> 	%if	0
    46                              <2> 	mov	edi, dword ptr [_devices+ebx]
    47                              <2> 	%endif
    48                              <2> 
    49 00000C50 8B9C33CC060000      <2> 	mov	ebx, dword ptr [esi+ebx+IO_PORT+128*4]
    50                              <2> 					; platform address + device descriptor
    51                              <2> 
    52                              <2> 
    53                              <2> 	%if	0
    54                              <2> 	mov	dword ptr [esi+eax*8+DATAFRAME], ebx	; rapid recall
    55                              <2> 	mov	dword ptr [esi+eax*8+DATAFRAME+4], edi	; device information
    56                              <2> 	%endif						; via window tag
    57                              <2> 
    58 00000C57 C1E908              <2> 	shr	ecx, 6+2		; lose previous shift + device code
    59 00000C5A F7C300004000        <2> 	test	ebx, 00400000h
    60 00000C60 750A                <2> 	jnz	peripheral_array
    61 00000C62 F7C300008000        <2> 	test	ebx, 00800000h
    62 00000C68 751D                <2> 	jnz	memory_array
    63                              <2> 
    64 00000C6A EBA5                <2> 	jmp	_sabr_guard		; no device code
    65                              <2> 
    66                              <2> peripheral_array:			; device types 00C00000 00400000
    67 00000C6C F6869E04000080      <2> 	test	byte ptr [esi+PSR+2], 128
    68 00000C73 749C                <2> 	jz	_sabr_guard
    69                              <2> 
    70 00000C75 81E1FFFF0000        <2> 	and	ecx, 0000FFFFh		; have # large blocks in low 16 bits
    71 00000C7B 81E3FFFF0000        <2> 	and	ebx, 0000FFFFh
    72 00000C81 29CB                <2> 	sub	ebx, ecx
    73 00000C83 7932                <2> 	jns	thru
    74 00000C85 EB29                <2> 	jmp	_sabr_safeguard
    75                              <2> 
    76                              <2> memory_array:
    77 00000C87 C1E106              <2> 	shl	ecx, 6			; block * 64
    78 00000C8A EB14                <2> 	jmp	memory_array_bound?
    79                              <2> 
    80                              <2> large_memory_page:
    81 00000C8C 81E1FFFFBF00        <2> 	and	ecx, 00BFFFFFh		; remove 00400000 bit for lower bound check
    82                              <2> 
    83                              <2> memory_page:
    84 00000C92 8B9ECC060000        <2> 	mov	ebx, dword ptr [esi+IO_PORT+128*4]	; device zero memory attribute
    85 00000C98 3B8EEC050000        <2> 	cmp	ecx, dword ptr [esi+IO_PORT+72*4]	; ISR / application boundary
    86 00000C9E 7210                <2> 	jb	_sabr_safeguard
    87                              <2> 
    88                              <2> memory_array_bound?:
    89 00000CA0 81E1FFFFBF00        <2> 	and	ecx, 00BFFFFFh		; bit 00800000 is a bad accident
    90 00000CA6 81E3FFFF3F00        <2> 	and	ebx, 003FFFFFh		; stop it here
    91 00000CAC 29CB                <2> 	sub	ebx, ecx
    92 00000CAE 7907                <2> 	jns	thru
    93                              <2> 
    94                              <2> _sabr_safeguard:
    95 00000CB0 B90100C000          <2> 	mov	ecx, 00C00001h
    96 00000CB5 EB03                <2> 	jmp	unthru
    97                              <2> 
    98 00000CB7 8B4D10              <2> thru:	mov	ecx, dword ptr [ebp+A]		; i.e. correct as supplied
    99 00000CBA 898C86CC040000      <2> unthru:	mov	dword ptr [esi+eax*4+IO_PORT], ecx
   100                              <2> 
   101 00000CC1 BF[00000000]        <2> 	mov	edi, _memory
   102 00000CC6 8B9ED0050000        <2> 	mov	ebx, dword ptr [esi+IO_PORT+65*4] ; thread control block
   103                              <2> 
   104 00000CCC C1E30C              <2> 	shl	ebx, 12			; multiply to TCB size
   105 00000CCF 01C3                <2> 	add	ebx, eax		; ea is target base index
   106 00000CD1 0FC9                <2> 	bswap	ecx			; for this is a big endian memory write
   107 00000CD3 898C9F00010000      <2> 	mov	dword ptr [edi+ebx*4+64*4], ecx
   108 00000CDA C3                  <2> 	ret				; save TCB reload copy of loaded pointer
    78                              <1> 
    79                              <1> 	%else
    80                              <1> 
    81                              <1> _sabr:	test	eax, 0000003Eh			; target window must be 2..63
    82                              <1> 	jz	_sabr_reserved
    83                              <1> 	test	eax, 00FFFFC0h
    84                              <1> 	jnz	_sabr_reserved
    85                              <1> 						; ea in range 2..63
    86                              <1> 	mov	ebx, dword ptr [ebp+A]		; read page index
    87                              <1> 	test	ebx, 00400000h
    88                              <1> 	jz	_sabr_executable_space		; 4K page 
    89                              <1> 	test	ebx, 63
    90                              <1> 	jz	_sabr_executable_space		; 256k page in system memory
    91                              <1> 						; otherwise a device
    92                              <1> 
    93                              <1> 	test	ebx, 00800000h			; a non-access device?
    94                              <1> 	jz	_sabr_access_device		; nor a trap device
    95                              <1> 						; a non-access trap device
    96                              <1> 	test	byte ptr [esi+PSR+2], 128
    97                              <1> 	jz	_sabr_reserved			; applications may not
    98                              <1> 	jmp	_sabr_thru			; ISRs may
    99                              <1> 
   100                              <1> _sabr_access_device
   101                              <1> 	mov	cl, bl				; find peripheral array
   102                              <1> 	and	ecx, 63
   103                              <1> 	mov	ecx, dword ptr [esi+ecx*4+IO_PORT+128*4]
   104                              <1> 	test	ecx, 00400000h
   105                              <1> 	jz	_sabr_array_type?
   106                              <1> 	test	byte ptr [esi+PSR+2], 128	; this device is filestore or network trunk
   107                              <1> 	jnz	_sabr_authorised		; only ISRs can base it
   108                              <1> 
   109                              <1> _sabr_reserved:
   110                              <1> 	jmp	guard_ii_authority		
   111                              <1> 
   112                              <1> _sabr_authorised:
   113                              <1> 
   114                              <1> ;	shl	ecx, 6				; align peripheral array high index
   115                              <1> ;	jmp	_sabr_array_type		; for comparison
   116                              <1> 
   117                              <1> 	mov	edi, ebx
   118                              <1> 	shr	ebx, 6
   119                              <1> 	and	ebx, 65535
   120                              <1> 	and	ecx, 65535
   121                              <1> 	jmp	_sabr_range?
   122                              <1> 
   123                              <1> _sabr_array_type?:
   124                              <1> 	test	ecx, 00800000h
   125                              <1> 	jz	_sabr_notype
   126                              <1> 	jmp	_sabr_array_type
   127                              <1> 
   128                              <1> _sabr_executable_space:
   129                              <1> 	mov	ecx, dword ptr [esi+IO_PORT+128*4]
   130                              <1> 
   131                              <1> _sabr_array_type:
   132                              <1> 	and	ecx, 003FFFFFh			; is that page index in range?
   133                              <1> 	mov	edi, ebx
   134                              <1> 	and	ebx, 003FFFFFh
   135                              <1> 
   136                              <1> _sabr_range?
   137                              <1> 	sub	ecx, ebx
   138                              <1> ;	mov	dword ptr [_ultra], ecx
   139                              <1> 	jns	_sabr_thru
   140                              <1> 
   141                              <1> _sabr_notype:
   142                              <1> 	mov	edi, 0C00001h			; not there
   143                              <1> 
   144                              <1> _sabr_thru:
   145                              <1> 	mov	dword ptr [esi+IO_PORT+eax*4], edi
   146                              <1> 	
   147                              <1> 	mov	ebx, dword ptr [esi+IO_PORT+65*4]
   148                              <1> 	shl	ebx, 12				; write thru to base table
   149                              <1> 	add	eax, ebx			; in reload store
   150                              <1> 	mov	ebx, edi
   151                              <1> 	bswap	ebx
   152                              <1> 	mov	edi, _memory
   153                              <1> 	mov	dword ptr [edi+eax*4+64*4], ebx
   154                              <1> 	ret
   155                              <1> 
   156                              <1> 	%if	0
   157                              <1> 
   158                              <1> 	mov	esi, eax		; target window
   159                              <1> 	mov	eax, dword ptr [ebp+A]	; requested storage block index
   160                              <1> 	mov	ebx, eax		; cache a copy
   161                              <1> 
   162                              <1> 	mov	ecx, dword ptr [esi+IO_PORT+128*4]
   163                              <1> 					; device zero = executable space
   164                              <1> 					; load its size parameter
   165                              <1> 	test	eax, 00400000h		; big and maybe not system memory?
   166                              <1> 	jz	_sabr_executable_space	; yes executable space
   167                              <1> 
   168                              <1> 	test	ebx, 63
   169                              <1> 	jz	_sabr_executable_space	; yes executable space
   170                              <1> 					; no some other space
   171                              <1> 
   172                              <1> 	and	ebx, 63
   173                              <1> 	mov	ecx, dword ptr [esi+IO_PORT+128*4+ebx*4]
   174                              <1> 	test	ecx, DATA16_FLAG
   175                              <1> 	jnz	 _sabr_device_array
   176                              <1> 	test	ecx, 00800000h
   177                              <1> 	jz	_sabr_guard		; range issue. The device is void
   178                              <1> 
   179                              <1> 	mov	ebx, eax
   180                              <1> 	and	ebx, 00BFFFC0h		; blocks of 64 pages if not device zero
   181                              <1> 	jmp	_sabr_executable_type	; devices usable as system memory
   182                              <1> 	
   183                              <1> _sabr_executable_space:			; is the target page @+ application space?
   184                              <1> 	and	ebx, 00BFFFFFh		; just the page, not any flags
   185                              <1> 	cmp	ebx, dword ptr [esi+IO_PORT+72*4]
   186                              <1> 	js	_sabr_guard		; neither ISrs nor applications may base ISR space
   187                              <1> 
   188                              <1> _sabr_executable_type:			; has the device this much memory?
   189                              <1> 	and	ecx, 003FFFFFh		; 4K-word page high index of device
   190                              <1> 					; has the device this many pages?
   191                              <1> 	sub	ecx, ebx
   192                              <1> 
   193                              <1> 	jns	_sabr_thru		; yes
   194                              <1> 	jmp	_sabr_guard		; no
   195                              <1> 
   196                              <1> _sabr_device_array:
   197                              <1> 	test	dword ptr [esi+PSR], 00800000h
   198                              <1> 	jz	near guard_ii_authority	; only be here if you are an ISR
   199                              <1> 	mov	ebx, eax		; refresh the requested block index
   200                              <1> 	and	ebx, 003FFFFFh
   201                              <1> 	shr	ebx, 6			; align it with high index from device port
   202                              <1> 	and	ecx, 003FFFFFh		; has the device array this many blocks?
   203                              <1> 
   204                              <1> 	sub	ecx, ebx
   205                              <1> 	jns	_sabr_thru		; yes
   206                              <1> 					; no
   207                              <1> _sabr_guard:
   208                              <1> 	mov	eax, 00C00001h		; no-access value
   209                              <1> 					; will trip on reference in target window
   210                              <1> _sabr_thru:
   211                              <1> 	mov	dword ptr [esi+IO_PORT+esi*4], eax	; ????????
   212                              <1> 					; esi = target window
   213                              <1> 	mov	ebx, dword ptr [esi+IO_PORT+65*4]	; thread TCB
   214                              <1> 	shl	ebx, 12+2		; 4K page * 4 platform bytes
   215                              <1> 	mov	edi, _memory		; so system memory of emulated machine
   216                              <1> 	add	edi, ebx		; + offset of TCB 
   217                              <1> 	bswap	eax			; big endian store at TCB + ABT + esi * 4 
   218                              <1> 	mov	dword ptr [edi+esi*4+64*4], eax
   219                              <1> 					; -> TCB + ABT + window index
   220                              <1> _sabrx:	ret
   221                              <1> 	%endif
   222                              <1> 	%endif
    33                                  	%include	"oport.msm"
     1                              <1> 
     2                              <1> OOO_TRACE	equ	0
     3                              <1> 
     4                              <1> 							; static void oport(int ea, int value, smp *xcore)
     5                              <1> 							; {
     6                              <1> oport:		; write I / O port			;    int		 rule,
     7                              <1> 		; RTA instructions outA outB		;			 device;
     8                              <1> 							; 
     9                              <1> 		; ports which are memory pointers	;    int		 mask,
    10                              <1> 		; must have a block that exists		;			 from,
    11                              <1> 		; ISRs can write trap value C00001 	;                 	 index;
    12                              <1> 		; = device 400001 | illegal 800000	; 
    13                              <1> 		; port # = effective address = eax	;    int		 device_index = 0;
    14                              <1> 		; write value in ebx			; 
    15                              <1> 		; multicast bits in RTA register k	;    smp		*ascor;
    16                              <1> 		 					;    unsigned	*register_set = xcore->register_set;
    17 00000CDB 3DC0000000          <1> 	cmp	eax, IO_PORTS				; 
    18 00000CE0 0F8390000000        <1> 	jnb	near no_port				;    if (ea < IO_PORTS)
    19                              <1> 							;    {
    20 00000CE6 8A88[3B0B0000]      <1> 	mov	cl, byte ptr [eax+mask_port_outAB]	;       rule = mask_port_outAB[ea];
    21 00000CEC 20C9                <1> 	and	cl, cl					; 
    22 00000CEE 0F8482000000        <1> 	jz	near no_rule				;       if (rule)
    23 00000CF4 F6C108              <1> 	test	cl, ISR_ONLY				;       {
    24 00000CF7 740D                <1> 	jz	application_plus_isr_rule		;          if (((rule & ISR_ONLY) == 0) || (psr & 0x00800000))
    25 00000CF9 F6869E04000080      <1> 	test	byte ptr [esi+PSR+2], 128		;          {
    26 00000D00 0F8470000000        <1> 	jz	near no_authority				;
    27                              <1> 							;
    28                              <1> application_plus_isr_rule:				;
    29 00000D06 F6C104              <1> 	test	cl, EXTERNAL_IO				;             if (rule & EXTERNAL_IO)
    30 00000D09 7423                <1> 	jz	broadcast_rule?				;             {
    31 00000D0B 899C86CC040000      <1> 	mov	dword ptr [esi+IO_PORT+eax*4], ebx	;                base[ea] = value;
    32 00000D12 83F866              <1> 	cmp	eax, 102	; INDICATION$		;                if (ea == 102) indication |= value;
    33 00000D15 7506                <1> 	jne	xi_ack?		 			;
    34 00000D17 099E90040000        <1> 	or	dword ptr [esi+INDICATION], ebx		;
    35                              <1>  							;
    36                              <1> xi_ack?:							;
    37 00000D1D 83F84B              <1> 	cmp	eax, 75					;                if (ea == 75)
    38 00000D20 750B                <1> 	jne	xi_no_ack				;                {
    39 00000D22 F6D3                <1> 	not	bl					;                    base[74] &= (value & 255) ^ 255;
    40 00000D24 0FB6DB              <1> 	movzx	ebx, bl					;                    // indication |= (value & 255) << 8;
    41                              <1> 							;                }
    42 00000D27 219EF4050000        <1> 	and	dword ptr [esi+IO_PORT+74*4], ebx	; 
    43                              <1> xi_no_ack:						; //               if ((ea == 79) && (value & 1)) indication |= ATTENTION;
    44 00000D2D C3                  <1> 	ret						;                return;
    45                              <1> 							;             }
    46                              <1> 							; 
    47                              <1> broadcast_rule?:					;             if (rule & BROADCAST)
    48 00000D2E F6C110              <1> 	test	cl, BROADCAST				;             {
    49 00000D31 7448                <1> 	jz	memory_rule?				;                mask = k;
    50                              <1> 
    51                              <1> 	%if	OOO_TRACE
    52                              <1> 	inc	dword ptr [esi+REGISTER+282*4]
    53                              <1> 	%endif
    54                              <1> 							;
    55 00000D33 899C86CC040000      <1> 	mov	dword ptr [esi+IO_PORT+eax*4], ebx 
    56 00000D3A 8B8E00060000        <1> 	mov	ecx, dword ptr [esi+IO_PORT+_CORE_SOCKET] ;
    57 00000D40 B801000000          <1> 	mov	eax, 1					;
    58 00000D45 D3E0                <1> 	shl	eax, cl					;
    59 00000D47 89C1                <1> 	mov	ecx, eax	; source identifier bit	;
    60                              <1> 							;
    61 00000D49 BB01000000          <1> 	mov	ebx, 1					;
    62 00000D4E BF[00000000]        <1> 	mov	edi, _core				;
    63 00000D53 8B4504              <1> 	mov	eax, dword ptr [ebp+REGISTER+K]		;
    64                              <1> 							;
    65                              <1> multicast_select:					;
    66 00000D56 85D8                <1> 	test	eax, ebx				;                from = base[77];
    67 00000D58 740F                <1> 	jz	multicast_next				; 
    68 00000D5A 31D8                <1> 	xor	eax, ebx				;                for (index = 0; index < RTA_SMP; index++)
    69 00000D5C 098F04060000        <1> 	or	dword ptr [edi+IO_PORT+_MCAST_PENDING], ecx ;             {
    70 00000D62 808F9004000080      <1> 	or	byte ptr [edi+INDICATION], ATTENTION	;                   if (mask & 1)
    71                              <1> 							;                   {
    72                              <1> multicast_next:						;                      ascor = core + index;
    73 00000D69 81C7CC090000        <1> 	add	edi, CORE_SIZE				;                      ascor->BASE[78] |= 1 << from;
    74 00000D6F D1E3                <1> 	shl	ebx, 1					;                      ascor->INDICATION |= ATTENTION;
    75 00000D71 21C0                <1> 	and	eax, eax				;                   }
    76 00000D73 75E1                <1> 	jnz	multicast_select			; 
    77 00000D75 C3                  <1> 	ret						;                   mask >>= 1;
    78                              <1> 							;                }
    79                              <1> no_port:						; 
    80                              <1> no_rule:						;                /**************************************************
    81                              <1> no_authority:						; 			keep these on the sending side
    82                              <1> 							; 			until constructing interrupt frame
    83 00000D76 E998010000          <1> 	jmp	guard_ii_authority			; 			between instructions at target core
    84                              <1> 							;                         to avoid overwrites from other cores
    85                              <1> 							;                **************************************************/
    86                              <1> 							; 
    87                              <1> 							;                base[ea] = value;	/* latent parameter	*/
    88                              <1> 							;                return;
    89                              <1> 							;             }
    90                              <1> 							; 
    91                              <1> memory_rule?:	; system memory type only		;             else if (rule & MEMTYPE)
    92                              <1> 
    93 00000D7B F6C101              <1> 	test	cl, MEMTYPE				;             {
    94 00000D7E 7459                <1> 	jz	page_pointer?				;                if (value & 0x00400000) device_index = value & 63;
    95 00000D80 F7C300004000        <1> 	test	ebx, 0400000h	; bank sized?		; 
    96 00000D86 745E                <1> 	jz	memory_page_pointer			;                if (device_index)
    97                              <1> 							;                {
    98 00000D88 F7C33F000000        <1> 	test	ebx, 63					;                   if (value & 0x00800000)
    99 00000D8E 7419                <1> 	jz	device_is_pointed			;                   {
   100 00000D90 F7C300008000        <1> 	test	ebx, 0800000h	; the trap device?	;                      if (psr & 0x00800000)
   101 00000D96 7411                <1> 	jz	device_is_pointed			;                      {
   102 00000D98 F6869E04000080      <1> 	test	byte ptr [esi+PSR+2], 128	; ISR?		;                         base[ea] = value;
   103 00000D9F 74D5                <1> 	jz	no_authority				;                         return;
   104 00000DA1 899C86CC040000      <1> 	mov	[esi+IO_PORT+eax*4], ebx		;                      }
   105 00000DA8 C3                  <1> 	ret						; 
   106                              <1> 							;                      GUARD_AUTHORITY
   107                              <1> device_is_pointed:					;                      return;
   108 00000DA9 8B8ECC060000        <1> 	mov	ecx, dword ptr [esi+IO_PORT+128*4]	;                   }
   109 00000DAF F7C100008000        <1> 	test	ecx, 00800000h				;                }
   110 00000DB5 74BF                <1> 	jz	no_authority				; 
   111 00000DB7 F7C100004000        <1> 	test	ecx, 00400000h				;                device = base[128+device_index];
   112 00000DBD 75B7                <1> 	jnz	no_authority				;            
   113 00000DBF 81E1FFFF3F00        <1> 	and	ecx, 003FFFFFh				;                if ((device & 0x00C00000) == 0x00800000)
   114 00000DC5 89DF                <1> 	mov	edi, ebx				;                {
   115 00000DC7 81E7FFFF3F00        <1> 	and	edi, 003FFFFFh	; catch any 00800000	;                   if ((value & 0x003FFFC0) > (device & 0x003FFFFF))
   116 00000DCD 39F9                <1> 	cmp	ecx, edi				;                   {
   117 00000DCF 7233                <1> 	jb	outwith		; beyond memory		;                   }
   118 00000DD1 899C86CC040000      <1> 	mov	[esi+IO_PORT+eax*4], ebx		;                   else
   119 00000DD8 C3                  <1> 	ret						;                   {
   120                              <1> 							;                      base[ea] = value;
   121                              <1> 							;                      return;
   122                              <1> 							;                   }
   123                              <1> 							;                }
   124                              <1> 							;             }
   125                              <1> 							;             else
   126                              <1> 							;             {
   127                              <1> 							;                /*******************************************
   128                              <1> ;	only a device zero page index will do		; 			page pointer to system memory
   129                              <1> 							;                *******************************************/
   130                              <1> page_pointer?:						; 
   131 00000DD9 F6C102              <1> 	test	cl, MEMZERONLY				;                if ((value & 0x00400000) == 0)
   132 00000DDC 7498                <1> 	jz	no_rule					;                {
   133 00000DDE F7C30000C000        <1> 	test	ebx, 00C00000h				;                   if (value > (base[128] & 0x003FFFFF))
   134 00000DE4 7590                <1> 	jnz	no_authority				;                   {
   135                              <1> 							;                   }
   136                              <1> memory_page_pointer:					;                   else
   137 00000DE6 8B8ECC060000        <1> 	mov	ecx, dword ptr [esi+IO_PORT+128*4]	;                   {
   138 00000DEC 81E1FFFF3F00        <1> 	and	ecx, 003FFFFFh				;                      base[ea] = value;
   139 00000DF2 81E3FFFFFF00        <1> 	and	ebx, 00FFFFFFh				;                      return;
   140 00000DF8 39D9                <1> 	cmp	ecx, ebx				;                   }
   141 00000DFA 7208                <1> 	jb	outwith					;                }
   142 00000DFC 899C86CC040000      <1> 	mov	dword ptr [esi+IO_PORT+eax*4], ebx		;             }
   143 00000E03 C3                  <1> 	ret						;          }
   144                              <1> 							;       }
   145                              <1> 							;    }
   146                              <1> outwith:							; 
   147 00000E04 B90E000000          <1> 	mov	ecx, LP_ADDRESS				;    GUARD_AUTHORITY;
   148 00000E09 E90A010000          <1> 	jmp	guard_ii_escape				; }							; 
    34                                  	%include	"ii.msm"
     1 00000E0E 6609869C040000      <1> _on:	or	word ptr [esi+PSR], ax	; only touch low-order 16 bits
     2 00000E15 C3                  <1> 	ret
     3                              <1> 
     4 00000E16 6683F0FF            <1> _off:	xor	ax, 0000FFFFh
     5 00000E1A 6621869C040000      <1> 	and	word ptr [esi+PSR], ax	; only touch low-order 16 bits
     6 00000E21 C3                  <1> 	ret
     7                              <1> 
     8                              <1> RELOAD_SMPP	equ	1
     9                              <1> III_TRACE	equ	1
    10                              <1> 
    11                              <1> _xi:
    12                              <1> 	%if	RELOAD_SMPP
    13 00000E22 8BB560020000        <1> 	mov	esi, dword ptr [ebp+CORE_INDEX1]
    14                              <1> 	%endif
    15                              <1> 
    16 00000E28 20E4                <1> 	and	ah, ah				; 8 external interrupts?
    17 00000E2A 741B                <1> 	jz	_xix				; nane
    18                              <1> 
    19 00000E2C 30C9                <1> 	xor	cl, cl
    20                              <1> 
    21                              <1> _xi_next:					; external interrupt pending signals[8]
    22 00000E2E 88A6F4050000        <1> 	mov	byte ptr [esi+IO_PORT+74*4], ah	; position for inA|B from port XI_PENDING$	LL.mm.hh.zz
    23 00000E34 C6869104000000      <1> 	mov	byte ptr [esi+INDICATION+1], 0	; clear from platform indications fabric	ll.MM.hh.zz
    24 00000E3B 31C9                <1> 	xor	ecx, ecx			; clear latent param
    25 00000E3D B802000000          <1> 	mov	eax, II_XINT			; select external interrupt
    26                              <1> 
    27 00000E42 E9FE000000          <1> 	jmp	_ii_
    28                              <1> 	
    29 00000E47 A880                <1> _xix:	test	al, ATTENTION			; core2core interrupt
    30 00000E49 0F8487000000        <1> 	jz	near _xiy
    31                              <1> 
    32 00000E4F BB01000000          <1> 	mov	ebx, 1
    33 00000E54 BF[00000000]        <1> 	mov	edi, _core
    34                              <1> 
    35                              <1> _xi_atn_sources:
    36                              <1> 
    37 00000E59 F78604060000FFFFFF- <1> 	test	dword ptr [esi+IO_PORT+_MCAST_PENDING], -1
    37 00000E62 FF                  <1>
    38 00000E63 745E                <1> 	jz	_xi_atn_sources_all				; i.e. all cleared
    39 00000E65 859E04060000        <1> 	test	dword ptr [esi+IO_PORT+_MCAST_PENDING], ebx	; this source cleared?
    40 00000E6B 744A                <1> 	jz	_xi_atn_source_next				; i.e. this one cleared
    41                              <1> 
    42 00000E6D 319E04060000        <1> 	xor	dword ptr [esi+IO_PORT+_MCAST_PENDING], ebx	; clear pending source
    43                              <1> 
    44 00000E73 8B8F08060000        <1> 	mov	ecx, dword ptr [edi+IO_PORT+_MCAST_TO]		; latent parameter from sending side
    45 00000E79 81E1FFFFFF00        <1> 	and	ecx, 00FFFFFFh					; relay updated dayclock?
    46 00000E7F 740A                <1> 	jz	_xi_atn_dayclock				; yes
    47                              <1> 
    48 00000E81 B805000000          <1> 	mov	eax, II_ATTENTION				; no
    49 00000E86 E9BA000000          <1> 	jmp	_ii_						; _ii_ takes ecx for
    50                              <1> 								; interrupt latent parameter
    51                              <1> _xi_atn_dayclock:
    52 00000E8B 8B8F58020000        <1> 	mov	ecx, dword ptr [edi+REGISTER+DAYCLOCK_U]
    53 00000E91 8B875C020000        <1> 	mov	eax, dword ptr [edi+REGISTER+DAYCLOCK] 
    54 00000E97 3B8F58020000        <1> 	cmp	ecx, dword ptr [edi+REGISTER+DAYCLOCK_U]
    55 00000E9D 75EC                <1> 	jnz	_xi_atn_dayclock
    56 00000E9F 89865C020000        <1> 	mov	dword ptr [esi+REGISTER+DAYCLOCK], eax
    57 00000EA5 898E58020000        <1> 	mov	dword ptr [esi+REGISTER+DAYCLOCK_U], ecx
    58                              <1> 
    59 00000EAB 8B8760060000        <1> 	mov	eax, dword ptr [edi+IO_PORT+_TZONE]
    60 00000EB1 898660060000        <1> 	mov	dword ptr [esi+IO_PORT+_TZONE], eax
    61                              <1> 
    62                              <1> _xi_atn_source_next:
    63 00000EB7 D1E3                <1> 	shl	ebx, 1
    64 00000EB9 7208                <1> 	jc	_xi_atn_sources_all
    65 00000EBB 81C7CC090000        <1> 	add	edi, CORE_SIZE
    66 00000EC1 EB96                <1> 	jmp	_xi_atn_sources
    67                              <1> 
    68                              <1> _xi_atn_sources_all:
    69 00000EC3 80B69004000080      <1> 	xor	byte ptr [esi+INDICATION], ATTENTION
    70                              <1> 
    71                              <1> 	%if	III_TRACE
    72 00000ECA 8B8604060000        <1> 	mov	eax, dword ptr [esi+IO_PORT+_MCAST_PENDING]
    73 00000ED0 898664040000        <1> 	mov	dword ptr [esi+REGISTER+281*4], eax
    74                              <1> 	%endif
    75                              <1> 
    76 00000ED6 8B8690040000        <1> _xiy:	mov	eax, dword ptr [esi+INDICATION]			; case we did _xix in the same sweep
    77 00000EDC F6869004000040      <1> 	test	byte ptr [esi+INDICATION], INCREMENTER_CARRY	; nanosecond or other counter 
    78 00000EE3 7410                <1> 	jz	_xiz						; from minus to carrry on zero
    79                              <1> 								; to feed millisecond dayclock
    80 00000EE5 80B69004000040      <1> 	xor	byte ptr [esi+INDICATION], INCREMENTER_CARRY
    81 00000EEC B804000000          <1> 	mov	eax, II_MSECOND
    82 00000EF1 31C9                <1> 	xor	ecx, ecx
    83 00000EF3 EB50                <1> 	jmp	_ii_
    84                              <1> 
    85 00000EF5 C3                  <1> _xiz:	ret
    86                              <1> 
    87                              <1> _ii_instruction:
    88 00000EF6 89C3                <1> 	mov	ebx, eax
    89 00000EF8 C1EB06              <1> 	shr	ebx, 6
    90 00000EFB 2B9EEC050000        <1> 	sub	ebx, dword ptr [esi+IO_PORT+72*4]	; application threshold
    91 00000F01 7910                <1> 	jns	guard_ii_authority	; must have executed a character string
    92                              <1> 					; like 757575
    93 00000F03 A9C0FFFFFF          <1> 	test	eax, -64
    94 00000F08 751F                <1> 	jnz	_ii			; not in restart page OK
    95 00000F0A F6869E04000080      <1> 	test	byte ptr [esi+PSR+2], 128	; psr + 1 in BE-speak LE:L_M_H_Z
    96 00000F11 7516                <1> 	jnz	_ii			; ISR may interrupt to restart page
    97                              <1> 
    98                              <1> 		; service call application to restart page not allowed
    99                              <1> 		; most likely to be an accident
   100                              <1> 		; drop thru and be quelled
   101                              <1> 
   102                              <1> guard_ii_authority:
   103 00000F13 B901000000          <1> 	mov	ecx, LP_AUTHORITY
   104                              <1> guard_ii_escape:
   105 00000F18 B85F000000          <1> 	mov	eax, II_GUARD
   106                              <1> _ii_escape:
   107                              <1> 	%if	RELOAD_SMPP
   108 00000F1D 8BB560020000        <1> 	mov	esi, dword ptr [ebp+CORE_INDEX1]		; read register 152 or 280
   109                              <1> 	%endif						; depending ebp -> application / ISR registers
   110                              <1> 
   111 00000F23 8BA67C040000        <1> 	mov	esp, dword ptr [esi+REGISTER+287*4]	; read esp at start of _execute
   112                              <1> 
   113 00000F29 83F85F              <1> _ii:	cmp	eax, II_GUARD
   114 00000F2C 7517                <1> 	jnz	_ii_
   115 00000F2E F605[19000000]01    <1> 	test	byte ptr [_uflag+'Z'-'A'], 1		; break to debug console?
   116 00000F35 740E                <1> 	jz	_ii_					; not if not opted
   117 00000F37 808E9004000002      <1> 	or	byte ptr [esi+INDICATION], LOCKSTEP
   118 00000F3E 800D[00000000]02    <1> 	or	byte ptr [_general_indication], LOCKSTEP
   119                              <1> 	
   120 00000F45 8DAE00020000        <1> _ii_:	lea	ebp, [esi+128*4] 
   121                              <1> 
   122 00000F4B 89AEA0040000        <1> 	mov	dword ptr [esi+REGISTER_SET], ebp
   123 00000F51 C78698040000800000- <1> 	mov	dword ptr [esi+ISELECT], 128
   123 00000F5A 00                  <1>
   124                              <1> 
   125 00000F5B 8B5D3C              <1> 	mov	ebx, dword ptr [ebp+S_P]
   126 00000F5E 81FB00010000        <1> 	cmp	ebx, 256
   127 00000F64 0F87BF010000        <1> 	ja	near guard_stack
   128 00000F6A 83C3FC              <1> 	add	ebx, -4
   129                              <1> 
   130 00000F6D 81FB9A000000        <1> 	cmp	ebx, 128+24+2
   131 00000F73 0F82B0010000        <1> 	jb	near guard_stack
   132 00000F79 895D3C              <1> 	mov	dword ptr [ebp+S_P], ebx
   133                              <1> 
   134 00000F7C 2B9688040000        <1> 	sub	edx, dword ptr [esi+B0P]
   135 00000F82 C1EA02              <1> 	shr	edx, 2
   136 00000F85 89549E0C            <1> 	mov	dword ptr [esi+ebx*4+REGISTER+3*4], edx	; save PC offset
   137 00000F89 8B96A4040000        <1> 	mov	edx, dword ptr [esi+B0_NAME]
   138 00000F8F 89549E08            <1> 	mov	dword ptr [esi+ebx*4+REGISTER+2*4], edx	; save bank ID
   139 00000F93 8B969C040000        <1> 	mov	edx, dword ptr [esi+PSR]
   140 00000F99 89549E04            <1> 	mov	dword ptr [esi+ebx*4+REGISTER+4], edx	; saved PSR
   141 00000F9D 890C9E              <1> 	mov	dword ptr [esi+ebx*4+REGISTER], ecx	; latent parameter
   142 00000FA0 F7C200008000        <1> 	test	edx, 00800000h				; nested interrupt ?
   143 00000FA6 7503                <1> 	jnz	_ii_ii
   144 00000FA8 895D38              <1> 	mov	dword ptr [ebp+FP], ebx			; if not, mark interrupted
   145                              <1> 							; application stack frame
   146                              <1> _ii_ii:
   147 00000FAB 81CA00008000        <1> 	or	edx, 00800000h				; ISR active
   148 00000FB1 89969C040000        <1> 	mov	dword ptr [esi+PSR], edx
   149                              <1> 
   150 00000FB7 89C2                <1> 	mov	edx, eax				; get to the operand
   151 00000FB9 83E23F              <1> 	and	edx, 63					; address from interrupt vector
   152 00000FBC C1E806              <1> 	shr	eax, 6
   153 00000FBF 25FF030000          <1> 	and	eax, 000003FFh				; eax -> page containing ISR ; edx  -> vector
   154 00000FC4 31DB                <1> 	xor	ebx, ebx				; single page ISR
   155 00000FC6 E970060000          <1> 	jmp	_go2_frame
   156                              <1> 
   157                              <1> ;	_ir	sign extended ea is in eax
   158                              <1> 
   159 00000FCB F6869E04000080      <1> _ir:	test	byte ptr [esi+PSR+2], 128		; eax = EA = variation on return offset
   160 00000FD2 0F843BFFFFFF        <1> 	jz	guard_ii_authority		; not good to do Interrupt Return from application space
   161 00000FD8 89D7                <1> 	mov	edi, edx			; save in case the operation interrupts itself
   162 00000FDA 89C2                <1> 	mov	edx, eax			; +- displacement operand, offset in stack added later
   163                              <1> 
   164 00000FDC E87F010000          <1> 	call	stack_read4			; [ebp+ebx*4] -> interrupt stack frame
   165                              <1> 						; interrupt stack pointer is already updated ebx+4
   166                              <1> 
   167 00000FE1 8B449E08            <1> 	mov	eax, dword ptr [esi+ebx*4+2*4]		; interrupted b0_name
   168                              <1> 
   169 00000FE5 8B4C9E04            <1> 	mov	ecx, dword ptr [esi+ebx*4+1*4]		; interrupted psr
   170                              <1> 
   171 00000FE9 03549E0C            <1> 	add	edx, dword ptr [esi+ebx*4+3*4]		; add interrupted iframe offset to EA
   172                              <1> 
   173 00000FED 31DB                <1> 	xor	ebx, ebx				; iframe default page high index  
   174 00000FEF A900008000          <1> 	test	eax, 00800000h
   175 00000FF4 7410                <1> 	jz	ir_4k_iframe				; 1-page iframe return target
   176                              <1> 
   177 00000FF6 89C3                <1> 	mov	ebx, eax				; iframe page high index
   178 00000FF8 C1E30C              <1> 	shl	ebx, 12					; from 6 bits at front of table
   179 00000FFB 0FB61C9D[01010000]  <1> 	movzx	ebx, byte ptr [_memory+ebx*4+64*4+1]	; at iframe + 64 words
   180 00001003 C1EB02              <1> 	shr	ebx, 2					; shift 6 bits into 8 bits
   181                              <1> 
   182                              <1> ir_4k_iframe:
   183 00001006 898E9C040000        <1> 	mov	dword ptr [esi+PSR], ecx
   184 0000100C F7C100008000        <1> 	test	ecx, 00800000h				; returning ISR -> ISR ?
   185 00001012 741B                <1> 	jz	ir_application				; no
   186                              <1> 
   187 00001014 8DAE00020000        <1> 	lea	ebp, [esi+REGISTER+128*4]		; for nested interrupts
   188 0000101A 89AEA0040000        <1> 	mov	dword ptr [esi+REGISTER_SET], ebp	; interrupt register set
   189 00001020 C78698040000800000- <1> 	mov	dword ptr [esi+ISELECT], 128		; interrupt register set
   189 00001029 00                  <1>
   190 0000102A E90C060000          <1> 	jmp	_go2_frame				; yes
   191                              <1> 
   192                              <1> ir_application:
   193 0000102F 89F5                <1> 	mov	ebp, esi				; application register set
   194 00001031 89AEA0040000        <1> 	mov	dword ptr [esi+REGISTER_SET], ebp
   195 00001037 C78698040000000000- <1> 	mov	dword ptr [esi+ISELECT], 0
   195 00001040 00                  <1>
   196 00001041 E9F5050000          <1> 	jmp	_go2_frame
   197                              <1> 
    35                                  	%include	"stack.msm"
     1                              <1> ;	stack operations call these to add or subract stack
     2                              <1> ;	limits are checked here
     3                              <1> ;	these routines always leave epb -> all registers 0..255
     4                              <1> ;	because both  interrupt internal stack pointer register 128 + 15
     5                              <1> ;		and application internal stack pointer register 15
     6                              <1> 
     7                              <1> ;	are absolute pointers to the entire register stack
     8                              <1> 
     9                              <1> ;	therefore instructions calling here must afterwards
    10                              <1> 
    11                              <1> ;		mov	ebp, dword ptr [_register_set]
    12                              <1> 
    13                              <1> ;	to get ebp back to application registers 0..127
    14                              <1> ;			or interrupt registers 128..255
    15                              <1> 
    16                              <1> ;	ebp governs which r k x y a b mantissa2 mantissa3 fp sp is implied in the instruction opcode
    17                              <1> ;	registers addressed as operand are always absolute in the range 0..255
    18                              <1> 
    19                              <1> ;	these don't move any data but leave [ebp+ebx*4] pointing to the required stack frame
    20                              <1> ;	and update the stack pointer
    21                              <1> 
    22                              <1> ;	although applications can and must read interrupt registers with load instructions
    23                              <1> ;	they can't read interrupt registers with runaway pop instructions
    24                              <1> ;	because the problem is easier to find with an interrupt as soon as 128+ gets popped
    25                              <1> 
    26                              <1> 
    27                              <1> 
    28                              <1> stack1:
    29                              <1> 	%if	0
    30                              <1> 	mov	ebx, dword ptr [ebp+S_P]
    31                              <1> 	dec	ebx
    32                              <1> 	mov	dword ptr [ebp+S_P], ebx
    33                              <1> 	ret
    34                              <1> 	%endif
    35                              <1> 
    36                              <1> 
    37 00001046 8B5D3C              <1> 	mov	ebx, dword ptr [ebp+S_P]	; read whichever internal sp
    38 00001049 F6869E04000080      <1> 	test	byte ptr [esi+PSR+2], 128	; ISR ?
    39 00001050 742B                <1> 	jz	stack1_a			; no ?
    40 00001052 81FB00010000        <1> 	cmp	ebx, 256			; in upper range ?
    41 00001058 0F87CB000000        <1> 	ja	near guard_stack		; no ?
    42 0000105E 4B                  <1> 	dec	ebx				; decrement
    43 0000105F 0F88C4000000        <1> 	js	near guard_stack		; < 0 ?
    44 00001065 81FB9A000000        <1> 	cmp	ebx, 128+24+2			; in clock registers?
    45 0000106B 730C                <1> 	jnb	stack1_j			;
    46 0000106D 81FB80000000        <1> 	cmp	ebx, 128			; in app stack? Allowed for thread switch
    47 00001073 0F83B0000000        <1> 	jnb	near guard_stack		; in working registers page
    48                              <1> stack1_j:
    49 00001079 895D3C              <1> 	mov	dword ptr [ebp+S_P], ebx	; new frame
    50 0000107C C3                  <1> 	ret
    51                              <1> 
    52                              <1> stack1_a:					; this is application
    53 0000107D 81FB80000000        <1> 	cmp	ebx, 128			; > interrupt register range start
    54 00001083 0F87A0000000        <1> 	ja	near guard_stack		; not allowed
    55 00001089 4B                  <1> 	dec	ebx				; decrement
    56 0000108A 0F8899000000        <1> 	js	near guard_stack		; < 0 ?
    57 00001090 83FB18              <1> 	cmp	ebx, 24				; in control registers ?
    58 00001093 0F8290000000        <1> 	jb	near guard_stack		; not allowed
    59 00001099 895D3C              <1> 	mov	dword ptr [ebp+S_P], ebx	; new frame
    60 0000109C C3                  <1> 	ret
    61                              <1> 
    62                              <1> stack2:
    63                              <1> 	%if	0
    64                              <1> 	mov	ebx, dword ptr [ebp+S_P]
    65                              <1> 	add	ebx, -2
    66                              <1> 	mov	dword ptr [ebp+S_P], ebx
    67                              <1> 	ret
    68                              <1> 	%endif
    69                              <1> 
    70 0000109D 8B5D3C              <1> 	mov	ebx, dword ptr [ebp+S_P]
    71 000010A0 F6869E04000080      <1> 	test	byte ptr [esi+PSR+2], 128
    72 000010A7 742A                <1> 	jz	stack2_a
    73 000010A9 81FB00010000        <1> 	cmp	ebx, 256
    74 000010AF 0F8774000000        <1> 	ja	near guard_stack
    75 000010B5 83C3FE              <1> 	add	ebx, -2
    76 000010B8 0F886B000000        <1> 	js	near guard_stack
    77 000010BE 81FB98000000        <1> 	cmp	ebx, 128+24
    78 000010C4 7309                <1> 	jnb	stack2_j
    79 000010C6 83FB7E              <1> 	cmp	ebx, 128-2
    80 000010C9 0F875A000000        <1> 	ja	near guard_stack
    81                              <1> 
    82                              <1> stack2_j:
    83 000010CF 895D3C              <1> 	mov	dword ptr [ebp+S_P], ebx
    84 000010D2 C3                  <1> 	ret
    85                              <1> 
    86                              <1> stack2_a:
    87 000010D3 81FB80000000        <1> 	cmp	ebx, 128			; application push high limit 128,  ISR 256
    88 000010D9 774E                <1> 	ja	guard_stack
    89 000010DB 83C3FE              <1> 	add	ebx, -2
    90 000010DE 7849                <1> 	js	guard_stack
    91 000010E0 83FB18              <1> 	cmp	ebx, 24
    92 000010E3 7244                <1> 	jb	guard_stack			; stack top limit zero ISR and application
    93 000010E5 895D3C              <1> 	mov	dword ptr [ebp+S_P], ebx
    94 000010E8 C3                  <1> 	ret
    95                              <1> 
    96                              <1> stack4:
    97                              <1> 	%if	0
    98                              <1> 	mov	ebx, dword ptr [ebp+S_P]
    99                              <1> 	add	ebx, -4
   100                              <1> 	mov	dword ptr [ebp+S_P], ebx
   101                              <1> 	ret
   102                              <1> 	%endif
   103                              <1> 
   104 000010E9 8B5D3C              <1> 	mov	ebx, dword ptr [ebp+S_P]
   105 000010EC F6869E04000080      <1> 	test	byte ptr [esi+PSR+2], 128	; read psr interrupt bit
   106 000010F3 741E                <1> 	jz	stack4_a			; stack is registers 24..127
   107 000010F5 81FB00010000        <1> 	cmp	ebx, 256			; stack is registers  0..255
   108 000010FB 772C                <1> 	ja	guard_stack
   109 000010FD 83C3FC              <1> 	add	ebx, -4				; proposed frame
   110 00001100 7827                <1> 	js	guard_stack			; not lower than register zero
   111 00001102 81FB98000000        <1> 	cmp	ebx, 128+24
   112 00001108 7305                <1> 	jnb	stack4_j
   113 0000110A 83FB7C              <1> 	cmp	ebx, 128-4			; in working registers page
   114 0000110D 771A                <1> 	ja	guard_stack
   115                              <1> 
   116                              <1> stack4_j:
   117 0000110F 895D3C              <1> 	mov	dword ptr [ebp+S_P], ebx
   118 00001112 C3                  <1> 	ret					; both sp are absolute pointers
   119                              <1> 
   120                              <1> stack4_a:
   121 00001113 81FB80000000        <1> 	cmp	ebx, 128			; don't push into a higher register than 127
   122 00001119 770E                <1> 	ja	guard_stack
   123 0000111B 83C3FC              <1> 	add	ebx, -4
   124 0000111E 7809                <1> 	js	guard_stack
   125 00001120 83FB18              <1> 	cmp	ebx, 24				; dont push lower than 24
   126 00001123 7204                <1> 	jb	guard_stack
   127 00001125 895D3C              <1> 	mov	dword ptr [ebp+S_P], ebx
   128 00001128 C3                  <1> 	ret					; return new frame
   129                              <1> 
   130                              <1> guard_stack:
   131                              <1> stack_underflow:
   132 00001129 8BAEA0040000        <1> 	mov	ebp, dword ptr [esi+REGISTER_SET] ; esi -> core.REGISTER
   133 0000112F F7869C040000000080- <1> 	test	dword ptr [esi+PSR], 00800000h	; interrupt mode?
   133 00001138 00                  <1>
   134 00001139 0F84D4FDFFFF        <1> 	jz	guard_ii_authority		; sideline the application
   135 0000113F C7453C00010000      <1> 	mov	dword ptr [ebp+S_P], 256	; restart the interrupt stack
   136 00001146 B801000000          <1> 	mov	eax, 1				; so the interrupt can be interrupted
   137 0000114B F605[19000000]01    <1> 	test	byte ptr [_uflag+'Z'-'A'], 1
   138 00001152 7407                <1> 	jz	gsago
   139 00001154 808E9004000002      <1> 	or	byte ptr [esi+INDICATION], LOCKSTEP
   140 0000115B E9BDFDFFFF          <1> gsago:	jmp	_ii_escape
   141                              <1> 
   142                              <1> stack_read4:
   143 00001160 BB04000000          <1> 	mov	ebx, 4
   144 00001165 035D3C              <1> 	add	ebx, dword ptr [ebp+S_P]
   145 00001168 81FB80000000        <1> 	cmp	ebx, 128			; you can have stack locations up to here
   146 0000116E 7611                <1> 	jna	stack_r4			; whoever you are
   147 00001170 F6869E04000080      <1> 	test	byte ptr [esi+PSR+2], 128	; any higher you have to be an ISR
   148 00001177 74B0                <1> 	jz	stack_underflow
   149 00001179 81FB00010000        <1> 	cmp	ebx, 256			; and then not any higher than this
   150 0000117F 77A8                <1> 	ja	stack_underflow
   151                              <1> 
   152                              <1> stack_r4:
   153 00001181 875D3C              <1> 	xchg	ebx, dword ptr [ebp+S_P]	; write new stack top
   154 00001184 C3                  <1> 	ret					; return old stack top
   155                              <1> 
   156                              <1> stack_read2:
   157 00001185 BB02000000          <1> 	mov	ebx, 2
   158 0000118A 035D3C              <1> 	add	ebx, dword ptr [ebp+S_P]
   159 0000118D 81FB80000000        <1> 	cmp	ebx, 128			; you can have stack locations up to here
   160 00001193 7611                <1> 	jna	stack_r2			; whoever you are
   161 00001195 F6869E04000080      <1> 	test	byte ptr [esi+PSR+2], 128	; any higher you have to be an ISR
   162 0000119C 748B                <1> 	jz	stack_underflow
   163 0000119E 81FB00010000        <1> 	cmp	ebx, 256			; and then not any higher than this
   164 000011A4 7783                <1> 	ja	stack_underflow
   165                              <1> 
   166                              <1> stack_r2:
   167 000011A6 875D3C              <1> 	xchg	ebx, dword ptr [ebp+S_P]	; write new stack top
   168 000011A9 C3                  <1> 	ret					; return old stack top
   169                              <1> 
   170                              <1> stack_read1:
   171 000011AA BB01000000          <1> 	mov	ebx, 1				; calculate
   172 000011AF 035D3C              <1> 	add	ebx, dword ptr [ebp+S_P]	; new stack top
   173 000011B2 81FB80000000        <1> 	cmp	ebx, 128			; you can have stack locations up to here
   174 000011B8 7619                <1> 	jna	stack_r1			; whoever you are
   175 000011BA F6869E04000080      <1> 	test	byte ptr [esi+PSR+2], 128	; any higher you have to be an ISR
   176 000011C1 0F8462FFFFFF        <1> 	jz	stack_underflow
   177 000011C7 81FB00010000        <1> 	cmp	ebx, 256			; and then not any higher than this
   178 000011CD 0F8756FFFFFF        <1> 	ja	stack_underflow
   179                              <1> 
   180                              <1> stack_r1:
   181 000011D3 875D3C              <1> 	xchg	ebx, dword ptr [ebp+S_P]	; write new stack top
   182 000011D6 C3                  <1> 	ret					; return old stack top
   183                              <1> 
    36                                  	%include	"return.msm"
     1                              <1> _autoexit:
     2 000011D7 B846000000          <1> 	mov	eax, II_EXIT
     3 000011DC B90B000000          <1> 	mov	ecx, LP_AUTOEXIT
     4 000011E1 E937FDFFFF          <1> 	jmp	_ii_escape
     5                              <1> 
     6 000011E6 F7869C040000000080- <1> _lret:	test	dword ptr [esi+PSR], 00800000h
     6 000011EF 00                  <1>
     7 000011F0 7509                <1> 	jnz	_lret_
     8                              <1> 
     9 000011F2 817D3C80000000      <1> 	cmp	dword ptr [ebp+S_P], 128
    10 000011F9 74DC                <1> 	jz	_autoexit
    11                              <1> 
    12 000011FB E8AAFFFFFF          <1> _lret_:	call	stack_read1
    13 00001200 03049E              <1> 	add	eax, dword ptr [esi+ebx*4]
    14 00001203 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
    15 00001208 E921020000          <1> 	jmp	_j
    16                              <1> 
    17 0000120D F7869C040000000080- <1> _fret:	test	dword ptr [esi+PSR], 00800000h
    17 00001216 00                  <1>
    18 00001217 7509                <1> 	jnz	_fret_
    19                              <1> 
    20 00001219 817D3C80000000      <1> 	cmp	dword ptr [ebp+S_P], 128
    21 00001220 74B5                <1> 	jz	_autoexit
    22                              <1> 
    23 00001222 E85EFFFFFF          <1> _fret_:	call	stack_read2
    24 00001227 899680040000        <1> 	mov	dword ptr [esi+APC], edx
    25 0000122D 89C2                <1> 	mov	edx, eax
    26 0000122F 03549E04            <1> 	add	edx, dword ptr [esi+ebx*4+1*4]	; add EA as displacement to offset on stack
    27 00001233 8B049E              <1> 	mov	eax, dword ptr [esi+ebx*4]
    28 00001236 31DB                <1> 	xor	ebx, ebx			; 1-page frame?
    29 00001238 A900008000          <1> 	test	eax, 00800000h			; multipages frame?
    30 0000123D 7410                <1> 	jz	_fret_1page
    31 0000123F 89C3                <1> 	mov	ebx, eax
    32 00001241 C1E30C              <1> 	shl	ebx, 12
    33 00001244 0FB61C9D[01010000]  <1> 	movzx	ebx, byte ptr [_memory+ebx*4+64*4+1]
    34 0000124C C1EB02              <1> 	shr	ebx, 2
    35                              <1> 
    36                              <1> _fret_1page:
    37 0000124F E9E7030000          <1> 	jmp	_go2_frame
    38                              <1> 
    39 00001254 B803000000          <1> _fpxpo:	mov	eax, II_FPXPO
    40 00001259 B90C000000          <1> 	mov	ecx, LP_RANGE
    41 0000125E E9BAFCFFFF          <1> 	jmp	_ii_escape
    42                              <1> 
    37                                  	%include	"rta.msm"
     1                              <1> 
     2 00001263 80F904              <1> _sr:	cmp	cl, I
     3 00001266 0F84A9F8FFFF        <1> 	jz	_inA
     4 0000126C 80F905              <1> 	cmp	cl, XI
     5 0000126F 0F8499FBFFFF        <1> 	jz	_on
     6                              <1> 
     7 00001275 8B5D00              <1> 	mov	ebx, dword ptr [ebp+R]
     8 00001278 E967F2FFFF          <1> 	jmp	_operand_write
     9                              <1> 
    10 0000127D 80F904              <1> _sk:	cmp	cl, I
    11 00001280 0F849AF8FFFF        <1> 	jz	_inB
    12 00001286 80F905              <1> 	cmp	cl, XI
    13 00001289 0F8487FBFFFF        <1> 	jz	_off
    14                              <1> 
    15 0000128F 8B5D04              <1> 	mov	ebx, dword ptr [ebp+K]
    16 00001292 E94DF2FFFF          <1> 	jmp	_operand_write
    17                              <1> 
    18 00001297 80F904              <1> _sx:	cmp	cl, I
    19 0000129A 0F848BF8FFFF        <1> 	jz	_outA
    20 000012A0 80F905              <1> 	cmp	cl, XI
    21 000012A3 0F8471F7FFFF        <1> 	jz	_rsr
    22                              <1> 
    23 000012A9 8B5D08              <1> 	mov	ebx, dword ptr [ebp+X]
    24 000012AC E933F2FFFF          <1> 	jmp	_operand_write
    25                              <1> 
    26 000012B1 80F904              <1> _sy:	cmp	cl, I
    27 000012B4 0F8479F8FFFF        <1> 	jz	_outB
    28 000012BA 80F905              <1> 	cmp	cl, XI
    29 000012BD 0F84CAF7FFFF        <1> 	jz	_wsr
    30                              <1> 
    31 000012C3 8B5D0C              <1> 	mov	ebx, dword ptr [ebp+Y]
    32 000012C6 E919F2FFFF          <1> 	jmp	_operand_write;
    33                              <1> 
    34 000012CB 80F904              <1> _sa:	cmp	cl, I
    35 000012CE 0F841FF9FFFF        <1> 	jz	_reload
    36 000012D4 80F905              <1> 	cmp	cl, XI
    37 000012D7 7452                <1> 	jz	escape
    38                              <1> 
    39 000012D9 8B5D10              <1> 	mov	ebx, dword ptr [ebp+A]
    40 000012DC E903F2FFFF          <1> 	jmp	_operand_write
    41                              <1> 
    42 000012E1 80F904              <1> _sb:	cmp	cl, I
    43 000012E4 0F8426F9FFFF        <1> 	jz	_emulator_cool
    44 000012EA 80F905              <1> 	cmp	cl, XI
    45 000012ED 743C                <1> 	jz	escape
    46                              <1> 
    47 000012EF 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]
    48 000012F2 E9EDF1FFFF          <1> 	jmp	_operand_write
    49                              <1> 
    50 000012F7 80F904              <1> _z:	cmp	cl, I
    51 000012FA 0F8416F9FFFF        <1> 	jz	_sabr
    52 00001300 80F905              <1> 	cmp	cl, XI
    53 00001303 0F84DDFEFFFF        <1> 	jz	_lret
    54 00001309 31DB                <1> 	xor	ebx, ebx
    55 0000130B E9D4F1FFFF          <1> 	jmp	_operand_write
    56                              <1> 
    57 00001310 80F904              <1> _pop:	cmp	cl, I
    58 00001313 7416                <1> 	jz	escape
    59 00001315 80F905              <1> 	cmp	cl, XI
    60 00001318 0F84EFFEFFFF        <1> 	jz	_fret
    61                              <1> 
    62 0000131E E887FEFFFF          <1> 	call	stack_read1
    63 00001323 8B1C9E              <1> 	mov	ebx, dword ptr [esi+ebx*4]
    64 00001326 E9B9F1FFFF          <1> 	jmp	_operand_write
    65                              <1> 
    66 0000132B C3                  <1> escape	ret
    67                              <1> 
    68 0000132C E81EF0FFFF          <1> _lr:	call	_operand_read
    69 00001331 894500              <1> 	mov	dword ptr [ebp+R], eax
    70 00001334 C3                  <1> 	ret
    71                              <1> 
    72 00001335 E815F0FFFF          <1> _lk:	call	_operand_read
    73 0000133A 894504              <1> 	mov	dword ptr [ebp+K], eax
    74 0000133D C3                  <1> 	ret
    75 0000133E E80CF0FFFF          <1> _lx:	call	_operand_read
    76 00001343 894508              <1> 	mov	dword ptr [ebp+X], eax
    77 00001346 C3                  <1> 	ret
    78                              <1> 
    79 00001347 E803F0FFFF          <1> _ly:	call	_operand_read
    80 0000134C 89450C              <1> 	mov	dword ptr [ebp+Y], eax
    81 0000134F C3                  <1> 	ret
    82                              <1> 
    83 00001350 E8FAEFFFFF          <1> _la:	call	_operand_read
    84 00001355 894510              <1> 	mov	dword ptr [ebp+A], eax
    85 00001358 C3                  <1> 	ret
    86                              <1> 
    87 00001359 E8F1EFFFFF          <1> _lb:	call	_operand_read
    88 0000135E 894514              <1> 	mov	dword ptr [ebp+B], eax
    89 00001361 C3                  <1> 	ret
    90                              <1> 
    91 00001362 80F904              <1> _tz:	cmp	cl, I
    92 00001365 0F8411140000        <1> 	jz	near _rex
    93 0000136B 80F905              <1> 	cmp	cl, XI
    94 0000136E B900000000          <1> 	mov	ecx, 0
    95 00001373 0F847DFBFFFF        <1> 	jz	_ii_instruction
    96                              <1> 
    97 00001379 E8D1EFFFFF          <1> 	call	_operand_read
    98 0000137E A9FFFFFF00          <1> 	test	eax, 00FFFFFFh
    99 00001383 7503                <1> 	jnz	_tz_
   100 00001385 83C204              <1> 	add	edx, 4
   101 00001388 C3                  <1> _tz_:	ret
   102                              <1> 
   103 00001389 80F904              <1> _tp:	cmp	cl, I
   104 0000138C 742D                <1> 	jz	_jdz
   105 0000138E 80F905              <1> 	cmp	cl, XI
   106 00001391 0F8434FCFFFF        <1> 	jz	_ir
   107                              <1> 
   108 00001397 E8B3EFFFFF          <1> 	call	_operand_read
   109 0000139C A900008000          <1> 	test	eax, 00800000h
   110 000013A1 7503                <1> 	jnz	_tp_
   111 000013A3 83C204              <1> 	add	edx, 4
   112 000013A6 C3                  <1> _tp_:	ret
   113                              <1> 
   114 000013A7 E8A3EFFFFF          <1> _push:	call	_operand_read
   115 000013AC 8BB560020000        <1> 	mov	esi, dword ptr [ebp+CORE_INDEX1]
   116 000013B2 E88FFCFFFF          <1> 	call	stack1
   117 000013B7 89049E              <1> 	mov	dword ptr [esi+ebx*4], eax
   118 000013BA C3                  <1> 	ret
   119                              <1> 
   120 000013BB 8B5D14              <1> _jdz:	mov	ebx, dword ptr [ebp+B]
   121 000013BE 0B5D10              <1> 	or	ebx, dword ptr [ebp+A]
   122 000013C1 0F8467000000        <1> 	jz	near _j
   123 000013C7 C3                  <1> 	ret
   124                              <1> 
   125 000013C8 8B5D00              <1> _jdr:	mov	ebx, dword ptr [ebp+R]	; dec r and jump if it passed from zero to -1
   126 000013CB 81C3FFFFFF00        <1> 	add	ebx, 00FFFFFFh
   127 000013D1 C1C308              <1> 	rol	ebx, 8
   128 000013D4 88D9                <1> 	mov	cl, bl
   129 000013D6 C1EB08              <1> 	shr	ebx, 8			; write back to registers only 00000000 thru 00FFFFFF
   130 000013D9 895D00              <1> 	mov	dword ptr [ebp+R], ebx
   131 000013DC F6C101              <1> 	test	cl, 1
   132 000013DF 754D                <1> 	jnz	_j
   133 000013E1 C3                  <1> 	ret
   134                              <1> 
   135 000013E2 E85FFCFFFF          <1> _lcal:	call	stack1
   136 000013E7 2B9688040000        <1> 	sub	edx, dword ptr [esi+B0P]
   137 000013ED C1EA02              <1> 	shr	edx, 2
   138 000013F0 89149E              <1> 	mov	dword ptr [esi+ebx*4], edx
   139 000013F3 EB39                <1> 	jmp	_j			; EA is in eax
   140 000013F5 C3                  <1> 	ret
   141                              <1> 
   142 000013F6 F7869C040000010000- <1> _jnc:	test	dword ptr [esi+PSR], 1
   142 000013FF 00                  <1>
   143 00001400 742C                <1> 	jz	_j
   144 00001402 C3                  <1> 	ret
   145                              <1> 
   146 00001403 F7869C040000010000- <1> _jc:	test	dword ptr [esi+PSR], 1
   146 0000140C 00                  <1>
   147 0000140D 751F                <1> 	jnz	_j
   148 0000140F C3                  <1> 	ret
   149                              <1> 
   150 00001410 F7451001000000      <1> _jao:	test	dword ptr [ebp+A], 1
   151 00001417 7515                <1> 	jnz	_j
   152 00001419 C3                  <1> 	ret
   153                              <1> 
   154 0000141A F7451000008000      <1> _jpa:	test	dword ptr [ebp+A], 00800000h
   155 00001421 740B                <1> 	jz	_j
   156 00001423 C3                  <1> 	ret
   157                              <1> 
   158 00001424 F7451400008000      <1> _jpb:	test	dword ptr [ebp+B], 00800000h
   159 0000142B 7401                <1> 	jz	_j
   160 0000142D C3                  <1> 	ret
   161                              <1> 
   162 0000142E 89D7                <1> _j:	mov	edi, edx			; save position for error handling
   163 00001430 8B9688040000        <1> 	mov	edx, dword ptr [esi+B0P]
   164                              <1> 
   165 00001436 C1E002              <1> 	shl	eax, 2
   166 00001439 01C2                <1> 	add	edx, eax
   167 0000143B 3B9684040000        <1> 	cmp	edx, dword ptr [esi+APCZ]
   168 00001441 7701                <1> 	ja	_j_check
   169 00001443 C3                  <1> 	ret
   170                              <1> 
   171                              <1> _j_check:
   172 00001444 89FA                <1> 	mov	edx, edi			; restore updated apc
   173 00001446 B90E000000          <1> 	mov	ecx, LP_ADDRESS
   174 0000144B E9C8FAFFFF          <1> 	jmp	guard_ii_escape			; for interrupt come-from
   175                              <1> 
   176 00001450 E8BF100000          <1> _jpo:	call	NEAR _get_parity
   177 00001455 7BD7                <1> 	jpo	_j
   178 00001457 C3                  <1> 	ret
   179                              <1> 
   180 00001458 816510FFFFFF00      <1> _jza:	and	dword ptr [ebp+A], 00FFFFFFh
   181 0000145F 74CD                <1> 	jz	_j
   182 00001461 C3                  <1> 	ret
   183                              <1> 
   184 00001462 816514FFFFFF00      <1> _jzb:	and	dword ptr [ebp+B], 00FFFFFFh
   185 00001469 74C3                <1> 	jz	_j
   186 0000146B C3                  <1> 	ret
   187                              <1> 
   188 0000146C 816510FFFFFF00      <1> _jnza:	and	dword ptr [ebp+A], 00FFFFFFh
   189 00001473 75B9                <1> 	jnz	_j
   190 00001475 C3                  <1> 	ret
   191                              <1> 
   192 00001476 816514FFFFFF00      <1> _jnzb:	and	dword ptr [ebp+B], 00FFFFFFh
   193 0000147D 75AF                <1> 	jnz	_j
   194 0000147F C3                  <1> 	ret
   195                              <1> 
   196 00001480 F7451000008000      <1> _jna:	test	dword ptr [ebp+A], 00800000h
   197 00001487 75A5                <1> 	jnz	_j
   198 00001489 C3                  <1> 	ret
   199                              <1> 
   200 0000148A F7451400008000      <1> _jnb:	test	dword ptr [ebp+B], 00800000h
   201 00001491 759B                <1> 	jnz	_j
   202 00001493 C3                  <1> 	ret
   203                              <1> 
   204 00001494 8B5D08              <1> _jxge:	mov	ebx, dword ptr [ebp+X]
   205 00001497 2B5D00              <1> 	sub	ebx, dword ptr [ebp+R]
   206 0000149A F7C300000001        <1> 	test	ebx, 01000000h		; microcarry?
   207 000014A0 748C                <1> 	jz	_j			; no:  x <  r,    jump
   208 000014A2 C3                  <1> 	ret				; yes: x >= r, no jump
   209                              <1> 
   210 000014A3 8B5D0C              <1> _jyge:	mov	ebx, dword ptr [ebp+Y]
   211 000014A6 2B5D00              <1> 	sub	ebx, dword ptr [ebp+R]
   212 000014A9 F7C300000001        <1> 	test	ebx, 01000000h		; microcarry?
   213 000014AF 0F8479FFFFFF        <1> 	jz	_j			; no:  y <  r,    jump
   214 000014B5 C3                  <1> 	ret				; yes: y >= r, no jump
   215                              <1> 
   216 000014B6 BB04000000          <1> _qs:	mov	ebx, a
   217 000014BB E9AEEFFFFF          <1> 	jmp	_burst_write4
   218                              <1> 
   219 000014C0 BB04000000          <1> _ql:	mov	ebx, a
   220 000014C5 E958EEFFFF          <1> 	jmp	_burst_read4
   221                              <1> 
   222 000014CA E891FCFFFF          <1> _qpop:	call	stack_read4			; places 4 stack registers in the scope of burst write
   223 000014CF 55                  <1> 	push	ebp
   224 000014D0 8BAD60020000        <1> 	mov	ebp, dword ptr [ebp+CORE_INDEX1] 
   225 000014D6 E893EFFFFF          <1> 	call	_burst_write4
   226 000014DB 5D                  <1> 	pop	ebp
   227 000014DC C3                  <1> 	ret					; stack pointers are absolute
   228                              <1> 
   229 000014DD E807FCFFFF          <1> _qpush: call	stack4
   230 000014E2 55                  <1> 	push	ebp
   231 000014E3 8BAD60020000        <1> 	mov	ebp, dword ptr [ebp+CORE_INDEX1]
   232 000014E9 E834EEFFFF          <1> 	call	_burst_read4
   233 000014EE 5D                  <1> 	pop	ebp
   234 000014EF C3                  <1> 	ret
   235                              <1> 
   236 000014F0 E890FCFFFF          <1> _dpop:	call	stack_read2
   237 000014F5 55                  <1> 	push	ebp
   238 000014F6 8BAD60020000        <1> 	mov	ebp, dword ptr [ebp+CORE_INDEX1]
   239 000014FC E8B2EFFFFF          <1> 	call	_burst_write2
   240 00001501 5D                  <1> 	pop	ebp
   241 00001502 C3                  <1> 	ret
   242                              <1> 
   243 00001503 E895FBFFFF          <1> _dpush:	call	stack2
   244 00001508 E800EEFFFF          <1> 	call	_burst_read2			; ebx overwritten
   245 0000150D 8B4D3C              <1> 	mov	ecx, dword ptr [ebp+S_P]	; but still here with required (new) offset
   246 00001510 8BB560020000        <1> 	mov	esi, dword ptr [ebp+CORE_INDEX1]
   247 00001516 895C8E04            <1> 	mov	dword ptr [esi+ecx*4+4], ebx	; stack the data
   248 0000151A 89048E              <1> 	mov	dword ptr [esi+ecx*4], eax
   249 0000151D C3                  <1> 	ret
   250                              <1> 
   251 0000151E E82CEEFFFF          <1> _mta:	call	_operand_read
   252 00001523 334510              <1> 	xor	eax, dword ptr [ebp+A]
   253 00001526 234504              <1> 	and	eax, dword ptr [ebp+K]
   254 00001529 7503                <1> 	jnz	_mta_
   255 0000152B 83C204              <1> 	add	edx, 4		; k AND (a XOR operand) = 0, skip 1 instruction
   256 0000152E C3                  <1> _mta_:	ret
   257                              <1> 
   258 0000152F E8D9EDFFFF          <1> _dte:	call	_burst_read2
   259 00001534 334510              <1> 	xor	eax, dword ptr [ebp+A]
   260 00001537 7508                <1> 	jnz	_dte_
   261 00001539 335D14              <1> 	xor	ebx, dword ptr [ebp+B]
   262 0000153C 7503                <1> 	jnz	_dte_
   263 0000153E 83C204              <1> 	add	edx, 4
   264 00001541 C3                  <1> _dte_:	ret	
   265                              <1> 
   266 00001542 8B9E9C040000        <1> _sc:	mov	ebx, dword ptr [esi+PSR]
   267 00001548 83E301              <1> 	and	ebx, 1		; store carry 
   268 0000154B E994EFFFFF          <1> 	jmp	_operand_write
   269                              <1> 
   270 00001550 E8FAEDFFFF          <1> _mlb:	call	_operand_read
   271 00001555 8B5D04              <1> 	mov	ebx, dword ptr [ebp+K]
   272 00001558 21D8                <1> 	and	eax, ebx
   273 0000155A 81F3FFFFFF00        <1> 	xor	ebx, 00FFFFFFh
   274 00001560 235D14              <1> 	and	ebx, dword ptr [ebp+B]
   275 00001563 09C3                <1> 	or	ebx, eax
   276 00001565 895D14              <1> 	mov	dword ptr [ebp+B], ebx	; b = (b AND (NOT k)) OR (operand AND k)
   277 00001568 C3                  <1> 	ret
   278                              <1> 
   279 00001569 BB04000000          <1> _ds:	mov	ebx, a
   280 0000156E E940EFFFFF          <1> 	jmp	_burst_write2
   281                              <1> 
   282 00001573 E895EDFFFF          <1> _dl:	call	_burst_read2
   283 00001578 895D14              <1> 	mov	dword ptr [ebp+B], ebx
   284 0000157B 894510              <1> 	mov	dword ptr [ebp+A], eax
   285 0000157E C3                  <1> 	ret
   286                              <1> 
   287 0000157F C3                  <1> _spare:	ret
   288                              <1> 
   289 00001580 E8DDF0FFFF          <1> _ex:	call	memory_read
   290 00001585 8BB560020000        <1> 	mov	esi, dword ptr [ebp+CORE_INDEX1]
   291 0000158B E9C3EBFFFF          <1> 	jmp	_execute
   292                              <1> 
   293 00001590 E804F1FFFF          <1> _ts:	call	memory_lock			; edi + esi -> memory word
   294 00001595 66B80080            <1> 	mov	ax, 08000h
   295 00001599 668704B7            <1> 	xchg	ax, word ptr [edi+esi*4]	; swap -> t1 for 080 under lock
   296 0000159D 6621C0              <1> 	and	ax, ax
   297 000015A0 7803                <1> 	js	_ts___				; no action if already locked
   298                              <1> 
   299 000015A2 83C204              <1> 	add	edx, 4				; skip if ms bit was clear before
   300                              <1> 
   301 000015A5 C3                  <1> _ts___:	ret
   302                              <1> 
   303                              <1> 
   304 000015A6 E8C2F0FFFF          <1> _sim:	call	memoreg				; edi -> device		edi <- NULL
   305                              <1> 						; esi -> word	OR	ebx -> register
   306                              <1> 						; eax <- data
   307 000015AB 8B8D60020000        <1> 	mov	ecx, dword ptr [ebp+CORE_INDEX1]
   308 000015B1 66C1E008            <1> 	shl	ax, 8
   309 000015B5 8A819E040000        <1> 	mov	al, byte ptr [ecx+PSR+2]
   310 000015BB C1C803              <1> 	ror	eax, 3
   311 000015BE C0C003              <1> 	rol	al, 3
   312 000015C1 88819E040000        <1> 	mov	byte ptr [ecx+PSR+2], al
   313 000015C7 C1E81D              <1> 	shr	eax, 32-3
   314                              <1> 
   315 000015CA E97EF0FFFF          <1> 	jmp	memoreg_writeback
   316                              <1> 
   317 000015CF 52                  <1> _call:	push	edx
   318 000015D0 E8C8FAFFFF          <1> 	call	stack2
   319 000015D5 2B9688040000        <1> 	sub	edx, dword ptr [esi+B0P]
   320 000015DB C1EA02              <1> 	shr	edx, 2
   321 000015DE 89549E04            <1> 	mov	dword ptr [esi+ebx*4+1*4], edx
   322 000015E2 8B96A4040000        <1> 	mov	edx, dword ptr [esi+B0_NAME]
   323 000015E8 89149E              <1> 	mov	dword ptr [esi+ebx*4], edx
   324 000015EB 5A                  <1> 	pop	edx		; in case the jump goes wrong
   325                              <1> 				; and an interrupt frame needs constructed
   326                              <1> 
   327 000015EC 899680040000        <1> _go:	mov	dword ptr [esi+APC], edx
   328 000015F2 E858EDFFFF          <1> 	call	_operand_read	; may be memory or register
   329                              <1> 
   330 000015F7 8BB560020000        <1> 	mov	esi, dword ptr [ebp+CORE_INDEX1]
   331                              <1> 
   332 000015FD 89C2                <1> 	mov	edx, eax	; lookaside to calculate the vector
   333 000015FF A900008000          <1> 	test	eax, 00800000h	; gate?
   334 00001604 7428                <1> 	jz	_go2_4k_frame
   335                              <1> 
   336 00001606 25FFFF7F00          <1> 	and	eax, 007FFFFFh	; read the gate constant
   337 0000160B E8FDECFFFF          <1> 	call	_burst_read2	;
   338                              <1> 
   339 00001610 8BB560020000        <1> 	mov	esi, dword ptr [ebp+CORE_INDEX1]
   340                              <1> 
   341 00001616 89C2                <1> 	mov	edx, eax	; page high index ++ word offset
   342 00001618 89D8                <1> 	mov	eax, ebx	; storage block base page index
   343 0000161A C1C20E              <1> 	rol	edx, 6+8
   344 0000161D 89D3                <1> 	mov	ebx, edx	; instruction frame page high index
   345 0000161F 83E33F              <1> 	and	ebx, 63
   346 00001622 7405                <1> 	jz	_go_gate	; one page iframe
   347 00001624 0D00008000          <1> 	or	eax, 00800000h	; two+ page iframe
   348                              <1> 
   349                              <1> _go_gate:
   350 00001629 C1EA0E              <1> 	shr	edx, 6+8	; net word offset
   351                              <1> 
   352 0000162C EB0D                <1> 	jmp	_go2_frame
   353                              <1> 	
   354                              <1> _go2_4k_frame:
   355 0000162E 83E23F              <1> 	and	edx, 63		; target is in 4k block, 64 vectors
   356 00001631 C1E806              <1> 	shr	eax, 6		; new b0_name
   357 00001634 25FFFF0000          <1> 	and	eax, 0000FFFFh	; bit 22 of GO / CALL word reserved
   358 00001639 31DB                <1> 	xor	ebx, ebx	; frame high page index
   359                              <1> 
   360                              <1> _go2_frame:
   361 0000163B F6869E04000080      <1> 	test	byte ptr [esi+PSR+2], 128	; already in interrupt code?
   362 00001642 751B                <1> 	jnz	_go2_base_frame	; 	; may branch into interrupt code
   363                              <1> 					; because he is interrupt code
   364 00001644 89C1                <1> 	mov	ecx, eax
   365 00001646 81E1FFFF3F00        <1> 	and	ecx, 03FFFFFh
   366 0000164C 2B8EEC050000        <1> 	sub	ecx, dword ptr [esi+IO_PORT+72*4]	; applications lower limit
   367 00001652 7D0B                <1> 	jnl	_go2_base_frame
   368                              <1> 
   369 00001654 8B9680040000        <1> 	mov	edx, dword ptr [esi+APC]
   370 0000165A E9B4F8FFFF          <1> 	jmp	guard_ii_authority
   371                              <1> 
   372                              <1> _go2_base_frame:
   373                              <1> 
   374 0000165F 8986A4040000        <1> 	mov	dword ptr [esi+B0_NAME], eax	; with flags
   375 00001665 25FFFF3F00          <1> 	and	eax, 003FFFFFh			; base page index only
   376 0000166A 01C3                <1> 	add	ebx, eax
   377 0000166C 899ECC050000        <1> 	mov	dword ptr [esi+IO_PORT+64*4], ebx
   378                              <1> 
   379                              <1> 	%if	1
   380 00001672 8B8ECC060000        <1> 	mov	ecx, dword ptr [esi+IO_PORT+128*4]	; memory page high index
   381 00001678 81E1FFFF3F00        <1> 	and	ecx, 003FFFFFh			; strip memory type bits
   382 0000167E 29D9                <1> 	sub	ecx, ebx			; iframe high page may be = not >
   383 00001680 7910                <1> 	jns	_go2_frame_in_range
   384                              <1> 
   385 00001682 B90E000000          <1> 	mov	ecx, LP_ADDRESS
   386 00001687 8B9680040000        <1> 	mov	edx, dword ptr [esi+APC]
   387 0000168D E986F8FFFF          <1> 	jmp	guard_ii_escape
   388                              <1> 
   389                              <1> _go2_frame_in_range:
   390                              <1> 
   391                              <1> 	%else
   392                              <1> 	PATH NOT IN USE
   393                              <1> 	mov	ecx, dword ptr [esi+IO_PORT+128*4]	; have we the highest frame page?
   394                              <1> 	and	ecx, 003FFFFFh			; read highest page index
   395                              <1> ; NO!	mov	esi, LP_ADDRESS			; trim off flags
   396                              <1> 	sub	ecx, ebx			; compare
   397                              <1> 	xchg	edx, dword ptr [esi+APC]
   398                              <1> 	js	guard_ii_escape			; if negative that should catch it
   399                              <1> 	xchg	edx, dword ptr [esi+APC]
   400                              <1> 	%endif
   401                              <1> 
   402 00001692 C1E30C              <1> 	shl	ebx, 12
   403 00001695 8D1C9D[FC3F0000]    <1> 	lea	ebx, [_memory+ebx*4+4095*4]	; last instruction word in iframe
   404                              <1> 						; higher = wrong
   405 0000169C 899E84040000        <1> 	mov	dword ptr [esi+APCZ], ebx	; set execution limit pointer
   406                              <1> 
   407 000016A2 8986CC040000        <1> 	mov	dword ptr [esi+IO_PORT], eax
   408 000016A8 C1E00E              <1> 	shl	eax, 12+2	; 4kword block multiplied by 4 for word
   409 000016AB 05[00000000]        <1> 	add	eax, _memory	; add the platform location of executable space
   410 000016B0 898688040000        <1> 	mov	dword ptr [esi+B0P], eax
   411 000016B6 C1E202              <1> 	shl	edx, 2		; add the vector offset * 4 for word
   412 000016B9 01C2                <1> 	add	edx, eax
   413 000016BB C3                  <1> _go_:	ret
   414                              <1> 
    38                                  	%include	"alu.msm"
     1                              <1> 
     2                              <1> 
     3 000016BC E88EECFFFF          <1> _ax:	call	_operand_read
     4 000016C1 034508              <1> 	add	eax, dword ptr [ebp+X]
     5 000016C4 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
     6 000016C9 894508              <1> 	mov	dword ptr [ebp+X], eax
     7 000016CC C3                  <1> 	ret
     8                              <1> 
     9 000016CD E87DECFFFF          <1> _ay:	call	_operand_read
    10 000016D2 03450C              <1> 	add	eax, dword ptr [ebp+Y]
    11 000016D5 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
    12 000016DA 89450C              <1> 	mov	dword ptr [ebp+Y], eax
    13 000016DD C3                  <1> 	ret
    14                              <1> 
    15 000016DE E86CECFFFF          <1> _or:	call	_operand_read
    16 000016E3 094510              <1> 	or	dword ptr [ebp+A], eax
    17 000016E6 C3                  <1> 	ret
    18                              <1> 
    19 000016E7 E863ECFFFF          <1> _orB:	call	_operand_read
    20 000016EC 094514              <1> 	or	dword ptr [ebp+B], eax
    21 000016EF C3                  <1> 	ret
    22                              <1> 
    23 000016F0 E85AECFFFF          <1> _and:	call	_operand_read
    24 000016F5 214510              <1> 	and	dword ptr [ebp+A], eax
    25 000016F8 C3                  <1> 	ret
    26                              <1> 
    27 000016F9 E851ECFFFF          <1> _andB:	call	_operand_read
    28 000016FE 214514              <1> 	and	dword ptr [ebp+B], eax
    29 00001701 C3                  <1> 	ret
    30                              <1> 
    31 00001702 E848ECFFFF          <1> _xor:	call	_operand_read
    32 00001707 314510              <1> 	xor	dword ptr [ebp+A], eax
    33 0000170A C3                  <1> 	ret
    34                              <1> 
    35 0000170B E83FECFFFF          <1> _xorB:	call	_operand_read
    36 00001710 314514              <1> 	xor	dword ptr [ebp+B], eax
    37 00001713 C3                  <1> 	ret
    38                              <1> 
    39 00001714 E836ECFFFF          <1> _aa:	call	_operand_read
    40 00001719 EB0D                <1> 	jmp	_aa_
    41                              <1> 
    42 0000171B E82FECFFFF          <1> _ana:	call	_operand_read
    43 00001720 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
    44 00001725 83C001              <1> 	add	eax, 1
    45                              <1> 
    46 00001728 034510              <1> _aa_:	add	eax, dword ptr [ebp+A]
    47 0000172B E8BC040000          <1> 	call	_alu_carry
    48                              <1> 
    49 00001730 894510              <1> 	mov	dword ptr [ebp+A], eax
    50 00001733 C3                  <1> 	ret
    51                              <1> 
    52 00001734 E816ECFFFF          <1> _ab:	call	_operand_read
    53 00001739 EB0D                <1> 	jmp	_ab_
    54                              <1> 
    55 0000173B E80FECFFFF          <1> _anb:	call	_operand_read
    56 00001740 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
    57 00001745 83C001              <1> 	add	eax, 1
    58                              <1> 
    59 00001748 034514              <1> _ab_:	add	eax, dword ptr [ebp+B]
    60 0000174B E89C040000          <1> 	call	_alu_carry
    61                              <1> 
    62 00001750 894514              <1> 	mov	dword ptr [ebp+B], eax
    63 00001753 C3                  <1> 	ret
    64                              <1> 
    65 00001754 52                  <1> _m:	push	edx			; 80386 platform has it ready made, so
    66 00001755 E8F5EBFFFF          <1> 	call	_operand_read
    67 0000175A C1E008              <1> 	shl	eax, 8			; prepare multiplier to be multiplicand 
    68 0000175D C1F808              <1> 	sar	eax, 8			; sign it in eax
    69 00001760 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]	; this is register side multiplicand but
    70                              <1> 					; it makes no difference which is which
    71 00001763 C1E308              <1> 	shl	ebx, 8			; so use it as multiplier if that is OK
    72 00001766 C1FB08              <1> 	sar	ebx, 8			; sign it first
    73                              <1> 
    74 00001769 F7EB                <1> 	imul	ebx
    75                              <1> 
    76 0000176B C1C008              <1> 	rol	eax, 8			; move 8 bits up from eax to edx
    77 0000176E C1E208              <1> 	shl	edx, 8
    78 00001771 88C2                <1> 	mov	dl, al
    79 00001773 C1E808              <1> 	shr	eax, 8
    80 00001776 894514              <1> 	mov	dword ptr [ebp+B], eax	; product bits 23..0
    81 00001779 C1E208              <1> 	shl	edx, 8
    82 0000177C C1EA08              <1> 	shr	edx, 8
    83 0000177F 895510              <1> 	mov	dword ptr [ebp+A], edx	; product high order bits
    84 00001782 5A                  <1> 	pop	edx
    85 00001783 C3                  <1> 	ret
    86                              <1> 
    87 00001784 52                  <1> _mf:	push	edx		; the multiplier is signed the multiplicand unsigned
    88 00001785 E8C5EBFFFF          <1> 	call	_operand_read
    89 0000178A 89C1                <1> 	mov	ecx, eax	; just to remember the multiplier sign
    90 0000178C A900008000          <1> 	test	eax, 00800000h
    91 00001791 7408                <1> 	jz	_mfplusplus
    92 00001793 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
    93 00001798 83C001              <1> 	add	eax, 1
    94                              <1> _mfplusplus:
    95 0000179B 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]	; this is the multiplicand, unsigned
    96 0000179E F7E3                <1> 	mul	ebx		; two 24-bit unsigned values should be OK here
    97 000017A0 C1C008              <1> 	rol	eax, 8
    98 000017A3 C1E208              <1> 	shl	edx, 8
    99 000017A6 88C2                <1> 	mov	dl, al
   100 000017A8 C1E808              <1> 	shr	eax, 8
   101 000017AB C1E208              <1> 	shl	edx, 8
   102 000017AE C1EA08              <1> 	shr	edx, 8
   103 000017B1 F7C100008000        <1> 	test	ecx, 00800000h	; was the multiplier signed?
   104 000017B7 741F                <1> 	jz	_mfstore
   105 000017B9 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   106 000017BE 81F2FFFFFF00        <1> 	xor	edx, 00FFFFFFh
   107 000017C4 83C001              <1> 	add	eax, 1
   108 000017C7 C1C008              <1> 	rol	eax, 8
   109 000017CA 0FB6C8              <1> 	movzx	ecx, al
   110 000017CD C1E808              <1> 	shr	eax, 8
   111 000017D0 01CA                <1> 	add	edx, ecx
   112 000017D2 81E2FFFFFF00        <1> 	and	edx, 00FFFFFFh
   113                              <1> _mfstore:
   114 000017D8 894514              <1> 	mov	dword ptr [ebp+B], eax
   115 000017DB 895510              <1> 	mov	dword ptr [ebp+A], edx
   116 000017DE 5A                  <1> 	pop	edx
   117 000017DF C3                  <1> 	ret
   118                              <1> 
   119 000017E0 BF04000000          <1> _d:	mov	edi, a
   120 000017E5 E80A000000          <1> 	call	_divide
   121 000017EA 895D10              <1> 	mov	dword ptr [ebp+A], ebx
   122 000017ED 894518              <1> 	mov	dword ptr [ebp+MANTISSA2], eax
   123 000017F0 894D14              <1> 	mov	dword ptr [ebp+B], ecx
   124 000017F3 C3                  <1> 	ret
   125                              <1> 
   126                              <1> 	%if	1
   127                              <1> 
   128                              <1> ;	this divide made from 2 Intel divides should be a better method
   129                              <1> ;	than the procession of 1-bit shifts and test subtracts
   130                              <1> ;	which is the %else which it replaces. That also works
   131                              <1> 
   132                              <1> ;	this converts to and from positive magnitude
   133                              <1> ;	because zoning the 2nd divide with a zero 1st remainder
   134                              <1> ;	can't tell +0 from -0 in platform 2s complement
   135                              <1> 
   136                              <1> ;	polarity conversions before and after need no explanation
   137                              <1> 
   138                              <1> ;	1st dividend is 48 zero bits and high order 16 data bits
   139                              <1> ;	of the the 48-bit RTA1 dividend
   140                              <1> 
   141                              <1> ;	2nd dividend is 1st remainder and the remaining 32 bits
   142                              <1> ;	the the RTA1 dividend
   143                              <1> 
   144                              <1> ;	input is compressed from 24-bit words and output unpacked
   145                              <1> ;	to 24-bit words
   146                              <1> 
   147                              <1> ;	64-bit dividend in 386 mode is high order bits in edx, low in eax
   148                              <1> ;	platform faults if quotient carries from eax. Remainder in edx
   149                              <1> 
   150                              <1> ;	RTA1 quotient is 48 bits so it takes 2 divides in 32-bit mode
   151                              <1> 
   152                              <1> _divide:
   153 000017F4 52                  <1> 	push	edx
   154 000017F5 57                  <1> 	push	edi
   155 000017F6 E854EBFFFF          <1> 	call	_operand_read	; read divisor
   156 000017FB 5F                  <1> 	pop	edi
   157 000017FC 31C9                <1> 	xor	ecx, ecx	; final sign
   158 000017FE A900008000          <1> 	test	eax, 00800000h
   159 00001803 7408                <1> 	jz	_dsig?
   160 00001805 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   161 0000180A F7D1                <1> 	not	ecx		; reverse final sign
   162 0000180C 40                  <1> 	inc	eax
   163 0000180D 25FFFFFF00          <1> _dsig?:	and	eax, 00FFFFFFh	; check zerodiv here mebbes
   164 00001812 89C3                <1> 	mov	ebx, eax	; eax will be used twice as divisor LS word
   165 00001814 746D                <1> 	jz	_d_ont		; zero results in eax ebx already
   166                              <1> 
   167 00001816 8B44BD04            <1> 	mov	eax, dword ptr [ebp+edi*4+4]
   168 0000181A 8B54BD00            <1> 	mov	edx, dword ptr [ebp+edi*4]
   169 0000181E C1E008              <1> 	shl	eax, 8		; pack two 24-bit words to 64 bits 
   170 00001821 88D0                <1> 	mov	al, dl
   171 00001823 C1C808              <1> 	ror	eax, 8
   172 00001826 C1E208              <1> 	shl	edx, 8
   173 00001829 C1EA10              <1> 	shr	edx, 16
   174 0000182C 6689D1              <1> 	mov	cx, dx		; save dividend sign
   175 0000182F 6621D2              <1> 	and	dx, dx		; bit 47 on?
   176 00001832 7912                <1> 	jns	_dive_in
   177                              <1> 
   178 00001834 81F10000FFFF        <1> 	xor	ecx, 0FFFF0000h	; reverse final sign
   179 0000183A F7D0                <1> 	not	eax
   180 0000183C 66F7D2              <1> 	not	dx
   181 0000183F 83C001              <1> 	add	eax, 1
   182 00001842 6683D200            <1> 	adc	dx, 0
   183                              <1> 
   184                              <1> _dive_in:
   185 00001846 89C6                <1> 	mov	esi, eax	; reserve 2nd dividend
   186 00001848 89D0                <1> 	mov	eax, edx	; position 1st dividend
   187 0000184A 31D2                <1> 	xor	edx, edx	; with leading zero
   188 0000184C F7F3                <1> 	div	ebx
   189 0000184E 96                  <1> 	xchg	eax, esi	; save 1st quotient
   190 0000184F F7F3                <1> 	div	ebx		; generate 2nd quotient
   191                              <1> 
   192 00001851 6621C9              <1> 	and	cx, cx		; dividend negative?
   193 00001854 7903                <1> 	jns	_d_remainder_plus
   194 00001856 F7D2                <1> 	not	edx
   195 00001858 42                  <1> 	inc	edx
   196                              <1> 
   197                              <1> _d_remainder_plus:
   198 00001859 81E2FFFFFF00        <1> 	and	edx, 00FFFFFFh
   199 0000185F 87D1                <1> 	xchg	edx, ecx	; remainder -> ecx / final sign -> edx
   200                              <1> 
   201 00001861 89C3                <1> 	mov	ebx, eax	; low order quotient
   202 00001863 89F0                <1> 	mov	eax, esi	; high order quotient
   203                              <1> 
   204 00001865 21D2                <1> 	and	edx, edx	; final sign?
   205 00001867 790C                <1> 	jns	_d_quotient_plus
   206                              <1> 
   207 00001869 F7D3                <1> 	not	ebx		; invert + increment quotient
   208 0000186B 66F7D0              <1> 	not	ax		; RTA1 integer is also 2s complement
   209 0000186E 83C301              <1> 	add	ebx, 1
   210 00001871 6683D000            <1> 	adc	ax, 0
   211                              <1> 
   212                              <1> _d_quotient_plus:
   213 00001875 0FB7C0              <1> 	movzx	eax, ax		; unpack from 32-bit words to 24-bit words
   214 00001878 C1E008              <1> 	shl	eax, 8		; move 8 bits up
   215 0000187B C1C308              <1> 	rol	ebx, 8
   216 0000187E 88D8                <1> 	mov	al, bl
   217 00001880 C1EB08              <1> 	shr	ebx, 8		; quotient in eax:ebx
   218                              <1> 
   219 00001883 5A                  <1> _d_ont:	pop	edx		; give back the emulated program counter
   220 00001884 C3                  <1> 	ret
   221                              <1> 
   222                              <1> 	%else
   223                              <1> 
   224                              <1> _divide:
   225                              <1> 	xor	ebx, ebx
   226                              <1> 	push	ebx		;
   227                              <1> 	push	ebx		; quotient
   228                              <1> 	push	ebx		; dividend[b]
   229                              <1> 	push	ebx		; dividend[a]
   230                              <1> 	push	ebx		; trailing divisor
   231                              <1> 	push	ebx		; divisor
   232                              <1> 	push	ebx		; signs2 
   233                              <1> 	push	ebx		; signs1
   234                              <1> 	mov	ebx, 24
   235                              <1> 	push	ebx		; beats
   236                              <1> 
   237                              <1> 
   238                              <1> _D_BEATS	equ	0
   239                              <1> _D_SIGNS1	equ	1*4
   240                              <1> _D_SIGNS2	equ	2*4
   241                              <1> _D_DIVISORU	equ	3*4
   242                              <1> _D_DIVISORL	equ	4*4
   243                              <1> _D_DIVIDENDU	equ	5*4
   244                              <1> _D_DIVIDENDL	equ	6*4
   245                              <1> _D_QUOTIENTU	equ	7*4
   246                              <1> _D_QUOTIENTL	equ	8*4
   247                              <1> 
   248                              <1> 	push	edi
   249                              <1> 	call	_operand_read
   250                              <1> 	pop	edi
   251                              <1> 
   252                              <1> 	test	eax, 00800000h
   253                              <1> 	jnz	_d_nmagnitude1			; must be stored negative
   254                              <1> 	xor	eax, 00FFFFFFh
   255                              <1> 	jmp	_d_nmagnitude2
   256                              <1> _d_nmagnitude1:
   257                              <1> 	add	eax, -1				; if it's already negative
   258                              <1> 	mov	dword ptr [esp+_D_SIGNS2], 0FFFFFFFFh
   259                              <1> _d_nmagnitude2:
   260                              <1> 	call	qscale
   261                              <1> 	cmp	bl, 24
   262                              <1> 	jz	_d_allsigns
   263                              <1> 	add	dword ptr [esp+_D_BEATS], ebx
   264                              <1> _d_allsigns:
   265                              <1> 	mov	ebx, 00FFFFFF00h ; make the divisor 48 bits contiguous	
   266                              <1> 	mov	bl, al
   267                              <1> 	ror	ebx, 8
   268                              <1> 	shl	eax, 8
   269                              <1> 	mov	ax, 65535
   270                              <1> 	ror	eax, 16
   271                              <1> 
   272                              <1> 	mov	dword ptr [esp+_D_DIVISORL], ebx
   273                              <1> 	mov	dword ptr [esp+_D_DIVISORU], eax
   274                              <1> 
   275                              <1> 	mov	ecx, 1				; precarry
   276                              <1> 
   277                              <1> ;	mov	ebx, dword ptr [ebp+B]	; dividend
   278                              <1> ;	mov	eax, dword ptr [ebp+A]
   279                              <1> 
   280                              <1> 	mov	ebx, dword ptr [ebp+edi*4+4]
   281                              <1> 	mov	eax, dword ptr [ebp+edi*4] 
   282                              <1> 
   283                              <1> 	test	eax, 00800000h
   284                              <1> 	jz	_d_pmagnitude			; must be stored positive
   285                              <1> 	mov	dword ptr [esp+_D_SIGNS1], 00FFFFFFFFh
   286                              <1> 	xor	ebx, 00FFFFFFh
   287                              <1> 	xor	eax, 00FFFFFFh
   288                              <1> 	add	ecx, ebx
   289                              <1> 	mov	ebx, ecx
   290                              <1> 	and	ebx, 00FFFFFFh
   291                              <1> 	shr	ecx, 24
   292                              <1> 	add	eax, ecx
   293                              <1> 	and	eax, 00FFFFFFh
   294                              <1> 
   295                              <1> _d_pmagnitude:
   296                              <1> 	shl	ebx, 8
   297                              <1> 	mov	bl, al
   298                              <1> 	ror	ebx, 8
   299                              <1> 	shl	eax, 8
   300                              <1> 	shr	eax, 16
   301                              <1> 	mov	dword ptr [esp+_D_DIVIDENDL], ebx
   302                              <1> 	mov	dword ptr [esp+_D_DIVIDENDU], eax
   303                              <1> 
   304                              <1> 	mov	ecx, dword ptr [esp+_D_BEATS]
   305                              <1> 
   306                              <1> 	add	ecx, -1
   307                              <1> _d_beat:			; iterative part as quick as possible
   308                              <1> 				; could study doing a pair of Intel divides here
   309                              <1> 	stc
   310                              <1> 	rcr	dword ptr [esp+_D_DIVISORU], 1
   311                              <1> 	rcr	dword ptr [esp+_D_DIVISORL], 1
   312                              <1> 
   313                              <1> 	stc
   314                              <1> 	adc	ebx, dword ptr [esp+_D_DIVISORL]
   315                              <1> 	adc	eax, dword ptr [esp+_D_DIVISORU]
   316                              <1> 
   317                              <1> 	jc	_d_carried
   318                              <1> 	mov	ebx, dword ptr [esp+_D_DIVIDENDL]
   319                              <1> 	mov	eax, dword ptr [esp+_D_DIVIDENDU]
   320                              <1> 	jmp	_d_carried_or_not
   321                              <1> 
   322                              <1> _d_carried:
   323                              <1> 	mov	dword ptr [esp+_D_DIVIDENDL], ebx
   324                              <1> 	mov	dword ptr [esp+_D_DIVIDENDU], eax
   325                              <1> 
   326                              <1> _d_carried_or_not:
   327                              <1> 	rcl	dword ptr [esp+_D_QUOTIENTL], 1
   328                              <1> 	rcl	dword ptr [esp+_D_QUOTIENTU], 1
   329                              <1> 	
   330                              <1> 	add	ecx, -1
   331                              <1> 	jc	_d_beat
   332                              <1> 
   333                              <1> 	pop	ecx		; BEATS
   334                              <1> 	pop	ecx		; SIGNS1
   335                              <1> 	pop	eax		; SIGNS2
   336                              <1> 	pop	ebx		; DIVISORU
   337                              <1> 	pop	ebx		; DIVISORL
   338                              <1> 	pop	ebx		; DIVIDENDU
   339                              <1> 	pop	ebx		; DIVIDENDL
   340                              <1> 
   341                              <1> 	xor	ebx, ecx	; set remainder to sign of dividend
   342                              <1> 	jns	_d_remplus
   343                              <1> 	inc	ebx		; set -remainder 2s complement
   344                              <1> 
   345                              <1> _d_remplus:
   346                              <1> 	and	ebx, 00FFFFFFh	; store remainder
   347                              <1> ;	mov	dword ptr [ebp+B], ebx
   348                              <1> 
   349                              <1> 	xor	ecx, eax	; set sign of quotient to difference of signs
   350                              <1> 	mov	ecx, ebx	; remainder for return
   351                              <1> 	pop	eax		; QUOTIENTU
   352                              <1> 	pop	ebx		; QUOTIENTL
   353                              <1> 
   354                              <1> 	jns	_d_quotient_plus		; cc set from xor of signy
   355                              <1> 
   356                              <1> 	not	eax
   357                              <1> 	not	ebx
   358                              <1> 	add	ebx, 1
   359                              <1> 	adc	eax, 0
   360                              <1> 
   361                              <1> _d_quotient_plus:
   362                              <1> 	shl	eax, 8
   363                              <1> 	rol	ebx, 8
   364                              <1> 	mov	al, bl
   365                              <1> 	shr	ebx, 8
   366                              <1> 	shl	eax, 8
   367                              <1> 	shr	eax, 8
   368                              <1> 
   369                              <1> ;	mov	dword ptr [ebp+A], ebx
   370                              <1> ;	mov	dword ptr [ebp+MANTISSA2], eax
   371                              <1> 	ret
   372                              <1> 
   373                              <1> 	%endif
   374                              <1> 
   375                              <1> 
   376 00001885 88C1                <1> _sar:	mov	cl, al			; eax shift radix is 31
   377 00001887 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
   378 0000188A F6C1E0              <1> 	test	cl, -32
   379 0000188D 7402                <1> 	jz	_sardo
   380 0000188F 31C0                <1> 	xor	eax, eax		; shift 32+ clears same as 24+
   381 00001891 D3E8                <1> _sardo:	shr	eax, cl
   382 00001893 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   383 00001898 894510              <1> 	mov	dword ptr [ebp+A], eax
   384 0000189B C3                  <1> 	ret
   385                              <1> 
   386 0000189C 88C1                <1> _sbr:	mov	cl, al
   387 0000189E 8B4514              <1> 	mov	eax, dword ptr [ebp+B]
   388 000018A1 F6C1E0              <1> 	test	cl, -32
   389 000018A4 7402                <1> 	jz	_sbrdo
   390 000018A6 31C0                <1> 	xor	eax, eax		; shift 32+ clears same as 24+
   391 000018A8 D3E8                <1> _sbrdo:	shr	eax, cl
   392 000018AA 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   393 000018AF 894514              <1> 	mov	dword ptr [ebp+B], eax
   394 000018B2 C3                  <1> 	ret
   395                              <1> 
   396                              <1> 
   397 000018B3 88C1                <1> _dsr:	mov	cl, al
   398 000018B5 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]
   399 000018B8 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
   400 000018BB E875000000          <1> 	call	dsr
   401 000018C0 895D14              <1> 	mov	dword ptr [ebp+B], ebx
   402 000018C3 894510              <1> 	mov	dword ptr [ebp+A], eax
   403 000018C6 C3                  <1> 	ret
   404                              <1> 
   405 000018C7 88C1                <1> _sal:	mov	cl, al			; shift radix eax is 31
   406 000018C9 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
   407 000018CC F6C1E0              <1> 	test	cl, -32
   408 000018CF 7402                <1> 	jz	_saldo
   409 000018D1 31C0                <1> 	xor	eax, eax		; shift 32+ clears same as 24+
   410 000018D3 D3E0                <1> _saldo:	shl	eax, cl
   411 000018D5 25FFFFFF00          <1> 	and	eax, 00FFFFFFh		; write back to registers only 00000000 thru 00FFFFFF
   412 000018DA 894510              <1> 	mov	dword ptr [ebp+A], eax
   413 000018DD C3                  <1> 	ret
   414                              <1> 
   415 000018DE 88C1                <1> _sbl:	mov	cl, al
   416 000018E0 8B4514              <1> 	mov	eax, dword ptr [ebp+B]
   417 000018E3 F6C1E0              <1> 	test	cl,-32
   418 000018E6 7402                <1> 	jz	_sbldo
   419 000018E8 31C0                <1> 	xor	eax, eax		; shift 32+ clears same as 24+
   420 000018EA D3E0                <1> _sbldo:	shl	eax, cl
   421 000018EC 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   422 000018F1 894514              <1> 	mov	dword ptr [ebp+B], eax
   423 000018F4 C3                  <1> 	ret
   424                              <1> 
   425 000018F5 88C1                <1> _dsl	mov	cl, al
   426 000018F7 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]
   427 000018FA 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
   428 000018FD E868000000          <1> 	call	dsl
   429 00001902 895D14              <1> 	mov	dword ptr [ebp+B], ebx
   430 00001905 894510              <1> 	mov	dword ptr [ebp+A], eax
   431 00001908 C3                  <1> 	ret
   432                              <1> 
   433 00001909 8B5D10              <1> _rar:	mov	ebx, dword ptr [ebp+A]
   434 0000190C E8C6000000          <1> 	call	rr
   435 00001911 895D10              <1> 	mov	dword ptr [ebp+A], ebx
   436 00001914 C3                  <1> 	ret
   437                              <1> 
   438 00001915 8B5D14              <1> _rbr:	mov	ebx, dword ptr [ebp+B]
   439 00001918 E8BA000000          <1> 	call	rr
   440 0000191D 895D14              <1> 	mov	dword ptr [ebp+B], ebx
   441 00001920 C3                  <1> 	ret
   442                              <1> 
   443 00001921 88C1                <1> _drr:	mov	cl, al
   444 00001923 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]
   445 00001926 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
   446 00001929 E8F7000000          <1> 	call	drr
   447 0000192E 895D14              <1> 	mov	dword ptr [ebp+B], ebx
   448 00001931 894510              <1> 	mov	dword ptr [ebp+A], eax
   449 00001934 C3                  <1> 	ret
   450                              <1> 
   451                              <1> 
   452 00001935 C1E008              <1> dsr:	shl	eax, 8
   453 00001938 C1E308              <1> 	shl	ebx, 8
   454 0000193B 80C1E8              <1> dsru:	add	cl, -24
   455 0000193E 7306                <1> 	jnc	dsrl
   456 00001940 89C3                <1> 	mov	ebx, eax
   457 00001942 31C0                <1> 	xor	eax, eax
   458 00001944 EBF5                <1> 	jmp	dsru
   459 00001946 80C110              <1> dsrl:	add	cl, 16
   460 00001949 730D                <1> 	jnc	dsr7
   461 0000194B C1E808              <1> dsr8:	shr	eax, 8
   462 0000194E 88C3                <1> 	mov	bl, al
   463 00001950 C1CB08              <1> 	ror	ebx, 8
   464 00001953 80C1F8              <1> 	add	cl,-8
   465 00001956 72F3                <1> 	jc	dsr8
   466 00001958 80E107              <1> dsr7:	and	cl, 7
   467 0000195B D3E8                <1> 	shr	eax, cl
   468 0000195D 88C3                <1> 	mov	bl, al		; bits from al in high-order positions bl
   469 0000195F D2C3                <1> 	rol	bl, cl		; roll them to low-order positions
   470 00001961 D3CB                <1> 	ror	ebx, cl
   471 00001963 C1EB08              <1> 	shr	ebx, 8
   472 00001966 C1E808              <1> 	shr	eax, 8
   473 00001969 C3                  <1> 	ret
   474                              <1> 
   475 0000196A C1E008              <1> dsl:	shl	eax, 8
   476 0000196D C1E308              <1> 	shl	ebx, 8
   477 00001970 80C1E8              <1> dslu:	add	cl, -24
   478 00001973 7306                <1> 	jnc	dsll
   479 00001975 89D8                <1> 	mov	eax, ebx
   480 00001977 31DB                <1> 	xor	ebx, ebx
   481 00001979 EBF5                <1> 	jmp	dslu
   482 0000197B 80C110              <1> dsll:	add	cl, 16
   483 0000197E 730F                <1> 	jnc	dsl7
   484 00001980 C1C308              <1> dsl8:	rol	ebx, 8
   485 00001983 88D8                <1> 	mov	al, bl
   486 00001985 30DB                <1> 	xor	bl, bl
   487 00001987 C1E008              <1> 	shl	eax, 8
   488 0000198A 80C1F8              <1> 	add	cl, -8
   489 0000198D 72F1                <1> 	jc	dsl8
   490 0000198F 80E107              <1> dsl7:	and	cl, 7
   491 00001992 D3C3                <1> 	rol	ebx, cl
   492 00001994 88D8                <1> 	mov	al, bl		; bits from bl in low-order positions al
   493 00001996 D2C8                <1> 	ror	al, cl		; roll them to high-order positions
   494 00001998 D3E0                <1> 	shl	eax, cl
   495 0000199A C1EB08              <1> 	shr	ebx, 8
   496 0000199D C1E808              <1> 	shr	eax, 8
   497 000019A0 C3                  <1> 	ret
   498                              <1> 
   499 000019A1 C1E008              <1> dsa:	shl	eax, 8
   500 000019A4 C1E308              <1> 	shl	ebx, 8
   501 000019A7 80C1E8              <1> dsa24:	add	cl, -24
   502 000019AA 7307                <1> 	jnc	dsa16
   503 000019AC 89C3                <1> 	mov	ebx, eax
   504 000019AE C1F818              <1> 	sar	eax, 24
   505 000019B1 EBF4                <1> 	jmp	dsa24
   506 000019B3 80C110              <1> dsa16:	add	cl, 16
   507 000019B6 730D                <1> 	jnc	dsa7
   508 000019B8 C1F808              <1> dsa8:	sar	eax, 8
   509 000019BB 88C3                <1> 	mov	bl, al
   510 000019BD C1CB08              <1> 	ror	ebx, 8
   511 000019C0 80C1F8              <1> 	add	cl, -8
   512 000019C3 72F3                <1> 	jc	dsa8
   513 000019C5 80E107              <1> dsa7:	and	cl, 7
   514 000019C8 D3F8                <1> 	sar	eax, cl
   515 000019CA 88C3                <1> 	mov	bl, al		; bits from al in high-order positions bl
   516 000019CC D2C3                <1> 	rol	bl, cl		; roll them to low-order positions
   517 000019CE D3CB                <1> 	ror	ebx, cl
   518 000019D0 C1E808              <1> 	shr	eax, 8
   519 000019D3 C1EB08              <1> 	shr	ebx, 8
   520 000019D6 C3                  <1> 	ret	
   521                              <1> 
   522                              <1> 
   523 000019D7 88C1                <1> rr:	mov	cl, al
   524 000019D9 C1E308              <1> 	shl	ebx, 8
   525 000019DC F6C118              <1> 	test	cl, 24		; bits 16:8 are self-cancelling
   526 000019DF 7A11                <1> 	jpe	rr7
   527 000019E1 F6C110              <1> 	test	cl, 16
   528 000019E4 7407                <1> 	jz	rr8		; 16 is off so 8 is on
   529 000019E6 C1C308              <1> 	rol	ebx, 8		; 8 left in 24-bit ring = 16 right
   530 000019E9 88DF                <1> 	mov	bh, bl		; compress 32-bit ring to 24-bit
   531 000019EB EB05                <1> 	jmp	short rr7
   532 000019ED 88FB                <1> rr8:	mov	bl, bh		; extend 24-bit ring to 32-bit
   533 000019EF C1CB08              <1> 	ror	ebx, 8
   534 000019F2 80E107              <1> rr7:	and	cl, 7		; isolate remaining count bits
   535 000019F5 88FB                <1> 	mov	bl, bh		; don't ask, just do it
   536 000019F7 D3CB                <1> 	ror	ebx, cl
   537 000019F9 C1EB08              <1> 	shr	ebx, 8
   538 000019FC C3                  <1> 	ret
   539                              <1> 
   540 000019FD 88C1                <1> rl:	mov	cl, al
   541 000019FF C1E308              <1> 	shl	ebx, 8
   542 00001A02 F6C118              <1> 	test	cl, 24		; bits 16:8 are self-cancelling
   543 00001A05 7A11                <1> 	jpe	rl7
   544 00001A07 F6C110              <1> 	test	cl, 16
   545 00001A0A 7407                <1> 	jz	rl8		; 16 is off so 8 is on
   546 00001A0C 88FB                <1> 	mov	bl, bh		; extend 24-bit ring to 32-bit
   547 00001A0E C1CB08              <1> 	ror	ebx, 8		; 8 right in 24-bit ring = 16 left
   548 00001A11 EB05                <1> 	jmp	short rl7
   549 00001A13 C1C308              <1> rl8:	rol	ebx, 8
   550 00001A16 88DF                <1> 	mov	bh, bl		; compress 32-bit ring to 24-bit	
   551 00001A18 80E107              <1> rl7:	and	cl, 7
   552 00001A1B 30DB                <1> 	xor	bl, bl
   553 00001A1D D3C3                <1> 	rol	ebx, cl
   554 00001A1F 08DF                <1> 	or	bh, bl
   555 00001A21 C1EB08              <1> 	shr	ebx, 8
   556 00001A24 C3                  <1> 	ret
   557                              <1> 
   558 00001A25 C1E008              <1> drr:	shl	eax, 8
   559 00001A28 C1E308              <1> 	shl	ebx, 8
   560                              <1> 
   561 00001A2B F6C130              <1> 	test	cl, 48		; bits 32:16 are self-cancelling
   562 00001A2E 7B07                <1> 	jpo	drr24		; rotate 48 = zero or 56 = 8 positions
   563 00001A30 F6C108              <1> 	test	cl, 8		; parity = pe dans le pays d'Intel
   564 00001A33 741C                <1> 	jz	drr7
   565 00001A35 EB15                <1> 	jmp	drr_cdrr8
   566                              <1> 
   567 00001A37 93                  <1> drr24:	xchg	eax, ebx	; rotate 24 right or left as you wish
   568 00001A38 F6C118              <1> 	test	cl, 24
   569 00001A3B 7A0D                <1> 	jpe	drr24_32	; pattern is 100xxx or 011xxx
   570 00001A3D F6C108              <1> 	test	cl, 8		; pattern is 010xxx or 101xxx
   571 00001A40 7401                <1> 	jz	drrl8		; pattern is 010
   572 00001A42 93                  <1> 	xchg	eax, ebx	; swap back, pattern 101 = 40 right = 8 left 
   573 00001A43 E828000000          <1> drrl8:	call	near drl8	; pattern is 010
   574 00001A48 EB07                <1> 	jmp	short drr7 	; already rotated 24 right, now 8 left
   575                              <1> 
   576                              <1> drr24_32:
   577 00001A4A 7505                <1> 	jnz	drr7		; pattern is 011 = rotate 24. We did
   578                              <1> drr_cdrr8:
   579 00001A4C E814000000          <1> 	call	near drr8	; pattern is 100 = rotate 32
   580 00001A51 80E107              <1> drr7:	and	cl, 7
   581 00001A54 7408                <1> 	jz	drrx
   582 00001A56 88E3                <1> 	mov	bl, ah		; rotate low bits ebx 31:8 to eax high positions
   583 00001A58 88F8                <1> 	mov	al, bh		; rotate low bits eax 31:8 to ebx high positions
   584 00001A5A D3C8                <1> 	ror	eax, cl		; bits from bh in low order positions al
   585 00001A5C D3CB                <1> 	ror	ebx, cl		; bits from ah in low order positions bl
   586 00001A5E C1E808              <1> drrx:	shr	eax, 8
   587 00001A61 C1EB08              <1> 	shr	ebx, 8
   588 00001A64 C3                  <1> 	ret
   589                              <1> 
   590 00001A65 88E3                <1> drr8:   mov     bl, ah          ; cross 8 bits from one 32-bit ring to another
   591 00001A67 88F8                <1>         mov     al, bh		
   592 00001A69 C1C808              <1>         ror     eax, 8
   593 00001A6C C1CB08              <1>         ror     ebx, 8
   594 00001A6F C3                  <1>         ret
   595                              <1> 
   596 00001A70 C1C008              <1> drl8:   rol     eax, 8
   597 00001A73 C1C308              <1>         rol     ebx, 8
   598 00001A76 88DC                <1>         mov     ah, bl          ; cross 8 bits from one 32-bit ring to another
   599 00001A78 88C7                <1>         mov     bh, al
   600 00001A7A C3                  <1>         ret
   601                              <1> 
   602 00001A7B C1E008              <1> drl:	shl	eax, 8
   603 00001A7E C1E308              <1> 	shl	ebx, 8
   604 00001A81 F6C130              <1> 	test	cl, 48		; values 32:16 cancel each other
   605 00001A84 7B07                <1> 	jpo	drl24
   606 00001A86 F6C108              <1> 	test	cl, 8
   607 00001A89 741C                <1> 	jz	drl7
   608 00001A8B EB15                <1> 	jmp	short drl_cdrl8
   609                              <1> 
   610 00001A8D 93                  <1> drl24:	xchg	eax, ebx
   611 00001A8E F6C118              <1> 	test	cl, 24
   612 00001A91 7A0D                <1> 	jpe	drl24_32	; pattern is 011xxx or 100xxx
   613 00001A93 F6C108              <1> 	test	cl, 8		; pattern is 010xxx or 101xxx
   614 00001A96 7401                <1> 	jz	drlr8		; pattern is 010 = 16 left = 8 right
   615 00001A98 93                  <1> 	xchg	eax, ebx	; swap back, pattern = 101 = 40 left = 8 right
   616 00001A99 E8C7FFFFFF          <1> drlr8:	call	drr8
   617 00001A9E EB07                <1> 	jmp	short drl7
   618                              <1> 
   619                              <1> drl24_32:
   620 00001AA0 7505                <1> 	jnz	drl7		; pattern is 011 = rotate24. We did
   621                              <1> drl_cdrl8:			; pattern = 100xxx or 001xxx, rotate 8 more
   622 00001AA2 E8C9FFFFFF          <1> 	call	drl8
   623 00001AA7 80E107              <1> drl7:	and	cl, 7		; rotate positions 0..7
   624 00001AAA 30C0                <1> 	xor	al, al
   625 00001AAC 30DB                <1> 	xor	bl, bl
   626 00001AAE D3C0                <1> 	rol	eax, cl
   627 00001AB0 D3C3                <1> 	rol	ebx, cl
   628 00001AB2 08DC                <1> 	or	ah, bl
   629 00001AB4 08C7                <1> 	or	bh, al
   630 00001AB6 C1E808              <1> 	shr	eax, 8
   631 00001AB9 C1EB08              <1> 	shr	ebx, 8
   632 00001ABC C3                  <1> 	ret
   633                              <1> 
   634 00001ABD 8B5D10              <1> _ral:	mov	ebx, dword ptr [ebp+A]
   635 00001AC0 E838FFFFFF          <1> 	call	rl
   636 00001AC5 895D10              <1> 	mov	dword ptr [ebp+A], ebx
   637 00001AC8 C3                  <1> 	ret
   638                              <1> 
   639 00001AC9 8B5D14              <1> _rbl:	mov	ebx, dword ptr [ebp+B]
   640 00001ACC E82CFFFFFF          <1> 	call	rl
   641 00001AD1 895D14              <1> 	mov	dword ptr [ebp+B], ebx
   642 00001AD4 C3                  <1> 	ret	
   643                              <1> 
   644 00001AD5 88C1                <1> _drl:	mov	cl, al
   645 00001AD7 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
   646 00001ADA 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]
   647 00001ADD E899FFFFFF          <1> 	call	drl
   648 00001AE2 895D14              <1> 	mov	dword ptr [ebp+B], ebx
   649 00001AE5 894510              <1> 	mov	dword ptr [ebp+A], eax
   650 00001AE8 C3                  <1> 	ret
   651                              <1> 
   652 00001AE9 88C1                <1> _saa:	mov	cl, al
   653 00001AEB 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
   654 00001AEE C1E008              <1> 	shl	eax, 8
   655 00001AF1 D3F8                <1> 	sar	eax, cl
   656 00001AF3 C1E808              <1> 	shr	eax, 8
   657 00001AF6 894510              <1> 	mov	dword ptr [ebp+A], eax
   658 00001AF9 C3                  <1> 	ret
   659                              <1> 
   660 00001AFA 88C1                <1> _sba:	mov	cl, al
   661 00001AFC 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]
   662 00001AFF C1E308              <1> 	shl	ebx, 8
   663 00001B02 D3FB                <1> 	sar	ebx, cl
   664 00001B04 C1EB08              <1> 	shr	ebx, 8
   665 00001B07 895D14              <1> 	mov	dword ptr [ebp+B], ebx
   666 00001B0A C3                  <1> 	ret
   667                              <1> 
   668 00001B0B 88C1                <1> _dsa:	mov	cl, al
   669 00001B0D 8B5D14              <1> 	mov	ebx, dword ptr [ebp+B]
   670 00001B10 8B4510              <1> 	mov	eax, dword ptr [ebp+A]
   671 00001B13 E889FEFFFF          <1> 	call	dsa
   672 00001B18 895D14              <1> 	mov	dword ptr [ebp+B], ebx
   673 00001B1B 894510              <1> 	mov	dword ptr [ebp+A], eax
   674 00001B1E C3                  <1> 	ret
   675                              <1> 
   676 00001B1F E849EBFFFF          <1> _n:	call	memoreg
   677 00001B24 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   678 00001B29 E91FEBFFFF          <1> 	jmp	memoreg_writeback
   679                              <1> 
   680 00001B2E E83AEBFFFF          <1> _inc:	call	memoreg
   681 00001B33 40                  <1> 	inc	eax
   682 00001B34 E914EBFFFF          <1> 	jmp	memoreg_writeback
   683                              <1> 
   684 00001B39 E82FEBFFFF          <1> _dec:	call	memoreg
   685 00001B3E 48                  <1> 	dec	eax
   686 00001B3F E909EBFFFF          <1> 	jmp	memoreg_writeback
   687                              <1> 
   688 00001B44 E824EBFFFF          <1> _src:	call	memoreg
   689 00001B49 C1E008              <1> 	shl	eax, 8
   690 00001B4C 8A869C040000        <1> 	mov	al, byte ptr [esi+PSR]
   691 00001B52 D1C8                <1> 	ror	eax, 1
   692 00001B54 D0C0                <1> 	rol	al, 1
   693 00001B56 88869C040000        <1> 	mov	byte ptr [esi+PSR], al
   694 00001B5C C1E808              <1> 	shr	eax, 8
   695 00001B5F E9E9EAFFFF          <1> 	jmp	memoreg_writeback
   696                              <1> 
   697 00001B64 E804EBFFFF          <1> _slc:	call	memoreg
   698 00001B69 C1E008              <1> 	shl	eax, 8
   699 00001B6C 8A869C040000        <1> 	mov	al, byte ptr [esi+PSR]
   700 00001B72 D0C8                <1> 	ror	al, 1
   701 00001B74 D1C0                <1> 	rol	eax, 1
   702 00001B76 88869C040000        <1> 	mov	byte ptr [esi+PSR], al
   703 00001B7C C1E808              <1> 	shr	eax, 8
   704 00001B7F E9C9EAFFFF          <1> 	jmp	memoreg_writeback
   705                              <1> 
   706                              <1> 	%if	0
   707                              <1> _popA:	call	stack_read1				; ebx <- stack pointer
   708                              <1> 	mov	ebx, dword ptr [esi+ebx*4+REGISTER]	; stack word
   709                              <1> 
   710                              <1> 	mov	ecx, esi				; keep core.REGISTER *
   711                              <1> 	push	ebx
   712                              <1> 	call	memoreg					; reply is memory edi + esi ->
   713                              <1> 							;     or register esi + ebx ->
   714                              <1> 	add	eax, dword ptr [esp]
   715                              <1> 	add	esp, 4
   716                              <1> 
   717                              <1> 	rol	eax, 8					; carry -> LS bit
   718                              <1> 	and	al, 1
   719                              <1> 
   720                              <1> 	and	byte ptr [ecx+PSR], 254
   721                              <1> 	or	byte ptr [ecx+PSR], al
   722                              <1> 	shr	eax, 8					; resulting value without carry
   723                              <1> 	jmp	memoreg_writeback			; eax -> target
   724                              <1> 							; [ edi ] + esi -> memory / register
   725                              <1> 	%else
   726                              <1> 
   727 00001B84 E8E4EAFFFF          <1> _popA:	call	memoreg					; eax <- addend for update
   728 00001B89 53                  <1> 	push	ebx					; ebx -> writeback register
   729 00001B8A 56                  <1> 	push	esi					; or [ edi esi ] -> writeback memory word
   730                              <1> 
   731 00001B8B 8BB560020000        <1> 	mov	esi, dword ptr [ebp+CORE_INDEX1]	; get back the smp core for PSR and...
   732                              <1> 							; total register array and...
   733                              <1> 							; whichever of [ 2 * RTA1 sp ] is in ebx *
   734                              <1> 							; that is simple position in register list
   735                              <1> 							; not application / ISR relative as in ebp
   736                              <1> 							; although each (RTA1 sp) MOSTLY operates
   737                              <1> 							; its own portions of the register array
   738                              <1> 							; CORE_INDEX is in both scopes of ebp :-)
   739                              <1> 
   740 00001B91 E814F6FFFF          <1> 	call	stack_read1				; ebx -> old (RTA1 internal stack) sp
   741 00001B96 03049E              <1> 	add	eax, dword ptr [esi+ebx*4+REGISTER]	; add word from internal stack
   742                              <1> 
   743 00001B99 C1C008              <1> 	rol	eax, 8					; isolate carry out of bit 23
   744 00001B9C 2401                <1> 	and	al, 1
   745 00001B9E 8B9E9C040000        <1> 	mov	ebx, dword ptr [esi+PSR]		; platform memory read then write MIGHT
   746 00001BA4 80E3FE              <1> 	and	bl, 254					; be better than 2 * read : write cycle
   747 00001BA7 08C3                <1> 	or	bl, al
   748 00001BA9 899E9C040000        <1> 	mov	dword ptr [esi+PSR], ebx		; write PSR back
   749                              <1> 
   750 00001BAF C1E808              <1> 	shr	eax, 8					; reposition and clean result
   751                              <1> 
   752 00001BB2 5E                  <1> 	pop	esi					; retrieve possible storage offset
   753 00001BB3 5B                  <1> 	pop	ebx					; retrieve possible register writeback
   754 00001BB4 E994EAFFFF          <1> 	jmp	memoreg_writeback
   755                              <1> 
   756                              <1> 	%endif
   757                              <1> 	
   758 00001BB9 E84FE7FFFF          <1> _da:	call	_burst_read2
   759 00001BBE EB11                <1> 	jmp	_da_
   760                              <1> 
   761 00001BC0 E848E7FFFF          <1> _dan:	call	_burst_read2
   762 00001BC5 81F3FFFFFF00        <1> 	xor	ebx, 00FFFFFFh
   763 00001BCB 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   764 00001BD0 43                  <1> 	inc	ebx			; carry from bit 23 
   765                              <1> 					; remains in bit 24 for now
   766                              <1> 
   767 00001BD1 035D14              <1> _da_:	add	ebx, [ebp+B]
   768 00001BD4 C1E308              <1> 	shl	ebx, 8
   769 00001BD7 83D000              <1> 	adc	eax, 0
   770 00001BDA C1EB08              <1> 	shr	ebx, 8
   771 00001BDD 895D14              <1> 	mov	[ebp+B], ebx
   772 00001BE0 034510              <1> 	add	eax, [ebp+A]
   773 00001BE3 E804000000          <1> 	call	_alu_carry
   774 00001BE8 894510              <1> 	mov	[ebp+A], eax
   775 00001BEB C3                  <1> 	ret
   776                              <1> 
   777                              <1> _alu_carry:
   778 00001BEC 8BB560020000        <1> 	mov	esi, dword ptr [ebp+CORE_INDEX1]
   779 00001BF2 C1C008              <1> 	rol	eax, 8
   780 00001BF5 2401                <1> 	and	al, 1
   781 00001BF7 80A69C040000FE      <1> 	and	byte ptr [esi+PSR], 254
   782 00001BFE 08869C040000        <1> 	or	byte ptr [esi+PSR], al
   783 00001C04 C1E808              <1> 	shr	eax, 8
   784 00001C07 C3                  <1> 	ret
   785                              <1> 
   786 00001C08 040302020101010100- <1> scalex	db	4,3,2,2, 1,1,1,1, 0,0,0,0, 0,0,0,0
   786 00001C11 00000000000000      <1>
   787                              <1> 
   788                              <1> field_scale:			; examine 24-bit integer in 8-position steps
   789 00001C18 C1C008              <1> 	rol	eax, 8		; until high-order 8 bits are not all signs
   790 00001C1B 88C4                <1> 	mov	ah, al
   791 00001C1D 30E8                <1> 	xor	al, ch
   792 00001C1F 7509                <1> 	jnz	not8signs
   793 00001C21 80C108              <1> 	add	cl, 8
   794 00001C24 80F918              <1> 	cmp	cl, 24
   795 00001C27 72EF                <1> 	jb	field_scale
   796 00001C29 C3                  <1> 	ret			; 24 signs = the RTA1 computer word
   797                              <1> not8signs:			; al = 0 indicates it
   798 00001C2A A8F0                <1> 	test	al, 240		; move back some positions but keep counting up
   799 00001C2C 7506                <1> 	jnz	scale_u
   800 00001C2E 80C104              <1> 	add	cl, 4
   801 00001C31 C0C004              <1> 	rol	al, 4
   802                              <1> scale_u:
   803 00001C34 C0E804              <1> 	shr	al, 4
   804 00001C37 0FB6F0              <1> 	movzx	esi, al		; add to count-up 1..7
   805 00001C3A 2E028E[081C0000]    <1> 	add	cl, [cs:esi+scalex]
   806 00001C41 6651                <1> 	push	cx		; roll back 7..1 positions
   807 00001C43 80E107              <1> 	and	cl, 7
   808 00001C46 80F107              <1> 	xor	cl, 7
   809 00001C49 80C101              <1> 	add	cl, 1
   810 00001C4C 88E0                <1> 	mov	al, ah
   811 00001C4E D3C8                <1> 	ror	eax, cl
   812 00001C50 6659                <1> 	pop	cx
   813 00001C52 C3                  <1> 	ret
   814                              <1> 
   815 00001C53 C1E008              <1> qscale:	shl	eax, 8		; 1.2.3
   816 00001C56 C1F808              <1> 	sar	eax, 8		; s.1.2.3
   817 00001C59 C1C008              <1> 	rol	eax, 8		; 1.2.3.s
   818 00001C5C 6631C9              <1> 	xor	cx, cx
   819 00001C5F 88C5                <1> 	mov	ch, al		; keep 8 sign bits
   820 00001C61 E8B2FFFFFF          <1> 	call	field_scale
   821                              <1> 
   822 00001C66 0FB6D9              <1> 	movzx	ebx, cl
   823                              <1> 
   824 00001C69 C1E808              <1> 	shr	eax, 8
   825 00001C6C C3                  <1> 	ret
   826                              <1> 
   827 00001C6D E8DDE6FFFF          <1> _lsc:	call	_operand_read
   828 00001C72 E8DCFFFFFF          <1> 	call	qscale
   829 00001C77 895D14              <1> 	mov	dword ptr [ebp+B], ebx	; store the scale
   830 00001C7A 894510              <1> 	mov	dword ptr [ebp+A], eax	; store the rotated value
   831 00001C7D C3                  <1> 	ret
   832                              <1> 
   833 00001C7E E88AE6FFFF          <1> _dlsc:	call	_burst_read2
   834 00001C83 894510              <1> 	mov	dword ptr [ebp+A], eax		; keep original 1st word
   835 00001C86 C1E008              <1> 	shl	eax, 8
   836 00001C89 C1F808              <1> 	sar	eax, 8
   837 00001C8C C1C008              <1> 	rol	eax, 8
   838 00001C8F 6631C9              <1> 	xor	cx, cx
   839 00001C92 88C5                <1> 	mov	ch, al				; keep 8 sign bits
   840 00001C94 E87FFFFFFF          <1> 	call	field_scale
   841 00001C99 20C0                <1> 	and	al, al
   842 00001C9B 7415                <1> 	jz	_dlsc24				; if the first word is all signs
   843                              <1> 
   844 00001C9D 0FB6C1              <1> 	movzx	eax, cl
   845 00001CA0 894518              <1> 	mov	dword ptr [ebp+MANTISSA2], eax	; store the scale
   846 00001CA3 8B4510              <1> 	mov	eax, dword ptr [ebp+A]		; retrieve the input high order word
   847 00001CA6 E8D0FDFFFF          <1> 	call	drl				; scale the two input words per cl
   848 00001CAB 895D14              <1> 	mov	dword ptr [ebp+B], ebx
   849 00001CAE 894510              <1> 	mov	dword ptr [ebp+A], eax  	; store the rotated value
   850 00001CB1 C3                  <1> 	ret
   851                              <1> 
   852                              <1> _dlsc24:				; different when high order word is all signs
   853 00001CB2 C1E808              <1> 	shr	eax, 8			; one result word of signs
   854 00001CB5 894514              <1> 	mov	dword ptr [ebp+B], eax	; into the low-order result word
   855 00001CB8 89D8                <1> 	mov	eax, ebx		; scale the low-order input
   856 00001CBA C1E008              <1> 	shl	eax, 8
   857 00001CBD 30C9                <1> 	xor	cl, cl			; restart the scale count-up
   858 00001CBF E854FFFFFF          <1> 	call	field_scale
   859 00001CC4 80C118              <1> 	add	cl, 24			; restore the early part of the count-up
   860                              <1> 
   861 00001CC7 0FB6D9              <1> 	movzx	ebx, cl
   862 00001CCA 895D18              <1> 	mov	dword ptr [ebp+MANTISSA2], ebx	; store the scale
   863                              <1> 
   864 00001CCD C1E808              <1> 	shr	eax, 8
   865 00001CD0 894510              <1> 	mov	dword ptr [ebp+A], eax	; store the rotated value
   866 00001CD3 C3                  <1> 	ret
   867                              <1> 
   868                              <1> 	%if	0
   869                              <1> 
   870                              <1> _fpx:	call	_burst_read2		; data read in eax ebx
   871                              <1> 	mov	esi, dword ptr [ebp+CORE_INDEX1]
   872                              <1> 	push	ebx			; ebx is used in RTA1 stack frame
   873                              <1> 	call	stack4			; construct RTA1 stack frame
   874                              <1> 
   875                              <1> 	shl	eax, 4			; move 12 mantissa bits out of eax
   876                              <1> 	movsx	ecx, ax			; and extend the normalising bit
   877                              <1> 
   878                              <1> 	rol	eax, 4+1		; shelter sign in eax bit 0
   879                              <1> 	shl	ax, 12			; better still in eax bit 12
   880                              <1> 	sar	eax, 12			; propagate the value at midpoint position
   881                              <1> 	ror	eax, 1			; have the sign back
   882                              <1> 	shr	eax, 8			; clear eax 31..24
   883                              <1> 	xor	eax, 003ffc00h		; reverse the 12 copies of midpoint bit
   884                              <1> 					; yon's ra complicated bit done
   885                              <1> 	mov	dword ptr [ebp+ebx*4], eax
   886                              <1> 
   887                              <1> 	xor	eax, ecx		; is the normalising bit opposite to signs ?
   888                              <1> 	test	eax, 00800000h
   889                              <1> 	jz	_fpx_allsigns		; no so unnormalised = zero
   890                              <1> 
   891                              <1> 	pop	eax			; the 2nd operand word, ya remember?
   892                              <1> 	shl	eax, 4			; get them 2 halves over the centre
   893                              <1> 
   894                              <1> 	shr	cx, 4			; zero quartets at high order of 16 bits
   895                              <1> 	shr	ax, 4
   896                              <1> 
   897                              <1> 	xchg	ax, cx			; low-order mantissa bits with unsigns in ecx
   898                              <1> 					; high-order mantissa bits with middle part in eax
   899                              <1> 
   900                              <1> 	shl	eax, 4			; LLLz | HHHz
   901                              <1> 	shr	ax, 4			; LLLz | zHHH
   902                              <1> 	rol	eax, 12			; zzHH | HLLL
   903                              <1> 
   904                              <1> 	mov	dword ptr [ebp+ebx*4+1*4], eax
   905                              <1> 	rol	ecx, 12
   906                              <1> 	xor	ecx, 0FFFh		; 12 normalising bits = 12 inverted signs
   907                              <1> 	mov	dword ptr [ebp+ebx*4+2*4], ecx
   908                              <1> 	not	ecx			; convert high order quartet to signs
   909                              <1> 	sar	ecx, 20			; 24 of them
   910                              <1> 	shr	ecx, 8
   911                              <1> 	mov	dword ptr [ebp+ebx*4+3*4], ecx
   912                              <1> ;	mov	ebp, dword ptr [esi+REGISTER_SET]
   913                              <1> 	mov	dword ptr [ebp+S_P], ebx	; update whichever sp that is
   914                              <1> 	ret
   915                              <1> 
   916                              <1> _fpx_allsigns:
   917                              <1> 	add	esp, 4			; take saved operand word back from stack
   918                              <1> 	sar	ecx, 8			; 16 unnormalised normalising bits
   919                              <1> 	shr	ecx, 8			; = 24 sign bits
   920                              <1> 
   921                              <1> 	mov	dword ptr [ebp+ebx*4], ecx
   922                              <1> 	mov	dword ptr [ebp+ebx*4+1*4], ecx
   923                              <1> 	mov	dword ptr [ebp+ebx*4+2*4], ecx
   924                              <1> 	mov	dword ptr [ebp+ebx*4+3*4], ecx
   925                              <1> 
   926                              <1> ;	mov	ebp, dword ptr [_register_set]
   927                              <1> 	mov	dword ptr [ebp+S_P], ebx	; update whichever sp that is
   928                              <1> 	ret
   929                              <1> 
   930                              <1> _fpp:	call	stack_read4
   931                              <1> 	push	eax				; thats EA
   932                              <1> 
   933                              <1> 	mov	eax, dword ptr [ebp+ebx*4]	; s + 23 exponent bits
   934                              <1> 	rol	eax, 8+2			; save sign and midpoint
   935                              <1> 	shl	eax, 12				; squeeze out 12 exponent bits
   936                              <1> 	shr	ax, 12				; bring sign + midpoint back
   937                              <1> 	ror	eax, 2				; and roll them back in
   938                              <1> 	shr	eax, 4				; position 12 bits low in 16 bits
   939                              <1> 	mov	ecx, dword ptr [ebp+ebx*4+1*4]	; take 1st mantissa word from the stack
   940                              <1> 	ror	ecx, 12				; rotate 12 bits down
   941                              <1> 	shl	cx, 4				; position 12 bits high in 16 bits
   942                              <1> 	mov	ax, cx				; merge
   943                              <1> 	shr	eax, 4				; position 24 bits low in 32 bits
   944                              <1> 	mov	dword ptr [ebp+ebx*4], eax	; place back in RTA1 stack frame
   945                              <1> 						; next 12 mantissa bits in ecx 31..20
   946                              <1> 
   947                              <1> 	mov	eax, dword ptr [ebp+ebx*4+2*4]	; read 24 more
   948                              <1> 	shr	eax, 12-4			; position 12 bits at ax 15..4
   949                              <1> 	shr	ecx, 4				;				
   950                              <1> 	mov	cx, ax				; juxtapose with mantissa 23..12
   951                              <1> 	shr	ecx, 4				; wirraff
   952                              <1> 
   953                              <1> 	mov	dword ptr [ebp+ebx*4+1*4], ecx	; making 2nd and final output word
   954                              <1> 
   955                              <1> 	pop	eax				; recover EA
   956                              <1> 	jmp	_burst_write2
   957                              <1> 
   958                              <1> 	%endif
    39                                  	%include	"fpu.msm"
     1                              <1> compress4to8:			; readout floating operand
     2                              <1> 				; and pack to 32-bit words
     3                              <1> 				; for 1 bit-distance shifting
     4                              <1> 				; acquired operand is in 1st half of 
     5                              <1> 				; 8-register block [edi]
     6                              <1> 
     7 00001CD4 8B07                <1> 	mov	eax, dword ptr [edi]	; 1s-complement scale field
     8 00001CD6 C1E008              <1> 	shl	eax, 8			; 1st data bit reveals sign
     9 00001CD9 C1F808              <1> 	sar	eax, 8			; propagate that sign some
    10 00001CDC 89C3                <1> 	mov	ebx, eax
    11 00001CDE C1F818              <1> 	sar	eax, 24			; propagate signs to 32 bits
    12 00001CE1 31C3                <1> 	xor	ebx, eax		; change scale to unsigned magnitude
    13 00001CE3 891F                <1> 	mov	dword ptr [edi], ebx	; position scale magnitude in 1st register
    14 00001CE5 89471C              <1> 	mov	dword ptr [edi+7*4], eax	; 96 trailing signs
    15 00001CE8 894718              <1> 	mov	dword ptr [edi+6*4], eax
    16 00001CEB 894714              <1> 	mov	dword ptr [edi+5*4], eax
    17 00001CEE 8B5F0C              <1> 	mov	ebx, dword ptr [edi+3*4]	; read low-order mantissa word
    18 00001CF1 88D8                <1> 	mov	al, bl				; low-order octet
    19 00001CF3 C1C808              <1> 	ror	eax, 8				; is followed by 24 signs
    20 00001CF6 894710              <1> 	mov	dword ptr [edi+4*4], eax	; ebx also contains mantissa 23..8
    21                              <1> 						; in positions 23..8
    22                              <1> 
    23 00001CF9 8B4708              <1> 	mov	eax, dword ptr [edi+2*4]	; eax now contains mantissa 47..24
    24 00001CFC C1E308              <1> 	shl	ebx, 8
    25 00001CFF 6689C3              <1> 	mov	bx, ax				; mantissa 39..24 -> ebx
    26 00001D02 C1C310              <1> 	rol	ebx, 16				; ebx now contains mantissa 40..8
    27 00001D05 895F0C              <1> 	mov	dword ptr [edi+3*4], ebx
    28 00001D08 8B5F04              <1> 	mov	ebx, dword ptr [edi+1*4]	; mantissa 71..48
    29 00001D0B C1E308              <1> 	shl	ebx, 8
    30 00001D0E C1E810              <1> 	shr	eax, 16				; mantissa 47..40
    31 00001D11 88C3                <1> 	mov	bl, al
    32 00001D13 895F08              <1> 	mov	dword ptr [edi+2*4], ebx	; mantissa 71..40
    33 00001D16 8B4714              <1> 	mov	eax, dword ptr [edi+5*4]	; copy 32 signs
    34 00001D19 894704              <1> 	mov	dword ptr [edi+1*4], eax	; to 2nd word of register block
    35 00001D1C C3                  <1> 	ret
    36                              <1> 
    37                              <1> 
    38                              <1> ;	___________________________________
    39                              <1> ;	| magnitude scale|     32 signs   |
    40                              <1> ;	|________________|________________|
    41                              <1> ;	| platform word 7| platform word 6|
    42                              <1> 
    43                              <1> 
    44                              <1> ;	<------------ 168-bit mantissa 167..72-------------|
    45                              <1> ;	<------------  72-bit mantissa ------>
    46                              <1> ;	_____________|___________|____________|____________________________
    47                              <1> ;	|      24    | 8 |   16  |   16   | 8 |    24 signs|96 more signs for
    48                              <1> ;	|____________|___|______ |________|___|____________|residue calculation
    49                              <1> ;	| platform word 5| platform word 4|   +rounding <--- @  96-bit operation
    50                              <1> 
    51                              <1> ;	                 <---------------------------------[ platform words 2..0
    52                              <1> ;	                 :
    53                              <1> ;	                 [                                                  ]
    54                              <1> 
    55                              <1> ;	                 |--- 168-bit mantissa 71:0   -------->
    56                              <1> ;	                      rounding @ 192-bit operation --->+
    57                              <1> ;      	                 _________________________|____________|_____________
    58                              <1> ;	                 |      24    | 8 |   16  |   16   | 8 |    24 signs|
    59                              <1> ;	                 |____________|___|_______|________|___|____________|
    60                              <1> ;	                 | platform word 2| platform word 1| platform word 0|
    61                              <1> 
    62                              <1> ;	                 |    residue rounding -->+
    63                              <1> ;	                 |--- 144-bit mantissa -->	                                    
    64                              <1> 
    65                              <1> _deliver_:
    66 00001D1D 8BB560020000        <1> 	mov	esi, dword ptr [ebp+CORE_INDEX1]
    67 00001D23 F7869C040000080000- <1> 	test	dword ptr [esi+PSR], FP_R
    67 00001D2C 00                  <1>
    68 00001D2D 0F847E000000        <1> 	jz	near _deliver
    69 00001D33 53                  <1> 	push	ebx		; save result register index
    70 00001D34 8B1F                <1> 	mov	ebx, dword ptr [edi]		; read scale unsigned magnitude
    71                              <1> 						; not yet signed
    72                              <1> 
    73                              <1> 				; all results except scale have been polarised
    74                              <1> 				; ebx = positive magnitude of major exponent
    75                              <1> 				; deliver floating residue
    76 00001D36 83C3B8              <1> 	add	ebx, -72	; calculate exponent of residue
    77 00001D39 B148                <1> 	mov	cl, 72
    78                              <1> 
    79 00001D3B 8B4710              <1> 	mov	eax, dword ptr [edi+4*4]	; mantissa */ 64 bits
    80 00001D3E C1E008              <1> 	shl	eax, 8		; separate residual mantissa
    81 00001D41 C1E808              <1> 	shr	eax, 8
    82 00001D44 50                  <1> 	push	eax
    83 00001D45 8B4714              <1> 	mov	eax, dword ptr [edi+5*4]	; mantissa */ 96 bits
    84 00001D48 50                  <1> 	push	eax
    85 00001D49 8B4718              <1> 	mov	eax, dword ptr [edi+6*4]	; mantissa */ 128 bits
    86 00001D4C 668B4704            <1> 	mov	ax, word ptr [edi+1*4]		; change low-order half trailing word to signs
    87 00001D50 50                  <1> 	push	eax				; before normalising
    88                              <1> 
    89                              <1> _normalise_residue:
    90 00001D51 8B442408            <1> 	mov	eax, dword ptr [esp+2*4]	; residual mantissa high-order word
    91 00001D55 334704              <1> 	xor	eax, dword ptr [edi+1*4]	; signs
    92 00001D58 2500008000          <1> 	and	eax, 00800000h			; normalising position
    93 00001D5D 751A                <1> 	jnz	_residue_normalised
    94 00001D5F 8B4704              <1> 	mov	eax, dword ptr [edi+1*4]	; signs again
    95 00001D62 D1D0                <1> 	rcl	eax, 1				; place a sign in carry				
    96 00001D64 D11424              <1> 	rcl	dword ptr [esp], 1		; rotate 96 bits residual mantissa
    97 00001D67 D1542404            <1> 	rcl	dword ptr [esp+1*4], 1
    98 00001D6B D1542408            <1> 	rcl	dword ptr [esp+2*4], 1		; thirdly the high-order word
    99 00001D6F 83C3FF              <1> 	add	ebx, -1
   100 00001D72 80C1FF              <1> 	add	cl, -1
   101 00001D75 72DA                <1> 	jc	_normalise_residue
   102 00001D77 31DB                <1> 	xor	ebx, ebx			; residue all signs zero -> scale
   103                              <1> _residue_normalised:
   104 00001D79 F7C3000080FF        <1> 	test	ebx, 0FF800000h
   105 00001D7F 0F85CFF4FFFF        <1> 	jnz	_fpxpo				; nonzero mantissa
   106                              <1> 						; and exponent underflow / overflow
   107                              <1> 						
   108                              <1> ;			residual mantissa on the stack now is
   109                              <1> ;			______________________________________________
   110                              <1> ;	sp------------->| mantissa bits 15..0 | 16 sign bits discard |
   111                              <1> ;			|_____________________|______________________|
   112                              <1> ;			|            mantissa bits 47..16            |
   113                              <1> ;			|____________________________________________| 
   114                              <1> ;			| 0000 0000  mantissa bits 71..48            |
   115                              <1> ;			|____________________________________________|
   116                              <1> ;			|	     result register indication      |
   117                              <1> ;			|____________________________________________|
   118                              <1> 
   119 00001D85 8B4704              <1> 	mov	eax, dword ptr [edi+1*4]	; signs
   120 00001D88 31D8                <1> 	xor	eax, ebx			; sign residue exponent now
   121 00001D8A C1E008              <1> 	shl	eax, 8				; trim characteristic to RTA1 24-bit word
   122 00001D8D C1E808              <1> 	shr	eax, 8
   123 00001D90 894520              <1> 	mov	dword ptr [ebp+8*4], eax	; scale XOR signs -> residue characteristic
   124                              <1> 
   125 00001D93 5B                  <1> 	pop	ebx				; low order mantissa part
   126 00001D94 58                  <1> 	pop	eax				; middle order mantissa part
   127 00001D95 88C3                <1> 	mov	bl, al				; donate 8 bits
   128 00001D97 C1CB08              <1> 	ror	ebx, 8				; distribute as RTA1 24-bit words
   129 00001D9A C1EB08              <1> 	shr	ebx, 8				; mantissa 23..0
   130 00001D9D C1E808              <1> 	shr	eax, 8				; mantissa 47..24
   131 00001DA0 895D2C              <1> 	mov	dword ptr [ebp+11*4], ebx
   132 00001DA3 894528              <1> 	mov	dword ptr [ebp+10*4], eax
   133 00001DA6 58                  <1> 	pop	eax				; high order residual mantissa part
   134 00001DA7 5B                  <1> 	pop	ebx				; saved result register index
   135 00001DA8 C1E008              <1> 	shl	eax, 8
   136 00001DAB C1E808              <1> 	shr	eax, 8				; normalising position is bit 23
   137 00001DAE 894524              <1> 	mov	dword ptr [ebp+9*4], eax	; mantissa 71..48
   138                              <1> 
   139                              <1> _deliver:					; deliver floating result
   140                              <1> 						; ebx = target register index
   141                              <1> 						; result register index [ebp+]ebx*4
   142 00001DB1 8B07                <1> 	mov	eax, dword ptr [edi]		; unsigned scale magnitude
   143 00001DB3 A9000080FF          <1> 	test	eax, 0FF800000h
   144 00001DB8 0F8596F4FFFF        <1> 	jnz	_fpxpo				; exponent underflow / overflow
   145 00001DBE 334704              <1> 	xor	eax, dword ptr [edi+1*4]	; sign it
   146 00001DC1 C1E008              <1> 	shl	eax, 8
   147 00001DC4 C1E808              <1> 	shr	eax, 8
   148                              <1> 
   149                              <1> _store_float:
   150 00001DC7 89449D00            <1>         mov     dword ptr [ebp+ebx*4], eax      ; store characteristic = scale XOR signs
   151 00001DCB 8B4708              <1>         mov     eax, dword ptr [edi+2*4]	; read bits 71..40 major mantissa
   152 00001DCE 0FB6C8              <1>         movzx   ecx, al
   153 00001DD1 C1E808              <1>         shr     eax, 8
   154 00001DD4 89449D04            <1>         mov     dword ptr [ebp+ebx*4+4], eax	; store mantissa bits 71..48
   155 00001DD8 8B470C              <1>         mov     eax, dword ptr [edi+3*4]	; read mantissa bits 39..8
   156 00001DDB C1E110              <1>         shl     ecx, 16				; position mantissa bits 47..40
   157 00001DDE C1C810              <1>         ror     eax, 16
   158 00001DE1 6689C1              <1>         mov     cx, ax				; position mantissa bits 39..24
   159 00001DE4 894C9D08            <1>         mov     dword ptr [ebp+ebx*4+8], ecx	; store mantissa bits 47..24
   160 00001DE8 8B4F10              <1>         mov     ecx, dword ptr [edi+4*4]	; read mantissa bits 7..0 plus 24 trailing bits
   161 00001DEB C1E910              <1>         shr     ecx, 16				; position after mantissa 23..8
   162 00001DEE 6689C8              <1>         mov     ax, cx
   163 00001DF1 C1E808              <1>         shr     eax, 8				; store mantissa bits 23..0
   164 00001DF4 89449D0C            <1>         mov     dword ptr [ebp+ebx*4+12], eax
   165 00001DF8 C3                  <1> 	ret
   166                              <1> 
   167                              <1> ;	_output equ	272
   168                              <1> ;	_inputr equ	264
   169                              <1> ;	_input2 equ	256
   170                              <1> 
   171                              <1> ;	_OUTPUT	equ	__register+_output*4
   172                              <1> ;	_INPUTR equ	__register+_inputr*4
   173                              <1> ;	_INPUT2 equ	__register+_input2*4
   174                              <1> ;	_BIAS	equ	_OUTPUT
   175                              <1> 
   176                              <1> zoutput:
   177 00001DF9 31C0                <1> 	xor	eax, eax
   178 00001DFB 8907                <1> 	mov	dword ptr [edi], eax
   179 00001DFD 894704              <1> 	mov	dword ptr [edi+1*4], eax
   180 00001E00 894708              <1> 	mov	dword ptr [edi+2*4], eax
   181 00001E03 89470C              <1> 	mov	dword ptr [edi+3*4], eax
   182 00001E06 894710              <1> 	mov	dword ptr [edi+4*4], eax
   183 00001E09 894714              <1> 	mov	dword ptr [edi+5*4], eax
   184 00001E0C 894718              <1> 	mov	dword ptr [edi+6*4], eax
   185 00001E0F 89471C              <1> 	mov	dword ptr [edi+7*4], eax
   186 00001E12 C3                  <1> 	ret
   187                              <1> 
   188                              <1> 
   189                              <1> ;	round before add or divide
   190                              <1> ;	XOR rounding pattern to guard field
   191                              <1> 
   192 00001E13 0FB6DD              <1> round1:	movzx	ebx, ch
   193 00001E16 8B8560020000        <1> 	mov	eax, dword ptr [ebp+CORE_INDEX1]
   194 00001E1C 8B804C020000        <1> 	mov	eax, dword ptr [eax+REGISTER+FP_GUARD]
   195 00001E22 D3E8                <1> 	shr	eax, cl
   196 00001E24 C1E008              <1> 	shl	eax, 8
   197 00001E27 31449F08            <1> 	xor	dword ptr [edi+ebx*4+2*4], eax
   198                              <1> 
   199 00001E2B C3                  <1> 	ret
   200                              <1> 
   201 00001E2C 0FB6DD              <1> round2:	movzx	ebx, ch
   202 00001E2F 8B8560020000        <1> 	mov	eax, dword ptr [ebp+CORE_INDEX1]
   203 00001E35 8B864C020000        <1> 	mov	eax, dword ptr [esi+REGISTER+FP_GUARD]
   204 00001E3B D3E8                <1> 	shr	eax, cl
   205 00001E3D C1E008              <1> 	shl	eax, 8
   206 00001E40 01449F08            <1> 	add	dword ptr [edi+ebx*4+2*4], eax
   207                              <1> round2more:
   208 00001E44 83549F0400          <1> 	adc	dword ptr [edi+ebx*4+1*4], 0
   209 00001E49 4B                  <1> 	dec	ebx
   210 00001E4A 75F8                <1> 	jnz	round2more
   211 00001E4C C3                  <1> 	ret
   212                              <1> 
   213                              <1> end_around_carry:
   214                              <1> 
   215 00001E4D F75608              <1> 	not	dword ptr [esi+2*4]		; seems to vary or be vaguely documented
   216 00001E50 0FB64604            <1> 	movzx	eax, byte ptr [esi+1*4]		; what size the call return stack frame is
   217                              <1> 						; so we push ei and copy esp to it
   218                              <1> 						; to see stuff near the stack top
   219                              <1> 
   220 00001E54 F6460880            <1> 	test	byte ptr dword ptr [esi+2*4], 128
   221 00001E58 790B                <1> 	jns	end_around_carry_plus		; updated signs +
   222                              <1> 
   223 00001E5A B8FFFFFFFF          <1> 	mov	eax, -1				; 1 -> -1 in 1s complement
   224 00001E5F D3E8                <1> 	shr	eax, cl
   225 00001E61 F7D0                <1> 	not	eax
   226 00001E63 EB06                <1> 	jmp	eoc1
   227                              <1> 
   228                              <1> end_around_carry_plus:
   229 00001E65 21C0                <1> ?	and	eax, eax
   230 00001E67 7415                <1> 	jz	eox1				; ? don't call this if there is no carry
   231 00001E69 D3C8                <1> 	ror	eax, cl
   232                              <1> 
   233 00001E6B 0FB6DD              <1> eoc1:	movzx	ebx, ch
   234 00001E6E 01449F08            <1> 	add	dword ptr [edi+ebx*4+2*4], eax
   235                              <1> 
   236 00001E72 9C                  <1> 	pushf
   237 00001E73 C1F81F              <1> 	sar	eax, 31				; shift leave carry alone
   238 00001E76 9D                  <1> 	popfd
   239                              <1> 
   240 00001E77 43                  <1> 	inc	ebx				; but reference displacements - 2
   241                              <1> 
   242 00001E78 11049F              <1> eoc:	adc	dword ptr [edi+ebx*4], eax	; referencing displacements - 2
   243 00001E7B 4B                  <1> 	dec	ebx
   244 00001E7C 75FA                <1> 	jnz	eoc
   245 00001E7E C3                  <1> eox1:	ret
   246                              <1> 
   247                              <1> restore_trailing_signs:
   248 00001E7F 0FB6DD              <1> 	movzx	ebx, ch
   249 00001E82 8B4704              <1> 	mov	eax, dword ptr [edi+1*4]
   250                              <1> 
   251 00001E85 89471C              <1> 	mov	dword ptr [edi+7*4], eax
   252                              <1> 
   253 00001E88 21C0                <1> 	and	eax, eax
   254 00001E8A 780B                <1> 	js	restore_trailing_ones
   255 00001E8C F7D0                <1> 	not	eax
   256 00001E8E D3E8                <1> 	shr	eax, cl
   257 00001E90 F7D0                <1> 	not	eax
   258 00001E92 21449F08            <1> 	and	dword ptr [edi+ebx*4+2*4], eax
   259                              <1> 
   260 00001E96 C3                  <1> 	ret
   261                              <1> restore_trailing_ones:
   262 00001E97 D3E8                <1> 	shr	eax, cl
   263 00001E99 09449F08            <1> 	or	dword ptr [edi+ebx*4+2*4], eax
   264                              <1> 
   265 00001E9D C3                  <1> 	ret
   266                              <1> 	
   267                              <1> bias_addend:					; input mantissa [esi] is biased into location _BIAS
   268 00001E9E 57                  <1> 	push	edi
   269 00001E9F 89F7                <1> 	mov	edi, esi
   270                              <1> 
   271 00001EA1 8BB560020000        <1> 	mov	esi, dword ptr[ebp+CORE_INDEX1]
   272 00001EA7 8DB640040000        <1> 	lea	esi, [esi+_BIAS]
   273                              <1> 
   274 00001EAD 56                  <1> 	push	esi
   275 00001EAE E803000000          <1> 	call	biasfp
   276                              <1> 
   277 00001EB3 5E                  <1> 	pop	esi
   278 00001EB4 5F                  <1> 	pop	edi
   279 00001EB5 C3                  <1> 	ret
   280                              <1> 
   281 00001EB6 52                  <1> biasfp:	push	edx
   282 00001EB7 51                  <1> 	push	ecx
   283                              <1> 
   284 00001EB8 BB01000000          <1> 	mov	ebx, 1				; output index
   285 00001EBD 66C1E003            <1> 	shl	ax, 3				; words sign fill
   286 00001EC1 C0E803              <1> 	shr	al, 3				; bits sign fill
   287 00001EC4 6689C1              <1> 	mov	cx, ax
   288 00001EC7 83C704              <1> 	add	edi, 4				; input pointer
   289 00001ECA 8B07                <1> 	mov	eax, dword ptr [edi]		; there shall be this word of signs at least
   290                              <1> 
   291 00001ECC 89049E              <1> bias32:	mov	dword ptr [esi+ebx*4], eax	; write 1 word of signs
   292 00001ECF 43                  <1> 	inc	ebx				; consider the next output word
   293 00001ED0 FECD                <1> 	dec	ch				; any more words of signs?
   294 00001ED2 79F8                <1> 	jns	bias32
   295                              <1> 
   296 00001ED4 20C9                <1> 	and	cl, cl
   297 00001ED6 7422                <1> 	jz	bias_fast			; there is no 32-bit shift
   298                              <1> 
   299 00001ED8 B520                <1> 	mov	ch, 32				; demonstrate the missing advantage
   300 00001EDA 28CD                <1> 	sub	ch, cl				; of instruction architectures
   301                              <1> 						; with 2-register shifts
   302                              <1> biasup2:
   303 00001EDC 83FB08              <1> 	cmp	ebx, 8
   304 00001EDF 742B                <1> 	jz	bias_addx
   305 00001EE1 83C704              <1> 	add	edi, 4				; read new mantissa word
   306 00001EE4 8B17                <1> 	mov	edx, dword ptr [edi]		; it becomes word # new in edx
   307 00001EE6 86E9                <1> 	xchg	ch, cl
   308 00001EE8 D3E0                <1> 	shl	eax, cl				; shift buffered word left 32 - bit offset
   309 00001EEA 86E9                <1> 	xchg	ch, cl
   310 00001EEC D3EA                <1> 	shr	edx, cl				; shift new mantissa word right bit offset
   311 00001EEE 09D0                <1> 	or	eax, edx
   312 00001EF0 89049E              <1> 	mov	dword ptr [esi+ebx*4], eax	; write 1 merged word
   313 00001EF3 8B07                <1> 	mov	eax, dword ptr [edi]		; read the same mantissa word again
   314 00001EF5 83C301              <1> 	add	ebx, 1				; it becomes word # previous in eax
   315 00001EF8 EBE2                <1> 	jmp	biasup2
   316                              <1> 
   317                              <1> bias_fast:
   318 00001EFA 83FB08              <1> 	cmp	ebx, 8
   319 00001EFD 740D                <1> 	jz	bias_addx
   320 00001EFF 83C704              <1> 	add	edi, 4
   321 00001F02 8B07                <1> 	mov	eax, dword ptr [edi]
   322 00001F04 89049E              <1> 	mov	dword ptr [esi+ebx*4], eax
   323 00001F07 83C301              <1> 	add	ebx, 1
   324 00001F0A EBEE                <1> 	jmp	bias_fast
   325                              <1> 
   326                              <1> bias_addx:
   327 00001F0C 59                  <1> 	pop	ecx
   328 00001F0D 5A                  <1> 	pop	edx				; restore the program counter
   329 00001F0E C3                  <1> 	ret
   330                              <1> 
   331                              <1> frame_mantissa:
   332                              <1> ;	ror	ecx, 16				; words count is up, beats index down
   333 00001F0F 80C501              <1> 	add	ch, 1				; up the beats index to beats count
   334 00001F12 66C1E905            <1> 	shr	cx, 5				; positions / 32 in ch
   335 00001F16 C0E903              <1> 	shr	cl, 3				; positions /// 32 in cl
   336 00001F19 0FB6DD              <1> 	movzx	ebx, ch				; derive platform words rounded down
   337 00001F1C C3                  <1> 	ret
   338                              <1> 
   339                              <1> renormalise:					; rule 1: restore sign fill in
   340                              <1> 						; low-order containing platform word
   341                              <1> ; done before end-around-carry, and saved
   342                              <1> ;;	call	frame_mantissa			; it was mashed by rounding and adding
   343 00001F1D E85DFFFFFF          <1> 	call	restore_trailing_signs
   344 00001F22 C1C910              <1> 	ror	ecx, 16				; the governing parameter is now
   345                              <1> 						; the containing words count in cx
   346                              <1> renormalise32:
   347 00001F25 8B4708              <1> 	mov	eax, dword ptr [edi+2*4]	; sample 32 mantissa bits
   348 00001F28 3B4704              <1> 	cmp	eax, dword ptr [edi+1*4]	; compare it with 32 signs
   349 00001F2B 750C                <1> 	jnz	renormalise8
   350 00001F2D E83E000000          <1> 	call	rotate32left			; this also discovers if it's ALL signs = 0
   351 00001F32 21C0                <1> 	and	eax, eax			; and is the only place that needs examined
   352 00001F34 75EF                <1> 	jnz	renormalise32
   353                              <1> 
   354 00001F36 8907                <1> 	mov	dword ptr [edi], eax		; mantissa is signed zero, +0 -> scale
   355                              <1> renormalised:
   356 00001F38 C3                  <1> 	ret
   357                              <1> 
   358                              <1> renormalise8:					; from this point on the value is nonzero
   359 00001F39 C1C008              <1> 	rol	eax, 8				; are there 8 signs at head of mantissa?
   360 00001F3C 3A4707              <1> 	cmp	al, byte ptr [edi+1*4+3]	; this is Intel and the 4th byte is high-order
   361 00001F3F 750A                <1> 	jnz	renormalise1			; you have found the 8 bits containing the
   362                              <1> 						; normalising bit
   363 00001F41 E849000000          <1> 	call	rotate8left			; or else you haven't
   364 00001F46 8B4708              <1> 	mov     eax, dword ptr [edi+2*4]	; sample the moved mantissa
   365 00001F49 EBEE                <1> 	jmp	renormalise8
   366                              <1> 
   367                              <1> renormalise1:
   368                              <1> ;	movzx	ebx, cx	
   369 00001F4B 8B4704              <1> 	mov	eax, dword ptr [edi+1*4]		
   370                              <1> ;	mov	dword ptr [edi+ebx*4+1*4], eax	; in case polarity has changed
   371 00001F4E 334708              <1> 	xor	eax, dword ptr [edi+2*4]	; normalising bit opposite polarity to sign?
   372 00001F51 78E5                <1> 	js	renormalised			; arrived
   373 00001F53 E802000000          <1> 	call	bitwise_scale			; almost arrived
   374 00001F58 EBF1                <1> 	jmp	renormalise1
   375                              <1> 
   376                              <1> 
   377                              <1> bitwise_scale:
   378 00001F5A D1571C              <1> 	rcl	dword ptr [edi+7*4], 1	; so it doesn't matter whether 0 or 1
   379 00001F5D D15718              <1> 	rcl	dword ptr [edi+6*4], 1	; gets shifted into the 192nd bit
   380 00001F60 D15714              <1> 	rcl	dword ptr [edi+5*4], 1
   381 00001F63 D15710              <1> 	rcl	dword ptr [edi+4*4], 1	; it's quicker to shift 6 words
   382 00001F66 D1570C              <1> 	rcl	dword ptr [edi+3*4], 1	; than a counted loop of 4 or 5 or 6 words
   383 00001F69 D15708              <1> 	rcl	dword ptr [edi+2*4], 1
   384                              <1> 
   385 00001F6C 8307FF              <1> 	add	dword ptr [edi], -1	; scale down
   386 00001F6F C3                  <1> 	ret
   387                              <1> 
   388                              <1> rotate32left:				; rotate all containing platform words of mantissa
   389 00001F70 52                  <1> 	push	edx			; 32 bit positions left and report if all signs
   390 00001F71 51                  <1> 	push	ecx
   391 00001F72 0FB7D9              <1> 	movzx	ebx, cx
   392 00001F75 31D2                <1> 	xor	edx, edx		; initialise equality = all signs
   393                              <1> 
   394                              <1> rotate32next:				; the word initially loaded in eax is all signs
   395 00001F77 4B                  <1> 	dec	ebx
   396 00001F78 87449F08            <1> 	xchg	eax, dword ptr [edi+ebx*4+2*4]
   397 00001F7C 89C1                <1> 	mov	ecx, eax
   398 00001F7E 334F04              <1> 	xor	ecx, dword ptr [edi+1*4] ; difference between this word and signs
   399 00001F81 09CA                <1> 	or	edx, ecx		; sum of differences
   400 00001F83 21DB                <1> 	and	ebx, ebx
   401 00001F85 75F0                <1> 	jnz	rotate32next
   402 00001F87 8307E0              <1> 	add	dword ptr [edi], -32	; scale down
   403 00001F8A 89D0                <1> 	mov	eax, edx
   404 00001F8C 59                  <1> 	pop	ecx
   405 00001F8D 5A                  <1> 	pop	edx
   406 00001F8E C3                  <1> 	ret
   407                              <1> 
   408                              <1> rotate8left:				; rotate all containing platform words of mantissa
   409 00001F8F 51                  <1> 	push	ecx			; 8 bit positions left. 1st word is rotated already
   410 00001F90 0FB7D9              <1> 	movzx	ebx, cx			; and contains signs in 8 low-order bit positions
   411                              <1> rotate8next:
   412 00001F93 8B4C9F08            <1> 	mov	ecx, dword ptr [edi+ebx*4+2*4]
   413 00001F97 C1C108              <1> 	rol	ecx, 8
   414 00001F9A 86C1                <1> 	xchg	al, cl
   415 00001F9C 894C9F08            <1> 	mov	dword ptr [edi+ebx*4+2*4], ecx
   416 00001FA0 83C3FF              <1> 	add	ebx, -1
   417 00001FA3 72EE                <1> 	jc	rotate8next
   418 00001FA5 8307F8              <1> 	add	dword ptr [edi], -8	; scale down
   419 00001FA8 59                  <1> 	pop	ecx
   420 00001FA9 C3                  <1> 	ret
   421                              <1> 
   422 00001FAA F75708              <1> zover:	not	dword ptr [edi+2*4]
   423 00001FAD F7570C              <1> 	not	dword ptr [edi+3*4]
   424 00001FB0 F75710              <1> 	not	dword ptr [edi+4*4]
   425 00001FB3 F75714              <1> 	not	dword ptr [edi+5*4]
   426 00001FB6 F75718              <1> 	not	dword ptr [edi+6*4]
   427 00001FB9 F7571C              <1> 	not	dword ptr [edi+7*4]
   428 00001FBC C3                  <1> 	ret
   429                              <1> 
   430                              <1> _add_low:
   431 00001FBD 8B961C040000        <1>         mov     edx, dword ptr [esi+_INPUT2+7*4]
   432 00001FC3 13963C040000        <1>         adc     edx, dword ptr [esi+_INPUTR+7*4]
   433 00001FC9 8B9E18040000        <1>         mov     ebx, dword ptr [esi+_INPUT2+6*4]
   434 00001FCF 139E38040000        <1>         adc     ebx, dword ptr [esi+_INPUTR+6*4]
   435 00001FD5 8B8614040000        <1>         mov     eax, dword ptr [esi+_INPUT2+5*4]
   436 00001FDB 138634040000        <1>         adc     eax, dword ptr [esi+_INPUTR+5*4]
   437 00001FE1 C3                  <1>         ret
   438                              <1> 
   439                              <1> _add_high:
   440 00001FE2 8B9610040000        <1>         mov     edx, dword ptr [esi+_INPUT2+4*4]
   441 00001FE8 139630040000        <1>         adc     edx, dword ptr [esi+_INPUTR+4*4]
   442 00001FEE 8B9E0C040000        <1>         mov     ebx, dword ptr [esi+_INPUT2+3*4]
   443 00001FF4 139E2C040000        <1>         adc     ebx, dword ptr [esi+_INPUTR+3*4]
   444 00001FFA 8B8608040000        <1>         mov     eax, dword ptr [esi+_INPUT2+2*4]
   445 00002000 138628040000        <1>         adc     eax, dword ptr [esi+_INPUTR+2*4]
   446 00002006 C3                  <1>         ret
   447                              <1> 
   448 00002007 8DBE00040000        <1> fan:	lea	edi, [esi+_INPUT2]
   449 0000200D E898FFFFFF          <1> 	call	zover				; mantissa
   450 00002012 F79604040000        <1> 	not	dword ptr [esi+_INPUT2+1*4]	; 32 signs
   451                              <1> 
   452 00002018 8DBE20040000        <1> fa:	lea	edi, [esi+_INPUTR]
   453 0000201E 8DB600040000        <1> 	lea	esi, [esi+_INPUT2]
   454                              <1> 
   455 00002024 8B4604              <1> 	mov	eax, dword ptr [esi+1*4]	; normalised?
   456 00002027 334608              <1> 	xor	eax, dword ptr [esi+2*4]	; normalising bit must ^ signs
   457 0000202A 7801                <1> 	js	fa_addend_normalised		; yes
   458 0000202C C3                  <1> fa_nop:	ret					; accumulator block unchanged
   459                              <1> 
   460                              <1> fa_addend_normalised:
   461 0000202D 8B4704              <1> 	mov	eax, dword ptr [edi+1*4]	; register side operand normalised?
   462 00002030 334708              <1> 	xor	eax, dword ptr [edi+2*4]	; normalising bit must ^ signs
   463 00002033 7803                <1> 	js	fa_promote_magnitude		; normalised, get on with it
   464 00002035 89F7                <1> 	mov	edi, esi			; accumulator block is not normalised
   465 00002037 C3                  <1> 	ret					; storage addend zero-added
   466                              <1> 
   467                              <1> fa_promote_magnitude:
   468 00002038 8B07                <1> 	mov	eax, dword ptr [edi]
   469 0000203A 2B06                <1> 	sub	eax, dword ptr [esi]
   470                              <1> 
   471 0000203C 7904                <1> 	jns	fa_add				; register-side operand is not lower
   472                              <1> 
   473 0000203E 87F7                <1> 	xchg	esi, edi			;
   474 00002040 F7D8                <1> 	neg	eax
   475                              <1> 
   476                              <1> fa_add:	;	call	frame_mantissa
   477 00002042 50                  <1> 	push	eax				; exponent difference
   478 00002043 E8CBFDFFFF          <1> 	call	round1
   479                              <1> 
   480 00002048 58                  <1> 	pop	eax				; exponent difference
   481 00002049 21C0                <1> 	and	eax, eax			; is + and either zero or not
   482 0000204B 740C                <1> 	jz	fa_addfast
   483                              <1> 
   484 0000204D 3DBF000000          <1> 	cmp	eax, 191			; do they touch?
   485 00002052 77D8                <1> 	ja	fa_nop
   486                              <1> 
   487 00002054 E845FEFFFF          <1> 	call	bias_addend
   488                              <1> ;	mov	esi, dword ptr [ebp+CORE_INDEX1] ; done inside bias_addend
   489                              <1> ;	lea	esi, [esi+_BIAS]		; shifted added
   490                              <1> 
   491                              <1> fa_addfast:
   492 00002059 8B4704              <1> 	mov	eax, dword ptr [edi+1*4]	; before look signs
   493 0000205C 50                  <1> 	push	eax				; near stack top until fa_normalised
   494                              <1> 
   495 0000205D C1C910              <1> 	ror	ecx, 16				; get containing compute words
   496 00002060 0FB7D9              <1> 	movzx	ebx, cx				; index / count
   497 00002063 C1C910              <1> 	ror	ecx, 16
   498                              <1> 
   499 00002066 F8                  <1> 	clc
   500                              <1> 
   501                              <1> fa_action:
   502 00002067 8B049E              <1> 	mov	eax, dword ptr [esi+ebx*4]
   503 0000206A 11049F              <1> 	adc	dword ptr [edi+ebx*4], eax
   504 0000206D 4B                  <1> 	dec	ebx				; process word 1
   505 0000206E 75F7                <1> 	jnz	fa_action			; leave word 0 alone
   506                              <1> 
   507 00002070 0F92C3              <1> 	setc	bl				; boolean instructions following
   508 00002073 53                  <1> 	push	ebx				; should not change carry but
   509                              <1> 
   510 00002074 8BB560020000        <1> 	mov	esi, dword ptr [ebp+CORE_INDEX1]
   511                              <1> 
   512                              <1> 	
   513 0000207A 8B4704              <1> 	mov	eax, dword ptr [edi+1*4]	; has sign switched ?
   514 0000207D 33442404            <1> 	xor	eax, dword ptr [esp+1*4]
   515                              <1> 	
   516 00002081 7918                <1> 	jns	fa_testcarry
   517                              <1> 
   518                              <1> ;	not	dword ptr [esi+7*4]
   519                              <1> 
   520 00002083 F6869C04000008      <1> 	test	byte ptr [esi+PSR], FP_R	; flag 8 = store residue
   521 0000208A 7506                <1> 	jnz	switch_long
   522                              <1> 
   523 0000208C F75718              <1> 	not	dword ptr [edi+6*4]		; if double size (+ residue)
   524 0000208F F75714              <1> 	not	dword ptr [edi+5*4]		; these are written in the add loop
   525                              <1> switch_long:
   526                              <1> 
   527                              <1> ;	not	dword ptr [edi+7*4]		; thru zero
   528                              <1> 
   529 00002092 56                  <1> 	push	esi				; have a clear expectation
   530 00002093 89E6                <1> 	mov	esi, esp			; where the first stack words are
   531 00002095 E8B3FDFFFF          <1> 	call	end_around_carry
   532 0000209A 5E                  <1> 	pop	esi
   533                              <1> 
   534                              <1> fa_testcarry:
   535                              <1> 
   536 0000209B 8B442404            <1> 	mov	eax, dword ptr [esp+1*4]		; [ esp + 1L ] -> updated signs
   537 0000209F 334704              <1> 	xor	eax, dword ptr [edi+1*4]		; carry from normalising position?
   538                              <1> 
   539 000020A2 2401                <1> 	and	al, 1
   540 000020A4 7422                <1> 	jz	fa_normalise
   541                              <1> 
   542 000020A6 FF07                <1> 	inc	dword ptr [edi]				; exponent magnitude++
   543                              <1> 
   544 000020A8 8B442404            <1> 	mov	eax, dword ptr [esp+1*4]	 	; read 32 signs
   545 000020AC D1C8                <1> 	ror	eax, 1					; move a sign to carry	
   546                              <1> 
   547 000020AE D15F04              <1> 	rcr	dword ptr [edi+1*4], 1			; shift from signs word
   548 000020B1 D15F08              <1> 	rcr	dword ptr [edi+2*4], 1			; to normalising position
   549 000020B4 D15F0C              <1> 	rcr	dword ptr [edi+3*4], 1			; keep going
   550 000020B7 D15F10              <1> 	rcr	dword ptr [edi+4*4], 1
   551 000020BA D15F14              <1> 	rcr	dword ptr [edi+5*4], 1
   552 000020BD D15F18              <1> 	rcr	dword ptr [edi+6*4], 1
   553 000020C0 D15F1C              <1> 	rcr	dword ptr [edi+7*4], 1
   554                              <1> 
   555 000020C3 894704              <1> 	mov	dword ptr [edi+1*4], eax		; write all signs back to signs word
   556                              <1> 
   557 000020C6 EB05                <1> 	jmp	fa_normalised
   558                              <1> 
   559                              <1> fa_normalise:
   560 000020C8 E850FEFFFF          <1> 	call	renormalise				; in case the sum is plenty positions
   561                              <1> 
   562                              <1> fa_normalised:
   563 000020CD 5B                  <1> 	pop	ebx
   564 000020CE 58                  <1> 	pop	eax					; below the fractional point
   565 000020CF C3                  <1> 	ret
   566                              <1> 	
   567 000020D0 8DBE40040000        <1> fm:	lea	edi, [esi+_OUTPUT]			; initialise final accumulation
   568 000020D6 E81EFDFFFF          <1> 	call	zoutput
   569                              <1> 
   570 000020DB 8B9E24040000        <1> 	mov	ebx, dword ptr [esi+_INPUTR+1*4]	; read register-side signs
   571 000020E1 8B8628040000        <1> 	mov	eax, dword ptr [esi+_INPUTR+2*4]	; and high-end mantissa
   572 000020E7 31D8                <1> 	xor	eax, ebx	 			; cache if-normalised in eax
   573 000020E9 339E04040000        <1> 	xor	ebx, dword ptr [esi+_INPUT2+1*4]	; multiply signs
   574 000020EF 899E44040000        <1> 	mov	dword ptr [esi+_OUTPUT+1*4], ebx	; save the output sign
   575 000020F5 21C0                <1> 	and	eax, eax				; test the cached if-normalised
   576 000020F7 790E                <1> 	jns	fmdont
   577                              <1> 
   578 000020F9 8B8604040000        <1> 	mov	eax, dword ptr [esi+_INPUT2+1*4]	; is the multiplier normalised?
   579 000020FF 338608040000        <1> 	xor	eax, dword ptr [esi+_INPUT2+2*4]	; sign XOR normalising bit?
   580 00002105 782F                <1> 	js	fmgo					; yes, proceed
   581                              <1> 
   582 00002107 899E48040000        <1> fmdont:	mov	dword ptr [esi+_OUTPUT+2*4], ebx
   583 0000210D 899E4C040000        <1> 	mov	dword ptr [esi+_OUTPUT+3*4], ebx
   584 00002113 899E50040000        <1> 	mov	dword ptr [esi+_OUTPUT+4*4], ebx
   585 00002119 899E54040000        <1> 	mov	dword ptr [esi+_OUTPUT+5*4], ebx
   586 0000211F 899E58040000        <1> 	mov	dword ptr [esi+_OUTPUT+6*4], ebx
   587 00002125 899E5C040000        <1> 	mov	dword ptr [esi+_OUTPUT+7*4], ebx
   588 0000212B C78640040000000000- <1> 	mov	dword ptr [esi+_OUTPUT], 0		; mantissa to go
   588 00002134 00                  <1>
   589                              <1> 
   590 00002135 C3                  <1> 	ret					; no, effective zero multiplier
   591                              <1> 
   592 00002136 51                  <1> fmgo:	push	ecx
   593 00002137 8B8624040000        <1> 	mov	eax, dword ptr [esi+_INPUTR+1*4]
   594 0000213D B148                <1> 	mov	cl, 72				; beats count exactly 72
   595 0000213F 21C0                <1> 	and	eax, eax
   596                              <1> 
   597 00002141 790B                <1> 	jns	fmp1
   598 00002143 8DBE20040000        <1> 	lea	edi, [esi+_INPUTR]
   599 00002149 E85CFEFFFF          <1> 	call	zover
   600                              <1> 
   601 0000214E 8B8604040000        <1> fmp1:	mov	eax, dword ptr [esi+_INPUT2+1*4]
   602 00002154 21C0                <1> 	and	eax, eax
   603 00002156 790B                <1> 	jns	fmadd
   604 00002158 8DBE00040000        <1> 	lea	edi, [esi+_INPUT2]
   605 0000215E E847FEFFFF          <1> 	call	zover
   606                              <1> 
   607 00002163 F8                  <1> fmadd:	clc
   608                              <1> 
   609 00002164 8DBE20040000        <1> 	lea	edi, [esi+_INPUTR]
   610 0000216A D15F08              <1> 	rcr	dword ptr [edi+2*4], 1		; addend shift right
   611 0000216D D15F0C              <1> 	rcr	dword ptr [edi+3*4], 1
   612 00002170 D15F10              <1> 	rcr	dword ptr [edi+4*4], 1
   613 00002173 D15F14              <1> 	rcr	dword ptr [edi+5*4], 1
   614 00002176 D15F18              <1> 	rcr	dword ptr [edi+6*4], 1
   615 00002179 D15F1C              <1> 	rcr	dword ptr [edi+7*4], 1
   616                              <1> 
   617 0000217C 8DBE00040000        <1> 	lea	edi, [esi+_INPUT2]
   618                              <1> ;	rcl	dword ptr [edi+7*4], 1		; multiplier shift left
   619                              <1> ;	rcl	dword ptr [edi+6*4], 1
   620                              <1> ;	rcl	dword ptr [edi+5*4], 1		; multiplier mantissa is only 72 bits
   621 00002182 D15710              <1> 	rcl	dword ptr [edi+4*4], 1
   622 00002185 D1570C              <1> 	rcl	dword ptr [edi+3*4], 1
   623 00002188 D15708              <1> 	rcl	dword ptr [edi+2*4], 1
   624                              <1> 
   625 0000218B 8DBE40040000        <1> 	lea	edi, [esi+_OUTPUT]
   626 00002191 7336                <1> 	jnc	fmadx
   627                              <1> 						; 1 shifted from multiplier
   628 00002193 8B863C040000        <1> fmadc:	mov	eax, dword ptr [esi+_INPUTR+7*4]	
   629 00002199 01471C              <1> 	add	dword ptr [edi+7*4], eax	; do not use carry
   630 0000219C 8B8638040000        <1> 	mov	eax, dword ptr [esi+_INPUTR+6*4]
   631 000021A2 114718              <1> 	adc	dword ptr [edi+6*4], eax	; start using carry
   632 000021A5 8B8634040000        <1> 	mov	eax, dword ptr [esi+_INPUTR+5*4]
   633 000021AB 114714              <1> 	adc	dword ptr [edi+5*4], eax
   634 000021AE 8B8630040000        <1> 	mov	eax, dword ptr [esi+_INPUTR+4*4]
   635 000021B4 114710              <1> 	adc	dword ptr [edi+4*4], eax
   636 000021B7 8B862C040000        <1> 	mov	eax, dword ptr [esi+_INPUTR+3*4]
   637 000021BD 11470C              <1> 	adc	dword ptr [edi+3*4], eax
   638 000021C0 8B8628040000        <1> 	mov	eax, dword ptr [esi+_INPUTR+2*4]
   639 000021C6 114708              <1> 	adc	dword ptr [edi+2*4], eax
   640                              <1> 
   641 000021C9 FEC9                <1> fmadx:	dec	cl
   642 000021CB 7596                <1> 	jnz	fmadd
   643                              <1> 
   644 000021CD 59                  <1> fmadz:	pop	ecx
   645                              <1> 
   646 000021CE 8B4708              <1> 	mov	eax, dword ptr [edi+2*4] 	; normalised?
   647 000021D1 D1D0                <1> 	rcl	eax, 1
   648 000021D3 721B                <1> 	jc	fm_normalised
   649                              <1> 
   650 000021D5 838620040000FF      <1> 	add	dword ptr [esi+_INPUTR], -1		; take 1 from scale
   651 000021DC D1571C              <1> 	rcl	dword ptr [edi+7*4], 1
   652 000021DF D15718              <1> 	rcl	dword ptr [edi+6*4], 1
   653 000021E2 D15714              <1> 	rcl	dword ptr [edi+5*4], 1
   654 000021E5 D15710              <1> 	rcl	dword ptr [edi+4*4], 1
   655 000021E8 D1570C              <1> 	rcl	dword ptr [edi+3*4], 1
   656 000021EB D15708              <1> 	rcl	dword ptr [edi+2*4], 1
   657                              <1> 
   658 000021EE EB26                <1> 	jmp	fm_inrange
   659                              <1> 
   660                              <1> fm_normalised:
   661 000021F0 8DBE40040000        <1> 	lea	edi, [esi+_OUTPUT]
   662 000021F6 E831FCFFFF          <1> 	call	round2
   663 000021FB 7319                <1> 	jnc	fm_inrange
   664                              <1> 
   665 000021FD D15F08              <1> 	rcr	dword ptr [edi+2*4], 1
   666 00002200 D15F0C              <1> 	rcr	dword ptr [edi+3*4], 1
   667 00002203 D15F10              <1> 	rcr	dword ptr [edi+4*4], 1
   668 00002206 D15F14              <1> 	rcr	dword ptr [edi+5*4], 1
   669 00002209 D15F18              <1> 	rcr	dword ptr [edi+6*4], 1
   670 0000220C D15F1C              <1> 	rcr	dword ptr [edi+7*4], 1
   671 0000220F 83862004000001      <1> 	add	dword ptr [esi+_INPUTR], 1
   672                              <1> 
   673                              <1> fm_inrange:
   674 00002216 8B8620040000        <1> 	mov	eax, dword ptr [esi+_INPUTR]
   675 0000221C 038600040000        <1> 	add	eax, dword ptr [esi+_INPUT2]
   676 00002222 050000C0FF          <1> 	add	eax, -00400000h
   677 00002227 8907                <1> 	mov	dword ptr [edi], eax		; insert unsigned magnitude product scale
   678 00002229 8B4704              <1> 	mov	eax, dword ptr [edi+1*4]
   679 0000222C 314708              <1> 	xor	dword ptr [edi+2*4], eax	; the mantissa gets polarised here
   680 0000222F 31470C              <1> 	xor	dword ptr [edi+3*4], eax
   681 00002232 314710              <1> 	xor	dword ptr [edi+4*4], eax
   682 00002235 314714              <1> 	xor	dword ptr [edi+5*4], eax
   683 00002238 314718              <1> 	xor	dword ptr [edi+6*4], eax
   684 0000223B 31471C              <1> 	xor	dword ptr [edi+7*4], eax
   685 0000223E C3                  <1> 	ret
   686                              <1> 
   687 0000223F 8DBE40040000        <1> fd:	lea	edi, [esi+_OUTPUT]
   688 00002245 E8AFFBFFFF          <1> 	call	zoutput				; result which may stay zero
   689 0000224A 8B8604040000        <1> 	mov	eax, dword ptr [esi+_INPUT2+1*4]	; signs
   690 00002250 89C3                <1> 	mov	ebx, eax
   691 00002252 338608040000        <1> 	xor	eax, dword ptr [esi+_INPUT2+2*4]	; normalising bit 31
   692 00002258 780C                <1> 	js	fdgo
   693 0000225A F79644040000        <1> 	not	dword ptr [esi+_OUTPUT+1*4]		; divisor 0 or otherwise unnormalised
   694 00002260 E845FDFFFF          <1> 	call	zover				; return -0.0
   695 00002265 C3                  <1> fdnop:	ret					; not normalised = zero divisor
   696                              <1> 
   697 00002266 8B8624040000        <1> fdgo:	mov     eax, dword ptr [esi+_INPUTR+1*4]	; make sure the dividend is present
   698 0000226C 338628040000        <1> 	xor	eax, dword ptr [esi+_INPUTR+2*4]	; normalising bit must be not sign
   699 00002272 783B                <1> 	js	fdop				; go after all
   700                              <1> 						; unnormalised = 0 = unnormalised
   701 00002274 8B8624040000        <1> 	mov	eax, dword ptr [esi+_INPUTR+1*4]	; read the signs I tell you
   702 0000227A C78640040000000000- <1> 	mov	dword ptr [esi+_OUTPUT], 0		; exponent magnitude of nowhere
   702 00002283 00                  <1>
   703 00002284 898644040000        <1> 	mov	dword ptr [esi+_OUTPUT+1*4], eax	; signs
   704 0000228A 898648040000        <1> 	mov	dword ptr [esi+_OUTPUT+2*4], eax	; and as much mantissa as you like
   705 00002290 89864C040000        <1> 	mov	dword ptr [esi+_OUTPUT+3*4], eax
   706 00002296 898650040000        <1> 	mov	dword ptr [esi+_OUTPUT+4*4], eax
   707 0000229C 898654040000        <1> 	mov	dword ptr [esi+_OUTPUT+5*4], eax
   708 000022A2 898658040000        <1> 	mov	dword ptr [esi+_OUTPUT+6*4], eax
   709 000022A8 89865C040000        <1> 	mov	dword ptr [esi+_OUTPUT+7*4], eax
   710 000022AE C3                  <1> 	ret
   711                              <1> 
   712 000022AF 21DB                <1> fdop:	and	ebx, ebx				; divisor either is negative magnitude
   713 000022B1 780B                <1> 	js	fd_comp1	
   714 000022B3 8DBE00040000        <1> 	lea	edi, [esi+_INPUT2]			; or shall be
   715 000022B9 E8ECFCFFFF          <1> 	call	zover
   716                              <1> fd_comp1:
   717 000022BE F78624040000000000- <1> 	test	dword ptr [esi+_INPUTR+1*4], 080000000h
   717 000022C7 80                  <1>
   718 000022C8 740B                <1> 	jz	fd_upright			; dividend must be positive magnitude
   719 000022CA 8DBE20040000        <1> 	lea	edi, [esi+_INPUTR]
   720 000022D0 E8D5FCFFFF          <1> 	call	zover
   721                              <1> fd_upright:
   722 000022D5 8DBE20040000        <1> 	lea	edi, [esi+_INPUTR]
   723                              <1> 
   724 000022DB E833FBFFFF          <1> 	call	round1				; this also sets counters
   725                              <1> 
   726 000022E0 52                  <1> 	push	edx
   727 000022E1 51                  <1> 	push	ecx
   728                              <1> 
   729                              <1> ;	add	cx, 01818h		; a divide needs 24 more beats
   730                              <1> 					; than a multiply
   731                              <1> 
   732 000022E2 89C8                <1> 	mov	eax, ecx		; save words count in add range
   733 000022E4 B15F                <1> 	mov	cl, 95
   734                              <1> 
   735 000022E6 C1E810              <1> 	shr	eax, 16			; isolate words count in add range
   736 000022E9 6683C0FA            <1> 	add	ax, -6			; is it big?
   737 000022ED 0F8391000000        <1> 	jnc	near fd_72
   738                              <1> 
   739                              <1> ;	test	ch, 128
   740                              <1> ;	jz	near fd_72
   741                              <1> 
   742 000022F3 89E7                <1> 	mov	edi, esp
   743                              <1> 
   744 000022F5 B1BF                <1> 	mov	cl, 191			; maybe
   745                              <1> 
   746 000022F7 F9                  <1> fd_144:	stc				; add negative mantissa
   747 000022F8 E8C0FCFFFF          <1> 	call	_add_low		; to positive dividend
   748 000022FD 52                  <1> 	push	edx			; save the low half in the stack
   749 000022FE 53                  <1> 	push	ebx
   750 000022FF 50                  <1> 	push	eax
   751 00002300 E8DDFCFFFF          <1> 	call	_add_high			; add the high half in eax edx ebx
   752                              <1> 
   753 00002305 7327                <1> 	jnc	fd_144level			; no carry = drop the result
   754                              <1> 
   755 00002307 898628040000        <1> 	mov	dword ptr [esi+_INPUTR+2*4], eax	; carry = update the dividend
   756 0000230D 899E2C040000        <1> 	mov	dword ptr [esi+_INPUTR+3*4], ebx
   757 00002313 899630040000        <1> 	mov	dword ptr [esi+_INPUTR+4*4], edx
   758                              <1> 
   759 00002319 58                  <1> 	pop	eax
   760 0000231A 898634040000        <1> 	mov	dword ptr [esi+_INPUTR+5*4], eax
   761 00002320 58                  <1> 	pop	eax
   762 00002321 898638040000        <1> 	mov	dword ptr [esi+_INPUTR+6*4], eax
   763 00002327 58                  <1> 	pop	eax
   764 00002328 89863C040000        <1> 	mov	dword ptr [esi+_INPUTR+7*4], eax
   765                              <1> fd_144level:
   766 0000232E 89FC                <1> 	mov	esp, edi	; clear stack whether popped or not
   767 00002330 D1965C040000        <1> 	rcl	dword ptr [esi+_OUTPUT+7*4], 1	; shift value of carry into quotient
   768 00002336 D19658040000        <1> 	rcl	dword ptr [esi+_OUTPUT+6*4], 1
   769 0000233C D19654040000        <1> 	rcl	dword ptr [esi+_OUTPUT+5*4], 1
   770 00002342 D19650040000        <1> 	rcl	dword ptr [esi+_OUTPUT+4*4], 1
   771 00002348 D1964C040000        <1> 	rcl	dword ptr [esi+_OUTPUT+3*4], 1
   772 0000234E D19648040000        <1> 	rcl	dword ptr [esi+_OUTPUT+2*4], 1
   773                              <1> 
   774 00002354 F9                  <1> 	stc
   775 00002355 D19E08040000        <1> 	rcr	dword ptr [esi+_INPUT2+2*4], 1	; shift negative addend
   776 0000235B D19E0C040000        <1> 	rcr	dword ptr [esi+_INPUT2+3*4], 1	; 1 position starboard
   777 00002361 D19E10040000        <1> 	rcr	dword ptr [esi+_INPUT2+4*4], 1
   778 00002367 D19E14040000        <1> 	rcr	dword ptr [esi+_INPUT2+5*4], 1
   779 0000236D D19E18040000        <1> 	rcr	dword ptr [esi+_INPUT2+6*4], 1
   780 00002373 D19E1C040000        <1> 	rcr	dword ptr [esi+_INPUT2+7*4], 1
   781                              <1> 
   782 00002379 80C1FF              <1> 	add	cl, -1
   783 0000237C 0F8275FFFFFF        <1> 	jc	fd_144
   784 00002382 EB44                <1> 	jmp	fd_restore	
   785                              <1> 
   786 00002384 F9                  <1> fd_72:	stc					; add negative mantissa
   787 00002385 E858FCFFFF          <1> 	call	_add_high			; to positive dividend
   788 0000238A 7312                <1> 	jnc	fd_72level			; no carry = drop the result
   789                              <1> 
   790 0000238C 898628040000        <1> 	mov	dword ptr [esi+_INPUTR+2*4], eax	; carry = update the dividend
   791 00002392 899E2C040000        <1> 	mov	dword ptr [esi+_INPUTR+3*4], ebx
   792 00002398 899630040000        <1> 	mov	dword ptr [esi+_INPUTR+4*4], edx
   793                              <1> fd_72level:
   794 0000239E D19650040000        <1> 	rcl	dword ptr [esi+_OUTPUT+4*4], 1	; shift value of carry into quotient
   795 000023A4 D1964C040000        <1> 	rcl	dword ptr [esi+_OUTPUT+3*4], 1
   796 000023AA D19648040000        <1> 	rcl	dword ptr [esi+_OUTPUT+2*4], 1
   797                              <1> 
   798 000023B0 F9                  <1> 	stc
   799 000023B1 D19E08040000        <1> 	rcr	dword ptr [esi+_INPUT2+2*4], 1	; shift negative addend
   800 000023B7 D19E0C040000        <1> 	rcr	dword ptr [esi+_INPUT2+3*4], 1	; 1 position starboard
   801 000023BD D19E10040000        <1> 	rcr	dword ptr [esi+_INPUT2+4*4], 1	;
   802                              <1> 
   803 000023C3 80C1FF              <1> 	add	cl, -1
   804 000023C6 72BC                <1> 	jc	fd_72
   805                              <1> 
   806 000023C8 59                  <1> fd_restore:	pop	ecx
   807 000023C9 5A                  <1> 		pop	edx				; hand the program counter back
   808                              <1> 
   809                              <1> 
   810                              <1> ;		mov	esi, dword ptr [ebp+CORE_INDEX1] ; fd kept esi -> core state
   811                              <1> 
   812 000023CA 8B8620040000        <1> 		mov	eax, dword ptr [esi+_INPUTR]	; + magnitude dividend exponent
   813 000023D0 2B8600040000        <1> 		sub	eax, dword ptr [esi+_INPUT2]	; + magnitude divisor exponent
   814 000023D6 0501004000          <1> 		add	eax, 00400001h			; midpoint + 1
   815 000023DB 898640040000        <1> 		mov	dword ptr [esi+_OUTPUT], eax	; magnitude of quotient scale
   816                              <1> 							; -> front of delivery string
   817 000023E1 8DBE40040000        <1> 		lea	edi, [esi+_OUTPUT]
   818                              <1> 
   819 000023E7 E831FBFFFF          <1> 		call	renormalise
   820                              <1> 
   821 000023EC 8DBE40040000        <1> 		lea	edi, [esi+_OUTPUT]			; tell rewrite where it is
   822 000023F2 8B8624040000        <1> 		mov	eax, dword ptr [esi+_INPUTR+1*4]	; determine sign of quotient
   823 000023F8 338604040000        <1> 		xor	eax, dword ptr [esi+_INPUT2+1*4]
   824 000023FE 894704              <1> 		mov	[edi+1*4], eax			; output 32 signs
   825                              <1> 							; _deliver_ polarises the quotient scale
   826 00002401 314708              <1> 		xor	dword ptr [edi+2*4], eax	; switch quotient mantissa
   827 00002404 31470C              <1> 		xor	dword ptr [edi+3*4], eax
   828 00002407 314710              <1> 		xor	dword ptr [edi+4*4], eax
   829 0000240A 314714              <1> 		xor	dword ptr [edi+5*4], eax	; switch the long mantissa
   830 0000240D 314718              <1> 		xor	dword ptr [edi+6*4], eax
   831 00002410 31471C              <1> 		xor	dword ptr [edi+7*4], eax
   832                              <1> 
   833 00002413 C3                  <1> fd_z:		ret
   834                              <1> 
   835                              <1> 	;	these instructions take the left-side + target as
   836                              <1> 	;	[register_set]->a:b:mantissa2:mantissa3
   837                              <1> 	;	and the right side as [ea]
   838                              <1> 
   839                              <1> 	;	after acquisition and before delivery they call modules
   840                              <1> ;	fa fan fm fd
   841                              <1> ;	which may be used in extended instruction sets
   842                              <1> ;	using source and target registers in the internal stack
   843                              <1> ;	with maximum mantissa size 168 bits
   844                              <1> 
   845                              <1> 
   846                              <1> ;	esi -> core state but must also be used dynamically a lot
   847                              <1> ;	ebp -> always points at either one of two locations
   848                              <1> 
   849                              <1> ;		RTA1 application registers [ 0..127 ] modeled in 128 integers
   850                              <1> ;		RTA1 interrupt registers [ 128..255 ] modeled in 128 integers
   851                              <1> ;
   852                              <1> ;	there is always a copy of esi for retrieval at [ ebp + 152 integers ] ->
   853                              <1> 
   854                              <1> ;	_________________________.------ esi and ebp in application mode
   855                              <1> ;	|  RTA1 register 0	|					|
   856                              <1> ;	|_______________________|					|
   857                              <1> ;									|
   858                              <1> ;	________________________.------- ebp in ISR mode		|
   859                              <1> ;	|  RTA1 register 128	|			|		|
   860                              <1> ;	|_______________________|			|		|
   861                              <1> ;							|		|
   862                              <1> ;							|		|
   863                              <1> ;							|		|
   864                              <1> ;	_________________________.______________________________________|
   865                              <1> ;	| RTA register 152 = esi| offset ebp + 152 integers 
   866                              <1> ;	|_______________________|			|
   867                              <1> ;							|
   868                              <1> ;	.________________________.______________________|
   869                              <1> ;	| RTA register 280 = esi| offset ebp + 152 integers
   870                              <1> ;	|_______________________|
   871                              <1> 
   872 00002414 BB04000000          <1> _fa:	mov 	ebx, a
   873 00002419 53                  <1> _far:	push	ebx
   874 0000241A E86D000000          <1> 	call	fp_operands
   875 0000241F E89A000000          <1> 	call	fp_registers_a
   876 00002424 E8EFFBFFFF          <1> 	call	fa
   877 00002429 5B                  <1> 	pop	ebx
   878 0000242A E9EEF8FFFF          <1> 	jmp	_deliver_
   879                              <1> 
   880 0000242F BB04000000          <1> _fan:	mov	ebx, a
   881 00002434 53                  <1> _fanr:	push	ebx
   882 00002435 E852000000          <1> 	call	fp_operands
   883 0000243A E87F000000          <1> 	call	fp_registers_a
   884 0000243F E8C3FBFFFF          <1> 	call	fan
   885 00002444 5B                  <1> 	pop	ebx
   886 00002445 E9D3F8FFFF          <1> 	jmp	_deliver_
   887                              <1> 
   888 0000244A BB04000000          <1> _fm:	mov	ebx, a
   889 0000244F 53                  <1> _fmr:	push	ebx
   890 00002450 E837000000          <1> 	call	fp_operands
   891 00002455 E881000000          <1> 	call	fp_registers_m
   892 0000245A E871FCFFFF          <1> 	call	fm
   893 0000245F 5B                  <1> 	pop	ebx
   894 00002460 8DBE40040000        <1> 	lea	edi, [esi+_OUTPUT]
   895 00002466 E9B2F8FFFF          <1> 	jmp	 _deliver_
   896                              <1> 
   897 0000246B BB04000000          <1> _fd:	mov	ebx, a				; default target register
   898 00002470 53                  <1> _fdr:	push	ebx
   899 00002471 E816000000          <1> 	call	fp_operands
   900 00002476 E860000000          <1> 	call	fp_registers_m
   901 0000247B E8BFFDFFFF          <1> 	call	fd
   902 00002480 5B                  <1> 	pop	ebx
   903 00002481 8DBE40040000        <1> 	lea	edi, [esi+_OUTPUT]
   904 00002487 E991F8FFFF          <1> 	jmp	_deliver_
   905                              <1> 
   906                              <1> fp_operands:
   907 0000248C 8DBE20040000        <1> 	lea	edi, [esi+_INPUTR]
   908 00002492 50                  <1> 	push	eax				; save effective address
   909 00002493 E860000000          <1> 	call	_load_quad
   910 00002498 E837F8FFFF          <1> 	call	compress4to8
   911 0000249D 58                  <1> 	pop	eax				; restore effective address
   912                              <1> 
   913 0000249E 55                  <1> 	push	ebp				; ebp must momentarily
   914 0000249F 89F5                <1> 	mov	ebp, esi			; -> start of all register list
   915 000024A1 BB00010000          <1> 	mov	ebx, _input2			; into starboard buffer
   916 000024A6 E877DEFFFF          <1> 	call	_burst_read4			; memory or registers @ ea
   917 000024AB 5D                  <1> 	pop	ebp				; App / Int register context
   918                              <1> 
   919 000024AC 8BB560020000        <1> 	mov	esi, dword ptr [ebp+CORE_INDEX1]
   920 000024B2 8DBE00040000        <1> 	lea	edi, [esi+_INPUT2]		; but still in ebp
   921 000024B8 E817F8FFFF          <1> 	call	compress4to8
   922 000024BD C3                  <1> 	ret
   923                              <1> 
   924                              <1> fp_registers_a:
   925 000024BE 8BB560020000        <1> 	mov	esi, dword ptr [ebp+CORE_INDEX1]
   926 000024C4 B908020400          <1> 	mov	ecx, 00040208h
   927 000024C9 F7869C040000080000- <1> 	test	dword ptr [esi+PSR], FP_R
   927 000024D2 00                  <1>
   928 000024D3 7405                <1> 	jz	fp_registers_x
   929 000024D5 B910040600          <1> 	mov	ecx, 00060410h
   930                              <1> fp_registers_x:
   931 000024DA C3                  <1> 	ret
   932                              <1> 
   933                              <1> fp_registers_m:
   934 000024DB 8BB560020000        <1> 	mov	esi, dword ptr [ebp+CORE_INDEX1]
   935 000024E1 B908020400          <1> 	mov	ecx, 00040208h
   936 000024E6 F7869C040000080000- <1> 	test	dword ptr [esi+PSR], FP_R
   936 000024EF 00                  <1>
   937 000024F0 7405                <1> 	jz	fp_registers_z
   938 000024F2 B910040600          <1> 	mov	ecx, 00060410h
   939                              <1> fp_registers_z:
   940 000024F7 C3                  <1> 	ret
   941                              <1> 
   942                              <1> _load_quad:
   943 000024F8 8B449D0C            <1> 	mov	eax, dword ptr[ebp+ebx*4+3*4]
   944 000024FC 89470C              <1> 	mov	dword ptr [edi+3*4], eax
   945 000024FF 8B449D08            <1> 	mov	eax, dword ptr  [ebp+ebx*4+2*4]
   946 00002503 894708              <1> 	mov	dword ptr [edi+2*4], eax
   947 00002506 8B449D04            <1> 	mov	eax, dword ptr [ebp+ebx*4+1*4]
   948 0000250A 894704              <1> 	mov	dword ptr [edi+1*4], eax
   949 0000250D 8B449D00            <1> 	mov	eax, dword ptr [ebp+ebx*4]
   950 00002511 8907                <1> 	mov	dword ptr [edi], eax
   951 00002513 C3                  <1> 	ret
   952                              <1> 
   953                              <1> 
   954                              <1> 	%if	0
   955                              <1> ultrate:
   956                              <1> 	mov	eax, dword ptr [edi]
   957                              <1> 	mov	dword ptr [_ultra], eax
   958                              <1>  
   959                              <1> 	mov     eax, dword ptr [edi+1*4]
   960                              <1> 	mov     dword ptr [_ultra1], eax
   961                              <1> 
   962                              <1>         mov     eax, dword ptr [edi+2*4]
   963                              <1>         mov     dword ptr [_ultra2], eax
   964                              <1> 
   965                              <1>         mov     eax, dword ptr [edi+3*4]
   966                              <1>         mov     dword ptr [_ultra3], eax
   967                              <1> 
   968                              <1>         mov     eax, dword ptr [edi+4*4]
   969                              <1>         mov     dword ptr [_ultra4], eax
   970                              <1> 
   971                              <1>         mov     eax, dword ptr [edi+5*4]
   972                              <1>         mov     dword ptr [_ultra5], eax
   973                              <1> 
   974                              <1>         mov     eax, dword ptr [edi+6*4]
   975                              <1>         mov     dword ptr [_ultra6], eax
   976                              <1> 
   977                              <1>         mov     eax, dword ptr [edi+7*4]
   978                              <1>         mov     dword ptr [_ultra7], eax
   979                              <1> 
   980                              <1> 	ret
   981                              <1> 
   982                              <1> zultrate:
   983                              <1> 	push	edi
   984                              <1> 	mov	edi, __ZERO
   985                              <1> 	call	ultrate
   986                              <1> 	pop	edi
   987                              <1> 	ret
   988                              <1> 
   989                              <1> __ZERO	dd	0, 0, 0, 0, 0, 0, 0, 0
   990                              <1> 	%endif
    40                                  	%include	"parity.msm"
     1                              <1> _get_parity:
     2 00002514 8B5D10              <1>         mov     ebx, dword ptr [ebp+A]
     3 00002517 235D04              <1>         and     ebx, dword ptr [ebp+K]
     4                              <1> _fold_parity:
     5 0000251A 30DF                <1>         xor     bh, bl
     6 0000251C C1EB08              <1>         shr     ebx, 8
     7 0000251F 30FB                <1>         xor     bl, bh
     8 00002521 C3                  <1>         ret
     9                              <1> 
    41                                  	%include	"margin.msm"
     1                              <1> read_straddle_12b?:
     2                              <1> 
     3 00002522 F6C101              <1> 	test	cl, 1				; 4 words? You are here because
     4 00002525 7537                <1> 	jnz	split_read4w			; offset is within last 3 of page
     5                              <1> 						; 2 words then
     6 00002527 81FEFF0F0000        <1> 	cmp	esi, 0FFFh			; starting @ last word of page?
     7 0000252D 722E                <1> 	jb	readout				; not so, go ahead with burst read
     8                              <1> 
     9                              <1> split_read2w:
    10 0000252F 8BB560020000        <1> 	mov	esi, dword ptr [ebp+CORE_INDEX1]
    11 00002535 893C24              <1> 	mov	dword ptr [esp], edi		; delete 1st return address + save EA
    12 00002538 89F8                <1> 	mov	eax, edi			; recover EA
    13 0000253A 30C9                <1> 	xor	cl, cl				; request 1 word
    14 0000253C E826DEFFFF          <1> 	call	_bus_read			;
    15 00002541 870424              <1> 	xchg	eax, dword ptr [esp]		; save 1st word read + load updated EA
    16 00002544 40                  <1> 	inc	eax				; advance EA onto next page
    17 00002545 30C9                <1> 	xor	cl, cl				; request 1 word
    18 00002547 E81BDEFFFF          <1> 	call	_bus_read			; read new page or block
    19 0000254C 89C3                <1> 	mov	ebx, eax
    20 0000254E 58                  <1> 	pop	eax				; recover 1st read word
    21 0000254F C3                  <1> 	ret					; return to caller of operand_read
    22                              <1> 
    23                              <1> read_straddle_18b?:
    24 00002550 F6C101              <1> 	test	cl, 1				; 4 words? You are here because 
    25 00002553 7509                <1> 	jnz	split_read4w			; offset is within last 3 of of bank
    26                              <1> 						; 2 words then
    27 00002555 81FEFFFF0300        <1> 	cmp	esi, 0003FFFFh			; starting @ last word of bank?
    28 0000255B 73D2                <1> 	jnb	split_read2w			; otherwise fall thru to burst read
    29                              <1> 
    30                              <1> readout:
    31 0000255D C3                  <1> 	ret					; burst read in order
    32                              <1> 
    33                              <1> split_read4w:					; write EA over stack top return address
    34 0000255E 8BB560020000        <1> 	mov	esi, dword ptr [ebp+CORE_INDEX1]
    35 00002564 893C24              <1> 	mov	dword ptr [esp], edi		; one or other of these 2-word reads
    36 00002567 89F8                <1> 	mov	eax, edi			; splits down to 1-word reads
    37 00002569 E807000000          <1> 	call	read2				; when offset is [3F]FFD
    38 0000256E E802000000          <1> 	call	read2				;             or [3F]FFF
    39 00002573 58                  <1> 	pop	eax				;   but not when [3F]FFE
    40 00002574 C3                  <1> 	ret					; return to caller of caller
    41                              <1> 	
    42 00002575 50                  <1> read2:	push	eax				; EA
    43 00002576 53                  <1> 	push	ebx				; destination index on stack top
    44 00002577 B106                <1> 	mov	cl, 6				; ask bus for 2 words
    45 00002579 E8E9DDFFFF          <1> 	call	_bus_read			; replaces eax and ebx
    46 0000257E 871C24              <1> 	xchg	ebx, dword ptr [esp]		; get destination index up again
    47 00002581 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax	; write 1st result word
    48 00002585 58                  <1> 	pop	eax				; recover 2nd result word
    49 00002586 89449D04            <1> 	mov	dword ptr [ebp+ebx*4+1*4], eax	; write 2nd result word
    50 0000258A 58                  <1> 	pop	eax				; EA
    51 0000258B 83C002              <1> 	add	eax, 2
    52 0000258E 83C302              <1> 	add	ebx, 2
    53 00002591 C3                  <1> 	ret	
    54                              <1> 
    42                                  	%include	"margin_w.msm"
     1                              <1> write_straddle_12b?:				; multiword write request
     2                              <1> write_straddle12b?:				; in last 3 words of block
     3 00002592 F6C101              <1> 	test	cl, 1				; 4-word write request?
     4 00002595 753C                <1> 	jnz	split_write4w			;
     5 00002597 81FEFF0F0000        <1> 	cmp	esi, 0FFFH			; 2 words then. In last word?
     6 0000259D 7233                <1> 	jb	writeout			; no
     7                              <1> 						; yes
     8                              <1> split_write2w:
     9 0000259F 8BB560020000        <1> 	mov	esi, dword ptr [ebp+CORE_INDEX1]
    10 000025A5 891C24              <1> 	mov	dword ptr [esp], ebx		; not returning to there
    11 000025A8 57                  <1> 	push	edi				; esp -> saved eax [ea], saved ebx
    12 000025A9 89F8                <1> 	mov	eax, edi			; place ea in eax
    13 000025AB 30C9                <1> 	xor	cl, cl				; request 1-word write
    14 000025AD 8B5C9D00            <1> 	mov	ebx, dword ptr [ebp+ebx*4]	; data from register array
    15 000025B1 E851DFFFFF          <1> 	call	bus_write
    16 000025B6 58                  <1> 	pop	eax				; retrieve ea from stack
    17 000025B7 5B                  <1> 	pop	ebx				; retrieve register index
    18 000025B8 40                  <1> 	inc	eax				; advance ea to next block
    19 000025B9 8B5C9D04            <1> 	mov	ebx, dword ptr [ebp+ebx*4+4]	; data from register array
    20 000025BD 30C9                <1> 	xor	cl, cl				; request 1-word write
    21 000025BF E843DFFFFF          <1> 	call	bus_write
    22 000025C4 C3                  <1> 	ret					; return caller of caller
    23                              <1> 
    24                              <1> write_straddle_18b?:				; multiword write request
    25                              <1> write_straddle18b?:				; in last 3 words of block
    26 000025C5 F6C101              <1> 	test	cl, 1				; 4 words?
    27 000025C8 7509                <1> 	jnz	split_write4w
    28 000025CA 81FEFFFF0300        <1> 	cmp	esi, 0003FFFFh			; 2 words then. In last word?
    29 000025D0 73CD                <1> 	jnb	split_write2w			; yes
    30                              <1> 						; no
    31                              <1> writeout:
    32 000025D2 C3                  <1> 	ret					; return to burst write
    33                              <1> 
    34                              <1> split_write4w:
    35 000025D3 8BB560020000        <1> 	mov	esi, dword ptr [ebp+CORE_INDEX1]
    36 000025D9 893C24              <1> 	mov	dword ptr [esp], edi		; return address at stack top not used
    37 000025DC 89F8                <1> 	mov	eax, edi			; copy ea
    38 000025DE E807000000          <1> 	call	write2				; request 2 writes word pairs
    39 000025E3 E802000000          <1> 	call	write2				; if 1 of them straddles it splits again
    40 000025E8 58                  <1> 	pop	eax				; this is ea
    41 000025E9 C3                  <1> 	ret					; return to caller of caller
    42                              <1> 
    43                              <1> 
    44 000025EA B106                <1> write2:	mov	cl, 6				; request 2-word bus write
    45 000025EC 50                  <1> 	push	eax				; save ea
    46 000025ED 53                  <1> 	push	ebx				; save register array index
    47 000025EE E814DFFFFF          <1> 	call	bus_write			; send write pair request
    48 000025F3 5B                  <1> 	pop	ebx				; retrieve register index
    49 000025F4 58                  <1> 	pop	eax				; and ea
    50 000025F5 83C302              <1> 	add	ebx, 2				; update register index
    51 000025F8 83C002              <1> 	add	eax, 2				; and ea
    52 000025FB C3                  <1> 	ret
    43                                  	%include	"rex.msm"
     1                              <1> 
     2                              <1> _rextable_1
     2          ******************  <1>  warning: label alone on a line without a colon might be in error [-w+orphan-labels]
     3 000025FC 000000000000000000- <1> 	dd	0, 0, 0, 0,		r_sa, r_sb, r_z, 0
     3 00002605 00000000000000-     <1>
     3 0000260C [3F290000]-         <1>
     3 00002610 [37290000]-         <1>
     3 00002614 [58290000]00000000  <1>
     4 0000261C 000000000000000000- <1> 	dd	0, 0, 0, 0,		r_la, r_lb, r_tz, r_tp
     4 00002625 00000000000000-     <1>
     4 0000262C [72290000]-         <1>
     4 00002630 [6A290000]-         <1>
     4 00002634 [00290000]-         <1>
     4 00002638 [1B290000]          <1>
     5 0000263C 0000000000000000-   <1> 	dd	0, 0, r_or, r_orB,	r_and, r_andB, r_xor, r_xorB
     5 00002644 [8F290000]-         <1>
     5 00002648 [87290000]-         <1>
     5 0000264C [B0290000]-         <1>
     5 00002650 [A8290000]-         <1>
     5 00002654 [D1290000]-         <1>
     5 00002658 [C9290000]          <1>
     6 0000265C [F2290000]-         <1> 	dd	r_aa, r_ab, r_ana, r_anb, r_m, r_mf, r_d, 0
     6 00002660 [EA290000]-         <1>
     6 00002664 [0F2A0000]-         <1>
     6 00002668 [072A0000]-         <1>
     6 0000266C [4B2A0000]-         <1>
     6 00002670 [2A2A0000]-         <1>
     6 00002674 [F02A0000]00000000  <1>
     7                              <1> 
     8                              <1> _rextable_6
     8          ******************  <1>  warning: label alone on a line without a colon might be in error [-w+orphan-labels]
     9 0000267C [312B0000]-         <1> 	dd	r_sar, r_sbr, r_dsr, 0, r_sal, r_sbl, r_dsl, 0
     9 00002680 [292B0000]-         <1>
     9 00002684 [4C2B0000]00000000- <1>
     9 0000268C [772B0000]-         <1>
     9 00002690 [6F2B0000]-         <1>
     9 00002694 [922B0000]00000000  <1>
    10 0000269C [BD2B0000]-         <1> 	dd	r_rar, r_rbr, r_drr, 0, r_ral, r_rbl, r_drl, 0
    10 000026A0 [B52B0000]-         <1>
    10 000026A4 [D62B0000]00000000- <1>
    10 000026AC [012C0000]-         <1>
    10 000026B0 [F92B0000]-         <1>
    10 000026B4 [1A2C0000]00000000  <1>
    11 000026BC [452C0000]-         <1> 	dd	r_saa, r_sba, r_dsa, 0, 0, 0, 0, 0
    11 000026C0 [3D2C0000]-         <1>
    11 000026C4 [612C0000]00000000- <1>
    11 000026CC 000000000000000000- <1>
    11 000026D5 00000000000000      <1>
    12 000026DC 000000000000000000- <1> 	dd	0, 0, 0, 0, 		0, 0, 0, 0
    12 000026E5 000000000000000000- <1>
    12 000026EE 000000000000000000- <1>
    12 000026F7 0000000000          <1>
    13                              <1> 
    14                              <1> _rextable_7
    14          ******************  <1>  warning: label alone on a line without a colon might be in error [-w+orphan-labels]
    15 000026FC 000000000000000000- <1> 	dd	0, 0, 0, 0,		0, 0, 0, 0
    15 00002705 000000000000000000- <1>
    15 0000270E 000000000000000000- <1>
    15 00002717 0000000000          <1>
    16 0000271C [842C0000]-         <1> 	dd	r_qs, r_ql, r_dte, 0,	r_fa, r_fan, r_fm, r_fd
    16 00002720 [932C0000]-         <1>
    16 00002724 [A22C0000]00000000- <1>
    16 0000272C [D0280000]-         <1>
    16 00002730 [DC280000]-         <1>
    16 00002734 [E8280000]-         <1>
    16 00002738 [F4280000]          <1>
    17 0000273C 000000000000000000- <1> 	dd	0, 0, 0, 0, 		0, r_mta, 0, 0
    17 00002745 000000000000000000- <1>
    17 0000274E 0000[B82C0000]0000- <1>
    17 00002756 000000000000        <1>
    18 0000275C [D62C0000]-         <1> 	dd	r_ds, r_dl, r_da, r_dan, 0, 0, 0, 0
    18 00002760 [E52C0000]-         <1>
    18 00002764 [182D0000]-         <1>
    18 00002768 [FE2C0000]00000000- <1>
    18 00002770 000000000000000000- <1>
    18 00002779 000000              <1>
    19                              <1> 
    20                              <1> 
    21 0000277C F6869E04000080      <1> _rex:	test	byte ptr [esi+PSR+2], 128
    22 00002783 0F88D7000000        <1> 	js	near _rex_z				; ISRs can't do this
    23                              <1> 
    24 00002789 E8D4DEFFFF          <1> 	call	memory_read				; ea -> instruction for repeat	
    25                              <1> 
    26 0000278E 8BB560020000        <1> 	mov	esi, dword ptr [ebp+CORE_INDEX1]	; retrieve smp core ->
    27 00002794 898678040000        <1> 	mov	dword ptr [esi+REGISTER+286*4], eax	; save instruction word
    28 0000279A E859D9FFFF          <1> 	call	__ea					; get initial ea of repeated  instruction
    29 0000279F 0FB6DD              <1> 	movzx	ebx, ch					; spin-off is opcode index in ch
    30                              <1> 							; and operand type in cl
    31 000027A2 80F906              <1> 	cmp	cl, 6
    32 000027A5 7214                <1> 	jb	_rex_itable1
    33 000027A7 7709                <1> 	ja	_rex_itable7
    34                              <1> 							; instruction list 6
    35 000027A9 8B1C9D[7C260000]    <1> 	mov	ebx, dword ptr [_rextable_6+ebx*4]	; shifts and jumps
    36 000027B0 EB10                <1> 	jmp	_rex_evaluate
    37                              <1> 
    38                              <1> _rex_itable7:						; instruction list 7
    39 000027B2 8B1C9D[FC260000]    <1> 	mov	ebx, dword ptr [_rextable_7+ebx*4]	; large arithmetic
    40 000027B9 EB07                <1> 	jmp	_rex_evaluate
    41                              <1> 
    42                              <1> _rex_itable1:						; instruction list 1
    43 000027BB 8B1C9D[FC250000]    <1> 	mov	ebx, dword ptr [_rextable_1+ebx*4]	; single integer arithmetic
    44                              <1> 
    45                              <1> _rex_evaluate:
    46 000027C2 21DB                <1> 	and	ebx, ebx				; instruction for repeat execute?
    47 000027C4 0F8496000000        <1> 	jz	near _rex_z				; no
    48 000027CA 899E74040000        <1> 	mov	dword ptr [esi+REGISTER+285*4], ebx	; yes: save execution logic pointer
    49                              <1> 
    50                              <1> 							; if repeat instruction is indexed:
    51                              <1> 							; quick lookup tag for index increment
    52 000027D0 C78670040000000000- <1> 	mov	dword ptr [esi+REGISTER+284*4], 0		; default no index register referenced
    52 000027D9 00                  <1>
    53 000027DA 8B9E78040000        <1> 	mov	ebx, dword ptr [esi+REGISTER+286*4]	; identify any index register tag
    54 000027E0 6621DB              <1> 	and	bx, bx					; in the instruction word
    55 000027E3 791A                <1> 	jns	_rex_ready				; by testing bit 15
    56 000027E5 66C1EB0C            <1> 	shr	bx, 12
    57                              <1> 							; must be > indirection tags *B0+ *B1+
    58 000027E9 80FB0A              <1> 	cmp	bl, 10					; pointers in storage not incremented
    59 000027EC 7211                <1> 	jb	_rex_ready				; index registers may increment
    60 000027EE 80FB0E              <1> 	cmp	bl, 14
    61 000027F1 7303                <1> 	jnb	_rex_indexed				; [   fp sp ]  registers   [ 14 15 ]
    62 000027F3 80E307              <1> 	and	bl, 7					; [ x y a b ]  registers [ 2 3 4 5 ]
    63                              <1> 
    64                              <1> _rex_indexed:
    65 000027F6 83E30F              <1> 	and	ebx, 15					; make 32-bit index value
    66 000027F9 899E70040000        <1> 	mov	dword ptr [esi+REGISTER+284*4], ebx	; write quick lookup
    67                              <1> 
    68                              <1> _rex_ready:
    69 000027FF 8B5E34              <1> 	mov	ebx, dword ptr [esi+REGISTER+Q]		; default target register [ q ] ->	
    70 00002802 FF9674040000        <1> 	call	dword ptr [esi+REGISTER+285*4]		; execute logic ->
    71                              <1> 
    72 00002808 8B8670040000        <1> 	mov	eax, dword ptr [esi+REGISTER+284*4]	; index register tag?
    73 0000280E 6621C0              <1> 	and	ax, ax
    74 00002811 7417                <1> 	jz	_rex_count				; no
    75                              <1> 
    76 00002813 8B4E5C              <1> 	mov	ecx, dword ptr [esi+REGISTER+WDATA]
    77 00002816 81E1FFFFFF00        <1> 	and	ecx, 00FFFFFFh				; index register increment configured?
    78 0000281C 740C                <1> 	jz	_rex_count				; no
    79                              <1> 
    80 0000281E 030C86              <1> 	add	ecx, dword ptr [esi+REGISTER+eax*4]	; calculate index + increment
    81 00002821 81E1FFFFFF00        <1> 	and	ecx, 00FFFFFFh				; 
    82 00002827 890C86              <1> 	mov	dword ptr [esi+REGISTER+eax*4], ecx	; write back to tagged index register
    83                              <1> 
    84                              <1> _rex_count:
    85 0000282A 8B4650              <1> 	mov	eax, dword ptr [esi+REGISTER+RDATAC]
    86 0000282D 48                  <1> 	dec	eax
    87 0000282E 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
    88                              <1> 
    89 00002833 894650              <1> 	mov	dword ptr [esi+REGISTER+RDATAC], eax
    90 00002836 A900008000          <1> 	test	eax, 00800000h
    91 0000283B 7523                <1> 	jnz	_rex_z					; reached -1 end
    92                              <1> 
    93 0000283D 66F78690040000C0FF  <1> 	test	word ptr [esi+INDICATION], EXTERNAL_INDICATIONS
    94 00002846 7405                <1> 	jz	_rex_along
    95                              <1> 
    96 00002848 83C2FC              <1> 	add	edx, -4					; restart after
    97 0000284B EB13                <1> 	jmp	_rex_z					; yielding to interrupt
    98                              <1> 
    99                              <1> _rex_along:
   100 0000284D 8B8678040000        <1> 	mov	eax, [esi+REGISTER+286*4]			; instruction encoding
   101 00002853 E8A0D8FFFF          <1> 	call	__ea
   102 00002858 8B9E74040000        <1> 	mov	ebx, [esi+REGISTER+285*4]			; command pointer
   103 0000285E EB9F                <1> 	jmp	_rex_ready
   104 00002860 C3                  <1> _rex_z:	ret
   105                              <1> 
   106                              <1> _rex_prime_final_count:
   107 00002861 F7455000008000      <1> 	test	dword ptr [ebp+RDATAC], 00800000h
   108 00002868 7422                <1> 	jz	_rex_primed
   109 0000286A 8B5D58              <1> 	mov	ebx, dword ptr [ebp+WDATAC]
   110 0000286D 895D50              <1> 	mov	dword ptr [ebp+RDATAC], ebx
   111 00002870 C3                  <1> 	ret
   112                              <1> 
   113                              <1> _rex_prime:
   114 00002871 F7455000008000      <1> 	test	dword ptr [ebp+RDATAC], 00800000h
   115 00002878 7412                <1> 	jz	_rex_primed
   116 0000287A 8B5D58              <1> 	mov	ebx, dword ptr [ebp+WDATAC]
   117 0000287D 895D50              <1> 	mov	dword ptr [ebp+RDATAC], ebx
   118 00002880 8B5D3C              <1> 	mov	ebx, dword ptr [ebp+S_P]
   119 00002883 81E3FFFFFF00        <1> 	and	ebx, 00FFFFFFh
   120 00002889 895D34              <1> 	mov	dword ptr [ebp+Q], ebx
   121                              <1> _rex_primed:
   122 0000288C C3                  <1> 	ret
   123                              <1> 
   124                              <1> _rex_accumulate:
   125 0000288D 8BB560020000        <1> 	mov	esi, dword ptr [ebp+CORE_INDEX1]
   126 00002893 8B5E54              <1> 	mov	ebx, dword ptr [esi+RDATA]
   127 00002896 035D34              <1> 	add	ebx, dword ptr [ebp+Q]
   128 00002899 81E3FFFFFF00        <1> 	and	ebx, 00FFFFFFh
   129 0000289F 895D34              <1> 	mov	dword ptr [ebp+Q], ebx
   130 000028A2 C3                  <1> 	ret
   131                              <1> 
   132                              <1> _rex_chex_127:
   133 000028A3 E8C9FFFFFF          <1> 	call	_rex_prime
   134 000028A8 83FB7F              <1> 	cmp	ebx, 127
   135 000028AB 7618                <1> 	jna	_rex_chex_low
   136 000028AD EB1C                <1> 	jmp	_rex_chexit
   137                              <1> 
   138                              <1> _rex_chex_126:
   139 000028AF E8BDFFFFFF          <1> 	call	_rex_prime
   140 000028B4 83FB7E              <1> 	cmp	ebx, 126
   141 000028B7 760C                <1> 	jna	_rex_chex_low
   142 000028B9 EB10                <1> 	jmp	_rex_chexit
   143                              <1> 
   144                              <1> _rex_chex_124:
   145 000028BB E8B1FFFFFF          <1> 	call	_rex_prime
   146 000028C0 83FB7C              <1> 	cmp	ebx, 124
   147 000028C3 7706                <1> 	ja	_rex_chexit
   148                              <1> _rex_chex_low:
   149 000028C5 83FB18              <1> 	cmp	ebx, 24
   150 000028C8 7201                <1> 	jb	_rex_chexit
   151 000028CA C3                  <1> 	ret
   152                              <1> 
   153                              <1> _rex_chexit:
   154 000028CB E943E6FFFF          <1> 	jmp	guard_ii_authority
   155                              <1> 
   156                              <1> ;	eax = EA
   157                              <1> ;	q -> target register selected
   158                              <1> 
   159 000028D0 E8E6FFFFFF          <1> r_fa:	call	_rex_chex_124
   160 000028D5 E83FFBFFFF          <1> 	call	_far
   161 000028DA EBB1                <1> 	jmp	_rex_accumulate
   162                              <1> 
   163 000028DC E8DAFFFFFF          <1> r_fan:	call	_rex_chex_124
   164 000028E1 E84EFBFFFF          <1> 	call	_fanr
   165 000028E6 EBA5                <1> 	jmp	_rex_accumulate
   166                              <1> 
   167 000028E8 E8CEFFFFFF          <1> r_fm:	call	_rex_chex_124
   168 000028ED E85DFBFFFF          <1> 	call	_fmr
   169 000028F2 EB99                <1> 	jmp	_rex_accumulate
   170                              <1> 
   171 000028F4 E8C2FFFFFF          <1> r_fd:	call	_rex_chex_124
   172 000028F9 E872FBFFFF          <1> 	call	_fdr
   173 000028FE EB8D                <1> 	jmp	_rex_accumulate
   174                              <1> 
   175 00002900 E85CFFFFFF          <1> r_tz:	call	_rex_prime_final_count
   176 00002905 80F904              <1> 	cmp	cl, 4			; may not be [ i xi ]
   177 00002908 732C                <1> 	jnb	r_noskip		; but pointers are updated on no_op
   178 0000290A E840DAFFFF          <1> 	call	_operand_read
   179 0000290F 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   180 00002914 7520                <1> 	jnz	r_noskip
   181                              <1> 
   182 00002916 E9B1030000          <1> 	jmp	r_skipout		; stop search repeat
   183                              <1> 
   184 0000291B E841FFFFFF          <1> r_tp:	call	_rex_prime_final_count
   185 00002920 80F904              <1> 	cmp	cl, 4			; may not be [ i xi ]
   186 00002923 7311                <1> 	jnb	r_noskip		; but pointers are updated on no_op
   187 00002925 E825DAFFFF          <1> 	call	_operand_read
   188 0000292A A900008000          <1> 	test	eax, 00800000h
   189 0000292F 7505                <1> 	jnz	r_noskip
   190                              <1> 
   191 00002931 E996030000          <1> 	jmp	r_skipout		; stop search repeat
   192                              <1> 
   193 00002936 C3                  <1> r_noskip:	ret
   194                              <1> 
   195 00002937 E873FFFFFF          <1> r_sb:	call	_rex_chex_126
   196 0000293C 43                  <1> 	inc	ebx			; starboard lane
   197 0000293D EB05                <1> 	jmp	r_s
   198 0000293F E85FFFFFFF          <1> r_sa:	call	_rex_chex_127
   199 00002944 80F904              <1> r_s:	cmp	cl, 4			; may not be [ i xi ]
   200 00002947 7309                <1> 	jnb	r_no_op_s		; but pointers are updated 
   201 00002949 8B5C9D00            <1> 	mov	ebx, dword ptr [ebp+ebx*4]
   202 0000294D E892DBFFFF          <1> 	call	_operand_write
   203                              <1> r_no_op_s:
   204 00002952 E936FFFFFF          <1> 	jmp	_rex_accumulate
   205 00002957 C3                  <1> 	ret
   206                              <1> 
   207 00002958 E804FFFFFF          <1> r_z:	call	_rex_prime_final_count
   208 0000295D 80F904              <1> 	cmp	cl, 4			; may not be [ i xi ]
   209 00002960 7307                <1> 	jnb	r_no_op_z		; but pointers are updated
   210 00002962 31DB                <1> 	xor	ebx, ebx
   211 00002964 E97BDBFFFF          <1> 	jmp	_operand_write
   212                              <1> r_no_op_z:
   213 00002969 C3                  <1> 	ret
   214                              <1> 
   215 0000296A E840FFFFFF          <1> r_lb:	call	_rex_chex_126
   216 0000296F 43                  <1> 	inc	ebx			; starboard lane
   217 00002970 EB05                <1> 	jmp	r_l
   218 00002972 E82CFFFFFF          <1> r_la:	call	_rex_chex_127
   219 00002977 53                  <1> r_l:	push	ebx
   220 00002978 E8D2D9FFFF          <1> 	call	_operand_read
   221 0000297D 5B                  <1> 	pop	ebx
   222 0000297E 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   223 00002982 E906FFFFFF          <1> 	jmp	_rex_accumulate
   224                              <1> 
   225 00002987 E823FFFFFF          <1> r_orB:	call	_rex_chex_126
   226 0000298C 43                  <1> 	inc	ebx			; starboard lane
   227 0000298D EB05                <1> 	jmp	r_OR
   228 0000298F E80FFFFFFF          <1> r_or:	call	_rex_chex_127
   229 00002994 53                  <1> r_OR:	push	ebx
   230 00002995 E8B5D9FFFF          <1> 	call	_operand_read
   231 0000299A 5B                  <1> 	pop	ebx
   232 0000299B 0B449D00            <1> 	or	eax, dword ptr [ebp+ebx*4]
   233 0000299F 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   234 000029A3 E9E5FEFFFF          <1> 	jmp	_rex_accumulate
   235                              <1> 
   236 000029A8 E802FFFFFF          <1> r_andB:	call	_rex_chex_126
   237 000029AD 43                  <1> 	inc	ebx		; starboard lane
   238 000029AE EB05                <1> 	jmp	r_AND
   239 000029B0 E8EEFEFFFF          <1> r_and:	call	_rex_chex_127
   240 000029B5 53                  <1> r_AND:	push	ebx
   241 000029B6 E894D9FFFF          <1> 	call	_operand_read
   242 000029BB 5B                  <1> 	pop	ebx
   243 000029BC 23449D00            <1> 	and	eax, dword ptr [ebp+ebx*4]
   244 000029C0 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   245 000029C4 E9C4FEFFFF          <1> 	jmp	_rex_accumulate
   246                              <1> 
   247 000029C9 E8E1FEFFFF          <1> r_xorB:	call	_rex_chex_126
   248 000029CE 43                  <1> 	inc	ebx		; starboard lane
   249 000029CF EB05                <1> 	jmp	r_XOR
   250 000029D1 E8CDFEFFFF          <1> r_xor:	call	_rex_chex_127
   251 000029D6 53                  <1> r_XOR:	push	ebx
   252 000029D7 E873D9FFFF          <1> 	call	_operand_read
   253 000029DC 5B                  <1> 	pop	ebx
   254 000029DD 33449D00            <1> 	xor	eax, dword ptr [ebp+ebx*4]
   255 000029E1 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   256 000029E5 E9A3FEFFFF          <1> 	jmp	_rex_accumulate
   257                              <1> 
   258 000029EA E8C0FEFFFF          <1> r_ab:	call	_rex_chex_126
   259 000029EF 43                  <1> 	inc	ebx		; starboard lane
   260 000029F0 EB05                <1> 	jmp	r_a
   261 000029F2 E8ACFEFFFF          <1> r_aa:	call	_rex_chex_127
   262 000029F7 53                  <1> r_a:	push	ebx
   263 000029F8 E852D9FFFF          <1> 	call	_operand_read
   264 000029FD 5F                  <1> 	pop	edi
   265 000029FE 0344BD00            <1> 	add	eax, dword ptr [ebp+edi*4]
   266 00002A02 E932030000          <1> 	jmp	r_store_carry
   267                              <1> 
   268 00002A07 E8A3FEFFFF          <1> r_anb:	call	_rex_chex_126
   269 00002A0C 43                  <1> 	inc	ebx		; starboard lane
   270 00002A0D EB05                <1> 	jmp	r_an
   271 00002A0F E88FFEFFFF          <1> r_ana:	call	_rex_chex_127
   272 00002A14 53                  <1> r_an:	push	ebx
   273 00002A15 E835D9FFFF          <1> 	call	_operand_read
   274 00002A1A 5F                  <1> 	pop	edi
   275 00002A1B 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   276 00002A20 40                  <1> 	inc	eax
   277 00002A21 0344BD00            <1> 	add	eax, dword ptr [ebp+edi*4]
   278 00002A25 E90F030000          <1> 	jmp	r_store_carry
   279                              <1> 
   280 00002A2A E874FEFFFF          <1> r_mf:	call    _rex_chex_127
   281 00002A2F 52                  <1> 	push	edx
   282 00002A30 53                  <1> 	push	ebx
   283 00002A31 E819D9FFFF          <1> 	call	_operand_read
   284 00002A36 5F                  <1> 	pop	edi
   285 00002A37 0FAF44BD00          <1> 	imul	eax, dword ptr [ebp+edi*4]
   286 00002A3C 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   287 00002A41 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
   288 00002A45 5A                  <1> 	pop	edx
   289 00002A46 E942FEFFFF          <1> 	jmp	_rex_accumulate
   290                              <1> 
   291                              <1> ; use the platform unsigned multiply
   292                              <1> ; work in positive magnitude
   293                              <1> ; adjust the final sign after offset-adding products
   294                              <1> 
   295 00002A4B E85FFEFFFF          <1> r_m:	call	_rex_chex_126
   296 00002A50 52                  <1> 	push	edx
   297 00002A51 53                  <1> 	push	ebx			; register stack cursor
   298 00002A52 E8F8D8FFFF          <1> 	call	_operand_read
   299 00002A57 5F                  <1> 	pop	edi			; recover register stack cursor
   300                              <1> 
   301 00002A58 31C9                <1> 	xor	ecx, ecx		; final sign
   302 00002A5A A900008000          <1> 	test	eax, 00800000h		;
   303 00002A5F 740D                <1> 	jz	r_msigu?		; negative multiplier?
   304 00002A61 F7D1                <1> 	not	ecx			; final sign reverse
   305 00002A63 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   306 00002A68 40                  <1> 	inc	eax			; 2s complement
   307 00002A69 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   308                              <1> 
   309                              <1> r_msigu?:
   310 00002A6E 89C3                <1> 	mov	ebx, eax		; multiplier 2b used twice
   311 00002A70 8B44BD00            <1> 	mov	eax, dword ptr [ebp+edi*4]
   312 00002A74 A900008000          <1> 	test	eax, 00800000h		; multiply high order part 1st
   313 00002A79 7426                <1> 	jz	r_mgoferit_yall
   314                              <1> 
   315 00002A7B F7D1                <1> 	not	ecx			; final sign reverse
   316 00002A7D 8B54BD04            <1> 	mov	edx, dword ptr [ebp+edi*4+4]
   317 00002A81 81F2FFFFFF00        <1> 	xor	edx, 00FFFFFFh
   318 00002A87 42                  <1> 	inc	edx			; 2s complement
   319 00002A88 C1C208              <1> 	rol	edx, 8
   320 00002A8B 0FB6F2              <1> 	movzx	esi, dl
   321 00002A8E C1EA08              <1> 	shr	edx, 8
   322 00002A91 8954BD04            <1> 	mov	dword ptr [ebp+edi*4+4], edx
   323 00002A95 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh		; ms register long multiplicand
   324 00002A9A 01F0                <1> 	add	eax, esi
   325 00002A9C 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   326                              <1> 
   327                              <1> r_mgoferit_yall:
   328 00002AA1 F7E3                <1> 	mul	ebx			; multiply high order part
   329 00002AA3 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax	; save lower half of product
   330 00002AA7 8B44BD04            <1> 	mov	eax, dword ptr [ebp+edi*4+4]	; multiply low order part
   331 00002AAB F7E3                <1> 	mul	ebx
   332 00002AAD C1E208              <1> 	shl	edx, 8			; 8 bits of eax must shift up to edx
   333 00002AB0 C1C008              <1> 	rol	eax, 8
   334 00002AB3 88C2                <1> 	mov	dl, al
   335 00002AB5 C1E808              <1> 	shr	eax, 8			; leaving 8 zeros in eax high end
   336 00002AB8 0354BD00            <1> 	add	edx, dword ptr [ebp+edi*4]	; add2 lower half of 1st product
   337 00002ABC 21C9                <1> 	and	ecx, ecx		; final sign?
   338 00002ABE 7917                <1> 	jns	r_m_writeback
   339                              <1> 
   340 00002AC0 81F2FFFFFF00        <1> 	xor	edx, 00FFFFFFh
   341 00002AC6 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   342 00002ACB 40                  <1> 	inc	eax			; 2s complement
   343 00002ACC C1C008              <1> 	rol	eax, 8			; carried out single bit?
   344 00002ACF 0FB6F0              <1> 	movzx	esi, al			; must add to edx
   345 00002AD2 C1E808              <1> 	shr	eax, 8
   346 00002AD5 01F2                <1> 	add	edx, esi
   347                              <1> 
   348                              <1> r_m_writeback:
   349 00002AD7 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   350 00002ADC 81E2FFFFFF00        <1> 	and	edx, 00FFFFFFh
   351 00002AE2 8944BD04            <1> 	mov	dword ptr [ebp+edi*4+4], eax	
   352 00002AE6 8954BD00            <1> 	mov	dword ptr [ebp+edi*4], edx
   353 00002AEA 5A                  <1> 	pop	edx
   354 00002AEB E99DFDFFFF          <1> 	jmp	_rex_accumulate
   355                              <1> 
   356 00002AF0 E8BAFDFFFF          <1> r_d:	call	_rex_chex_126
   357 00002AF5 89DF                <1> 	mov	edi, ebx		; register cursor
   358 00002AF7 E8F8ECFFFF          <1> 	call	_divide
   359 00002AFC 895CBD04            <1> 	mov	dword ptr [ebp+edi*4+4], ebx
   360 00002B00 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
   361 00002B04 8BB560020000        <1> 	mov	esi, dword ptr [ebp+CORE_INDEX1]
   362 00002B0A F6869C04000008      <1> 	test	byte ptr [esi+PSR], FP_R
   363 00002B11 0F8476FDFFFF        <1> 	jz	_rex_accumulate
   364 00002B17 83FF7D              <1> 	cmp	edi, 125
   365 00002B1A 0F876DFDFFFF        <1> 	ja	_rex_accumulate
   366 00002B20 894CBD08            <1> 	mov	dword ptr [ebp+edi*4+8], ecx
   367 00002B24 E964FDFFFF          <1> r_dnor:	jmp	_rex_accumulate
   368                              <1> 
   369 00002B29 E881FDFFFF          <1> r_sbr:	call	_rex_chex_126
   370 00002B2E 43                  <1> 	inc	ebx		; starboard lane
   371 00002B2F EB05                <1> 	jmp	r_lsr
   372 00002B31 E86DFDFFFF          <1> r_sar:	call	_rex_chex_127
   373 00002B36 88C1                <1> r_lsr	mov	cl, al
   374 00002B38 8B449D00            <1> 	mov	eax, dword ptr [ebp+ebx*4]
   375 00002B3C D3E8                <1> 	shr	eax, cl
   376 00002B3E 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   377 00002B43 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   378 00002B47 E941FDFFFF          <1> 	jmp	_rex_accumulate
   379                              <1> 
   380 00002B4C E85EFDFFFF          <1> r_dsr:	call	_rex_chex_126
   381 00002B51 88C1                <1> 	mov	cl, al
   382 00002B53 89DF                <1> 	mov	edi, ebx
   383 00002B55 8B44BD00            <1> 	mov	eax, dword ptr [ebp+edi*4]
   384 00002B59 8B5CBD04            <1> 	mov	ebx, dword ptr [ebp+edi*4+4]
   385 00002B5D E8D3EDFFFF          <1> 	call	dsr
   386 00002B62 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
   387 00002B66 895CBD04            <1> 	mov	dword ptr [ebp+edi*4+4], ebx
   388 00002B6A E91EFDFFFF          <1> 	jmp	_rex_accumulate
   389                              <1> 
   390 00002B6F E83BFDFFFF          <1> r_sbl:	call	_rex_chex_126
   391 00002B74 43                  <1> 	inc	ebx		; starboard lane
   392 00002B75 EB05                <1> 	jmp	r_lsl
   393 00002B77 E827FDFFFF          <1> r_sal:	call	_rex_chex_127
   394 00002B7C 88C1                <1> r_lsl:	mov	cl, al
   395 00002B7E 8B449D00            <1> 	mov	eax, dword ptr [ebp+ebx*4]
   396 00002B82 D3E0                <1> 	shl	eax, cl
   397 00002B84 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   398 00002B89 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   399 00002B8D E9FBFCFFFF          <1> 	jmp	_rex_accumulate
   400                              <1> 
   401 00002B92 E818FDFFFF          <1> r_dsl:	call	_rex_chex_126
   402 00002B97 88C1                <1> 	mov	cl, al
   403 00002B99 89DF                <1> 	mov	edi, ebx
   404 00002B9B 8B44BD00            <1> 	mov	eax, dword ptr [ebp+edi*4]
   405 00002B9F 8B5CBD04            <1> 	mov	ebx, dword ptr [ebp+edi*4+4]
   406 00002BA3 E8C2EDFFFF          <1> 	call	dsl
   407 00002BA8 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
   408 00002BAC 895CBD04            <1> 	mov	dword ptr [ebp+edi*4+4], ebx
   409 00002BB0 E9D8FCFFFF          <1> 	jmp	_rex_accumulate
   410                              <1> 
   411 00002BB5 E8F5FCFFFF          <1> r_rbr:	call	_rex_chex_126
   412 00002BBA 43                  <1> 	inc	ebx		; starboard lane
   413 00002BBB EB05                <1> 	jmp	r_rr
   414 00002BBD E8E1FCFFFF          <1> r_rar:	call	_rex_chex_127
   415 00002BC2 89DF                <1> r_rr:	mov	edi, ebx
   416 00002BC4 8B5CBD00            <1> 	mov	ebx, dword ptr [ebp+edi*4]
   417 00002BC8 E80AEEFFFF          <1> 	call	rr
   418 00002BCD 895CBD00            <1> 	mov	dword ptr [ebp+edi*4], ebx
   419 00002BD1 E9B7FCFFFF          <1> 	jmp	_rex_accumulate
   420                              <1> 
   421 00002BD6 E8D4FCFFFF          <1> r_drr:	call	_rex_chex_126
   422 00002BDB 88C1                <1> 	mov	cl, al
   423 00002BDD 89DF                <1> 	mov	edi, ebx
   424 00002BDF 8B44BD00            <1> 	mov	eax, dword ptr [ebp+edi*4]
   425 00002BE3 8B5CBD04            <1> 	mov	ebx, dword ptr [ebp+edi*4+4]
   426 00002BE7 E839EEFFFF          <1> 	call	drr
   427 00002BEC 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
   428 00002BF0 895CBD04            <1> 	mov	dword ptr [ebp+edi*4+4], ebx
   429 00002BF4 E994FCFFFF          <1> 	jmp	_rex_accumulate
   430                              <1> 
   431 00002BF9 E8B1FCFFFF          <1> r_rbl:	call	_rex_chex_126
   432 00002BFE 43                  <1> 	inc	ebx		; starboard lane
   433 00002BFF EB05                <1> 	jmp	r_rl
   434 00002C01 E89DFCFFFF          <1> r_ral:	call	_rex_chex_127
   435 00002C06 89DF                <1> r_rl:	mov	edi, ebx
   436 00002C08 8B5CBD00            <1> 	mov	ebx, dword ptr [ebp+edi*4]
   437 00002C0C E8ECEDFFFF          <1> 	call	rl
   438 00002C11 895CBD00            <1> 	mov	dword ptr [ebp+edi*4], ebx
   439 00002C15 E973FCFFFF          <1> 	jmp	_rex_accumulate
   440                              <1> 
   441 00002C1A E890FCFFFF          <1> r_drl:	call	_rex_chex_126
   442 00002C1F 88C1                <1> 	mov	cl, al
   443 00002C21 89DF                <1> 	mov	edi, ebx
   444 00002C23 8B44BD00            <1> 	mov	eax, dword ptr [ebp+edi*4]
   445 00002C27 8B5CBD04            <1> 	mov	ebx, dword ptr [ebp+edi*4+4]
   446 00002C2B E84BEEFFFF          <1> 	call	drl
   447 00002C30 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
   448 00002C34 895CBD04            <1> 	mov	dword ptr [ebp+edi*4+4], ebx
   449 00002C38 E950FCFFFF          <1> 	jmp	_rex_accumulate
   450                              <1> 
   451 00002C3D E86DFCFFFF          <1> r_sba:	call	_rex_chex_126
   452 00002C42 43                  <1> 	inc	ebx		; starboard lane
   453 00002C43 EB05                <1> 	jmp	r_asr
   454 00002C45 E859FCFFFF          <1> r_saa:	call	_rex_chex_127
   455 00002C4A 88C1                <1> r_asr:	mov	cl, al
   456 00002C4C 8B449D00            <1> 	mov	eax, dword ptr [ebp+ebx*4]
   457 00002C50 C1E008              <1> 	shl	eax, 8
   458 00002C53 D3F8                <1> 	sar	eax, cl
   459 00002C55 C1E808              <1> 	shr	eax, 8
   460 00002C58 89449D00            <1> 	mov	dword ptr [ebp+ebx*4], eax
   461 00002C5C E92CFCFFFF          <1> 	jmp	_rex_accumulate
   462                              <1> 
   463 00002C61 E849FCFFFF          <1> r_dsa:	call	_rex_chex_126
   464 00002C66 88C1                <1> 	mov	cl, al
   465 00002C68 89DF                <1> 	mov	edi, ebx
   466 00002C6A 8B44BD00            <1> 	mov	eax, dword ptr [ebp+edi*4]
   467 00002C6E 8B5CBD04            <1> 	mov	ebx, dword ptr [ebp+edi*4+4]
   468 00002C72 E82AEDFFFF          <1> 	call	dsa
   469 00002C77 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
   470 00002C7B 895CBD04            <1> 	mov	dword ptr [ebp+edi*4+4], ebx
   471 00002C7F E909FCFFFF          <1> 	jmp	_rex_accumulate
   472                              <1> 
   473 00002C84 E832FCFFFF          <1> r_qs:	call	_rex_chex_124
   474 00002C89 E8E0D7FFFF          <1> 	call	_burst_write4	; eax -> ea / ebx -> register cursor
   475 00002C8E E9FAFBFFFF          <1> 	jmp	_rex_accumulate
   476                              <1> 
   477 00002C93 E823FCFFFF          <1> r_ql:	call	_rex_chex_124
   478 00002C98 E885D6FFFF          <1> 	call	_burst_read4	; eax -> ea / ebx -> register cursor
   479 00002C9D E9EBFBFFFF          <1> 	jmp	_rex_accumulate
   480                              <1> 
   481 00002CA2 E8BAFBFFFF          <1> r_dte:	call	_rex_prime_final_count
   482 00002CA7 E861D6FFFF          <1> 	call	_burst_read2
   483 00002CAC 334510              <1> 	xor	eax, dword ptr [ebp+A]
   484 00002CAF 7524                <1> 	jnz	r_mtax
   485 00002CB1 335D14              <1> 	xor	ebx, dword ptr [ebp+B]
   486 00002CB4 751F                <1> 	jnz	r_mtax
   487 00002CB6 EB14                <1> 	jmp	r_skipout		; stop search repeat
   488                              <1> 
   489 00002CB8 E8A4FBFFFF          <1> r_mta:	call	_rex_prime_final_count
   490 00002CBD B100                <1> 	mov	cl, 0		; operand size 1 word
   491 00002CBF E88BD6FFFF          <1> 	call	_operand_read
   492 00002CC4 334510              <1> 	xor	eax, dword ptr [ebp+A]
   493 00002CC7 234504              <1> 	and	eax, dword ptr [ebp+K]
   494 00002CCA 7509                <1> 	jnz	r_mtax
   495                              <1> 
   496                              <1> r_skipout:				; stop search repeat
   497 00002CCC 83C204              <1> 	add	edx, 4
   498 00002CCF 8BA57C040000        <1> 	mov	esp, dword ptr [ebp+287*4]
   499 00002CD5 C3                  <1> r_mtax:	ret
   500                              <1> 
   501 00002CD6 E8D4FBFFFF          <1> r_ds:	call	_rex_chex_126
   502 00002CDB E8D3D7FFFF          <1> 	call	_burst_write2	; eax -> ea / ebx -> register cursor
   503 00002CE0 E9A8FBFFFF          <1> 	jmp	_rex_accumulate
   504                              <1> 
   505 00002CE5 E8C5FBFFFF          <1> r_dl:	call	 _rex_chex_126
   506 00002CEA 53                  <1> 	push	ebx
   507 00002CEB E81DD6FFFF          <1> 	call	_burst_read2
   508 00002CF0 5F                  <1> 	pop	edi
   509 00002CF1 895CBD04            <1> 	mov	dword ptr [ebp+edi*4+4], ebx
   510 00002CF5 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
   511 00002CF9 E98FFBFFFF          <1> 	jmp	_rex_accumulate
   512                              <1> 
   513 00002CFE E8ACFBFFFF          <1> r_dan:	call	 _rex_chex_126
   514 00002D03 53                  <1> 	push	ebx
   515 00002D04 E804D6FFFF          <1> 	call	_burst_read2
   516 00002D09 5F                  <1> 	pop	edi
   517 00002D0A 81F3FFFFFF00        <1> 	xor	ebx, 00FFFFFFh
   518 00002D10 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   519 00002D15 43                  <1> 	inc	ebx
   520 00002D16 EB0C                <1> 	jmp	r_danad
   521                              <1> 
   522 00002D18 E892FBFFFF          <1> r_da:	call	 _rex_chex_126
   523 00002D1D 53                  <1> 	push	ebx
   524 00002D1E E8EAD5FFFF          <1> 	call	_burst_read2
   525 00002D23 5F                  <1> 	pop	edi
   526                              <1> 
   527                              <1> r_danad:
   528 00002D24 035CBD04            <1> 	add	ebx, dword ptr [ebp+edi*4+4]
   529 00002D28 C1E308              <1> 	shl	ebx, 8
   530 00002D2B 83D000              <1> 	adc	eax, 0
   531 00002D2E C1EB08              <1> 	shr	ebx, 8
   532 00002D31 895CBD04            <1> 	mov	dword ptr [ebp+edi*4+4], ebx
   533 00002D35 0344BD00            <1> 	add	eax, dword ptr [ebp+edi*4]
   534                              <1> 
   535                              <1> r_store_carry:
   536 00002D39 E8AEEEFFFF          <1> 	call	_alu_carry
   537 00002D3E 8944BD00            <1> 	mov	dword ptr [ebp+edi*4], eax
   538 00002D42 E946FBFFFF          <1> 	jmp	_rex_accumulate
   539                              <1> 
    44                                  					; data follows here
    45                                  					; if it is in this assembly
    46                                  	%if	RTA_MBANKS
    47                                  
    48                                  	section		.data
    49                                  	%include	"rta_data.msm"
    50                                  
    51                                  	section		.bss
    52                                  _memory	resd	MEMORY
    53                                  
    54                                  	%endif
    55                                  
    56                                  	end
    56          ******************       warning: label alone on a line without a colon might be in error [-w+orphan-labels]
    57                                  
