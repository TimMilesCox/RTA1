
p	$proc
__TILE*	$name

__MORE*	$proc						. cluster power 2 # blocks view > 1 window
	call	(array_bind)				. splice onto next array and skip
	la	1*/__GRANULE_LOG-12, a, i		. or advance in this array
	sabr	WINDOW+?
	$end

__ANOTHER*	$proc					. cluster 1 block, view > 1 window
							. if you come over the end of the list
	la	?, x					. there need to be a few handles C00001
	sabr	WINDOW+?				. to act as arrester hooks
	$end

p	$proc
__GUARD* $name
	chex_load
	lx	a
	$if	p(1)>3
	jxge	p(1, 4)
	$else
	jxge	(ii	GUARD$)
	$endif
	$end

f	$func
__BLOG*	$name
?	$do	12,	$do	1*/?-1=f(1, 1),	$return	?-1
	$return	6
	$end

__CLUSTER_LOG	$set	__BLOG("p(2, 1)_CLUSTER")

.	$trace	__CLUSTER_LOG

	$do	(__GRANULE_LOG^=18)**(__CLUSTER_LOG^=0),	;
	$flag	4K pages array may be monolithic or pointer array to single pages

	$if	__CLUSTER_LOG>6

	$if	p()>4
__CEILING	$equf	p(5)
	$else
__CEILING	$equf	(__CHEX_LIMIT:s)
	$endif

	dsl	24-__GRANULE_LOG+__SCALE		. pull up everything except words offset

	c	(terabase)	(WINDOW, __SEVERAL, "p(2, 1)_CLUSTER", __CLUSTER_LOG:q),,float	;
				array,,i	__CEILING	a,,long			

								. [ __CLUSTER_LOG not > 6 ]
	$elseif	__CLUSTER_LOG					. i.e. cluster > 1 block ?
	$if	__APPLY_GUARD
	dsl	24-__GRANULE_LOG+__SCALE			. get a block number
	__GUARD	p(5)						. check against total memory blocks all arrays
	dsr	__CLUSTER_LOG					. get an array number
	$else
__TRANSFERS	$set	6-__CLUSTER_LOG
	$do	__TRANSFERS+__SCALE^=0,	dsl	__TRANSFERS+__SCALE
	$endif

	aa	array,,i
	sa	7

	la	0,,xi
	dsl	__CLUSTER_LOG
	orB	WINDOW
	rbr	24-__GRANULE_LOG

	$if	__SEVERAL
	lx	a
	lr	"p(2, 1)_CLUSTER"
	$endif

	$do	__GRANULE_LOG=18,	sal	6
	aa	*7
	sabr	WINDOW
?	$do	__SEVERAL,	__MORE

	$else			. __CLUSTER = 1

	dsl	24-__GRANULE_LOG
	$do	__APPLY_GUARD,	__GUARD	p(5)
	orB	WINDOW,,xi
	rbr	24-__GRANULE_LOG
	aa	array,,i
	lx	a
	la	0,a
	sabr	WINDOW

?	$do	__SEVERAL,	__ANOTHER

	$endif		. __CLUSTER_LOG > 6 or > 0 or not
	$end
