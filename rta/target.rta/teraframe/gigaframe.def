__KEEP_SIMD_SETTING	$set	0

p		$proc
gigapage*	$name	12
gigaframe*	$name	18

S		$set	24
CONTAINER_SIZE	$set	p(3, 1)
instance	$equf	p(4)
WINDOW		$set	p(1, 1)
array		$equf	p(2)

__SEVERAL	$set	p(1, 1:2)-p(1, 1:1)

__CLUSTER_LOG	$set	p(2, 3)

__CHEX_LIMIT	$set	p(5, 1)//(1*/p(0,0))	. optionally calculate maximum storage blocks // array
__CHEX_ESCAPE	$set	p(5, 1:2)

p		$proc
pointp*		$name
		dsl	p(1, 1)+__SCALE-__CLUSTER_LOG

		$if	__CLUSTER_LOG
		aa	array,,i
		sa	7
		dsl	__CLUSTER_LOG
		$do	__SEVERAL^=0,	sa	6
		$endif

		orB	WINDOW
		rbr	p(1, 1)
		$end

LOG_TRUE*	$func
LOG	$do	18,	$do	1*/LOG=CONTAINER_SIZE,	$return	LOG
		$return	0
		$end

__SCALE		$set	LOG_TRUE

		$if	p(4, 3)=S
__SCALE		$set	0
		$do	(instance\2^=0)++(p(4, *1))++(instance^=b),	lb	p(4, 1:1)
		mf	CONTAINER_SIZE,,xi

		$elseif	__SCALE++(CONTAINER_SIZE=1)
		$do	(instance\2^=0)++(p(4, *1))++(instance^=a),	dl	instance
		$else

		$if	__KEEP_SIMD_SETTING
		dpush	instance
		pop	b
		m	CONTAINER_SIZE,,xi
		sb	6
		pop	b
		mf	CONTAINER_SIZE,,xi
		aa	6
		$else
		dpush	instance
		rex	(m	CONTAINER_SIZE,,xi)
		dpop	a
		$endif
		$endif

		pointp	24-p(0, 0)
		$do	p(0, 0)=gigaframe,	sal	6

__SEVERAL	$set	p(1, 1:2)-WINDOW
		$do	__SEVERAL<0,__SEVERAL	$set	0
		$do	__SEVERAL>15,__SEVERAL	$set	0

		$if	p(5, 1:)>1
		lr	__CHEX_LIMIT+1*/p(0, 0)-12,,xi
		lx	__SEVERAL+1, a, i
		jxge	__CHEX_ESCAPE
		$endif

		$if	__CLUSTER_LOG
		aa	*7
		$else
		aa	array
		$endif

		sabr	WINDOW

p		$proc
__MORE*		$name
		$if	__CLUSTER_LOG
		la	+(1*/__CLUSTER_LOG)-1,,xi
		$if	p(1, 1)=18
		call	(gronlick18)
		$else
		call	(gronlick12)
		$endif
		$else
		la	1*/(p(1, 1)-12), a, i
		$endif
		sabr	WINDOW+__NEXT
		$end

__NEXT		$do	__SEVERAL,	__MORE	p(0, 0)
		$end

