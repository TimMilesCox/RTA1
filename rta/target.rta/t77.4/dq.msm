.       
.    Copyright Tim Cox, 2012
.    TimMilesCox@gmx.ch
.
.    This file is instruction code for the freeware processor architecture
.
.                RTA1
.
.    RTA1 is a free processor architecture specification.
.
.    The executable emulation of RTA1 is free software.
.
.    This instruction code for the target RTA1 architecture is free software
.
.    Software programs delivered with this software to connect the
.    emulated RTA1 with real network interfaces in the emulator host
.    are free software
.
.    Scripts and programs delivered with this software for running
.    on other computers and interacting with the RTA1 are free software
.
.    Scripts and utility programs for constructing RTA1 target
.    executable software are free software      
.
.    You can redistribute it and/or modify RTA1
.    under the terms of the GNU General Public License as published by
.    the Free Software Foundation, either version 3 of the License, or
.    (at your option) any later version.
.
.    RTA1 is distributed in the hope that it will be useful,
.    but WITHOUT ANY WARRANTY; without even the implied warranty of
.    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.    GNU General Public License for more details.
.
.    You should have received a copy of the GNU General Public License
.    along with RTA1.  If not, see <http://www.gnu.org/licenses/>.
.
.


$(66::,x)
pool	mpool

$(67::,y)
queue	dq

$(0)
init_pool	$tree
	$head_near	scalars(caller_y,		int,	y	;
				save_simd,		float,	RDATAC	;
				initial_pointers,	float		;
				simd_control,		float,		;
				(-1, 0, NET_FREECHAINS//4-1, 4q)	)

	qpop	RDATAC		. 4 chain pointers 0,0,0,0q at stack top

	ly		a			. words in pool	
	ay		x			. top of pool
	ay, xi		-ACW_SIZE*2		. minus 2 descriptors
	sy		pool:next		. first assignable descriptor
	sx		descriptor:frame+ACW_SIZE, y
						. buffer in fixed top descriptor
	lb		-1,,xi
	sb		descriptor:i_f+ACW_SIZE, y
	z		descriptor:bytes+ACW_SIZE, y
	lb, i		+(2+NET_FREECHAINS)//NET_GRANULE*NET_GRANULE, x
	sb		descriptor:frame, y
						. first assignable address in
						. first assignable descriptor

	ly		pool:free(1),,i
	rex		(qs	0, y)
	$endif

	z		pool:lock_cell

	qpop		0, sp
	qpop		RDATAC
	pop		y

	lret		0
	$root

buy1	aa, xi	-1
	jc	buy1_soon

buy1_never		. requested size is out of range
	la, xi	0	. result = no descriptor
	lret	0
buy1_soon
	sar	NET_LOG
	anu,xi	NET_FREECHAINS
	jc	buy1_never

	LOCK	pool:lock_cell

	lb, i	1, a		. b = # granules
	aa, i	pool:free(1)
	ly	a
	la	0, y		. free chain head
	jza	buy1_new
	lb	0, a		. second in chain
	sb	0, y		. -> chain head
	z	descriptor:bytes, a
	z	descriptor:next, a

	j	buy1_complete

buy1_new
	la	pool:next
	sbl	NET_LOG
	ab	descriptor:frame, a
	jc	buy1_wraparound	. new next buffer
				. may not outflow adress space

	aa, xi	-ACW_SIZE	. new next descriptor

	ly	b
	anu	y		. descriptor < buffer
	jc	buy1_new_now	. if so unavailable

buy1_wraparound
	la, xi	0		. result = no descriptor
	j	buy1_complete

buy1_new_now
	sa	pool:next
	sy	descriptor:frame, a
	la	ACW_SIZE, a, i
	z	descriptor:bytes, a
	z	descriptor:next, a

buy1_complete
	FREE	pool:lock_cell
	lret	0


sell1	jza	sell1_u			. popped from an empty queue?
	tnz	x
	j	sell1_u			. buffer pool pointer an untested variable?

	LOCK	pool:lock_cell

	lb	descriptor:bytes, a
	andB	(0400000)
	jnzb	sell1_z			. already freed or some mistake
	
	lr	a
	jxge	wrong_pool

	ly	pool:next		. is the candidate the
	anu, i	ACW_SIZE, y		. descriptor above next-> ?

	jzb	sell1_more		. stack top
	jc	sell1_list		. within stack
	j	sell1_z			. not assigned

sell1_more
	sa	pool:next
	z	descriptor:bytes, a	. remove markings

	push	(-__PANGA)		. -(__PANGA)	-__PANGA,,xi

sell1_more?
	lb	descriptor:bytes+ACW_SIZE, a	. new next or non-free or stack root?
	andB	(0400000)		. descriptor in a free chain?
	jzb	sell1_final		. root descriptor never is either
					. it's at free chain far end
	ly	a			. above pointer
	la	ACW_SIZE, a, i		. new stack top

	lb	descriptor:frame, y
	anb	descriptor:frame, a
	sbr	NET_LOG			. size chain index + 1
	ly	pool:free(1)-1,,i	. chains - 1
	ay	b

. CHECK_PARADOX	$set	1

	lr	a			. for comparison
	lk	-1,,xi

sell1_chain_walk			. chain starts descriptor @ highest address
	lb	y			. = buffer @ lowest address = preferred memory grant
	ly	0, y			. so this always walks the whole chain on memory free
	jyge	sell1_chain_equal?
	j	sell1_final		. paradox = not in chain

sell1_chain_equal?
	mta	y			. = a ?
	j	sell1_chain_walk	. no, > a
					. yes
	push	0, y			. relink chain
	pop	0, b
	
	sr	pool:next

	$if	__PANGA

	inc	0, sp			. from minus towards plus 
	tp	0, sp
	j	sell1_more?

sell1_final
	inc	sp
	j	sell1_z

	$else	

	j	sell1_more?
	
	$endif

sell1_list
sell1_log
	ly	a			. find free chain
	ay, xi	-ACW_SIZE		. per buffer size
	lb	descriptor:frame, y
	anb	descriptor:frame, a

	sbr	NET_LOG
	ab, i	pool:free(1)-1
	lr	b


sell1_list?
	ly	r
	lr	0, y
	
	anu	r

	jnc	sell1_list?		. keep moving towards
					. the stack top

	jzb	sell1_z			. equal, it's already free

	sr	0, a			. chain it in
	sa	0, y
	lb	descriptor:bytes, a
	orB	(0400000)
	sb	descriptor:bytes, a

	$if	__PANGA=0
sell1_final
	$endif

sell1_z	FREE	pool:lock_cell
sell1_u	lret	0
	
wrong_pool
	ii	GUARD$

q2first?
	tz	queue:head
	j	q2z
	sa	queue:head
	sa	queue:tail
	z	0, a
	lret	1		. indicate this is a write
				. to a previously empty q
				. by skipping an instruction
				. on return

q2	tz	queue:head
	j	q2z
	sa	queue:head
	sa	queue:tail
	z	0, a
	lret	0
q2z	lb	queue:tail
	sa	0, b
	sa	queue:tail
	z	0, a
	lret	0	

readq	la	queue:head
	jza	readqz
	lb	0, a
	sb	queue:head
readqz	lret	0

	$if	0		. switch on if required ever
q2head	push	queue:head
	tnz	0, sp
	sa	queue:tail
	pop	0, a
	sa	queue:head
	lret	0
	$endif

