tcp_event1_acknowledged?

__REMOTE_ACK	$equf	1, sp

	dl	transmission:sequence_ackx
	andB	(0FF0000s)			. ls 16 bits aren't used yet, but...
	dan	__REMOTE_ACK			. is the new remote ACK
	lret	0

tcp_restart_timer2
	$if	TCP_TIMER2<32768
	la	TCP_TIMER2,,xi
	$else
	la	(TCP_TIMER2)
	$endif

	$if	HVSOCKET
	tp	*(BSOCKET*/12++tlist:flags)
	sal	HVSOCKET_LOG				. lcal	tcp_stretch_timer2
	$endif					. timer(2) is stretched by waiting
						. for service to hv connection blocks
						. traffic = restart timer(2)
	aa	DAYCLOCK$
	sa	transmission:timer(2)
	lret	0

tcp_start_timewait
	$if	TCP_TIMEWAIT_MS<32768
	la	TCP_TIMEWAIT_MS,,xi
	$else
	la	(TCP_TIMEWAIT_MS)
	$endif

	j	tcp_add_timer1

tcp_restart_timer1
	la	(TCP_TIMER1)			. something arrived
tcp_add_timer1
	aa	DAYCLOCK$			. restart the big timer
.	jnza	tcp_store_timer1
	or, xi	1				. but don't restart it to zero
tcp_store_timer1
	sa	transmission:timer(1)
	lret	0

tcp4_reset_dq_lx
	lx	TP_HEADER
tcp4_reset_dq
	la	transfer:hl_code
	and	TCP_RST,,xi
	jnza	tcp4_reset_dqx			. don't answer a reset

	ly	descriptor:dgram
	lcal	tcp_reject
tcp4_reset_dqx
	lret	0

	$if	HVSOCKET
tcp4_net_free_txdatagram
	lcal	readq
	jza	tcp4_net_free_txdatagram_no_action
	dpush	x
	lcal	tcp_free_tx
	dpop	x
tcp4_net_free_txdatagram_no_action
	lret	0
	$endif

tcp4_rxaction	$tree	. all calling routines have fp -> rx segment descriptor

	$head_near	scalars(connection,	int,	x	;
				ACK_AWAITED,	int		;
				state,		int		;
				received_seq,	long		;
				remote_ack,	long		)

	$if	TCP_NOQ

	.	buffer acquire t_ibuffer writes descriptor to fp
	.	fp is saved in case a buffer is bought for SYN_ACK.RST.ACK_FIN
	.	and should be reloaded after

	$else
	sa	fp
	dl	descriptor:sobdi
	sabr	BSOCKET
	la	s:tcp:tbase, b
	sabr	BSOCKET
	$endif

	lcal	tcp_locate_connection
	tz	x
	j	tcp_connection_located	.

					. so is it an incoming connect?
	lx	descriptor:uproto
	sx	TP_HEADER
	la	transfer:hl_code, x
	sa	HL_FLAGS

	and, xi	TCP_SYN++TCP_ACK++TCP_RST
	xor, xi	TCP_SYN
	jza	tcp4_accept

tcp_reset_dq_lx
	lcal	tcp4_reset_dq_lx		. similar case to IP input loop
	j	tcp_stepover_response		. nothing listening, but we must
						. dq from tcpq and drop, send RST
						. and continue in this loop here
tcp_accept_fail2
	sx	connection
	j	tcp_ripdown_reset

.	lcal	tcp4_ripdown_reset
.	j	tcp_stepover_response
						. either q the request to
						. the listening socket owner
						. or do this automatic accept
tcp4_accept
	lcal	tcp_auto_accept
	j	tcp_reset_dq_lx			. connection not assigned
	j	tcp_accept_fail2		. connection assigned but not working
						. connection SYN_ACK, 3rd return
	j	tcp_stepover_response		. SYN pdu consumed

tcp_connection_located

	la	transmission:state
	jpa	$+2
	xor	-1,,xi
	sa	state

	sx	connection
	tz	transmission:timer(1)		. restart the big timer
	lcal	tcp_restart_timer1		. unless it's switched off

	ly	TP_HEADER
	la	transfer:hl_code, y
	sa	HL_FLAGS
	and	TCP_SYN++TCP_ACK,,xi
	xor	TCP_SYN++TCP_ACK,,xi
	jza	tcp_synsent?			. SYN ++ ACK
	
	and	TCP_SYN,,xi
	jnza	tcp_no2ndsyn			. SYN = no SYN (xor does that 2u)

	$if	1
	la	state
	$else
	la	transmission:state
 jpa $+2					. -STATE = awaiting transition
 xor -1,,xi
	$endif

	ana, xi	TCP_SYNRECEIVED
	jza	tcp_stepover_response
	j	tcp_ripdown_reset

tcp_synsent?
        la      state				. here because you got SYN_ACK
	aa	-TCP_SYNSENT,,xi
        jza	tcp_syn_ack_correct		. your were expecting SYN_ACK

	aa	TCP_SYNSENT-TCP_ESTABLISHED,,xi	. moved to established?
	jza	tcp_ack				. SYN ++ ACK, already seen it
	j	tcp_ripdown_reset		. not making enough sense to use

tcp_syn_ack_correct
tcp_no2ndsyn
	la	HL_FLAGS
	sar	11
	and, xi	30

	aa	y
	sa	descriptor:apdata
	sa	RX_APDATA
						. policy if remote ack is illogical:
						. network has delivered out of order

						. is the ACK reasonable?

	dl	transmission:remote_ack_window	. previous state remote ack
	andB	(255*/16:s)

	ds	remote_ack			. remote ack so far

	dl	transfer:ack, y			. new remote ack <- store format
	sbl	8				. ms 32 bits of 2 words
	dsl	8
	ds	8				. proposed new remote ack 8..9

	dan	remote_ack			. remote ACK gone backwards?

						. new remote ack < stored remote ack ?
	jna	tcp_stepover_response		. segment already accepted
						. and cannot be needed
tcp_compare_forward
        la      HL_FLAGS
        and     TCP_RST,,xi
        jnza    tcp_ripdown_silently

	dl	transmission:sequence_ackx
	andB	(255*/16:s)

	dan	8				. remote ACK beyond local SEQ?

	jpa	tc_no_problem_p

	$if	1
	inc	ACK_AWAITED
	j	tcp_stepover_response		. drop as a broken segment
	$else
	j	tcp_ripdown_reset		. or complain about it
	$endif

tc_no_problem_p

	dl	8				. accept proferred remote ack
	ds	remote_ack			. in cached copy
	lk	(00FFFF)
	mlb	transfer:window, y		. remote ack ++ remote window
	ds	transmission:remote_ack_window	. in connection state ->

	.	0:	is the remote ACK possible?

	.	0:5	is there a remote reset?

	.	1:	cache remote ACK and window

	.	2:1	send waiting segments as remote
	.		window allows

	.	2:2	release segments queued for ACK
	.		according to remote ACK value
	.		vs sequence + size of sent output

	.	3:	compare remote sequence with local
	.		ACK

	.	4:	if less, shave the leading edge
	.		of the input

	.	5:	if more but sequence + length
	.		within local ACK + window, deferq
	.		and otherwise drop

	.	6:	accept as much of the net input at 4:
	.		as local window allowed. This avoids
	.		accepting single bytes which are
	.		sent to push the window open
	.		and also avoids rejecting payload
	.		for which we have advertised
	.		window. Drop the segment if no
	.		part of it is accepted, and shave
	.		the trailing edge if part of it
	.		is rejected

	.		It might be unwise to accept beyond
	.		window. A well behaved remote system
	.		won't send beyond window (apart from
	.		experimental 1-byters, and the response
	.		to those is drop them and advertise
	.		new window). A malicious remote system
	.		might try to manipulate window

	.	7:	Advance local ACK and reduce local
	.		window according to the amount accepted

	.	8:	generate new local window

	.	9:	transmit segments queued for remote window
	.		according to remote ACK + window,  and
	.		if there is none, and no further input
	.		segment after this has yet been received
	.		for this connection, send an ACK, unless
	.		the incoming segment is an ACK without
	.		payload and its SEQ is not beyond local ACK

	.		SYN and FIN have a payload weight of
	.		1 byte

	.		restart connection:timer(1)
	.		maybe do this at an early point, depending
	.		whether the attempt to communicate
	.		counts as keepalive even if it is
	.		out of range




	.	1	is the remote ACK possible?


	.	2:1	drop ACKed outputs
	.		remote ACK is still in 6:7


p	$proc
jlist*	$name
?	$do	p(1),	+	p(1, ?)
	$end

	lb	state
	andB	15,,xi
	lb	stepfor, b
	j	0, b

stepfor	jlist	;
	tcp_listen,		tcp_closed,	tcp_listen,	tcp_synsent,	;
	tcp_synreceived,   tcp_established,	tcp_finwait1,	tcp_finwait2,	;
	tcp_closewait,	       tcp_lastack,	tcp_closing,	tcp_timewait,	;
	tcp_deletetcb,		tcp_listen,	tcp_listen,	tcp_listen


tcp_established
tcp_closewait
tcp_tx_segments_acked?

	la	transmission:q4ack:head
	jza	tcp_rx_in_range?
	lc	tcp4_outstanding	remote_ack,,long

tcp_rx_in_range?
						. finally time to calculate the
						. header length, payload address

	dl	transmission:ack_window, x
	sb	9				. save the window
	andB	(255*/16:s)


local_ack $equf	remote_ack			. reuse cached location

	ds	local_ack			. exactly expected sequence?

tcp_place_in_stream
	lb	TP_HEADER
	anb	RX_APDATA
	sbl	1				. minus header length in bytes
	ab	descriptor:bytes
	sb	descriptor:bytes		. calculate payload length

tcp_retrain_stream
	inc	ACK_AWAITED

	sb	11				. make a 48 bit payload byte count
	sb	TPAYLOAD_BYTES
	z	10

	ly	TP_HEADER
	dl	transfer:seq, y			. extract the incoming sequence

	sbl	8
	dsl	8

	ds	received_seq

	dan	local_ack
	jdz	tcp_rx_exact_sequence

	$if	TCP_RX_ABOVE_ACK
	jpa	tcp_rx_above_range?
	$else
	jpa	tcp_rx_above_range
	$endif
						. have you ACKED all this payload?

						. comparison with expected sequence
						. yields a negative #
						. which reduces the net payload

	dsa	16
	da	10				. payload + sequence - acked
	jdz	tcp_rx_already_acked
	jna	tcp_rx_already_acked

tcp_rx_exact_sequence
	sb	descriptor:readpoint		. rx_seq + payload - stored_ack
						. = descriptor -> bytes_to_bypass
	la	HL_FLAGS
	and, xi	TCP_FIN				. established -> closewait ?

	jza	tcp_rx_payload?			. no such event, keep going

	dl	received_seq			. add event_weight + remote_sequence
	da	(1*/16:d)			. equivalent 1 octet
	ds	local_ack
	lk	(00FFFF)
	mlb	9				. that had better be local_window
	ds	transmission:ack_window, x	. store connection -> local_ack:window

	push,xi	TCP_CLOSEWAIT			. store updated state
	pop	transmission:state

	inc	ACK_AWAITED			. lcal	tcp_send_ack
	j	tcp_rx_payload			. zero payload is queued as a signal
						. to the application of remote close

tcp_lastack
	lcal	tcp_event1_acknowledged?
	jdz	tcp_lastack2closed
	la	DAYCLOCK$
	aa	6000,,xi			. in case last ack gets lost
	sa	transmission:timer(1)		. drop connection in a few seconds
	j	tcp_stepover_response

tcp_lastack2closed
	push,xi	TCP_CLOSED
	pop	transmission:state
	j	tcp_stepover_response
	
tcp_rx_payload?
	tz	TPAYLOAD_BYTES
	j	tcp_rx_payload

	$if	1
	j	tcp_stepover_response
	$else
	.	to do it this way first update ack as below in rx_payload
	.	there seem to be enough acks for intense flow control anyway

	j	tcp_rx_ack_nopayload
	$endif

tcp_rx_payload
						. now is the segment within window?
	la	9				. for now, discard any segment not
	and	(00FFFF)			. completely within window
	ana	11				. down with window
	jnc	tcp_rx_above_range		. drop + ACK
	sa	9				. reduced local window
	dl	local_ack			. ACK is */ 16

	dsr	16				. + 48-bit payload count
	da	10				. up with ACK

	ds	10				. cache the new ACK point
						. from here register 11 is not rx payload
						. but TPAYLOAD_BYTES is
	dsl	16
	ds	local_ack			. update cached ACK
	orB	9				. save new ACK ++ WINDOW
	ds	transmission:ack_window

	la	fp
	lcal	tcp_write_rxq
						. now see if deferq joins on

	$if	TCP_RX_ABOVE_ACK
	ly	transmission:deferq.head, x, i
tcp_rx_rechain
	lr	y				. 1st pass -> q.head 
	la	0, y				. next
	jza	tcp_ack_point			. if any
	ly	a				. a gets arithmetic
	dl	descriptor:uproto, y
	sa	TP_HEADER
	sb	RX_APDATA
	dl	transfer:seq, a			. is deferred segnent
	sbl	8
	dsl	8
	dan	local_ack			. sequence < ack ?
	jdz	tcp_rx_inline			. already checked in range
	jpa	tcp_rx_rechain			. still gapped
						. filtered if all already ACKed 
tcp_rx_inline
	push	descriptor:next, y		. take from chain
	pop	*r				. r -> next = y -> next

	sy	fp				. 
.	dl	descriptor:uproto		. read uproto ++ apdata
	la	TP_HEADER
	lb	transfer:hl_code, a
	sb	HL_FLAGS
	lb	descriptor:bytes		. now net application data bytes
	j	tcp_retrain_stream

	$elseif	0

	la, i	transmission:deferq.head, x
	ly	a
tcp_rx_rechain					. look for any deferred segment
	lr	y				. which is no longer gapped
	la	0, a
	jza	tcp_ack_point
	ly	a
	la	descriptor:uproto, a
	sa	TP_HEADER
	dl	transfer:seq, a
	sbl	8
	dsl	8

	dan	local_ack
	jna	tcp_rx_rechain

	push	descriptor:next, y
	pop	*r				. unchain the segment

	sy	fp				. expected descriptor base
	dl	descriptor:uproto		. + TP_HEADER
	sa	TP_HEADER
	sb	RX_APDATA
	lb	transfer:hl_code, a
	sb	HL_FLAGS
	j	tcp_place_in_stream

	$endif

	. here you decide whether waiting segments
	. can be transmitted. Any earlier, and the
	. local ACK pointer would be out of date

	. checksum must always be finalised at
	. the moment of transmission, because local
	. ACK is summed in the segment header

tcp_ack_point
	lx	connection
	tz	ACK_AWAITED
	lcal	tcp_rack
	j	tcp4xreact			. go keep input data on connection chain

	$if	TCP_RX_ABOVE_ACK
tcp_rx_above_range?				. add remote ack - seq  /* 16 to size
	dsr	16
tcp_rx_above_ack
	tnz	11				. if there is a payload size
	j	tcp_stepover_response
						. 48-bit positive difference SEQ > ACK is in A:B
						. and window is in 9 but with some bits from ACK
	da	10				. calculate SEQ - ACK + payload
	ds	10

	la	9
	sal	8
	dsr	32
	dan	10

	jnc	tcp_rx_above_range

	$if	TCP_NOQ

	la	fp
	ly	transmission:deferq,,i		. deferq only accessed in ip thread
	
	tz	0, y				. only 1 segment in this queue or none
						. only a segment with payload
						. presently not even a payload-like event
	j	tcp_stepover_response		. deferq -> populated drop new segment

	lcal	q2				. populate deferq
						. to save some remote resends
	$else	TCP_NOQ

	ly	tcpq,,xi
	la, i	transmission:deferq
	lcal	net_transfer

	$endif	TCP_NOQ

	j	tcp4xreact			. rx this segment complete
						. until it's read from deferq
	$endif	TCP_RX_ABOVE_ACK

tcp_rx_already_acked
	la	TPAYLOAD_BYTES
	jza	tcp_stepover_response
	$do	0,	MIB_ICOUNT48	tcpDupDrops:i		. all this segment already rx
	j	tcp_ack				. tell remote tcp where it's at

	$if	1	
tcp_rx_above_range
.	la, xi	1
.	sa	ACK_AWAITED
.	lcal	tcp_send_ack

tcp_rx_ack_nopayload
	j	tcp_ack
.	ly, xi	tcpq
.	lcal	net_drop
.	j	tcp_ack_point
	$endif

tcp_finwait1
	la	HL_FLAGS
	and, xi	TCP_FIN
	jza	tcp_finwait1_acked?
	dl	(1*/16d)
	da	transmission:ack_window
	ds	transmission:ack_window
	push,xi	TCP_CLOSING
	pop	transmission:state
	lcal	tcp_rack
				. ACK and FIN  may be on the same segment
tcp_closing
	lcal	tcp_event1_acknowledged?
	jdz	tcp_close2timewait
	j	tcp_stepover_response

tcp_finwait1_acked?
	lcal	tcp_event1_acknowledged?
	jdz	tcp_finwait1tofinwait2
	j	tcp_stepover_response

tcp_finwait1tofinwait2
	push,xi	TCP_FINWAIT2
	pop	transmission:state
	j	tcp_stepover_response

tcp_close2timewait
	push,xi	TCP_TIMEWAIT
	pop	transmission:state
	lcal	tcp_start_timewait
	j	tcp_stepover_response
	
tcp_finwait2
	la	HL_FLAGS
	and, xi	TCP_FIN
	jza	tcp_stepover_response
	dl	(1*/16d)
	da	transmission:ack_window
	ds	transmission:ack_window
	lcal	tcp_rack
	j	tcp_close2timewait
	
tcp_timewait
	la	DAYCLOCK$
	ana	transmission:timer(1)
	jna	tcp_stepover_response
	la, xi	TCP_CLOSED
	sa	transmission:state
	j	tcp_stepover_response

tcp_synreceived
	lcal	tcp_event1_acknowledged?
	jdz	tcp_syn_ack_acked
	j	tcp_ripdown_reset

tcp_syn_ack_acked
	la, xi	TCP_ESTABLISHED
	sa	transmission:state

        ly      transmission:q4ack,,i
        $if     HVSOCKET
        lcal    tcp4_net_free_txdatagram
        $else
        lcal    net_free_txdatagram
        $endif

        j	tcp_stepover_response

tcp_ripdown_reset
	lx	connection
	la	transmission:state
 jpa $+2				. -STATE = awaiting transition
 xor -1,,xi
	aa	-TCP_CLOSED,,xi
	jza	tcp_stepover_response
	aa	TCP_CLOSED-TCP_DELETETCB,,xi
	jza	tcp_stepover_response
	lcal	tcp_reset		. send a reset if possible
	j	$+1			. there are two returns
tcp_ripdown_silently
	lx	connection

	la	transmission:state
 jpa $+2				. -STATE = awaiting transition
 xor -1,,xi
	aa	-TCP_DELETETCB,,xi
	jza	tcp_stepover_response
	aa	TCP_DELETETCB-TCP_CLOSED,,xi
	jza	tcp_stepover_response

	lcal	tcp_ripdown

tcp_deletetcb
	push,xi	TCP_CLOSED
	pop	transmission:state
tcp_closed				. the TCB may already be reassigned
	j	tcp_stepover_response	. this PDU wasn't added to an input chain
.	ly, xi	tcpq
.	lcal	net_drop
.	j	tcp4xreact

tcp_synsent
	lcal	tcp_event1_acknowledged?
	jdz	tcp_synsent1
	j	tcp_ripdown_reset
tcp_synsent1
	la, xi	TCP_ESTABLISHED
	sa	transmission:state
	ly	TP_HEADER
	dl	transfer:seq, y
	sbl	8
	dsl	8
	da	(1*/16d)
	ds	transmission:ack_window

	$if	HVSOCKET
	tn	*(BSOCKET*/12++tlist:flags)
	$endif
	call	(tcp_agent_add)

	ly	transmission:q4ack,,i

tcp_clear_syn				. take SYN segment off output q

	$if	HVSOCKET
	lcal	tcp4_net_free_txdatagram
	$else
	lcal	net_free_txdatagram
	$endif

tcp_ack	lcal	tcp_rack

tcp_listen				. stub
tcp_stepover_response			. getting here drops buffered rx segment

	$if	TCP_NOQ
	la	fp
	lx	*(BSOCKET*/12++tlist:rxbu_p)
	lcal	sell1


	$else

	ly	tcpq,,xi
	lcal	net_drop

	$endif
					. get here without dropping segment
tcp4xreact				. when buffered rx segment is queued to socket

	j	ipv4_rxz		. this $ret doesn't happen but it looks nice 
					. interface window must be freed
	$ret

tcp_rack
	$if	0			. send up to 1 ack in state machine
	push	1,,xi			. when all available rx segments are scanned
	popA	transmission:sequence_ackx+1
	lret	0
	$else				. otherwise remote host resends unnecessarily

	push	fp
	lcal	tcp_send_ack
	$if	1
	sr	0			. ack was not resourced
	$else
	lcal	tcp_ack_dropped		. ack was not resourced and neither is a mib metric
	$endif
	pop	fp
	lret	0
	$endif

	$root

tcp_rx_far				. called from reassembly device driver
	dl	SOCKET_LPOINTER		. fp -> rx segment descriptor
	sabr	BSOCKET
	la	s:tcp:tbase
	sabr	BSOCKET

	lcal	tcp4_rxaction
	fret	0
