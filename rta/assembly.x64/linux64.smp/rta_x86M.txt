     1                                  
     2                                  	%include	"rta_x86n.def"
     1                              <1> 
     2                              <1> __SMP		equ	8
     3                              <1> 
     4                              <1> TIME_UPDATE	equ     1
     5                              <1> LOCKSTEP	equ	2
     6                              <1> BREAKPOINT	equ	4
     7                              <1> CHILLDOWN	equ	8
     8                              <1> TOUCHPOINT	equ	16
     9                              <1> 
    10                              <1> EXTERNAL_INTERRUPT 	equ	00FF00h
    11                              <1> ATTENTION		equ	128
    12                              <1> INCREMENTER_CARRY	equ	64
    13                              <1> TPULSE			equ	32
    14                              <1> 
    15                              <1> 		%if	DRANG & 2
    16                              <1> INDICATIONS	equ	CHILLDOWN|TIME_UPDATE|LOCKSTEP
    17                              <1> 		%else
    18                              <1> INDICATIONS	equ	CHILLDOWN|TIME_UPDATE|LOCKSTEP|BREAKPOINT
    19                              <1> 		%endif
    20                              <1> 
    21                              <1> EXTERNAL_INDICATIONS equ EXTERNAL_INTERRUPT|ATTENTION|INCREMENTER_CARRY|TPULSE
    22                              <1> 
    23                              <1> IO_PORTS	equ	192
    24                              <1> 
    25                              <1> 	%if	RTA_MBANKS
    26                              <1> global	_metric
    27                              <1> global	_indication
    28                              <1> global	_iselect
    29                              <1> global	_iselectu
    30                              <1> global	_readout
    31                              <1> global	_readoutx
    32                              <1> global	_readoutp
    33                              <1> global	_psr
    34                              <1> global	_apc
    35                              <1> global	_apcz
    36                              <1> global	_breakpoint
    37                              <1> global	_b0_name
    38                              <1> global	_b0p
    39                              <1> global	_devices
    40                              <1> global	_base
    41                              <1> global	_register_set
    42                              <1> global	__register
    43                              <1> global	_memory
    44                              <1> 
    45                              <1> 	%if	RTA_MBANKS<1
    46                              <1> RTA_MPAGES	equ	32
    47                              <1> 	%else
    48                              <1> RTA_MPAGES	equ	RTA_MBANKS*64
    49                              <1> 	%endif
    50                              <1> 
    51                              <1> 	%else
    52                              <1> ;	extern	_metric
    53                              <1> extern	_general_indication
    54                              <1> ;	extern	_iselect
    55                              <1> ;	extern	_iselectu
    56                              <1> ;	extern	_psr
    57                              <1> ;	extern	_apc
    58                              <1> ;	extern	_apcu
    59                              <1> ;	extern	_apcz
    60                              <1> 
    61                              <1> extern	_breakpoint
    62                              <1> extern	_touchpoint
    63                              <1> extern	_touchpoint2
    64                              <1> 
    65                              <1> ;	extern	_b0_name
    66                              <1> ;	extern	_b0p
    67                              <1> extern	_devices
    68                              <1> ;	extern	_base
    69                              <1> ;	extern	_register_set
    70                              <1> ;	extern	__register
    71                              <1> extern	_memory
    72                              <1> 
    73                              <1> _output equ     272
    74                              <1> _inputr equ     264
    75                              <1> _input2 equ     256
    76                              <1> 
    77                              <1> _OUTPUT	equ	_output*4
    78                              <1> _INPUTR	equ	_inputr*4
    79                              <1> _INPUT2 equ	_input2*4
    80                              <1> _BIAS	equ	_OUTPUT
    81                              <1> 
    82                              <1> 	%endif
    83                              <1> 
    84                              <1> 	extern	_flag
    85                              <1> 	extern	_uflag
    86                              <1> 
    87                              <1> HALF_W	equ	128
    88                              <1> FP_R	equ	8
    89                              <1> B_STREAMZR  equ 64
    90                              <1> B_STREAM16R equ 32
    91                              <1> B_STREAM16W equ 16
    92                              <1> 
    93                              <1> r	equ	0
    94                              <1> k	equ	1
    95                              <1> x	equ	2
    96                              <1> y	equ	3
    97                              <1> a	equ	4
    98                              <1> b	equ	5
    99                              <1> mantissa2 equ	6
   100                              <1> mantissa3 equ	7
   101                              <1> residue	equ	8
   102                              <1> p	equ	12
   103                              <1> q	equ	13
   104                              <1> fp	equ	14
   105                              <1> s_p	equ	15
   106                              <1> 
   107                              <1> rdatac	equ	20
   108                              <1> rdata	equ	21
   109                              <1> wdatac	equ	22
   110                              <1> wdata	equ	23
   111                              <1> 
   112                              <1> 
   113                              <1> fp_guard equ	128+19
   114                              <1> 
   115                              <1> rt_clock equ	128+20
   116                              <1> priority equ	128+21
   117                              <1> dayclock_u equ	128+22
   118                              <1> dayclock equ	128+23
   119                              <1> 
   120                              <1> R	equ	r*4
   121                              <1> K	equ	k*4
   122                              <1> X	equ	x*4
   123                              <1> Y	equ	y*4
   124                              <1> A	equ	a*4
   125                              <1> B	equ	b*4
   126                              <1> MANTISSA2 equ	mantissa2*4
   127                              <1> MANTISSA3 equ	mantissa3*4
   128                              <1> RESIDUE	equ	residue*4
   129                              <1> 
   130                              <1> P	equ	p*4
   131                              <1> Q	equ	q*4
   132                              <1> FP	equ	fp*4
   133                              <1> S_P	equ	s_p*4
   134                              <1> 
   135                              <1> RDATAC	equ	rdatac*4
   136                              <1> RDATA	equ	rdata*4
   137                              <1> WDATAC	equ	wdatac*4
   138                              <1> WDATA	equ	wdata*4
   139                              <1> 
   140                              <1> FP_GUARD equ	fp_guard*4
   141                              <1> 
   142                              <1> RT_CLOCK equ	rt_clock*4
   143                              <1> PRIORITY equ	priority*4
   144                              <1> DAYCLOCK_U equ	dayclock_u*4
   145                              <1> DAYCLOCK equ	dayclock*4
   146                              <1> 
   147                              <1> I	equ	4
   148                              <1> XI	equ	5
   149                              <1> 
   150                              <1> DEVICE  equ	32768
   151                              <1> SYSMEM  equ	16384
   152                              <1> DATA16  equ	1
   153                              <1> FSYS24  equ	2
   154                              <1> 
   155                              <1> II_GUARD equ	64+31
   156                              <1> II_EXIT	equ	64+6
   157                              <1> II_YIELD equ	64+1
   158                              <1> II_SPAWN equ	64+2
   159                              <1> II_BANK equ	64+3
   160                              <1> II_ARRAY equ	64+4
   161                              <1> II_BANK_FREE equ 64+5
   162                              <1> II_TWAIT equ	64+27
   163                              <1> II_EVENT_WAIT equ 64+28
   164                              <1> II_FPXPO equ	0+3
   165                              <1> 
   166                              <1> II_XINT		equ	0+2
   167                              <1> II_MSECOND	equ	0+4
   168                              <1> II_ATTENTION	equ	0+5
   169                              <1> 
   170                              <1> LP_AUTHORITY	equ	1		; latent parameters GUARD$
   171                              <1> LP_ADDRESS	equ	14
   172                              <1> 
   173                              <1> LP_TIMESLICE	equ	10		; latent parameter timeslice -> yield
   174                              <1> LP_RANGE	equ	12		; latent parameter FP$XPO
   175                              <1> LP_AUTOEXIT	equ	11		; latent parameter return -> EXIT$
     3                                  	%include	"rta_smp.def"
     1                              <1> __POINTER	equ	8
     2                              <1> 
     3                              <1> REGISTER	equ	0			; /*	288	int	*/
     4                              <1> 
     5                              <1> APC		equ	REGISTER+288*4		; /*	1	->	*/
     6                              <1> APCZ		equ	APC+__POINTER		; /*	1	->	*/
     7                              <1> B0P		equ	APCZ+__POINTER		; /*	1	->	*/
     8                              <1> REGISTER_SET	equ	B0P+__POINTER 
     9                              <1> 
    10                              <1> RESTART_VECTOR	equ	REGISTER_SET+__POINTER	; /*	1	int	*/
    11                              <1> INDICATION	equ	RESTART_VECTOR+4	; /*	1	int	*/	
    12                              <1> LATENT_PARAMETER equ	INDICATION+4		; /*	1	int	*/
    13                              <1> ISELECT		equ	LATENT_PARAMETER+4	; /*	1	int	*/	
    14                              <1> 
    15                              <1> PSR		equ	ISELECT+4		; /*	1	int	*/
    16                              <1> B0_NAME		equ	PSR+4			; /*	1	int	*/
    17                              <1> B0_SCOPE	equ	B0_NAME+4		; /*	1	int	*/
    18                              <1> 
    19                              <1> spare		equ	B0_SCOPE+4		; align with C structure
    20                              <1> 						; and align metric block 
    21                              <1> 
    22                              <1> DELTA		equ	spare+4			; /*	1	int	*/
    23                              <1> __METRIC	equ	DELTA+4			; /*	1	int	*/
    24                              <1> 
    25                              <1> DELTA_BASE	equ	__METRIC+4		; /*	1	long	*/
    26                              <1> TOTAL_DELTA	equ	DELTA_BASE+8		; /*	1	long	*/
    27                              <1> TOTAL_METRIC	equ	TOTAL_DELTA+8		; /*	1	long	*/
    28                              <1> 
    29                              <1> IO_PORT		equ	TOTAL_METRIC+8		; /*	192	int	*/
    30                              <1> DATAFRAME	equ	IO_PORT+192*4		; /*	nothing		*/
    31                              <1> 
    32                              <1> CORE_SIZE	equ	DATAFRAME+0
    33                              <1> 
    34                              <1> 		%if	0
    35                              <1> CORE_INDEX2	equ	4*280
    36                              <1> CORE_INDEX1	equ	4*(280-128)
    37                              <1> 		%endif
     4                                  	%include	"rw.def"
     1                              <1> __REGFOR	equ	0
     2                              <1> __MOVBE		equ	0
     3                              <1> 
     4                              <1> 		default	abs
     5                                  	%include	"io.def"
     1                              <1> 
     2                              <1> ;	_NAMES of ports as referenced in implementation or emulation 
     3                              <1> 
     4                              <1> _CORE_PIN		equ	73*4	; read-only port 1 */ _CORE_SOCKET
     5                              <1> 
     6                              <1> _XI_PENDING		equ	74*4	; mask of external interrupt sources
     7                              <1> _XI_ACK			equ	75*4	; writeable ack to quench pending signals
     8                              <1> _INCREMENTER_RESTART	equ	76*4
     9                              <1> _CORE_SOCKET		equ	77*4	; socket index this core read only
    10                              <1> 
    11                              <1> _MCAST_PENDING		equ	78*4	; mask of cores which have multicast to here
    12                              <1> _MCAST_TO		equ	79*4	; -> latent parameter
    13                              <1> 					; destinations mask in register k
    14                              <1> _TZONE			equ	101*4
    15                              <1> 
    16                              <1> _APP_THRESHOLD		equ	72*4	; lowest application code page / limit ISRs
    17                              <1> _INDICATE		equ	102*4	; control commands powersave + others
    18                              <1> _CHILLDOWN		equ	103*4	; powersave microseconds
    19                              <1> 
    20                              <1> _SYS_SWITCH		equ	126*4	; if a switch block is connected
    21                              <1> _SYS_LEDS		equ	127*4	; if a LEDs block is connected
    22                              <1> 
    23                              <1> _DEVICE			equ	128*4	; descriptors 64 devices starting executable space
    24                              <1> _RAM_THRESHOLD		equ	124*4	; 1st writeable page executable space
    25                              <1> _IFRAME_U		equ	64*4	; highest page instruction frame B0 + iframe pages - 1
    26                              <1> 
    27                              <1> _I_DATA			equ	80*4	; external data read port
    28                              <1> _O_DATA			equ	88*4	; external daza write port
    29                              <1> 
    30                              <1> _CORES_MASK		equ	125*4	; bit map cores present +(1*/RTA_SMP)-1
     6                                  
     7                                  ;	this is not PIC code
     8                                  ;	but does relative jumps for compactness
     9                                  
    10                                  %define ptr
    11                                  %define include
    12                                  %define .model
    13                                  %define .code
    14                                  
    15                                  SYSMEM_FLAG	equ	00800000h
    16                                  DATA16_FLAG	equ	00400000h
    17                                  FSYS24_FLAG	equ	00C00000h
    18                                  
    19                                  					; instruction code starts here
    20                                  	section		.text
    21                                  	global		_leloup
    22                                  	global		_execute
    23                                  	global		_device_readp
    24                                  	global		_bus_readp
    25                                  	global		_memory_read
    26                                  	global		_bus_read
    27                                  	global		_device_read
    28                                  
    29                                  	%include	"leloup.msm"
     1                              <1> 
     2                              <1> 	extern	_ultra
     3                              <1> 	extern	_ultra1
     4                              <1> 	extern	_ultra2
     5                              <1> 	extern	_ultra3
     6                              <1> 	extern	_ultra4
     7                              <1> 	extern	_ultra5
     8                              <1> 	extern	_ultra6
     9                              <1> 	extern	_ultra7
    10                              <1> 	extern	_core
    11                              <1> 
    12                              <1> _save_ebp	equ	0
    13                              <1> _save_return	equ	4
    14                              <1> _1st_param	equ	8
    15                              <1> 
    16                              <1> _leloup:
    17 00000000 55                  <1> 	push	rbp
    18                              <1> 
    19                              <1> 	%if	0
    20                              <1> 	push	rsi
    21                              <1> 	push	rdi
    22                              <1> 	push	rax
    23                              <1> 	push	rcx
    24                              <1> 	push	rdx
    25                              <1> 	%endif
    26                              <1> 
    27 00000001 53                  <1> 	push	rbx
    28                              <1> 
    29 00000002 4889FE              <1> 	mov	rsi, rdi			; structure smp ->
    30                              <1> 
    31 00000005 4157                <1> 	push	r15
    32 00000007 4156                <1> 	push	r14
    33 00000009 4155                <1> 	push	r13
    34 0000000B 4154                <1> 	push	r12
    35                              <1> 
    36 0000000D 4C8BA680040000      <1> 	mov	r12, qword ptr [rsi+APC]
    37 00000014 488BAE98040000      <1> 	mov	rbp, qword ptr [rsi+REGISTER_SET]
    38 0000001B 4C8BAE88040000      <1> 	mov	r13, qword ptr [rsi+APCZ]
    39 00000022 4C8B3425[00000000]  <1> 	mov	r14, qword ptr [_breakpoint]
    40 0000002A 4C8B3C25[00000000]  <1> 	mov	r15, qword ptr [_touchpoint]
    41                              <1> 						; balance core state pointer
    42 00000032 56                  <1> 	push	rsi				; on stack top
    43 00000033 480F6EFE            <1> 	movq	mm7, rsi			; refresh source
    44                              <1> 
    45 00000037 4D39EC              <1> loup:	cmp	r12, r13			; [rsi+APCZ]
    46 0000003A 7744                <1> 	ja	off_limits
    47                              <1> 
    48                              <1> 	%if	__MOVBE
    49                              <1> 	movbe	eax, dword ptr [r12]
    50                              <1> 	%else
    51 0000003C 418B0424            <1> 	mov	eax, dword ptr [r12]
    52 00000040 0FC8                <1> 	bswap	eax
    53                              <1> 	%endif
    54                              <1> 
    55 00000042 4983C404            <1> 	add	r12, 4
    56                              <1> 
    57 00000046 E82F010000          <1> 	call	_execute
    58                              <1> 
    59 0000004B 488B3424            <1> 	mov	rsi, qword ptr [rsp] 		; core pointer needed all the way round
    60                              <1> 
    61                              <1> 	%if	TSLICE
    62 0000004F F786B0040000000087- <1> 	test	dword ptr [rsi+PSR], 00870000h	; not while ISR or interrupt mask
    62 00000058 00                  <1>
    63 00000059 752F                <1> 	jnz	louping
    64 0000005B F78650020000FFFFFF- <1> 	test	dword ptr [rsi+RT_CLOCK], 00FFFFFFh
    64 00000064 00                  <1>
    65 00000065 7423                <1> 	jz	louping
    66                              <1> 
    67 00000067 FF8E50020000        <1> 	dec	dword ptr [rsi+RT_CLOCK]
    68 0000006D 751B                <1> 	jnz	louping
    69                              <1> 
    70 0000006F B841000000          <1> 	mov	eax, II_YIELD
    71                              <1> 
    72 00000074 B90A000000          <1> 	mov	ecx, LP_TIMESLICE
    73 00000079 E8C7100000          <1> 	call	_ii
    74                              <1> 
    75                              <1> 	%endif
    76                              <1> 
    77 0000007E EB0A                <1> 	jmp	louping
    78                              <1> 
    79                              <1> off_limits:
    80 00000080 B85F000000          <1> 	mov	eax, II_GUARD
    81 00000085 E8BB100000          <1> 	call	_ii
    82                              <1> 
    83                              <1> louping:
    84 0000008A 4D39F4              <1> 	cmp	r12, r14			; [ _breakpoint ]
    85 0000008D 7519                <1> 	jnz	loup_count
    86                              <1> 
    87 0000008F 800C25[00000000]02  <1> 	or	byte ptr [_general_indication], LOCKSTEP
    88 00000097 808EA404000002      <1> 	or	byte ptr [rsi+INDICATION], LOCKSTEP
    89 0000009E 800C25[12000000]01  <1> 	or	byte ptr [_flag+'s'-'a'], 1
    90 000000A6 EB51                <1> 	jmp	indicated
    91                              <1> 
    92                              <1> loup_count:
    93 000000A8 FF8E6C040000        <1> 	dec	dword ptr [rsi+283*4]		; decrement from quantity RATIO
    94 000000AE 7908                <1> 	jns	loup_away
    95 000000B0 66838EA404000001    <1> 	or	word ptr [rsi+INDICATION], TIME_UPDATE
    96                              <1> loup_away:
    97                              <1> 
    98 000000B8 668B86A4040000      <1> 	mov	ax, word ptr [rsi+INDICATION]
    99 000000BF 8A8EB2040000        <1> 	mov	cl, byte ptr [rsi+PSR+2]
   100 000000C5 80E107              <1> 	and	cl, 7				; highest interrupt mask?
   101 000000C8 80F107              <1> 	xor	cl, 7
   102                              <1> 
   103 000000CB 7422                <1> 	jz	internal_indications?		; maskable interrupts are masked
   104                              <1> 
   105 000000CD 66A9EBFF            <1>         test	ax, INDICATIONS|EXTERNAL_INDICATIONS	; 1 or both of internal++external
   106 000000D1 0F8460FFFFFF        <1> 	jz	loup					; indications? No?
   107 000000D7 66A9E0FF            <1> 	test	ax, EXTERNAL_INDICATIONS	; external indications among the yes?
   108                              <1> 
   109 000000DB 741C                <1> 	jz	indicated			; external indications there are not
   110                              <1> 						; therefore internal indications there are
   111                              <1> ;	push	rsi				; therefore raise their interrupts
   112 000000DD E8570F0000          <1> 	call	_xi
   113 000000E2 488B3424            <1> 	mov	rsi, qword ptr [rsp]
   114                              <1> 
   115 000000E6 80A6A40400007F      <1> 	and	byte ptr [rsi+INDICATION], 127
   116 000000ED EB9B                <1> 	jmp	louping				; keep going intil pending flags are off
   117                              <1> 
   118                              <1> internal_indications?:
   119 000000EF 66A90B00            <1> 	test	ax, INDICATIONS			; just read from esi->INDICATION
   120 000000F3 0F843EFFFFFF        <1> 	jz	loup
   121                              <1> 
   122                              <1> indicated:
   123 000000F9 80A6A4040000FD      <1> 	and	byte ptr [rsi+INDICATION], LOCKSTEP^255
   124                              <1> 
   125 00000100 4889AE98040000      <1> 	mov	qword ptr [rsi+REGISTER_SET], rbp
   126 00000107 4C89A680040000      <1> 	mov	qword ptr [rsi+APC], r12
   127 0000010E 4C89AE88040000      <1> 	mov	qword ptr [rsi+APCZ], r13
   128                              <1> 
   129 00000115 5F                  <1> 	pop	rdi				; take core pointer off stack
   130                              <1> 						; was passed in rdi, should not matter
   131 00000116 415C                <1> 	pop	r12
   132 00000118 415D                <1> 	pop	r13
   133 0000011A 415E                <1> 	pop	r14
   134 0000011C 415F                <1> 	pop	r15
   135                              <1> 
   136 0000011E 5B                  <1> 	pop	rbx				; caller values
   137                              <1> 
   138                              <1> 	%if	0
   139                              <1> 	pop	rdx
   140                              <1> 	pop	rcx
   141                              <1> 	pop	rax
   142                              <1> 	pop	rdi
   143                              <1> 	pop	rsi
   144                              <1> 	%endif
   145                              <1> 
   146 0000011F 5D                  <1> 	pop	rbp
   147 00000120 C3                  <1> 	ret
   148                              <1> 
    30                                  	%include	"execute.msm"
     1                              <1> ;	include	rta_x86.h
     2                              <1> .model	small
     2          ******************  <1>  warning: label alone on a line without a colon might be in error [-w+orphan-labels]
     3                              <1> .code
     4                              <1> 
     5 00000121 89C1                <1> __ea:	mov	ecx, eax
     6 00000123 C1E108              <1> 	shl	ecx, 8
     7 00000126 C1E913              <1> 	shr	ecx, 24-5		; instruction index in ch
     8 00000129 C0E905              <1> 	shr	cl, 5			; operand designator in cl
     9                              <1> 
    10 0000012C C1E010              <1> 	shl	eax, 16
    11 0000012F 80F905              <1> 	cmp	cl, XI			; sign extended immediate?
    12 00000132 7508                <1> 	jnz	derive_ea
    13                              <1> 
    14 00000134 C1F808              <1> 	sar	eax, 8			; different from other EAs
    15 00000137 C1E808              <1> 	shr	eax, 8
    16 0000013A EB3D                <1> 	jmp	ea_derived
    17                              <1> 
    18                              <1> derive_ea:
    19 0000013C C1E810              <1> 	shr	eax, 16			; no sign of it
    20 0000013F 6621C0              <1> 	and	ax, ax			; indexing / indirection ?
    21 00000142 7935                <1> 	jns	ea_derived		; no
    22                              <1> 
    23 00000144 89C3                <1> 	mov	ebx, eax
    24 00000146 80E47F              <1> 	and	ah, 127			; ie: and ax 32767
    25 00000149 66C1EB0C            <1> 	shr	bx, 12			; position index tag
    26 0000014D F6C306              <1> 	test	bl, 6			; indirect or indexed ?
    27 00000150 7415                <1> 	jz	indirect
    28                              <1> 					; pe = PF set
    29                              <1> 					; can only be tested on b7..0
    30 00000152 7A03                <1> 	jpe	indexed_4bit		; indexed fp / sp
    31                              <1> 					; indexed x / y / a / b
    32 00000154 80E307              <1> 	and	bl, 7			; zero bit 3
    33                              <1> 
    34                              <1> indexed_4bit:
    35 00000157 6625FF0F            <1> 	and	ax, 4095		; isolate adqress offset
    36 0000015B 03449D00            <1> 	add	eax, dword ptr [rbp+rbx*4]
    37                              <1> 
    38 0000015F C1E008              <1> 	shl	eax, 8			; truncate any overflow
    39 00000162 C1E808              <1> 	shr	eax, 8
    40                              <1> 
    41 00000165 EB12                <1> 	jmp	ea_derived
    42                              <1> 
    43                              <1> indirect:				; indirect via page B0 / B1
    44 00000167 6689CB              <1> 	mov	bx, cx
    45 0000016A 6631C9              <1> 	xor	cx, cx			; cl <- zero to read 1-word indirection pointer
    46 0000016D E888030000          <1> 	call	_operand_read
    47 00000172 6689D9              <1> 	mov	cx, bx			; retrieve instruction:class into cx
    48                              <1> 
    49 00000175 480F7EFE            <1> 	movq	rsi, mm7
    50                              <1> ;	mov	rsi, qword ptr [rbp+CORE_INDEX1]	; retrieve smp core ->
    51                              <1> 
    52                              <1> ea_derived:
    53 00000179 C3                  <1> 	ret
    54                              <1> 
    55                              <1> _execute:
    56 0000017A 4889A678040000      <1> 	mov	qword ptr [rsi+REGISTER+286*4], rsp
    57 00000181 E89BFFFFFF          <1> 	call	__ea
    58                              <1> 
    59 00000186 0FB6DD              <1> 	movzx	ebx, ch			; instruction index
    60 00000189 80F906              <1> 	cmp	cl, 6
    61 0000018C 0F8410010000        <1> 	jz	near shifts_jumps
    62 00000192 0F8714020000        <1> 	ja	near large_operations
    63                              <1> 
    64                              <1> integer_operations:
    65 00000198 488B1CDD[A2010000]  <1> 	mov	rbx, qword ptr [operations1+rbx*8]
    66 000001A0 FFE3                <1> 	jmp	rbx
    67                              <1> 
    68                              <1> operations1:
    69 000001A2 [A214000000000000]  <1>         dq	_sr
    70 000001AA [BC14000000000000]  <1>         dq	_sk
    71 000001B2 [D614000000000000]  <1>         dq	_sx
    72 000001BA [F014000000000000]  <1>         dq	_sy
    73 000001C2 [0A15000000000000]  <1>         dq	_sa
    74 000001CA [2015000000000000]  <1>         dq	_sb
    75 000001D2 [3215000000000000]  <1>         dq	_z
    76 000001DA [4B15000000000000]  <1>         dq	_pop
    77                              <1> 
    78 000001E2 [6715000000000000]  <1>         dq	_lr
    79 000001EA [7015000000000000]  <1>         dq	_lk
    80 000001F2 [7915000000000000]  <1>         dq	_lx
    81 000001FA [8215000000000000]  <1>         dq	_ly
    82 00000202 [8B15000000000000]  <1>         dq	_la
    83 0000020A [9415000000000000]  <1>         dq	_lb
    84 00000212 [9D15000000000000]  <1>         dq	_tz
    85 0000021A [C515000000000000]  <1>         dq	_tp
    86                              <1> 
    87 00000222 [F318000000000000]  <1>         dq	_ax
    88 0000022A [0419000000000000]  <1>         dq	_ay
    89 00000232 [1519000000000000]  <1>         dq	_or
    90 0000023A [1E19000000000000]  <1>         dq	_orB
    91 00000242 [2719000000000000]  <1>         dq	_and
    92 0000024A [3019000000000000]  <1>         dq	_andB
    93 00000252 [3919000000000000]  <1>         dq	_xor
    94 0000025A [4219000000000000]  <1>         dq	_xorB
    95                              <1> 
    96 00000262 [4B19000000000000]  <1>         dq	_aa
    97 0000026A [6B19000000000000]  <1>         dq	_ab
    98 00000272 [5219000000000000]  <1>         dq	_ana
    99 0000027A [7219000000000000]  <1>         dq	_anb
   100 00000282 [8B19000000000000]  <1>         dq	_m
   101 0000028A [B919000000000000]  <1>         dq	_mf
   102 00000292 [131A000000000000]  <1>         dq	_d
   103 0000029A [E415000000000000]  <1>         dq	_push
   104                              <1> 
   105                              <1> shifts_jumps:
   106 000002A2 488B1CDD[AC020000]  <1> 	mov	rbx, qword ptr [operations6+rbx*8]
   107 000002AA FFE3                <1> 	jmp	rbx
   108                              <1> 
   109                              <1> operations6:
   110 000002AC [B81A000000000000]  <1>         dq	_sar
   111 000002B4 [CF1A000000000000]  <1>         dq	_sbr
   112 000002BC [E61A000000000000]  <1>         dq	_dsr
   113 000002C4 [0316000000000000]  <1>         dq	_jdr
   114 000002CC [FA1A000000000000]  <1>         dq	_sal
   115 000002D4 [111B000000000000]  <1>         dq	_sbl
   116 000002DC [281B000000000000]  <1>         dq	_dsl
   117 000002E4 [1D16000000000000]  <1>         dq	_lcal
   118                              <1> 
   119 000002EC [3C1B000000000000]  <1>         dq	_rar
   120 000002F4 [481B000000000000]  <1>         dq	_rbr
   121 000002FC [541B000000000000]  <1>         dq	_drr
   122 00000304 [3516000000000000]  <1>         dq	_jnc
   123 0000030C [F01C000000000000]  <1>         dq	_ral
   124 00000314 [FC1C000000000000]  <1>         dq	_rbl
   125 0000031C [081D000000000000]  <1>         dq	_drl
   126 00000324 [4216000000000000]  <1>         dq	_jc
   127                              <1> 
   128 0000032C [1C1D000000000000]  <1>         dq	_saa
   129 00000334 [2D1D000000000000]  <1>         dq	_sba
   130 0000033C [3E1D000000000000]  <1>         dq	_dsa
   131 00000344 [4F16000000000000]  <1>         dq	_jao
   132 0000034C [5916000000000000]  <1>         dq	_jpa
   133 00000354 [6316000000000000]  <1>         dq	_jpb
   134 0000035C [6D16000000000000]  <1>         dq	_j
   135 00000364 [8616000000000000]  <1>         dq	_jpo
   136                              <1> 
   137 0000036C [8E16000000000000]  <1>         dq	_jza
   138 00000374 [9816000000000000]  <1>         dq	_jzb
   139 0000037C [A216000000000000]  <1>         dq	_jnza
   140 00000384 [AC16000000000000]  <1>         dq	_jnzb
   141 0000038C [B616000000000000]  <1>         dq	_jna
   142 00000394 [C016000000000000]  <1>         dq	_jnb
   143 0000039C [CA16000000000000]  <1>         dq	_jxge
   144 000003A4 [D916000000000000]  <1>         dq	_jyge
   145                              <1> 
   146                              <1> 
   147                              <1> large_operations:
   148 000003AC 488B1CDD[B8030000]  <1> 	mov	rbx, qword ptr [operations7+rbx*8]
   149 000003B4 B100                <1> 	mov	cl, 0		; default size large operand
   150 000003B6 FFE3                <1> 	jmp	rbx		; 1 word
   151                              <1> 
   152                              <1> operations7:
   153 000003B8 [BD17000000000000]  <1>         dq	_ts
   154 000003C0 [521D000000000000]  <1>         dq	_n
   155 000003C8 [611D000000000000]  <1>         dq	_inc
   156 000003D0 [6D1D000000000000]  <1>         dq	_dec
   157 000003D8 [D417000000000000]  <1>         dq	_sim
   158 000003E0 [B91D000000000000]  <1>         dq	_popA
   159 000003E8 [791D000000000000]  <1>         dq	_src
   160 000003F0 [991D000000000000]  <1>         dq	_slc
   161                              <1> 
   162 000003F8 [E816000000000000]  <1>         dq	_qs
   163 00000400 [F216000000000000]  <1>         dq	_ql
   164 00000408 [5D17000000000000]  <1>         dq	_dte
   165 00000410 [2217000000000000]  <1>         dq	_dpop
   166 00000418 [4D26000000000000]  <1>         dq	_fa
   167 00000420 [6826000000000000]  <1>         dq	_fan
   168 00000428 [8326000000000000]  <1>         dq	_fm
   169 00000430 [A526000000000000]  <1>         dq	_fd
   170                              <1> 
   171 00000438 [FC16000000000000]  <1>         dq	_qpop
   172 00000440 [0D17000000000000]  <1>         dq	_qpush
   173 00000448 [AF17000000000000]  <1>         dq	_ex
   174 00000450 [3317000000000000]  <1>         dq	_dpush
   175 00000458 [9D1E000000000000]  <1>         dq	_lsc
   176 00000460 [4B17000000000000]  <1>         dq	_mta
   177 00000468 [7117000000000000]  <1>         dq	_sc
   178 00000470 [7F17000000000000]  <1>         dq	_mlb
   179                              <1> 
   180 00000478 [9817000000000000]  <1>         dq	_ds
   181 00000480 [A217000000000000]  <1>         dq	_dl
   182 00000488 [EC1D000000000000]  <1>         dq	_da
   183 00000490 [F31D000000000000]  <1>         dq	_dan
   184 00000498 [AE1E000000000000]  <1>         dq	_dlsc
   185 000004A0 [AE17000000000000]  <1>         dq	_spare
   186 000004A8 [1B18000000000000]  <1>         dq	_go
   187 000004B0 [FB17000000000000]  <1>         dq	_call
   188                              <1> 
    31                                  	%include	"rw.msm"
     1                              <1> 
     2                              <1> 
     3                              <1> ;	include	rta_x86.h
     4                              <1> ;	.model	large
     5                              <1> ;	.code
     6                              <1> 
     7                              <1> ;	this is the operand reader / writer
     8                              <1> ;	for emulated RTA1 on x86
     9                              <1> 
    10                              <1> ;	layout is
    11                              <1> 
    12                              <1> ;	RTA1 24-bit registers are modeled in an array of
    13                              <1> ;	platform-endian integers. In x86 these are 32-bit
    14                              <1> ;	little-endian integers
    15                              <1> 
    16                              <1> ;	platform-endian doesn't affect registers
    17                              <1> ;	because endianness is not at the CPU
    18                              <1> ;	side of the bus, but at the memory side
    19                              <1> 
    20                              <1> ;	when Intel circuitry in the x86 CPU staticises the value
    21                              <1> ;	of an emulated register, that value is big endian
    22                              <1> 
    23                              <1> ;	the stored integers where emulated registers are modeled
    24                              <1> ;	are platform-endian, with identical effect on big and
    25                              <1> ;	little endian emulator platforms
    26                              <1> 
    27                              <1> ;	RTA1 24-bit executable space storage words are modeled in
    28                              <1> ;	another array of platform-endian 32-bit integers. Emulation
    29                              <1> ;	on x86 swaps the byte order of storage words on read and
    30                              <1> ;	before write to conform with RTA1 canonical storage order
    31                              <1> 
    32                              <1> ;       RTA1 architecture has registers in the first 256 locations
    33                              <1> ;       of address space and access differentiates registers from
    34                              <1> ;       from memory according to effective address
    35                              <1> 
    36                              <1> ;	location of registers and storage are handed to read / write
    37                              <1> ;	routines as RTA1 word linear effective addresses
    38                              <1> 
    39                              <1> ;	These routines maintain the RTA1 linear addresses passed
    40                              <1> ;	in x86 registers and apply them with shifted scale plus
    41                              <1> ;	displacement, for example
    42                              <1> 
    43                              <1> ;		mov	eax, dword ptr [edi+esi*4+_memory]
    44                              <1> ;		bswap	eax
    45                              <1> ;		mov	dword_ptr [ebp+ebx*4], eax
    46                              <1> 
    47                              <1> ;	RTA1 register addresses are already absolute in terms of
    48                              <1> ;	the emulated RTA1 machine
    49                              <1> 
    50                              <1> ;	ebp points at the context register frame. There are two
    51                              <1> ;	register frames, application and interrupt. Registers
    52                              <1> ;	addressed as storage operand are in a single list
    53                              <1> 
    54                              <1> ;		mov	eax, dword ptr [esi*4+__register]
    55                              <1> 
    56                              <1> ;	RTA1 storage addresses are translated by RTA1 relocation
    57                              <1> ;	architecture before application. The updated linear addresses
    58                              <1> ;	of the emulated machine are in esi
    59                              <1> 
    60                              <1> ;	The operand routines in this file point edi to the x86 platform
    61                              <1> ;	storage array start of the storage device, most often emulated
    62                              <1> ;	RTA1 executable space
    63                              <1> 
    64                              <1> ;	instructions call these operand routines with RTA1 effective 
    65                              <1> ;	address in eax
    66                              <1> 
    67                              <1> ;	instructions receive load operand values in eax and ebx, or in
    68                              <1> ;	a list of RTA1 emulated register locations pointed by ebp+ebx
    69                              <1> 
    70                              <1> ;	store instructions submit a value in ebx, or values in list of
    71                              <1> ;	RTA1 emulated register locations pointed by ebp+ebx
    72                              <1> 
    73                              <1> ;	to preserve linear address consistency, application instruction
    74                              <1> ;	work areas, where needed in addition to x86 registers, are
    75                              <1> ;	implemented as sub-architectural extra RTA1 registers at the end
    76                              <1> ;	of the 256-longword register stack. x86 register ebp+ebx*4 identify
    77                              <1> ;	these locations by linear RTA1 word quantum as "registers"
    78                              <1> 
    79                              <1> ;	RTA1 registers and storage alike are in 24-bit word address quantum space
    80                              <1> 
    81                              <1> ;	emulated instructions loading or storing multiple hidden extra work
    82                              <1> ;	registers should unconditionally set ebp to the start or application
    83                              <1> ;	frame of the emulated register array, so that [ebp+ebx*4] accesses the
    84                              <1> ;	correct locations at register occurence 256+
    85                              <1> 
    86                              <1> ;               _floating_operand2 equ  256+12
    87                              <1> 
    88                              <1> ;		push	ebp
    89                              <1> ;		mov	ebp, __register	; point to application register frame[0]
    90                              <1> ;		mov	ebx, 256+_floating_operand2
    91                              <1> ;		call	_burst_read4
    92                              <1> 
    93                              <1> ;		pop	ebp		; return to previous register frame[0] application
    94                              <1> 					;                          or frame[1] interrupt
    95                              <1> 
    96                              <1> ;	Both internal stack pointers are also absolute, so for stack operations
    97                              <1> ;	ebp should be momentarily forced to the lower-addressed (application) stack
    98                              <1> ;	frame after being used to point the stack location of reference
    99                              <1> 
   100                              <1> ;		mov	ebx, dword ptr [ebp+S_P]	; read one of the two stack pointers
   101                              <1> ;		cmp	ebx, ebp+STACK_LOWER_LIMIT	; 24*4 within context of either stack
   102                              <1> ;		jl	II_GUARD
   103                              <1> ;		add	ebx, -1				; new stack top
   104                              <1> ;		mov	dword ptr [ebp+S_P], ebx
   105                              <1> ;		push	ebp				; which ever stack pointer it is, it points
   106                              <1> ;		mov	ebp,__register			; relative to all the register stack
   107                              <1> ;		call	_operand_read			; for I am the single-word push instruction
   108                              <1> ;		pop	ebp				;
   109                              <1> 
   110                              <1> ;	register identities supplied from emulated instructions to these routines
   111                              <1> ;	are their lowercase names equated to RTA1 word addresses
   112                              <1> 
   113                              <1> ;	There exist also uppercase spellings which instruction routines may
   114                              <1> ;	access internally. The uppercase names are four times in value the
   115                              <1> ;	equivalent lowercase ordinal names to give x86 platform offset values
   116                              <1> 
   117                              <1> ;       Assembly language equate is like parentheses! What's in a label
   118                              <1> ;       is not an expression but its value. Nothing like C preprocessor.
   119                              <1> ;       Just in case you're developing enhancements in assembly using
   120                              <1> ;       preprocessor and #define
   121                              <1> 
   122                              <1> ;		_floating_operand2 equ	256+12
   123                              <1> ;		FLOATING_OPERAND2 equ	_floating_operand2*4
   124                              <1> 
   125                              <1> 
   126                              <1> ;		a	equ	4
   127                              <1> ;		b	equ	5
   128                              <1> ;		mantissa2 equ	6
   129                              <1> 
   130                              <1> ;		A	equ	a*4
   131                              <1> ;		B	equ	b*4
   132                              <1> ;		MANTISSA2 equ	mantissa2*4
   133                              <1> 
   134                              <1> ;		mov	ebx, dword ptr [bp+MANTISSA2]	; the very same!
   135                              <1> ;		mov	ebx, dword ptr [bp+mantissa2*4]	; the very same
   136                              <1> 
   137                              <1> ;	but to identify an instruction-implied register to these operand routines
   138                              <1> 
   139                              <1> ;		mov	ebx, mantissa2		; bp already says which register set
   140                              <1> 
   141                              <1> ;	instruction evaluation supplies right-hand side operand EA in eax
   142                              <1> ;	Instruction implementation needs not examine EA. Call _operand_read
   143                              <1> ;	or _operand_write. eax must be as supplied to the instruction routine
   144                              <1> ;	on on operand retrieve and store
   145                              <1> 
   146                              <1> ;	simple instructions receive operand mode in cl from instruction
   147                              <1> ;	evaluation
   148                              <1> 
   149                              <1> ;	shifts and jumps use the ea which is already indexed or indirected
   150                              <1> ;	if necessary and make no operand call
   151                              <1> 
   152                              <1> ;	instructions call _burst_read2 or _burst_write2 for two-word operand cycles
   153                              <1> ;	instructions call _burst_read4 or _burst_write4 for four-word operand cycles
   154                              <1> 
   155                              <1> ;	operand reads of 1 or 2 words return values in eax:ebx
   156                              <1> 
   157                              <1> ;		call	_burst_read2
   158                              <1> ;		mov	dword ptr [ebp+A], eax
   159                              <1> ;		mov	dword ptr [ebp+B], ebx
   160                              <1> 
   161                              <1> ;	to store one operand word place it in ebx
   162                              <1> 
   163                              <1> ;	_sc	mov	ebx, dword ptr[_psr]	; I am the store carry instruction sc
   164                              <1> ;		and	ebx, 1			; CARRY
   165                              <1> ;		call	_operand_write
   166                              <1> 
   167                              <1> ;	to store two or four words or to load four words, point bx to register
   168                              <1> 
   169                              <1> ;	_qpop	mov	ebx, dword ptr [ebp+S_P] ; internal stack pointer
   170                              <1> ;						; either application sp or interrupt sp
   171                              <1> ;
   172                              <1> ;		add	dword ptr [ebp+S_P], 4	; internal stack+= 4
   173                              <1> ;		push	ebp			;
   174                              <1> ;		mov	ebp, __register		; in case context is interrupt registers
   175                              <1> ;		call	_burst_write4		; both internal stack pointers are absolute
   176                              <1> ;		pop	ebp			; point epb back to application registers
   177                              <1> ;						;                or interrupt registers
   178                              <1> 
   179                              <1> ;	more complex instructions do something to the registers after
   180                              <1> ;	acquiring operands
   181                              <1> 
   182                              <1> ;		call	_operand_read
   183                              <1> ;		add	eax, dword ptr [ebp+A]
   184                              <1> ;		rol	eax
   185                              <1> ;		and	al, CARRY		; 1
   186                              <1> ;		or	byte ptr [_psr], al	; low-order byte of longword _psr
   187                              <1> ;		shr	eax, 8
   188                              <1> ;		mov	dword ptr [ebp+A], eax
   189                              <1> 
   190                              <1> ;	emulated RTA1 instructions which both read and write (modify)
   191                              <1> ;	storage use the address in [edi+esi*4] to rewrite. edi is
   192                              <1> ;	NULL if it's not a suitable memory for a modify operation
   193                              <1> 
   194                              <1> ;	modify instructions which may have a register operand (not TS)
   195                              <1> ;	call _operand_write to rewrite a register. This guards aganst
   196                              <1> ;	applications writing interrupt registers.
   197                              <1>  
   198                              <1> ;	the effect of storage buses characteristically different
   199                              <1> ;	from RTA1 executable space is emulated in the routines
   200                              <1> ;	device_read and device_write
   201                              <1> 
   202                              <1> ;	Peripheral bus types implemented are
   203                              <1> 
   204                              <1> ;		filestore containing extents of up to 768K octets
   205                              <1> ;		accessible to RTA1 as up to 256K words in each extent.
   206                              <1> ;		The 3-octet words are in canonical order and packed
   207                              <1> 
   208                              <1> ;		network interface buffer store shared with the emulator
   209                              <1> ;		platform and reading out to RTA1 at 16 data bits per word
   210                              <1> ;		with eight high-order zero bits. RTA writes 16 data bits
   211                              <1> ;		to these locations from register low-order bit positions.
   212                              <1> ;		Storage byte order is canonical. These buffers are normal
   213                              <1> ;		and contiguous byte arrays of the emulator platform.
   214                              <1> ;		To RTA1 they are an attached device array of 16-bit words
   215                              <1> 
   216                              <1> ;	Device array types are
   217                              <1> 
   218                              <1> ;		executable space
   219                              <1> ;		24-bit filestore array
   220                              <1> ;		16-bit network interface array
   221                              <1> 
   222                              <1> ;	devices are identified in RTA1 memory relocation pointers and
   223                              <1> ;	tagged with device type. Executable space is device zero
   224                              <1> 
   225                              <1> ;	esi -> core.REGISTER
   226                              <1> 
   227                              <1> _burst_read2:
   228 000004B8 66B90600            <1> 	mov	cx, 6
   229 000004BC A900FFFF00          <1> 	test	eax, 00FFFF00h
   230 000004C1 7402                <1> 	jz	read2_registers
   231 000004C3 EB4D                <1> 	jmp	_bus_read
   232                              <1> 
   233                              <1> read2_registers:				; load registers from registers
   234                              <1> 	%if	__REGFOR
   235                              <1> 
   236                              <1> 	mov	rax, qword ptr [rsi+rax*4]	; swap the halves of r8 if computing in r8
   237                              <1> 	ret					; just mov for double register load
   238                              <1> 						; do this load inline anyway
   239                              <1> 	%else	
   240                              <1> 
   241 000004C5 8B5C8604            <1> 	mov	ebx, dword ptr [rsi+rax*4+4]
   242 000004C9 8B0486              <1> 	mov	eax, dword ptr [rsi+rax*4]
   243 000004CC C3                  <1> 	ret
   244                              <1> 
   245                              <1> 	%endif
   246                              <1> 	
   247                              <1> ;	rsi -> core.REGISTER
   248                              <1> 
   249                              <1> _burst_read4:					; buffered read
   250 000004CD 66B90700            <1> 	mov	cx, 7				; that will help the caller
   251 000004D1 A900FFFF00          <1> 	test	eax, 00FFFF00h			; ebp+ebx contains a register number
   252 000004D6 7402                <1> 	jz	read4_registers			; may also identify extra
   253 000004D8 EB38                <1> 	jmp	_bus_read
   254                              <1> 						; workspace registers
   255                              <1> read4_registers:				; at register stack tail
   256                              <1> 
   257                              <1> 	%if	__REGFOR			; registers are modelled
   258                              <1> 						; platform endian in storage
   259                              <1> 	mov	rax, qword ptr [rsi+rax*4+2*4]	; core-ways round individually but reverse order
   260                              <1> 	mov	rdx, qword ptr [rsi+rax*4]	; into correct register order individually platform-ordered 
   261                              <1> 	ret
   262                              <1> 
   263                              <1> 	%else
   264                              <1> 
   265 000004DA 8B4C860C            <1> 	mov	ecx, dword ptr [rsi+rax*4+3*4]
   266 000004DE 894C9D0C            <1> 	mov	dword ptr [rbp+rbx*4+3*4], ecx
   267 000004E2 8B4C8608            <1> 	mov	ecx, dword ptr [rsi+rax*4+2*4]
   268 000004E6 894C9D08            <1> 	mov	dword ptr [rbp+rbx*4+2*4], ecx
   269 000004EA 8B4C8604            <1> 	mov	ecx, dword ptr [rsi+rax*4+4]
   270 000004EE 894C9D04            <1> 	mov	dword ptr [rbp+rbx*4+4], ecx
   271 000004F2 8B0C86              <1> 	mov	ecx, dword ptr [rsi+rax*4]
   272 000004F5 894C9D00            <1> 	mov	dword ptr [rbp+rbx*4], ecx
   273 000004F9 C3                  <1> 	ret
   274                              <1> 
   275                              <1> 	%endif
   276                              <1> 
   277                              <1> ;	esi -> core.REGISTER
   278                              <1> 
   279                              <1> _operand_read:			; call here with designator coded in cx
   280 000004FA 80E107              <1> 	and	cl, 7		; and ea in eax
   281 000004FD 80F904              <1> 	cmp	cl, 4
   282 00000500 740F                <1> 	je	immediate	; EA is operand
   283 00000502 80F905              <1> 	cmp	cl, 5
   284 00000505 740A                <1> 	je	immediate_xi	; EA is operand
   285                              <1> 
   286 00000507 A900FFFF00          <1> 	test	eax, 00FFFF00h
   287 0000050C 7504                <1> 	jnz	_bus_read	; ea does not point to registers
   288 0000050E 8B0486              <1> 	mov	eax, dword ptr [rsi+rax*4]
   289                              <1> 
   290                              <1> immediate:
   291                              <1> immediate_xi:
   292 00000511 C3                  <1> 	ret 
   293                              <1> 
   294                              <1> _bus_read:				; readout any memory
   295                              <1> 
   296 00000512 E82F060000          <1> 	call	base_read_pointer	; returns eax <- storage block
   297                              <1> 					; 	  esi <- word offset
   298                              <1> 					;	  edi <- EA
   299                              <1> 
   300 00000517 A900004000          <1> 	test	eax, 00400000h		; big block?
   301 0000051C 7420                <1> 	je	memory_read_4k_block
   302                              <1> 
   303 0000051E 80F906              <1> 	cmp	cl, 6			; multiword operation?
   304 00000521 720D                <1> 	jb	_bus_read_256k_block
   305                              <1> 
   306 00000523 81FEFCFF0300        <1> 	cmp	esi, 03FFFCh		; near the edge?
   307 00000529 7605                <1> 	jna	_bus_read_256k_block	; no
   308                              <1> 
   309 0000052B E85A220000          <1> 	call	read_straddle_18b?
   310                              <1> 
   311                              <1> _bus_read_256k_block:
   312 00000530 25FFFF3F00          <1> 	and	eax, 003FFFFFh		; 64-bit shift to page won't brush off 00400000 bit
   313 00000535 A83F                <1> 	test	al, 63
   314 00000537 742A                <1> 	jz	memory_read_page
   315                              <1> 
   316 00000539 E916040000          <1> 	jmp	device_read
   317                              <1> 
   318                              <1> memory_read_4k_block:
   319 0000053E F7C600F00300        <1> 	test	esi, 0003F000h		; inside 4k block?
   320 00000544 740A                <1> 	jz	memory_read_thru
   321                              <1> 
   322 00000546 B90E000000          <1> 	mov	ecx, LP_ADDRESS
   323 0000054B E9E50B0000          <1> 	jmp	guard_ii_escape		; no
   324                              <1> 
   325                              <1> memory_read_thru:
   326 00000550 80F906              <1> 	cmp	cl, 6
   327 00000553 720E                <1> 	jb	memory_read_page
   328                              <1> 
   329 00000555 4881FEFC0F0000      <1> 	cmp	rsi, 0FFCh		; near the edge?
   330 0000055C 7605                <1> 	jna	memory_read_page	; no
   331                              <1> 
   332 0000055E E8F7210000          <1> 	call	read_straddle_12b?
   333                              <1> 
   334                              <1> memory_read_page:
   335 00000563 48C1E00C            <1> 	shl	rax, 12			; multiply by page and lose bit 00400000
   336 00000567 4801C6              <1> 	add	rsi, rax
   337                              <1> ;	mov	ch, byte ptr [edi+PSR]	; field of PSR with byte options
   338 0000056A 48BF-               <1> 	mov	rdi, _memory		; byte address
   338 0000056C [0000000000000000]  <1>
   339                              <1> 
   340                              <1> memory_read_on:
   341 00000574 488D3CB7            <1> 	lea	rdi, [rdi+rsi*4]
   342                              <1> 
   343 00000578 480F7EFE            <1> 	movq	rsi, mm7
   344                              <1> ;	mov	rsi, qword ptr [rbp+CORE_INDEX1]
   345 0000057C 480FB6C1            <1> 	movzx	rax, cl
   346 00000580 488B04C5[8A050000]  <1> 	mov	rax, qword ptr [read_action+rax*8]
   347 00000588 FFE0                <1> 	jmp	rax
   348                              <1> 
   349                              <1> read_action:
   350 0000058A [CA05000000000000]  <1> 	dq	memory_read_w0
   351 00000592 [0B06000000000000]  <1> 	dq	memory_t1
   352 0000059A [1206000000000000]  <1> 	dq	memory_t2	; or h1
   353 000005A2 [2206000000000000]  <1> 	dq	memory_t3	; or h2
   354 000005AA [1105000000000000]  <1> 	dq	immediate	; don't get here
   355 000005B2 [1105000000000000]  <1> 	dq	immediate_xi	; don't get here
   356 000005BA [D105000000000000]  <1> 	dq	memory_read2
   357 000005C2 [DF05000000000000]  <1> 	dq	memory_read4
   358                              <1> 
   359                              <1> memory_read_w0:			; readout system memory 1 word
   360                              <1> 
   361                              <1> 	%if	__MOVBE
   362                              <1> 	movbe	eax, dword ptr [rdi]
   363                              <1> 	%else
   364 000005CA 8B07                <1> 	mov	eax, dword ptr [rdi]
   365 000005CC B000                <1> 	mov	al, 0
   366 000005CE 0FC8                <1> 	bswap	eax
   367                              <1> 	%endif
   368                              <1> ; immediate:
   369                              <1> ; immediate_xi:
   370 000005D0 C3                  <1>  	ret
   371                              <1> 
   372                              <1> memory_read2:			; readout system memory 2 words
   373                              <1> 	%if	__MOVBE
   374                              <1> 
   375                              <1> 	movbe	rax, qword ptr [rdi]
   376                              <1> 	ret
   377                              <1> 
   378                              <1> 	%else
   379                              <1> 
   380 000005D1 8B5F04              <1> 	mov	ebx, dword ptr [rdi+4]
   381 000005D4 8B07                <1> 	mov	eax, dword ptr [rdi]
   382                              <1> 
   383 000005D6 B000                <1> 	mov	al, 0
   384 000005D8 B300                <1> 	mov	bl, 0
   385 000005DA 0FC8                <1> 	bswap	eax
   386 000005DC 0FCB                <1> 	bswap	ebx
   387 000005DE C3                  <1> 	ret
   388                              <1> 
   389                              <1> 	%endif
   390                              <1> 				; readout system memory 4 words
   391                              <1> memory_read4:			; store by pointer
   392                              <1> 				; this will be useful to the caller
   393                              <1> 
   394                              <1> 	%if	__MOVBE
   395                              <1> 	
   396                              <1> 	movbe	rax, qword ptr [rdi+2*4]
   397                              <1> 	movbe	rdx, qword ptr [rdi]
   398                              <1> 	ret
   399                              <1> 
   400                              <1> 	%else
   401                              <1> 
   402 000005DF 8B07                <1> 	mov	eax, dword ptr [rdi]
   403 000005E1 B000                <1> 	mov	al, 0
   404 000005E3 0FC8                <1> 	bswap	eax
   405 000005E5 89449D00            <1> 	mov	dword ptr [rbp+rbx*4], eax
   406 000005E9 8B4704              <1> 	mov	eax, dword ptr [rdi+4]
   407 000005EC B000                <1> 	mov	al, 0
   408 000005EE 0FC8                <1> 	bswap	eax
   409 000005F0 89449D04            <1> 	mov	dword ptr [rbp+rbx*4+4], eax
   410 000005F4 8B4708              <1> 	mov	eax, dword ptr [rdi+2*4]
   411 000005F7 B000                <1> 	mov	al, 0
   412 000005F9 0FC8                <1> 	bswap	eax
   413 000005FB 89449D08            <1> 	mov	dword ptr [rbp+rbx*4+2*4], eax
   414 000005FF 8B470C              <1> 	mov	eax, dword ptr [rdi+3*4]
   415 00000602 B000                <1> 	mov	al, 0
   416 00000604 0FC8                <1> 	bswap	eax
   417 00000606 89449D0C            <1> 	mov	dword ptr [rbp+rbx*4+3*4], eax
   418 0000060A C3                  <1> 	ret
   419                              <1> 
   420                              <1> 	%endif
   421                              <1> 
   422                              <1> memory_t1:
   423 0000060B 8B07                <1> 	mov	eax, dword ptr [rdi]
   424 0000060D C1E010              <1> 	shl	eax, 16		; t1 = 3.2.THIS.zero
   425 00000610 EB1B                <1> 	jmp	memory_tw
   426                              <1> 
   427                              <1> memory_t2:
   428 00000612 8B07                <1> 	mov	eax, dword ptr [rdi]
   429 00000614 F686B004000080      <1> 	test	byte ptr [rsi+PSR], HALF_W
   430 0000061B 7517                <1> 	jnz	memory_h1
   431 0000061D C1E008              <1> 	shl	eax, 8		; t2 = 3.THIS.1.zero
   432 00000620 EB0B                <1> 	jmp	memory_tw
   433                              <1> 
   434                              <1> memory_t3:
   435 00000622 8B07                <1> 	mov	eax, dword ptr [rdi]
   436 00000624 F686B004000080      <1> 	test	byte ptr [rsi+PSR], HALF_W
   437 0000062B 750E                <1> 	jnz	memory_h2
   438                              <1> memory_tw:
   439 0000062D C1F810              <1> 	sar	eax, 16		; t3 = THIS.2.1.zero
   440 00000630 C1E808              <1> 	shr	eax, 8
   441 00000633 C3                  <1> 	ret
   442                              <1> 
   443                              <1> memory_h1:
   444 00000634 0FC8                <1> 	bswap	eax		; already loaded but not swapped
   445 00000636 C1E008              <1> 	shl	eax, 8		; h1 = zero.HERE.2.3
   446 00000639 EB05                <1> 	jmp	memory_hw
   447                              <1> 
   448                              <1> memory_h2:
   449 0000063B 0FC8                <1> 	bswap	eax		; already loaded but not swapped
   450 0000063D C1E014              <1> 	shl	eax, 8+12
   451                              <1> memory_hw:
   452 00000640 C1F80C              <1> 	sar	eax, 12
   453 00000643 C1E808              <1> 	shr	eax, 8
   454 00000646 C3                  <1> 	ret
   455                              <1> 
   456                              <1> ;	esi -> core.REGISTER
   457                              <1> 				; store system memory
   458                              <1> _burst_write4:
   459 00000647 66B90700            <1> 	mov	cx, 7
   460 0000064B A900FFFF00          <1> 	test	eax, 00FFFF00h
   461 00000650 0F858A000000        <1> 	jnz	NEAR bus_write
   462                              <1> 
   463                              <1> 	; store emulated registers to emulated registers
   464                              <1> 
   465 00000656 F786B0040000000080- <1> 	test	dword ptr [rsi+PSR], 0800000h	; ISR ?
   465 0000065F 00                  <1>
   466 00000660 750A                <1> 	jnz	write4_registers	; ISRs may write some spare registers
   467 00000662 83F87C              <1> 	cmp	eax, 124
   468 00000665 7605                <1> 	jna	write4_registers
   469 00000667 E9C40A0000          <1> 	jmp	guard_ii_authority	; but applications may not write
   470                              <1> 					; any interrupt registers
   471                              <1> 
   472                              <1> write4_registers:
   473                              <1> ;	mov	edi, eax		; eax can be freed
   474                              <1> 
   475                              <1> 	%if	__REGFOR
   476                              <1> 	mov	rdx, qword ptr [rbp+rbx*4]
   477                              <1> 	ror	rdx, 32
   478                              <1> 	mov	qword ptr [rsi+REGISTER+rax*4], rdx
   479                              <1> 
   480                              <1> 	mov	rdx, qword ptr [rbp+rbx*4+2*4]
   481                              <1> 	ror	rdx, 32
   482                              <1> 	mov	qword ptr [rsi+REGISTERrax*4+2*4], rdx
   483                              <1> 	ret
   484                              <1> 
   485                              <1> 	%else
   486                              <1> 
   487 0000066C 8B4C9D00            <1> 	mov	ecx, dword ptr [rbp+rbx*4]	; data for store
   488                              <1> 					; ebp+ebx is a register number
   489                              <1> 					; which can be extra register locations
   490                              <1> 					; serving as workspace at the tail of
   491                              <1> 					; the register stack
   492                              <1> 
   493 00000670 890C86              <1> 	mov	dword ptr [rsi+rax*4], ecx
   494 00000673 8B4C9D04            <1> 	mov	ecx, dword ptr [rbp+rbx*4+4]
   495 00000677 894C8604            <1> 	mov	dword ptr [rsi+rax*4+4], ecx
   496                              <1> 
   497 0000067B 8B4C9D08            <1> 	mov	ecx, dword ptr [rbp+rbx*4+2*4]
   498 0000067F 894C8608            <1> 	mov	dword ptr [rsi+rax*4+2*4], ecx
   499 00000683 8B4C9D0C            <1> 	mov	ecx, dword ptr [rbp+rbx*4+3*4]
   500 00000687 894C860C            <1> 	mov	dword ptr [rsi+rax*4+3*4], ecx
   501 0000068B C3                  <1> 	ret
   502                              <1> 
   503                              <1> 	%endif
   504                              <1> 
   505                              <1> ;	esi -> core.REGISTER
   506                              <1> 
   507                              <1> _burst_write2:
   508 0000068C 66B90600            <1> 	mov	cx, 6
   509 00000690 A900FFFF00          <1> 	test	eax, 00FFFF00h
   510 00000695 7549                <1> 	jnz	bus_write
   511                              <1> 
   512                              <1> 	; store to emulated registers
   513                              <1> 
   514 00000697 F786B0040000000080- <1> 	test	dword ptr [rsi+PSR], 0800000h	; ISR ?
   514 000006A0 00                  <1>
   515 000006A1 750A                <1> 	jnz	write2_registers	; there are spare registers at the end
   516 000006A3 83F87E              <1> 	cmp	eax, 126		; but applications may not write
   517 000006A6 7605                <1> 	jna	write2_registers	; any interrupt registers
   518 000006A8 E9830A0000          <1> 	jmp	guard_ii_authority
   519                              <1> 
   520                              <1> write2_registers:
   521                              <1> ;	mov	edi, eax			; time to free eax
   522                              <1> 
   523                              <1> 	%if	__REGFOR
   524                              <1> 
   525                              <1> 	mov	rdx, qword ptr [rbp+rbx*4]
   526                              <1> 	ror	rdx, 32
   527                              <1> 	mov	qword ptr [rsi+REGISTER+rax*4], rdx
   528                              <1> 	ret 
   529                              <1> 
   530                              <1> 	%else
   531                              <1> 
   532 000006AD 8B4C9D00            <1> 	mov	ecx, dword ptr [rbp+rbx*4]
   533 000006B1 890C86              <1> 	mov	dword ptr [rsi+rax*4], ecx
   534 000006B4 8B4C9D04            <1> 	mov	ecx, dword ptr [rbp+rbx*4+4]
   535 000006B8 894C8604            <1> 	mov	dword ptr [rsi+rax*4++4], ecx
   536 000006BC C3                  <1> 	ret
   537                              <1> 
   538                              <1> 	%endif
   539                              <1> 
   540                              <1> ;	esi -> core.REGISTER
   541                              <1> 
   542                              <1> _operand_write:
   543 000006BD A900FFFF00          <1> 	test	eax, 00FFFF00h
   544 000006C2 751C                <1> 	jnz	bus_write
   545                              <1> 
   546                              <1> _operand_write_register:
   547 000006C4 A980000000          <1> 	test	eax, 80h		; in the interrupt registers?
   548 000006C9 7411                <1> 	jz	write1_register
   549 000006CB F786B0040000000080- <1> 	test	dword ptr [rsi+PSR], 0800000h
   549 000006D4 00                  <1>
   550 000006D5 7505                <1> 	jnz	write1_register
   551 000006D7 E9540A0000          <1> 	jmp	guard_ii_authority
   552                              <1> 
   553                              <1> write1_register:
   554 000006DC 891C86              <1> 	mov	dword ptr [rsi+rax*4], ebx
   555 000006DF C3                  <1> 	ret
   556                              <1> 
   557                              <1> bus_write:				; write any memory
   558                              <1> 					;	eax <- EA
   559                              <1> 					;	ebx <- data | [ ebp + ebx * 4] -> 1st data word
   560                              <1> 					;	cl  <- encoding [ word * 1 / 2 / 4 ] / byte
   561                              <1> 					;	esi <- core
   562                              <1> 
   563 000006E0 E8B3040000          <1> 	call	base_write_pointer	; returns eax <- block
   564                              <1> 					;         edi <- EA
   565                              <1> 					;	  esi <- word offset
   566                              <1> 
   567 000006E5 A900004000          <1> 	test	eax, 00400000h		; big block?
   568 000006EA 7423                <1> 	jz	memory_write_4k_block	; no
   569 000006EC 80F906              <1> 	cmp	cl, 6			; multiword operation?
   570 000006EF 720D                <1> 	jb	bus_write_256k_block	; no
   571                              <1> 
   572 000006F1 81FEFCFF0300        <1> 	cmp	esi, 03FFFCh		; near the edge?
   573 000006F7 7605                <1> 	jna	bus_write_256k_block	; no
   574                              <1> 
   575 000006F9 E806210000          <1> 	call	write_straddle_18b?
   576                              <1> 
   577                              <1> bus_write_256k_block:
   578 000006FE 25FFFF3F00          <1> 	and	eax, 003FFFFFh		; 64-bit shift to page size won't rub off 00400000 bit
   579 00000703 A93F000000          <1> 	test	eax, 63			; a device array?
   580 00000708 7429                <1> 	jz	memory_write_page	; no. scaling shift will scrub bit 400000
   581 0000070A E951030000          <1> 	jmp	_device_write		; yes a device array
   582                              <1> 
   583                              <1> memory_write_4k_block:
   584 0000070F F7C600F00300        <1> 	test	esi, 0003F000h		; inside a 4k page?
   585 00000715 740A                <1> 	jz	memory_write_thru
   586 00000717 B90E000000          <1> 	mov	ecx, LP_ADDRESS
   587 0000071C E9140A0000          <1> 	jmp	guard_ii_escape		; no
   588                              <1> 
   589                              <1> memory_write_thru:
   590 00000721 80F906              <1> 	cmp	cl, 6			; multiword operation?
   591 00000724 720D                <1> 	jb	memory_write_page	; no
   592                              <1> 
   593 00000726 81FEFC0F0000        <1> 	cmp	esi, 0FFCh		; near the edge?
   594 0000072C 7605                <1> 	jna	memory_write_page	; no
   595                              <1> 
   596 0000072E E89C200000          <1> 	call	write_straddle_12b?
   597                              <1> 
   598                              <1> memory_write_page:
   599 00000733 480F7EFF            <1> 	movq	rdi, mm7
   600                              <1> ;	mov	rdi, qword ptr [rbp+CORE_INDEX1]
   601                              <1> 
   602 00000737 3B87D0060000        <1> 	cmp	eax, dword ptr [rdi+IO_PORT+_RAM_THRESHOLD] ; edi -> core registers
   603 0000073D 0F88ED090000        <1> 	js	near guard_ii_authority	; guard the NVRAM whether real or emulated
   604                              <1> 
   605 00000743 48C1E00C            <1> 	shl	rax, 12			; multiply by page and lose bit 00400000
   606 00000747 4801C6              <1> 	add	rsi, rax		; add offset
   607                              <1> 
   608                              <1> ;	mov	ch, byte ptr [edi+PSR]	; field of PSR with byte options
   609 0000074A 48BF-               <1> 	mov	rdi, _memory
   609 0000074C [0000000000000000]  <1>
   610                              <1> 
   611                              <1> memory_write_on:
   612 00000754 488D3CB7            <1> 	lea	rdi, [rdi+rsi*4]
   613                              <1> 
   614 00000758 480F7EFE            <1> 	movq	rsi, mm7
   615                              <1> ;	mov	rsi, qword ptr [ebp+CORE_INDEX1]
   616                              <1> 
   617                              <1> 	%if	1
   618 0000075C 4D21FF              <1> 	and	r15, r15		; is there any touchpoint?
   619 0000075F 7414                <1> 	jz	memory_write_on_go
   620 00000761 4C39FF              <1> 	cmp	rdi, r15		; value of TOUCHPOINT
   621 00000764 780F                <1> 	js	memory_write_on_go	; below range
   622 00000766 483B3C25[00000000]  <1> 	cmp	rdi, qword ptr [_touchpoint2]
   623 0000076E 7905                <1> 	jns	memory_write_on_go	; above range
   624 00000770 E9BB090000          <1> 	jmp	guard_ii_authority
   625                              <1> 
   626                              <1> 	%else
   627                              <1> 
   628                              <1> 	test	dword ptr [_general_indication], TOUCHPOINT
   629                              <1> 	jz	memory_write_on_go
   630                              <1> 
   631                              <1> 	cmp	edi, dword ptr [_touchpoint]
   632                              <1> 	js	memory_write_on_go
   633                              <1> 	cmp	edi, dword ptr [_touchpoint2]
   634                              <1> 	jns	memory_write_on_go
   635                              <1> 	jmp	guard_ii_authority
   636                              <1> 
   637                              <1> 	%endif
   638                              <1> 
   639                              <1> memory_write_on_go:
   640 00000775 480FB6C1            <1> 	movzx	rax, cl
   641 00000779 488B04C5[83070000]  <1> 	mov	rax, qword ptr [write_action+rax*8]
   642 00000781 FFE0                <1> 	jmp	rax
   643                              <1> 
   644                              <1> write_action:
   645 00000783 [C307000000000000]  <1> 	dq	memory_write
   646 0000078B [C807000000000000]  <1> 	dq	write_t1
   647 00000793 [CC07000000000000]  <1> 	dq	write_t2	; or h1
   648 0000079B [D907000000000000]  <1> 	dq	write_t3	; or h2
   649 000007A3 [C707000000000000]  <1> 	dq	just_dont
   650 000007AB [C707000000000000]  <1> 	dq	just_dont
   651 000007B3 [1308000000000000]  <1> 	dq	memory_write2
   652 000007BB [2508000000000000]  <1> 	dq	memory_write4
   653                              <1> 
   654                              <1> memory_write:					; store system memory 1 word
   655                              <1> 
   656                              <1> 	%if	__MOVBE
   657                              <1> 
   658                              <1> 	movbe	dword ptr [rdi], ebx
   659                              <1> 
   660                              <1> 	%else
   661                              <1> 
   662 000007C3 0FCB                <1> 	bswap	ebx
   663 000007C5 891F                <1> 	mov	dword ptr [rdi], ebx
   664                              <1> 
   665                              <1> 	%endif
   666                              <1> 
   667                              <1> just_dont:
   668 000007C7 C3                  <1> 	ret
   669                              <1> 
   670                              <1> write_t1:
   671 000007C8 885F01              <1> 	mov	byte ptr [rdi+1], bl
   672 000007CB C3                  <1> 	ret
   673                              <1> 
   674                              <1> write_t2:
   675 000007CC F686B004000080      <1> 	test	byte ptr [rsi+PSR], HALF_W
   676 000007D3 7511                <1> 	jnz	write_h1
   677 000007D5 885F02              <1> 	mov	byte ptr [rdi+2], bl
   678 000007D8 C3                  <1> 	ret
   679                              <1> 
   680                              <1> write_t3:
   681 000007D9 F686B004000080      <1> 	test	byte ptr [rsi+PSR], HALF_W
   682 000007E0 751A                <1> 	jnz	write_h2
   683 000007E2 885F03              <1> 	mov	byte ptr [rdi+3], bl
   684 000007E5 C3                  <1> 	ret
   685                              <1> 
   686                              <1> write_h1:
   687                              <1> 	%if	__MOVBE
   688                              <1> 	movbe	eax, dword ptr [rdi]
   689                              <1> 	%else
   690 000007E6 8B07                <1> 	mov	eax, dword ptr [rdi]
   691 000007E8 0FC8                <1> 	bswap	eax
   692                              <1> 	%endif
   693                              <1> 
   694 000007EA 81E3FF0F0000        <1> 	and	ebx, 4095
   695 000007F0 C1E30C              <1> 	shl	ebx, 12
   696 000007F3 25FF0F0000          <1> 	and	eax, 4095
   697 000007F8 09D8                <1> 	or	eax, ebx
   698 000007FA EB12                <1> 	jmp	write_hw
   699                              <1> 
   700                              <1> write_h2:
   701                              <1> 	%if	__MOVBE
   702                              <1> 	movbe	eax, dword ptr [rdi]
   703                              <1> 	%else
   704 000007FC 8B07                <1> 	mov	eax, dword ptr [rdi]
   705 000007FE 0FC8                <1> 	bswap	eax
   706                              <1> 	%endif
   707                              <1> 
   708 00000800 C1E80C              <1> 	shr	eax, 12
   709 00000803 C1E00C              <1> 	shl	eax, 12
   710 00000806 81E3FF0F0000        <1> 	and	ebx, 4095
   711 0000080C 09D8                <1> 	or	eax, ebx
   712                              <1> 
   713                              <1> write_hw:
   714                              <1> 	%if	__MOVBE
   715                              <1> 	movbe	dword ptr [rdi], eax
   716                              <1> 	ret
   717                              <1> 
   718                              <1> 	%else
   719                              <1> 
   720 0000080E 0FC8                <1> 	bswap	eax
   721 00000810 8907                <1> 	mov	dword ptr [rdi], eax
   722 00000812 C3                  <1> 	ret
   723                              <1> 
   724                              <1> 	%endif
   725                              <1> 
   726                              <1> 	%if	__MOVBE
   727                              <1> 
   728                              <1> memory_write2:
   729                              <1> 	movbe	qword ptr [rdi], rax
   730                              <1> 	ret	
   731                              <1> 
   732                              <1> memory_write4:
   733                              <1> 	movbe	qword ptr [rdi+2*4], rax
   734                              <1> 	movbe	qword ptr [rdi], rdx
   735                              <1> 	ret
   736                              <1> 
   737                              <1> 	%else
   738                              <1> 
   739                              <1> 					; store system memory 2 words
   740                              <1> memory_write2:				; eax is already free
   741 00000813 8B449D00            <1> 	mov	eax, dword ptr [rbp+rbx*4]
   742 00000817 0FC8                <1> 	bswap	eax
   743 00000819 8907                <1> 	mov	dword ptr [rdi], eax
   744                              <1> 
   745 0000081B 8B449D04            <1> 	mov	eax, dword ptr [rbp+rbx*4+4]
   746 0000081F 0FC8                <1> 	bswap	eax
   747 00000821 894704              <1> 	mov	dword ptr [rdi+4], eax
   748 00000824 C3                  <1> 	ret
   749                              <1> 
   750                              <1> memory_write4:					; store system memory 4 words
   751 00000825 8B449D00            <1> 	mov	eax, dword ptr [rbp+rbx*4]	; bx is a register number and may
   752                              <1> 						; identify extra workspace registers
   753                              <1> 						; at register stack tail
   754 00000829 0FC8                <1> 	bswap	eax
   755 0000082B 8907                <1> 	mov	dword ptr [rdi], eax
   756 0000082D 8B449D04            <1> 	mov	eax, dword ptr [rbp+rbx*4+4]
   757 00000831 0FC8                <1> 	bswap	eax
   758 00000833 894704              <1> 	mov	dword ptr [rdi+4], eax
   759 00000836 8B449D08            <1> 	mov	eax, dword ptr [rbp+rbx*4+8]
   760 0000083A 0FC8                <1> 	bswap	eax
   761 0000083C 894708              <1> 	mov	dword ptr [rdi+2*4], eax
   762 0000083F 8B449D0C            <1> 	mov	eax, dword ptr [rbp+rbx*4+12]
   763 00000843 0FC8                <1> 	bswap	eax
   764 00000845 89470C              <1> 	mov	dword ptr [rdi+3*4], eax
   765 00000848 C3                  <1> 	ret
   766                              <1> 
   767                              <1> ;	modify instructions n inc dec src slc sim popA
   768                              <1> ;	rewrite here
   769                              <1> 
   770                              <1> 	%endif
   771                              <1> 
   772                              <1> memoreg_writeback:
   773                              <1> 	%if	1
   774 00000849 4821FF              <1> 	and	rdi, rdi
   775 0000084C 7509                <1> 	jnz	memory_direct
   776 0000084E 25FFFFFF00          <1> 	and	eax, 00FFFFFFh			; unchanged esi -> core.REGISTER	
   777 00000853 89049E              <1> 	mov	[rsi+rbx*4+REGISTER], eax	; platform endian
   778                              <1> 						; register writeback index ebx ->
   779 00000856 C3                  <1> 	ret
   780                              <1> 	%else
   781                              <1> 
   782                              <1> 
   783                              <1> 	test	ebx, -256			; save EA is ?
   784                              <1> 	jnz	memory_direct			; a memory device
   785                              <1> 	xchg	eax, ebx			; a register
   786                              <1> 	and	ebx, 00FFFFFFh
   787                              <1> 	jmp	_operand_write_register		; esi -> core.REGISTER
   788                              <1> 
   789                              <1> ;	if not a register rewrite
   790                              <1> ;	n inc dec src slc sim popA
   791                              <1> ;	write RTA memory at its saved platform address
   792                              <1> 	%endif
   793                              <1> 
   794                              <1> memory_direct:					; esi <- memory_offset
   795                              <1> 	%if	__MOVBE
   796                              <1> 	movbe	dword ptr [rdi+rsi*4], eax
   797                              <1> 	%else
   798 00000857 0FC8                <1> 	bswap	eax				; write components edi esi kept from base_read
   799 00000859 30C0                <1> 	xor	al, al				
   800 0000085B 8904B7              <1> 	mov	dword ptr [rdi+rsi*4], eax
   801                              <1> 	%endif
   802 0000085E C3                  <1> 	ret
   803                              <1> 
   804                              <1> 
   805                              <1> ;	execute calls memory read
   806                              <1> ;	ea < 256 is not for execute a register
   807                              <1> ;	operand is at a readable address in system memory or array
   808                              <1> 
   809                              <1> memory_read:					; for execute and modify instructions:
   810 0000085F E872000000          <1> 	call	memory_point			; read only executable space
   811                              <1> 	%if	__MOVBE
   812                              <1> 	movbe	eax, dword ptr [rdi+rsi*4]
   813                              <1> 	%else
   814 00000864 8B04B7              <1> 	mov	eax, dword ptr [rdi+rsi*4]	; and similar memory types
   815 00000867 B000                <1> 	mov	al, 0
   816 00000869 0FC8                <1> 	bswap	eax
   817                              <1> 	%endif
   818 0000086B C3                  <1> 	ret
   819                              <1> 
   820                              <1> ;	modify instructions n inc dec src slc sim popA call here
   821                              <1> ;	ea < 256 is a register
   822                              <1> 
   823                              <1> memoreg:					; read-modify-write registers / system memory
   824 0000086C A900FFFFFF          <1> 	test	eax, -256			; but nothing marked as a peripheral bus
   825 00000871 751B                <1> 	jnz	memory_read_lock
   826 00000873 A880                <1> 	test	al, 128				; interrupt register?
   827 00000875 740E                <1> 	jz	register_read_for_write		; no, clear to update
   828 00000877 F686B204000080      <1> 	test	byte ptr [rsi+PSR+2], 128	; ISR ?
   829 0000087E 7505                <1> 	jnz	register_read_for_write
   830 00000880 E9AB080000          <1> 	jmp	guard_ii_authority
   831                              <1> 
   832                              <1> register_read_for_write:			; unchanged esi -> core.REGISTER
   833 00000885 89C3                <1>         mov     ebx, eax                        ; copy of ea -> registers to memoreg_writeback
   834 00000887 4831FF              <1>         xor     rdi, rdi                        ; tell memoreg->writeback that's how it is, no device
   835 0000088A 8B0486              <1>         mov     eax, dword ptr [rsi+REGISTER+rax*4]
   836 0000088D C3                  <1>         ret					; register writeback index ebx ->
   837                              <1> 
   838                              <1> 
   839                              <1> ;	RAM boundary in port 124 defines the upper page limit
   840                              <1> ;	of a real or emulated NVRAM containing the fixed system image
   841                              <1> 
   842                              <1> ;	fixed system image may be kernel + loader in a dozen pages
   843                              <1> ;	or it may be the entire application
   844                              <1> 
   845                              <1> ;	emulated machine applies the update limit
   846                              <1> ;	whether NVRAM is emulated or real
   847                              <1> 
   848                              <1> ;	if not a register
   849                              <1> ;	n inc dec src slc sim popA read a memory word which is legal to write
   850                              <1> ;	and keep the platform address to write the modified value
   851                              <1> ;	modify instructions do not lock memory between read and rewrite
   852                              <1> 
   853                              <1> memory_read_lock:
   854 0000088E E808000000          <1> 	call	memory_lock
   855                              <1> 	%if	__MOVBE
   856                              <1> 	movbe	eax, dword ptr [rdi+rsi*4]
   857                              <1> 	%else
   858 00000893 8B04B7              <1> 	mov	eax, dword ptr [rdi+rsi*4]
   859 00000896 B000                <1> 	mov	al, 0
   860 00000898 0FC8                <1> 	bswap	eax
   861                              <1> 	%endif
   862 0000089A C3                  <1> 	ret
   863                              <1> 
   864                              <1> ;	memory_read_lock calls here for modify instructions if ea > registers
   865                              <1> ;	ts calls here with ea whatever range always -> memory
   866                              <1> 
   867                              <1> ;	ea must be a legally writable memory word
   868                              <1> ;	memory_lock does not lock but identifies a platform write address  
   869                              <1> ;	ts reads / unconditionally replaces word.t1
   870                              <1> ;	under platform locking protocol, xchg platform instruction
   871                              <1> 
   872                              <1> memory_lock:					; point for update
   873                              <1> 						; barred below RAM boundary as write is
   874 0000089B E8F8020000          <1> 	call	base_write_pointer		; resolve device:block:offset from EA
   875                              <1> 						; edi <- core.REGISTERS <- esi
   876                              <1> 						; eax <- memory block index
   877                              <1> 						; esi <- memory word offset
   878 000008A0 480F7EFF            <1> 	movq	rdi, mm7
   879                              <1> ;	mov	rdi, qword ptr [rbp+CORE_INDEX1]
   880                              <1> 
   881 000008A4 A900004000          <1> 	test	eax, 00400000h			; update block name is a big bank ?
   882 000008A9 741E                <1> 	jz	memory_lock_page		; no
   883                              <1> 
   884 000008AB 25FFFF3F00          <1> 	and	eax, 003FFFFFh			; 64-bit shift won't rub off 00400000 bit
   885                              <1> 						; on shift to page size
   886                              <1> 
   887 000008B0 A93F000000          <1> 	test	eax, 63				; a device outside executable space ?
   888 000008B5 7557                <1> 	jnz	_yspace_read			; yes
   889 000008B7 25FFFF3F00          <1> 	and	eax, 003FFFFFh			; bit 0400000 is gets stripped later anyway
   890 000008BC 3B87D0060000        <1> 	cmp	eax, dword ptr [rdi+IO_PORT+_RAM_THRESHOLD]	; below RAM boundary?
   891 000008C2 733E                <1> 	jnb	_xspace_read			; no, go ahead
   892 000008C4 E967080000          <1> 	jmp	guard_ii_authority
   893                              <1> 
   894                              <1> memory_lock_page:
   895 000008C9 3B87D0060000        <1> 	cmp	eax, dword ptr [rdi+IO_PORT+_RAM_THRESHOLD]	; below RAM boundary?
   896 000008CF 731F                <1> 	jnb	_xspace_read4K			; no, go head if offset < 1000 hex
   897 000008D1 E95A080000          <1> 	jmp	guard_ii_authority
   898                              <1> 
   899                              <1> 
   900                              <1> ;	memory_read calls here for execute
   901                              <1> ;	identify a platform read address of an RTA memory word
   902                              <1> 
   903                              <1> memory_point:
   904 000008D6 E86B020000          <1> 	call	base_read_pointer		; edi <- core.REGISTERS <- esi
   905                              <1> 						; esi <- word offset in memory block
   906 000008DB A900004000          <1> 	test	eax, 00400000h			; eax <- page index
   907 000008E0 740E                <1> 	jz	_xspace_read4K
   908                              <1> 
   909 000008E2 25FFFF3F00          <1> 	and	eax, 003FFFFFh			; 64-bit shift won't rub off 00400000 bit
   910                              <1> 						; on shift to page size
   911 000008E7 A93F000000          <1> 	test	eax, 63
   912 000008EC 7414                <1> 	jz	_xspace_read
   913 000008EE EB1E                <1> 	jmp	_yspace_read			; ie a device either appropriate or not
   914                              <1> 
   915                              <1> _xspace_read4K:
   916 000008F0 F7C600F00300        <1> 	test	esi, 003F000h
   917 000008F6 740A                <1> 	jz	_xspace_read
   918 000008F8 B90E000000          <1> 	mov	ecx, LP_ADDRESS
   919 000008FD E933080000          <1> 	jmp	guard_ii_escape
   920                              <1> 
   921                              <1> _xspace_read:					; must be a read in a sysmem-like device
   922 00000902 48BF-               <1> 	mov	rdi, _memory
   922 00000904 [0000000000000000]  <1>
   923 0000090C EB39                <1> 	jmp	_memory_deliver			; device array zero
   924                              <1> 
   925                              <1> _yspace_read:
   926 0000090E A900008000          <1> 	test	eax, 00800000h			; a tripsy non-space?
   927 00000913 753A                <1> 	jnz	_zspace_read			; not allowed
   928                              <1> 
   929 00000915 4889C7              <1> 	mov	rdi, rax
   930 00000918 4883E73F            <1> 	and	rdi, 63
   931 0000091C 8BBCBEE0060000      <1> 	mov	edi, dword ptr [rsi+IO_PORT+_DEVICE+rdi*4]
   932 00000923 F7C700008000        <1> 	test	edi, SYSMEM_FLAG		; _DEVICE are 32-bit descriptors
   933 00000929 7424                <1> 	jz	_zspace_read
   934 0000092B F7C700004000        <1> 	test	edi, DATA16_FLAG
   935 00000931 751C                <1> 	jnz	_zspace_read
   936                              <1> 
   937 00000933 C1E002              <1> 	shl	eax, 2				; al = 4 * device index
   938 00000936 480FB6F8            <1> 	movzx	rdi, al
   939                              <1> 
   940 0000093A 488BBC3F[00000000]  <1> 	mov	rdi, qword ptr [_devices+rdi*2]	; _devices are 64-bit pointers
   941 00000942 30C0                <1> 	xor	al, al				; necessary to lose the device bits now
   942 00000944 C1E802              <1> 	shr	eax, 2				; eax = bank * 64 = page in 28 bits
   943                              <1> _memory_deliver:
   944 00000947 48C1E00C            <1> 	shl	rax, 12				; multiply by page
   945 0000094B 4801C6              <1> 	add	rsi, rax			; bit 00400000 aleady removed
   946                              <1> 
   947                              <1> 	%if	__SMP
   948                              <1> 	%else
   949                              <1> 	mov	eax, dword ptr [edi+esi*4]
   950                              <1> 	bswap	eax
   951                              <1> 	%endif
   952 0000094E C3                  <1> 	ret
   953                              <1> 
   954                              <1> _zspace_read:
   955 0000094F E9DC070000          <1> 	jmp	guard_ii_authority
   956                              <1> 
   957                              <1> 
   958                              <1> ;	sub-architectural measure on sabr and reload instructions
   959                              <1> 
   960                              <1> ;	check the target memory block is in range and the bus characteristic
   961                              <1> ;	of the memory device when selecting blocks of memory, not when
   962                              <1> ;	accessing them. Use 8 spare bits in the word containing _base[]
   963                              <1> ;	for a quick recall of the emulated bus attribute on reference
   964                              <1> 
   965                              <1> ;	because this software emulation needs to act differently for
   966                              <1> 
   967                              <1> ;		executable space	rta1 24-bit words canonical memory
   968                              <1> ;					modeled in platform 32-bit words
   969                              <1> 
   970                              <1> ;		shared network buffers	16-bit words canonical in memory
   971                              <1> ;					and zero extend on readout to RTA1
   972                              <1> 
   973                              <1> ;		24-bit filestore array	3-octet words stored big-endian
   974                              <1> ;					in packed array
   975                              <1> 
   976                              <1> ;	concept RTA1 device arrays with bus behaviour differences are completely
   977                              <1> ;	emulated on PC emulations because device arrays are modeled in PC RAM.
   978                              <1> 
   979                              <1> ;	Various bus behaviours are emulated transparently to RTA1 target software
   980                              <1> ;	in anticipation	that different memories for different uses may be attached
   981                              <1> ;	on product boards, making core-emulated RTA1s much more efficient for not
   982                              <1> ;	needing this part of emulation
   983                              <1> 
   984                              <1> ;	devices
   985                              <1> 
   986                              <1> ;	device 0 is always executable space, but there may be more devices
   987                              <1> ;	with bus characteristics like device 0. The device descriptors are
   988                              <1> 
   989                              <1> ;		_________________________________________________________________
   990                              <1> ;		| 16 bits flags	| 16 bits banks	|       32 bits pointer		|
   991                              <1> ;		|_______________|____high index_|_______________________________|
   992                              <1> 
   993                              <1> 
   994                              <1> ;	[out]	sabr	[go]	[call]	reload instructions call here
   995                              <1> ;	go and call can probably check quicker themself
   996                              <1> ;	out can be trusted because applications don't out memory _base[] ports
   997                              <1> 
   998                              <1> ;	a big block in an RTA1 address window is 262144 words.
   999                              <1> ;	this checking concerns address windows tagged 2..63
  1000                              <1> ;	a device is an array up to 65536 big blocks or banks
  1001                              <1> 
  1002                              <1> ;	you get here with the relocation handle in ebx
  1003                              <1> ;	and the target window tag in eax, because that is the EA of a sabr instruction
  1004                              <1> 
  1005                              <1> device_read:				; readout device arrays
  1006 00000954 A900008000          <1>         test    eax, 0800000h           ; the vilainous bank index?
  1007 00000959 753C                <1>         jnz     device_read_escape
  1008                              <1> 
  1009                              <1> 					; edi -> core.REGISTER
  1010 0000095B 48C1E002            <1> 	shl	rax, 2			; al is device index * 4
  1011 0000095F 50                  <1> 	push	rax			; rest of eax is block index * 4
  1012 00000960 480FB6C0            <1> 	movzx	rax, al			; extend device number
  1013                              <1> 					; sense device descriptor
  1014 00000964 480F7EFF            <1> 	movq	rdi, mm7
  1015                              <1> ;	mov	rdi, qword ptr [rbp+CORE_INDEX1]
  1016 00000968 F68438E2060000C0    <1> 	test	byte ptr [rdi+rax+IO_PORT+_DEVICE+2], 192
  1017                              <1> 
  1018 00000970 58                  <1> 	pop	rax			; recover storage block index
  1019                              <1> 
  1020 00000971 7424                <1> 	jz	device_read_escape	; neither type flag set
  1021                              <1> 
  1022 00000973 9C                  <1> 	pushfq				; sign is set for descriptor bit 23	
  1023                              <1> 					; parity is set if both bits are
  1024                              <1> 
  1025                              <1> ;	mov	ch, byte ptr [rdi+PSR]	; flag field with byte options for memory read
  1026 00000974 480FB6F8            <1> 	movzx	rdi, al			; device select
  1027                              <1> 
  1028 00000978 30C0                <1> 	xor	al, al			; add storage block to offset
  1029 0000097A C1E008              <1> 	shl	eax, 8			; brush of bit 00400000 (now bit 01000000)
  1030 0000097D 48C1E002            <1> 	shl	rax, 10-8		; block index * 64 * 4 now times 262144
  1031 00000981 4801C6              <1> 	add	rsi, rax		; offset += <-
  1032                              <1> 
  1033                              <1> 
  1034 00000984 488BBC3F[00000000]  <1> 	mov	rdi,  qword ptr [_devices+rdi*2]	; rdi = device id * 4
  1035                              <1> 							; pointers in array are * 8 bytes
  1036                              <1> 
  1037                              <1> 					; known that one or two bits is set
  1038 0000098C 58                  <1> 	pop	rax			; flags from test of device	
  1039                              <1> 
  1040 0000098D A804                <1> 	test	al, 4			; parity flag?
  1041 0000098F 7560                <1> 	jnz	device_read_array24	; parity -> 2 bits set -> FSYS24 bus
  1042                              <1> 
  1043 00000991 A880                <1> 	test	al, 128			; sign -> descriptor bit 23 -> SYSMEM
  1044 00000993 7411                <1> 	jz	device_read_data16	; otherwise NET16 trunk
  1045 00000995 EB0A                <1> 	jmp	device_read_sysmem	; system memory type if yes				
  1046                              <1> 
  1047                              <1> device_read_escape:
  1048 00000997 B90E000000          <1> 	mov	ecx, LP_ADDRESS
  1049 0000099C E994070000          <1> 	jmp	guard_ii_escape
  1050                              <1> 
  1051                              <1> 
  1052                              <1> device_read_sysmem:			; readout system memory array
  1053 000009A1 E9CEFBFFFF          <1> 	jmp	memory_read_on		; allow all variations partial word / multiword
  1054                              <1> 
  1055                              <1> device_read_data16:			; readout 16-bit array
  1056                              <1> 
  1057 000009A6 80F907              <1> 	cmp	cl, 7
  1058 000009A9 7419                <1> 	jz	device_read_data16_4
  1059 000009AB 80F906              <1> 	cmp	cl, 6
  1060 000009AE 7407                <1> 	jz	device_read_data16_2
  1061                              <1> ;	jmp	device_read_data16_1
  1062                              <1> 
  1063                              <1> device_read_data16_1:			; readout 1 word of 16-bit array
  1064 000009B0 0FB70477            <1> 	movzx	eax, word ptr [rdi+rsi*2]
  1065 000009B4 86E0                <1> 	xchg	ah, al
  1066 000009B6 C3                  <1> 	ret
  1067                              <1> 
  1068                              <1> device_read_data16_2:			; readout 2 words of 16-bit array
  1069 000009B7 8B0477              <1> 	mov	eax, dword ptr [rdi+rsi*2]	; 4.3.2.1
  1070 000009BA 0FC8                <1> 	bswap	eax				; 1.2.3.4
  1071 000009BC 480FB7D8            <1> 	movzx	rbx, ax				; 0.0.3.4
  1072 000009C0 C1E810              <1> 	shr	eax, 16				; 0.0.1.2
  1073 000009C3 C3                  <1> 	ret
  1074                              <1> 
  1075                              <1> device_read_data16_4:			; readout 4 words of 16-bit array
  1076 000009C4 488B0477            <1> 	mov	rax, qword ptr [rdi+rsi*2]
  1077 000009C8 480FC8              <1> 	bswap	rax				; 1.2.3.4
  1078 000009CB 0FB7C8              <1> 	movzx	ecx, ax
  1079 000009CE 894C9D0C            <1> 	mov	dword ptr [rbp+rbx*4+12], ecx
  1080 000009D2 48C1E810            <1> 	shr	rax, 16
  1081 000009D6 0FB7C8              <1> 	movzx	ecx, ax
  1082 000009D9 894C9D08            <1> 	mov	dword ptr [rbp+rbx*4+8], ecx
  1083 000009DD 48C1E810            <1> 	shr	rax, 16
  1084 000009E1 0FB7C8              <1> 	movzx	ecx, ax
  1085 000009E4 48C1E810            <1> 	shr	rax, 16
  1086 000009E8 894C9D04            <1> 	mov	dword ptr [rbp+rbx*4+4], ecx
  1087 000009EC 89449D00            <1> 	mov	dword ptr [rbp+rbx*4], eax
  1088 000009F0 C3                  <1> 	ret
  1089                              <1> 
  1090                              <1> device_read_array24:			; readout from packed 24-bit array
  1091 000009F1 E846010000          <1> 	call	device_array24_setpointer
  1092                              <1> 
  1093 000009F6 80F907              <1> 	cmp	cl, 7
  1094 000009F9 7440                <1> 	jz	device_read_array24_4
  1095 000009FB 80F906              <1> 	cmp	cl, 6
  1096 000009FE 7430                <1> 	jz	device_read_array24_2
  1097                              <1> ;	jmp	device_read_array24_1
  1098                              <1> 
  1099                              <1> device_read_array24_1:			; readout a word of packed 24-bit array
  1100 00000A00 660FB60437          <1> 	movzx	ax, byte ptr [rdi+rsi]
  1101 00000A05 C1E008              <1> 	shl	eax, 8
  1102 00000A08 8A443701            <1> 	mov	al, byte ptr [rdi+rsi+1]
  1103 00000A0C C1E008              <1> 	shl	eax, 8
  1104 00000A0F 8A443702            <1> 	mov	al, byte ptr [rdi+rsi+2]
  1105 00000A13 4883C603            <1> 	add	rsi, 3
  1106 00000A17 C3                  <1> 	ret
  1107                              <1> 
  1108                              <1> device_read_array24_1R:
  1109 00000A18 660FB61C37          <1> 	movzx	bx, byte ptr [rdi+rsi]
  1110 00000A1D C1E308              <1> 	shl	ebx, 8
  1111 00000A20 8A5C3701            <1> 	mov	bl, byte ptr [rdi+rsi+1]
  1112 00000A24 C1E308              <1> 	shl	ebx, 8
  1113 00000A27 8A5C3702            <1> 	mov	bl, byte ptr [rdi+rsi+2]
  1114 00000A2B 4883C603            <1> 	add	rsi, 3
  1115 00000A2F C3                  <1> 	ret
  1116                              <1> 
  1117                              <1> device_read_array24_2:			; readout 2 words of packed 24-bit array
  1118 00000A30 E8CBFFFFFF          <1> 	call	device_read_array24_1
  1119 00000A35 E8DEFFFFFF          <1> 	call	device_read_array24_1R
  1120 00000A3A C3                  <1> 	ret
  1121                              <1> 
  1122                              <1> device_read_array24_4:			; readout 4 words of packed 24-bit array
  1123 00000A3B E8C0FFFFFF          <1> 	call	device_read_array24_1
  1124 00000A40 89449D00            <1> 	mov	dword ptr [rbp+rbx*4], eax
  1125 00000A44 E8B7FFFFFF          <1> 	call	device_read_array24_1
  1126 00000A49 89449D04            <1> 	mov	dword ptr [rbp+rbx*4+4], eax
  1127 00000A4D E8AEFFFFFF          <1> 	call	device_read_array24_1
  1128 00000A52 89449D08            <1> 	mov	dword ptr [rbp+rbx*4+8], eax
  1129 00000A56 E8A5FFFFFF          <1> 	call	device_read_array24_1
  1130 00000A5B 89449D0C            <1> 	mov	dword ptr [rbp+rbx*4+12], eax
  1131 00000A5F C3                  <1> 	ret
  1132                              <1> 
  1133                              <1> _device_write:				; store device arrays
  1134 00000A60 A900008000          <1> 	test	eax, 0800000h		; the vilainous bank index?
  1135 00000A65 7542                <1> 	jnz	device_write_escape
  1136                              <1> 
  1137                              <1>                                         ; edi -> core.REGISTER
  1138 00000A67 48C1E002            <1>         shl     rax, 2                  ; al is device index * 4
  1139 00000A6B 50                  <1>         push    rax                     ; rest of eax is block index * 4
  1140 00000A6C 480FB6C0            <1>         movzx   rax, al                 ; extend device number
  1141                              <1>                                         ; sense device descriptor
  1142 00000A70 480F7EFF            <1> 	movq	rdi, mm7
  1143                              <1> ;	mov	rdi, qword ptr [rbp+CORE_INDEX1]
  1144 00000A74 F68438E2060000C0    <1>         test    byte ptr [rdi+rax+IO_PORT+_DEVICE+2], 192
  1145                              <1> 
  1146 00000A7C 58                  <1>         pop     rax                     ; recover storage block index
  1147                              <1> 
  1148 00000A7D 742A                <1>         jz      device_write_escape      ; neither type flag set
  1149                              <1> 
  1150 00000A7F 9C                  <1>         pushfq                          ; sign is set for descriptor bit 23     
  1151                              <1>                                         ; parity is set if both bits are
  1152                              <1> 
  1153 00000A80 8AAFB0040000        <1>         mov     ch, byte ptr [rdi+PSR]  ; flag field with byte options for memory read
  1154 00000A86 480FB6F8            <1>         movzx   rdi, al                 ; device select
  1155                              <1> 
  1156 00000A8A 30C0                <1>         xor     al, al                  ; add storage block to offset
  1157 00000A8C C1E008              <1> 	shl	eax, 8			; brush off bit 00400000 (now bit 01000000)
  1158 00000A8F 48C1E002            <1>         shl     rax, 10-8		; block index * 64 * 4 now times 262144
  1159 00000A93 4801C6              <1>         add     rsi, rax                ; offset += <-
  1160                              <1> 
  1161 00000A96 488BBC3F[00000000]  <1>         mov     rdi,  qword ptr [_devices+rdi*2]	; rdi = device id * 4
  1162                              <1> 							; pointers in array are * 8 octets
  1163                              <1> 
  1164                              <1>                                         ; known that one or two bits is set
  1165 00000A9E 58                  <1>         pop     rax                     ; flags from test of device     
  1166                              <1> 
  1167 00000A9F A804                <1>         test    al, 4                   ; parity?
  1168 00000AA1 754C                <1>         jnz     device_write_array24    ; parity -> 2 bits set -> FSYS24 bus
  1169 00000AA3 A880                <1>         test    al, 128                 ; sign -> descriptor bit 23 -> SYSMEM
  1170 00000AA5 7411                <1>         jz      device_write_data16     ; otherwise NET16 trunk
  1171 00000AA7 EB0A                <1>         jmp     device_write_sysmem     ; system memory type if yes                     
  1172                              <1> 
  1173                              <1> 
  1174                              <1> device_write_escape:
  1175 00000AA9 B90E000000          <1> 	mov	ecx, LP_ADDRESS
  1176 00000AAE E982060000          <1> 	jmp	guard_ii_escape
  1177                              <1> 
  1178                              <1> 
  1179                              <1> device_write_sysmem:
  1180 00000AB3 E99CFCFFFF          <1> 	jmp	memory_write_on		; allow all variations partial word / multiword
  1181                              <1> 
  1182                              <1> 
  1183                              <1> device_write_data16:
  1184                              <1> 
  1185 00000AB8 80F907              <1> 	cmp	cl, 7
  1186 00000ABB 740C                <1> 	jz	device_write_data16_4
  1187 00000ABD 80F906              <1> 	cmp	cl, 6
  1188 00000AC0 741A                <1> 	jz	device_write_data16_2
  1189                              <1> ;	jmp	device_write_data16_1
  1190                              <1> 
  1191                              <1> 	%if	__MOVBE
  1192                              <1> 
  1193                              <1> 	movbe	word ptr [rdi+rsi*2], bx
  1194                              <1> 	ret
  1195                              <1> 
  1196                              <1> device_write_data16_2:
  1197                              <1> 	mov	ax, word ptr [rbp+rbx*4]
  1198                              <1> 	shl	eax, 16
  1199                              <1> 	mov	ax, word ptr [rbp+rbx*4+4]
  1200                              <1> 	movbe	dword ptr [rdi+rsi*2], ax
  1201                              <1> 	
  1202                              <1> 	ret
  1203                              <1> 
  1204                              <1> device_write_data16_4:
  1205                              <1> 	mov	ax, word ptr [rbp+rbx*4]
  1206                              <1> 	shl	rax, 16
  1207                              <1> 	mov	ax, word ptr [rbp+rbx*4+4]
  1208                              <1> 	shl	rax, 16
  1209                              <1> 	mov	ax, word ptr [rbp+rbx*4+4*2]
  1210                              <1> 	shl	rax, 16
  1211                              <1> 	mov	ax, word ptr [rbp+rbx*4+4*3]
  1212                              <1> 	movbe	qword ptr [rdi+rsi*2], rax
  1213                              <1> 	ret
  1214                              <1> 
  1215                              <1> 	%else
  1216                              <1> 
  1217                              <1> device_write_data16_1:			; store 16-bit array
  1218 00000AC2 86FB                <1> 	xchg	bh, bl
  1219 00000AC4 66891C77            <1> 	mov	word ptr [rdi+rsi*2], bx
  1220 00000AC8 C3                  <1> 	ret
  1221                              <1> 
  1222                              <1> 
  1223                              <1> device_write_data16_4:			; store 4 words in 16-bit array
  1224                              <1> 					; low-order half is swapped on bus read
  1225                              <1> 					; and canonical in eax
  1226 00000AC9 668B449D08          <1> 	mov	ax, word ptr [rbp+rbx*4+8]	; get low-order half 3rd register
  1227 00000ACE C1E010              <1> 	shl	eax, 16				; 5.6.0.0
  1228 00000AD1 668B449D0C          <1> 	mov	ax, word ptr [rbp+rbx*4+12]	; 5.6.7.8
  1229 00000AD6 0FC8                <1> 	bswap	eax				; it's correct so swap for bus write
  1230 00000AD8 89447704            <1> 	mov	dword ptr [rdi+rsi*2+4], eax
  1231                              <1> 
  1232                              <1> 
  1233                              <1> device_write_data16_2:			; store 2 words in 16-bit array
  1234                              <1> 					; registers are modeled in storage
  1235                              <1> 					; so each bus read corrects an octet pair
  1236                              <1> 
  1237 00000ADC 668B449D00          <1> 	mov	ax, word ptr [rbp+rbx*4]	; get low-order half 1st register
  1238 00000AE1 C1E010              <1> 	shl	eax, 16				; 1.2.0.0
  1239 00000AE4 668B449D04          <1> 	mov	ax, word ptr [rbp+rbx*4+4]	; 1.2.3.4
  1240 00000AE9 0FC8                <1> 	bswap	eax				; it's correct, so swap for bus write
  1241 00000AEB 890477              <1> 	mov	dword ptr [rdi+rsi*2], eax
  1242 00000AEE C3                  <1> 	ret
  1243                              <1> 
  1244                              <1> 	%endif
  1245                              <1> 
  1246                              <1> device_write_array24:			; store 24-bit packed array
  1247 00000AEF E848000000          <1> 	call	device_array24_setpointer
  1248                              <1> 
  1249 00000AF4 80F907              <1> 	cmp	cl, 7
  1250 00000AF7 7435                <1> 	jz	device_write_array24_4
  1251 00000AF9 80F906              <1> 	cmp	cl, 6
  1252 00000AFC 741D                <1> 	jz	device_write_array24_2
  1253 00000AFE EB00                <1> 	jmp	device_write_array24_1
  1254                              <1> 
  1255                              <1> device_write_array24_1:			; store 1 word in packed 24-bit array
  1256 00000B00 89D8                <1> 	mov	eax, ebx
  1257                              <1> device_write_array24_x:
  1258 00000B02 C1C010              <1> 	rol	eax, 16
  1259 00000B05 880437              <1> 	mov	byte ptr [rdi+rsi], al
  1260 00000B08 C1C008              <1> 	rol	eax, 8
  1261 00000B0B 88443701            <1> 	mov	byte ptr [rdi+rsi+1], al
  1262 00000B0F C1C008              <1> 	rol	eax, 8
  1263 00000B12 88443702            <1> 	mov	byte ptr [rdi+rsi+2], al
  1264 00000B16 4883C603            <1> 	add	rsi, 3
  1265 00000B1A C3                  <1> 	ret
  1266                              <1> 
  1267                              <1> device_write_array24_2:			; store 2 words in packed 24-bit array
  1268 00000B1B 8B449D00            <1> 	mov	eax, [rbp+rbx*4]
  1269 00000B1F E8DEFFFFFF          <1> 	call	device_write_array24_x
  1270 00000B24 8B449D04            <1> 	mov	eax, [rbp+rbx*4+4]
  1271 00000B28 E8D5FFFFFF          <1> 	call	device_write_array24_x
  1272                              <1> ;	add	ebx, 2
  1273 00000B2D C3                  <1> 	ret
  1274                              <1> 
  1275                              <1> device_write_array24_4:			; store 4 words in packed 24-bit array
  1276 00000B2E E8E8FFFFFF          <1> 	call	device_write_array24_2
  1277 00000B33 83C302              <1> 	add	ebx, 2
  1278 00000B36 E8E0FFFFFF          <1> 	call	device_write_array24_2
  1279 00000B3B C3                  <1> 	ret
  1280                              <1> 
  1281                              <1> device_array24_setpointer:
  1282 00000B3C 4889F0              <1> 	mov	rax, rsi			; think of a number
  1283 00000B3F 48D1E0              <1> 	shl	rax, 1				; double it
  1284 00000B42 4801C6              <1> 	add	rsi, rax			; add it to the number you first thought of...
  1285 00000B45 C3                  <1> 	ret
  1286                              <1> 
    32                                  	%include	"base_map.msm"
     1                              <1> 
     2                              <1> base_read_pointer:
     3 00000B46 4889C7              <1> 	mov	rdi, rax		; keep EA for +words reads
     4                              <1> 					; straddling storage blocks
     5 00000B49 C1C910              <1> 	ror	ecx, 16			; conserve designator / word counts
     6                              <1> 
     7 00000B4C C1C812              <1> 	ror	eax, 18
     8 00000B4F A83F                <1> 	test	al, 63
     9 00000B51 750C                <1> 	jnz	read_address18
    10 00000B53 C1C006              <1> 	rol	eax, 6
    11 00000B56 660FB6C8            <1> 	movzx	cx, al
    12 00000B5A C1E814              <1> 	shr	eax, 32-12
    13                              <1> 					; advise caller address 6.12
    14 00000B5D EB07                <1> 	jmp	resolve_read_tag	; this path is  most storage reads
    15                              <1> 	
    16                              <1> read_address18:
    17 00000B5F 660FB6C8            <1> 	movzx	cx, al
    18 00000B63 C1E80E              <1> 	shr	eax, 32-18
    19                              <1> 
    20                              <1> resolve_read_tag:
    21                              <1> 
    22 00000B66 80E13F              <1> 	and	cl, 63
    23 00000B69 7418                <1> 	jz	read_window_free	; everyone may read B0
    24 00000B6B F6C138              <1> 	test	cl, 56
    25 00000B6E 7513                <1> 	jnz	read_window_free
    26 00000B70 80F10F              <1> 	xor	cl, 8+7			; [ 1 2 3 4 5 6 7 ] -> 8 + [ 6 5 4 3 2 1 0]
    27 00000B73 660FA38EB0040000    <1> 	bt	word ptr [rsi+PSR], cx	; in memory bytes ffff f00c 0xxx xxxx
    28 00000B7B 7303                <1> 	jnc	read_application_window	; x86 bus read -> 0xxx xxxx ffff f00c
    29 00000B7D 80C940              <1> 	or	cl, 64
    30                              <1> 
    31                              <1> read_application_window:
    32 00000B80 80F10F              <1> 	xor	cl, 8+7			; [ 1 2 3 4 5 6 7 ] <- 8 + [ 6 5 4 3 2 1 0]
    33                              <1> 
    34                              <1> read_window_free:
    35 00000B83 4889C2              <1> 	mov	rdx,rax
    36 00000B86 480FB6C1            <1> 	movzx	rax, cl
    37 00000B8A 8B8486E0040000      <1> 	mov	eax, dword ptr [rsi+rax*4+IO_PORT]
    38 00000B91 4889D6              <1> 	mov	rsi, rdx
    39                              <1> 
    40 00000B94 C1C910              <1> 	ror	ecx, 16
    41 00000B97 C3                  <1> 	ret
    42                              <1> 
    43                              <1> base_write_pointer:
    44                              <1> 
    45 00000B98 4889C7              <1> 	mov	rdi, rax		; keep EA for +words writes
    46 00000B9B C1C910              <1> 	ror	ecx, 16			; straddling storage blocks
    47                              <1> 					; protect designators in ecx
    48 00000B9E C1C812              <1> 	ror	eax, 18			
    49                              <1> 
    50 00000BA1 A83F                <1> 	test	al, 63
    51 00000BA3 750C                <1> 	jnz	write_address18
    52 00000BA5 C1C006              <1> 	rol	eax, 6
    53 00000BA8 660FB6C8            <1> 	movzx	cx, al
    54 00000BAC C1E814              <1> 	shr	eax, 32-12
    55 00000BAF EB07                <1> 	jmp	resolve_write_tag	; this path is
    56                              <1> 					; most storge writes
    57                              <1> write_address18:
    58 00000BB1 660FB6C8            <1> 	movzx	cx, al
    59 00000BB5 C1E80E              <1> 	shr	eax, 32-18
    60                              <1> 	
    61                              <1> resolve_write_tag:
    62                              <1> 
    63 00000BB8 80E13F              <1> 	and	cl, 63
    64 00000BBB 0F846F050000        <1> 	jz	near guard_ii_authority	; no-one may write B0
    65 00000BC1 F6C138              <1> 	test	cl, 56
    66 00000BC4 7538                <1> 	jnz	write_window_free
    67 00000BC6 80F10F              <1> 	xor	cl, 8+7			; [ 1 2 3 4 5 6 7 ] -> 8 + [ 6 5 4 3 2 1 0]
    68 00000BC9 660FA38EB0040000    <1> 	bt	word ptr [rsi+PSR], cx		; in memory bytes ffff f00c 0xxx xxxx
    69 00000BD1 7313                <1> 	jnc	write_application_window	; x86 bus read -> 0xxx xxxx ffff f00c
    70 00000BD3 F786B0040000000080- <1> 	test	dword ptr [rsi+PSR], 00800000h 
    70 00000BDC 00                  <1>
    71 00000BDD 0F844D050000        <1> 	jz	near guard_ii_authority
    72 00000BE3 80C940              <1> 	or	cl, 64
    73                              <1> 
    74                              <1> write_application_window:
    75 00000BE6 80F10F              <1> 	xor	cl, 8+7			; [ 1 2 3 4 5 6 7 ] <- 8 + [ 6 5 4 3 2 1 0]
    76                              <1> 
    77                              <1> write_window_known:
    78 00000BE9 80F902              <1> 	cmp	cl, 2			; application dnw vector page
    79 00000BEC 7510                <1> 	jnz	write_window_free
    80 00000BEE F786B0040000000080- <1> 	test	dword ptr [rsi+PSR], 00800000h			; ISR ?
    80 00000BF7 00                  <1>
    81 00000BF8 0F8432050000        <1> 	jz	near guard_ii_authority		; the unbalanced push is harmless
    82                              <1> 						; stack is reset on faults
    83                              <1> write_window_free:
    84 00000BFE 4889C2              <1> 	mov	rdx, rax
    85 00000C01 480FB6C1            <1> 	movzx	rax, cl
    86 00000C05 8B8486E0040000      <1> 	mov	eax, dword ptr [rsi+rax*4+IO_PORT]
    87 00000C0C 4889D6              <1> 	mov	rsi, rdx
    88                              <1> 
    89 00000C0F C1C910              <1> 	ror	ecx, 16		; restore designator information
    90 00000C12 C3                  <1> 	ret
    91                              <1> 
    33                                  	%include	"sr.msm"
     1                              <1> 
     2                              <1> ;	read staging register
     3                              <1> ;	read bits from a stream of bits
     4                              <1> 
     5 00000C13 8B4E50              <1> _rsr:	mov	ecx, dword ptr [rsi+RDATAC]
     6 00000C16 88CD                <1> 	mov	ch, cl
     7 00000C18 88C1                <1> 	mov	cl, al
     8                              <1> 
     9 00000C1A 31C0                <1> 	xor	eax, eax
    10 00000C1C F786B0040000400000- <1> 	test	dword ptr [rsi+PSR], B_STREAMZR
    10 00000C25 00                  <1>
    11 00000C26 7503                <1> 	jnz	_rsr_zadd
    12 00000C28 8B4510              <1> 	mov	eax, dword ptr [rbp+A]
    13                              <1> _rsr_zadd:
    14 00000C2B 20C9                <1> 	and	cl, cl
    15 00000C2D 7451                <1> 	jz	_rsr_x
    16 00000C2F 8B5E54              <1> 	mov	ebx, dword ptr [rsi+RDATA]
    17                              <1> 
    18 00000C32 20ED                <1> 	and	ch, ch			; any data loaded yet?
    19 00000C34 740F                <1> 	jz	_rsr_read		; if not read first no question 
    20 00000C36 38CD                <1> 	cmp	ch, cl			; otherwise, already enough for request?
    21 00000C38 7331                <1> 	jnb	_rsr_draw		; if so deliver data
    22 00000C3A 28E9                <1> 	sub	cl, ch			; if not trim the oustanding count
    23 00000C3C 86CD                <1> 	xchg	cl, ch			
    24 00000C3E E85A0F0000          <1> 	call	dsl			; and deliver available data
    25 00000C43 86E9                <1> 	xchg	ch, cl			; before reading some more
    26                              <1> _rsr_read:
    27 00000C45 E896000000          <1> 	call	stream_read
    28                              <1> 
    29 00000C4A 480F7EFE            <1> 	movq	rsi, mm7
    30                              <1> ;	mov	rsi, qword ptr [rbp+CORE_INDEX1]	; after call to operand_read
    31                              <1> 
    32 00000C4E C7465018000000      <1> 	mov	dword ptr [rsi+RDATAC], 24
    33 00000C55 F786B0040000200000- <1> 	test	dword ptr [rsi+PSR], B_STREAM16R
    33 00000C5E 00                  <1>
    34 00000C5F 740A                <1> 	jz	_rsr_draw
    35 00000C61 C7465010000000      <1> 	mov	dword ptr [rsi+RDATAC], 16
    36 00000C68 C1E308              <1> 	shl	ebx, 8
    37                              <1> _rsr_draw:
    38 00000C6B 6651                <1> 	push	cx
    39 00000C6D E82B0F0000          <1> 	call	dsl
    40 00000C72 6659                <1> 	pop	cx
    41 00000C74 81E1FF000000        <1> 	and	ecx, 255
    42 00000C7A 294E50              <1> 	sub	dword ptr [rsi+RDATAC], ecx
    43 00000C7D 895E54              <1> 	mov	dword ptr [rsi+RDATA], ebx
    44                              <1> _rsr_x:
    45 00000C80 894510              <1> 	mov	dword ptr [rbp+A], eax
    46 00000C83 C3                  <1> 	ret
    47                              <1> 
    48                              <1> 
    49                              <1> ;	write staging register
    50                              <1> ;	write bits to a stream of bits
    51                              <1> 
    52 00000C84 8B4E58              <1> _wsr:	mov	ecx, dword ptr [rsi+WDATAC]
    53 00000C87 88CD                <1> 	mov	ch, cl					; accumulated count
    54 00000C89 88C1                <1> 	mov	cl, al					; new request
    55                              <1> 
    56 00000C8B 8B465C              <1> 	mov	eax, dword ptr [rsi+WDATA]	; accumulated data
    57 00000C8E 8B5D10              <1> 	mov	ebx, dword ptr [rbp+A]		; source new data
    58                              <1> 
    59 00000C91 80C5E8              <1> 	add	ch, -24				; space for new data expressed negative
    60 00000C94 F786B0040000100000- <1> 	test	dword ptr [rsi+PSR], B_STREAM16W	; 16 bits / word flag
    60 00000C9D 00                  <1>
    61 00000C9E 7403                <1> 	jz	_wsr24
    62 00000CA0 80C508              <1> 	add	ch, 8
    63                              <1> 
    64 00000CA3 00CD                <1> _wsr24:	add	ch, cl			; increment towards zero
    65 00000CA5 7404                <1> 	jz	_wsr_write		; accumulated word exactly full
    66 00000CA7 731E                <1> 	jnc	_wsr_add		; not yet full
    67                              <1> 
    68 00000CA9 28E9                <1> 	sub	cl, ch			; full + some more
    69                              <1> 
    70                              <1> _wsr_write:
    71 00000CAB E8ED0E0000          <1> 	call	dsl			; fill output word
    72 00000CB0 88E9                <1> 	mov	cl, ch			; position outstanding count
    73 00000CB2 E83E000000          <1> 	call	stream_write
    74                              <1> 
    75 00000CB7 480F7EFE            <1> 	movq	rsi, mm7
    76                              <1> ;	mov	esi, dword ptr [rbp+CORE_INDEX1]	; after call to operand_write
    77 00000CBB B800000000          <1> 	mov	eax, 0
    78 00000CC0 C7465800000000      <1> 	mov	dword ptr [rsi+REGISTER+WDATAC], 0
    79                              <1> 
    80                              <1> _wsr_add:
    81 00000CC7 6651                <1> 	push	cx
    82 00000CC9 E8CF0E0000          <1> 	call	dsl			; add to output word
    83 00000CCE 6659                <1> 	pop	cx
    84 00000CD0 81E1FF000000        <1> 	and	ecx, 255		; format ecx for add to accumulated count 
    85 00000CD6 014E58              <1> 	add	dword ptr [rsi+REGISTER+WDATAC], ecx
    86 00000CD9 89465C              <1> 	mov	dword ptr [rsi+REGISTER+WDATA], eax
    87 00000CDC 895D10              <1> 	mov	dword ptr [rbp+A], ebx
    88 00000CDF C3                  <1> 	ret
    89                              <1> 
    90                              <1> stream_read:
    91 00000CE0 51                  <1> 	push	rcx
    92 00000CE1 50                  <1> 	push	rax
    93 00000CE2 8B4534              <1> 	mov	eax, dword ptr [rbp+Q]
    94 00000CE5 83453401            <1> 	add	dword ptr [rbp+Q], 1
    95 00000CE9 30C9                <1> 	xor	cl, cl
    96 00000CEB E80AF8FFFF          <1> 	call	_operand_read
    97 00000CF0 89C3                <1> 	mov	ebx, eax
    98 00000CF2 58                  <1> 	pop	rax
    99 00000CF3 59                  <1> 	pop	rcx
   100 00000CF4 C3                  <1> 	ret
   101                              <1> 
   102                              <1> stream_write:
   103 00000CF5 51                  <1> 	push	rcx
   104 00000CF6 53                  <1> 	push	rbx
   105 00000CF7 89C3                <1> 	mov	ebx, eax
   106 00000CF9 8B4530              <1> 	mov	eax, dword ptr [rbp+P]
   107 00000CFC 83453001            <1> 	add	dword ptr [rbp+P], 1
   108 00000D00 30C9                <1> 	xor	cl, cl
   109 00000D02 E8B6F9FFFF          <1> 	call	_operand_write
   110 00000D07 5B                  <1> 	pop	rbx
   111 00000D08 59                  <1> 	pop	rcx
   112 00000D09 C3                  <1> 	ret
   113                              <1> 
    34                                  	%include	"io.msm"
     1 00000D0A 678B9C86E0040000    <1> _inA:	mov	ebx, dword ptr [esi+IO_PORT+eax*4]
     2 00000D12 67895D10            <1> 	mov	dword ptr [ebp+A], ebx
     3 00000D16 C3                  <1> _inA_:	ret
     4                              <1> 
     5 00000D17 678B9C86E0040000    <1> _inB:	mov	ebx, dword ptr [esi+IO_PORT+eax*4]
     6 00000D1F 67895D14            <1> 	mov	dword ptr [ebp+B], ebx
     7 00000D23 C3                  <1> _inB_:	ret
     8                              <1> 
     9 00000D24 678B5D10            <1> _outA:	mov	ebx, dword ptr [ebp+A]
    10 00000D28 E9BD010000          <1> 	jmp	oport
    11                              <1> 
    12 00000D2D 678B5D14            <1> _outB:	mov	ebx, dword ptr [ebp+B]
    13 00000D31 E9B4010000          <1> 	jmp	oport
    14                              <1> 
    15                              <1> 
    16                              <1> ISR_ONLY equ	8
    17                              <1> MEMTYPE	equ	1
    18                              <1> MEMZERONLY equ	2
    19                              <1> EXTERNAL_IO equ	4
    20                              <1> BROADCAST equ	16
    21                              <1> 
    22                              <1> B_1	equ	MEMTYPE
    23                              <1> B_TCB	equ	MEMTYPE+ISR_ONLY
    24                              <1> B_KERN	equ	MEMTYPE+ISR_ONLY
    25                              <1> A_THREP	equ	MEMZERONLY+ISR_ONLY
    26                              <1> I_PORT	equ	EXTERNAL_IO
    27                              <1> O_PORT	equ	EXTERNAL_IO
    28                              <1> O_INDICA equ	EXTERNAL_IO
    29                              <1> O_CHILL	equ	EXTERNAL_IO
    30                              <1> I_TZONE	equ	EXTERNAL_IO
    31                              <1> RAM_THRESH equ	ISR_ONLY+MEMZERONLY
    32                              <1> XI_ACK	equ	ISR_ONLY+EXTERNAL_IO
    33                              <1> O_LEDS	equ	EXTERNAL_IO
    34                              <1> O_INC	equ	ISR_ONLY+EXTERNAL_IO
    35                              <1> O_MCAST	equ	ISR_ONLY+BROADCAST
    36                              <1> 
    37                              <1> 
    38                              <1> mask_port_outAB:
    39 00000D36 000100000000000000- <1> 	db	0, B_1, 0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    39 00000D3F 00000000000000      <1>
    40 00000D46 000000000000000000- <1> 	db	    0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    40 00000D4F 00000000000000      <1>
    41                              <1> 
    42 00000D56 000000000000000000- <1> 	db	    0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    42 00000D5F 00000000000000      <1>
    43 00000D66 000000000000000000- <1> 	db	    0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    43 00000D6F 00000000000000      <1>
    44                              <1> 
    45 00000D76 0009090909090909    <1> 	db	0,  B_TCB,B_KERN,B_KERN,B_KERN,B_KERN,B_KERN,B_KERN
    46 00000D7E 0A00000C0C000018    <1> 	db	A_THREP, 0, 0, XI_ACK,  O_INC, 0,0, O_MCAST
    47                              <1> 
    48 00000D86 0404040404040404    <1> 	db	I_PORT,I_PORT,I_PORT,I_PORT,I_PORT,I_PORT,I_PORT,I_PORT
    49 00000D8E 0404040404040404    <1> 	db	O_PORT,O_PORT,O_PORT,O_PORT,O_PORT,O_PORT,O_PORT,O_PORT
    50                              <1> 
    51 00000D96 0000000000040404    <1> 	db	0,0,0,0, 0, I_TZONE, O_INDICA, O_CHILL
    52 00000D9E 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  RAM_THRESH, 0,0, O_LEDS
    52 00000DA7 0000000A000004      <1>
    53                              <1> 
    54 00000DAE 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    54 00000DB7 00000000000000      <1>
    55 00000DBE 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    55 00000DC7 00000000000000      <1>
    56 00000DCE 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    56 00000DD7 00000000000000      <1>
    57 00000DDE 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    57 00000DE7 00000000000000      <1>
    58                              <1> 
    59                              <1> 					; outA|B rules flags per I/O port
    60                              <1> 
    61                              <1> _reload:
    62 00000DEE 50                  <1> 	push	rax
    63 00000DEF 8B4510              <1> 	mov	eax, dword ptr [rbp+A]
    64 00000DF2 83451002            <1> 	add	dword ptr [rbp+A], 2
    65 00000DF6 E8BDF6FFFF          <1> 	call	_burst_read2
    66 00000DFB 5F                  <1> 	pop	rdi
    67                              <1> 
    68 00000DFC 480F7EFE            <1> 	movq	rsi, mm7
    69                              <1> ;	mov	rsi, qword ptr [rbp+CORE_INDEX1]
    70                              <1> 
    71 00000E00 8984BEE0040000      <1> 	mov	dword ptr [rsi+IO_PORT+rdi*4], eax
    72 00000E07 899CBEE4040000      <1> 	mov	dword ptr [rsi+IO_PORT+rdi*4+4], ebx
    73 00000E0E C3                  <1> 	ret
    35                                  	%include	"sabr.msm"
     1                              <1> ;	check and write to I/O port <- storage base index in range [ 2..63 ]
     2                              <1> ;	write a copy to reload base table in thread control block
     3                              <1> ;	values out of memory range are replaced with trap device C00001
     4                              <1> ;	which causes GUARD$ exception if the sindow is accessed
     5                              <1> 
     6                              <1> ;	anauthorised actions
     7                              <1> ;
     8                              <1> ;		attempt to write window base < 2 or > 63
     9                              <1> ;		application selecting ISR space
    10                              <1> ;		application selecting NVRAM
    11                              <1> ;
    12                              <1> ;	are not carried out and a GUARD$ exception is raised
    13                              <1> ;	ISRs write the trap device C00001 to close memory windows
    14                              <1> 
    15                              <1> _sabr_guard:
    16 00000E0F E91C030000          <1> 	jmp	guard_ii_authority
    17                              <1> 
    18 00000E14 A93E000000          <1> _sabr:	test	eax, 03Eh		; ea not < 2
    19 00000E19 74F4                <1> 	jz	_sabr_guard
    20 00000E1B A9C0FFFF00          <1> 	test	eax, 0FFFFC0h		; ea not > 63
    21 00000E20 75ED                <1> 	jnz	_sabr_guard
    22                              <1> 
    23 00000E22 8B4D10              <1> 	mov	ecx, dword ptr [rbp+A]
    24                              <1> 
    25 00000E25 F7C100004000        <1> 	test	ecx, 00400000h
    26 00000E2B 746C                <1> 	jz	memory_page
    27 00000E2D F7C13F000000        <1> 	test	ecx, 63
    28 00000E33 745E                <1> 	jz	large_memory_page
    29                              <1> 
    30 00000E35 F7C100008000        <1> 	test	ecx, 00800000h
    31 00000E3B 740E                <1> 	jz	array_attribute
    32                              <1> 
    33 00000E3D F786B0040000000080- <1> 	test	dword ptr [rsi+PSR], 0800000h
    33 00000E46 00                  <1>
    34 00000E47 74C6                <1> 	jz	_sabr_guard
    35 00000E49 EB76                <1> 	jmp	unthru			; ISR write illegal device thru
    36                              <1> 					; closes the address space window
    37                              <1> 
    38                              <1> 					; application may not write device
    39                              <1> 					; but may zero -> sabr  with same effect
    40                              <1> array_attribute:
    41                              <1> 
    42 00000E4B 48C1E102            <1> 	shl	rcx, 2
    43 00000E4F 480FB6D9            <1> 	movzx	rbx, cl			; cl = device * 4
    44                              <1> 
    45 00000E53 8B9C33E0060000      <1> 	mov	ebx, dword ptr [rsi+rbx+IO_PORT+_DEVICE]
    46                              <1> 					; platform address + device descriptor
    47                              <1> 
    48                              <1> 
    49                              <1> 	%if	0
    50                              <1> 	mov	dword ptr [rsi+eax*8+DATAFRAME], rbx	; rapid recall
    51                              <1> 	mov	dword ptr [rsi+eax*8+DATAFRAME+4], rdi	; device information
    52                              <1> 	%endif						; via window tag
    53                              <1> 
    54 00000E5A 48C1E908            <1> 	shr	rcx, 6+2		; lose previous shift + device code
    55 00000E5E F7C300004000        <1> 	test	ebx, 00400000h
    56 00000E64 750A                <1> 	jnz	peripheral_array
    57 00000E66 F7C300008000        <1> 	test	ebx, 00800000h
    58 00000E6C 7520                <1> 	jnz	memory_array
    59                              <1> 
    60 00000E6E EB9F                <1> 	jmp	_sabr_guard		; no device code
    61                              <1> 
    62                              <1> peripheral_array:			; device types 00C00000 00400000
    63 00000E70 F786B0040000000080- <1> 	test	dword ptr [rsi+PSR], 00800000h
    63 00000E79 00                  <1>
    64 00000E7A 7493                <1> 	jz	_sabr_guard
    65                              <1> 
    66 00000E7C 81E1FFFF0000        <1> 	and	ecx, 0000FFFFh		; have # large blocks in low 16 bits
    67 00000E82 81E3FFFF0000        <1> 	and	ebx, 0000FFFFh
    68 00000E88 29CB                <1> 	sub	ebx, ecx
    69 00000E8A 7932                <1> 	jns	thru
    70 00000E8C EB29                <1> 	jmp	_sabr_safeguard
    71                              <1> 
    72                              <1> memory_array:
    73 00000E8E C1E106              <1> 	shl	ecx, 6			; block * 64
    74 00000E91 EB14                <1> 	jmp	memory_array_bound?
    75                              <1> 
    76                              <1> large_memory_page:
    77 00000E93 81E1FFFFBF00        <1> 	and	ecx, 00BFFFFFh		; remove 00400000 bit for lower bound check
    78                              <1> 
    79                              <1> memory_page:
    80 00000E99 8B9EE0060000        <1> 	mov	ebx, dword ptr [rsi+IO_PORT+_DEVICE]	; device zero memory attribute
    81 00000E9F 3B8E00060000        <1> 	cmp	ecx, dword ptr [rsi+IO_PORT+_APP_THRESHOLD]	; ISR / application boundary
    82 00000EA5 7210                <1> 	jb	_sabr_safeguard
    83                              <1> 
    84                              <1> memory_array_bound?:
    85 00000EA7 81E1FFFFBF00        <1> 	and	ecx, 00BFFFFFh		; bit 00800000 is a bad accident
    86 00000EAD 81E3FFFF3F00        <1> 	and	ebx, 003FFFFFh		; stop it here
    87 00000EB3 29CB                <1> 	sub	ebx, ecx
    88 00000EB5 7907                <1> 	jns	thru
    89                              <1> 
    90                              <1> _sabr_safeguard:
    91 00000EB7 B90100C000          <1> 	mov	ecx, 00C00001h
    92 00000EBC EB03                <1> 	jmp	unthru
    93                              <1> 
    94 00000EBE 8B4D10              <1> thru:	mov	ecx, dword ptr [rbp+A]		; i.e. correct as supplied
    95 00000EC1 898C86E0040000      <1> unthru:	mov	dword ptr [rsi+rax*4+IO_PORT], ecx
    96                              <1> 
    97 00000EC8 48BF-               <1> 	mov	rdi, _memory
    97 00000ECA [0000000000000000]  <1>
    98 00000ED2 678B9EE4050000      <1> 	mov	ebx, dword ptr [esi+IO_PORT+65*4] ; thread control block
    99                              <1> 
   100 00000ED9 48C1E30C            <1> 	shl	rbx, 12			; multiply to TCB size
   101 00000EDD 4801C3              <1> 	add	rbx, rax		; ea is target base index
   102 00000EE0 0FC9                <1> 	bswap	ecx			; for this is a big endian memory write
   103 00000EE2 898C9F00010000      <1> 	mov	dword ptr [rdi+rbx*4+64*4], ecx
   104 00000EE9 C3                  <1> 	ret				; save TCB reload copy of loaded pointer
    36                                  	%include	"oport.msm"
     1                              <1> 
     2                              <1> OOO_TRACE	equ	0
     3                              <1> 
     4                              <1> 							; static void oport(int ea, int value, smp *xcore)
     5                              <1> 							; {
     6                              <1> oport:		; write I / O port			;    int		 rule,
     7                              <1> 		; RTA instructions outA outB		;			 device;
     8                              <1> 							; 
     9                              <1> 		; ports which are memory pointers	;    int		 mask,
    10                              <1> 		; must have a block that exists		;			 from,
    11                              <1> 		; ISRs can write trap value C00001 	;                 	 index;
    12                              <1> 		; = device 400001 | illegal 800000	; 
    13                              <1> 		; port # = effective address = eax	;    int		 device_index = 0;
    14                              <1> 		; write value in ebx			; 
    15                              <1> 		; multicast bits in RTA register k	;    smp		*ascor;
    16                              <1> 		 					;    unsigned	*register_set = xcore->register_set;
    17                              <1> 
    18 00000EEA 3DC0000000          <1> 	cmp	eax, IO_PORTS				; 
    19 00000EEF 0F8393000000        <1> 	jnb	near no_port				;    if (ea < IO_PORTS)
    20                              <1> 							;    {
    21 00000EF5 8A88[360D0000]      <1> 	mov	cl, byte ptr [rax+mask_port_outAB]	;       rule = mask_port_outAB[ea];
    22 00000EFB 20C9                <1> 	and	cl, cl					; 
    23 00000EFD 0F8485000000        <1> 	jz	near no_rule				;       if (rule)
    24 00000F03 F6C108              <1> 	test	cl, ISR_ONLY				;       {
    25 00000F06 7410                <1> 	jz	application_plus_isr_rule		;          if (((rule & ISR_ONLY) == 0) || (psr & 0x00800000))
    26 00000F08 F786B0040000000080- <1> 	test	dword ptr [rsi+PSR], 0800000h		;          {
    26 00000F11 00                  <1>
    27 00000F12 0F8470000000        <1> 	jz	near no_authority			;
    28                              <1> 							;
    29                              <1> application_plus_isr_rule:				;
    30 00000F18 F6C104              <1> 	test	cl, EXTERNAL_IO				;             if (rule & EXTERNAL_IO)
    31 00000F1B 7423                <1> 	jz	broadcast_rule?				;             {
    32 00000F1D 899C86E0040000      <1> 	mov	dword ptr [rsi+IO_PORT+rax*4], ebx	;                base[ea] = value;
    33 00000F24 83F866              <1> 	cmp	eax, 102	; INDICATION$		;                if (ea == 102) indication |= value;
    34 00000F27 7506                <1> 	jne	xi_ack?		 			;
    35 00000F29 099EA4040000        <1> 	or	dword ptr [rsi+INDICATION], ebx		;
    36                              <1>  							;
    37                              <1> xi_ack?:							;
    38 00000F2F 83F84B              <1> 	cmp	eax, 75					;                if (ea == 75)
    39 00000F32 750B                <1> 	jne	xi_no_ack				;                {
    40 00000F34 F6D3                <1> 	not	bl					;                    base[74] &= (value & 255) ^ 255;
    41 00000F36 0FB6DB              <1> 	movzx	ebx, bl					;                    // indication |= (value & 255) << 8;
    42                              <1> 							;                }
    43 00000F39 219E08060000        <1> 	and	dword ptr [rsi+IO_PORT+_XI_PENDING], ebx	; 
    44                              <1> xi_no_ack:						; //               if ((ea == 79) && (value & 1)) indication |= ATTENTION;
    45 00000F3F C3                  <1> 	ret						;                return;
    46                              <1> 							;             }
    47                              <1> 							; 
    48                              <1> broadcast_rule?:					;             if (rule & BROADCAST)
    49 00000F40 F6C110              <1> 	test	cl, BROADCAST				;             {
    50 00000F43 7448                <1> 	jz	memory_rule?				;                mask = k;
    51                              <1> 							;
    52 00000F45 8B9604060000        <1> 	mov	edx, dword ptr [rsi+IO_PORT+_CORE_PIN]	;
    53                              <1> 							;
    54 00000F4B 48BF-               <1> 	mov	rdi, _core				;
    54 00000F4D [0000000000000000]  <1>
    55 00000F55 8B4D04              <1> 	mov	ecx, dword ptr [rbp+REGISTER+K]		;
    56 00000F58 238ED4060000        <1> 	and	ecx, dword ptr [rsi+IO_PORT+_CORES_MASK] ;
    57                              <1> 							;
    58                              <1> multicast_select:					;
    59 00000F5E D1E9                <1> 	shr	ecx, 1					;                from = base[77];
    60 00000F60 731A                <1> 	jnc	multicast_next				; 
    61 00000F62 21DB                <1> 	and	ebx, ebx	; operand value?	;                for (index = 0; index < RTA_SMP; index++)
    62 00000F64 740F                <1> 	jz	multicast_time
    63                              <1> 
    64 00000F66 099718060000        <1> 	or	dword ptr [rdi+IO_PORT+_MCAST_PENDING], edx ;             {
    65 00000F6C 808FA404000080      <1> 	or	byte ptr [rdi+INDICATION], ATTENTION	;                   if (mask & 1)
    66 00000F73 EB07                <1> 	jmp	multicast_next				;                   {
    67                              <1> 
    68                              <1> multicast_time:
    69 00000F75 808FA404000020      <1> 	or	byte ptr [rdi+INDICATION], TPULSE
    70                              <1> 
    71                              <1> multicast_next:						;                      ascor = core + index;
    72 00000F7C 4881C7E0070000      <1> 	add	rdi, CORE_SIZE				;                      ascor->BASE[78] |= 1 << from;
    73                              <1> 							;                      ascor->INDICATION |= ATTENTION;
    74 00000F83 21C0                <1> 	and	eax, eax				;                   }
    75 00000F85 75D7                <1> 	jnz	multicast_select			; 
    76 00000F87 C3                  <1> 	ret						;                   mask >>= 1;
    77                              <1> 							;                }
    78                              <1> no_port:						; 
    79                              <1> no_rule:						;                /**************************************************
    80                              <1> no_authority:						; 			keep these on the sending side
    81                              <1> 							; 			until constructing interrupt frame
    82 00000F88 E9A3010000          <1> 	jmp	guard_ii_authority			; 			between instructions at target core
    83                              <1> 							;                         to avoid overwrites from other cores
    84                              <1> 							;                **************************************************/
    85                              <1> 							; 
    86                              <1> 							;                base[ea] = value;	/* latent parameter	*/
    87                              <1> 							;                return;
    88                              <1> 							;             }
    89                              <1> 							; 
    90                              <1> memory_rule?:	; system memory type only		;             else if (rule & MEMTYPE)
    91                              <1> 
    92 00000F8D F6C101              <1> 	test	cl, MEMTYPE				;             {
    93 00000F90 745C                <1> 	jz	page_pointer?				;                if (value & 0x00400000) device_index = value & 63;
    94 00000F92 F7C300004000        <1> 	test	ebx, 0400000h	; bank sized?		; 
    95 00000F98 7461                <1> 	jz	memory_page_pointer			;                if (device_index)
    96                              <1> 							;                {
    97 00000F9A F7C33F000000        <1> 	test	ebx, 63					;                   if (value & 0x00800000)
    98 00000FA0 741C                <1> 	jz	device_is_pointed			;                   {
    99 00000FA2 F7C300008000        <1> 	test	ebx, 0800000h	; the trap device?	;                      if (psr & 0x00800000)
   100 00000FA8 7414                <1> 	jz	device_is_pointed			;                      {
   101 00000FAA F786B004000000350C- <1> 	test	dword ptr [rsi+PSR], 00800000	; ISR?	;                         base[ea] = value;
   101 00000FB3 00                  <1>
   102 00000FB4 74D2                <1> 	jz	no_authority				;                         return;
   103 00000FB6 899C86E0040000      <1> 	mov	[rsi+IO_PORT+rax*4], ebx		;                      }
   104 00000FBD C3                  <1> 	ret						; 
   105                              <1> 							;                      GUARD_AUTHORITY
   106                              <1> device_is_pointed:					;                      return;
   107 00000FBE 8B8EE0060000        <1> 	mov	ecx, dword ptr [rsi+IO_PORT+_DEVICE]	;                   }
   108 00000FC4 F7C100008000        <1> 	test	ecx, 00800000h				;                }
   109 00000FCA 74BC                <1> 	jz	no_authority				; 
   110 00000FCC F7C100004000        <1> 	test	ecx, 00400000h				;                device = base[128+device_index];
   111 00000FD2 75B4                <1> 	jnz	no_authority				;            
   112 00000FD4 81E1FFFF3F00        <1> 	and	ecx, 003FFFFFh				;                if ((device & 0x00C00000) == 0x00800000)
   113 00000FDA 89DF                <1> 	mov	edi, ebx				;                {
   114 00000FDC 81E7FFFF3F00        <1> 	and	edi, 003FFFFFh	; catch any 00800000	;                   if ((value & 0x003FFFC0) > (device & 0x003FFFFF))
   115 00000FE2 39F9                <1> 	cmp	ecx, edi				;                   {
   116 00000FE4 7233                <1> 	jb	outwith		; beyond memory		;                   }
   117 00000FE6 899C86E0040000      <1> 	mov	[rsi+IO_PORT+rax*4], ebx		;                   else
   118 00000FED C3                  <1> 	ret						;                   {
   119                              <1> 							;                      base[ea] = value;
   120                              <1> 							;                      return;
   121                              <1> 							;                   }
   122                              <1> 							;                }
   123                              <1> 							;             }
   124                              <1> 							;             else
   125                              <1> 							;             {
   126                              <1> 							;                /*******************************************
   127                              <1> ;	only a device zero page index will do		; 			page pointer to system memory
   128                              <1> 							;                *******************************************/
   129                              <1> page_pointer?:						; 
   130 00000FEE F6C102              <1> 	test	cl, MEMZERONLY				;                if ((value & 0x00400000) == 0)
   131 00000FF1 7495                <1> 	jz	no_rule					;                {
   132 00000FF3 F7C30000C000        <1> 	test	ebx, 00C00000h				;                   if (value > (base[128] & 0x003FFFFF))
   133 00000FF9 758D                <1> 	jnz	no_authority				;                   {
   134                              <1> 							;                   }
   135                              <1> memory_page_pointer:					;                   else
   136 00000FFB 8B8EE0060000        <1> 	mov	ecx, dword ptr [rsi+IO_PORT+_DEVICE]	;                   {
   137 00001001 81E1FFFF3F00        <1> 	and	ecx, 003FFFFFh				;                      base[ea] = value;
   138 00001007 81E3FFFFFF00        <1> 	and	ebx, 00FFFFFFh				;                      return;
   139 0000100D 39D9                <1> 	cmp	ecx, ebx				;                   }
   140 0000100F 7208                <1> 	jb	outwith					;                }
   141 00001011 899C86E0040000      <1> 	mov	dword ptr [rsi+IO_PORT+rax*4], ebx	;             }
   142 00001018 C3                  <1> 	ret						;          }
   143                              <1> 							;       }
   144                              <1> 							;    }
   145                              <1> outwith:						; 
   146 00001019 B90E000000          <1> 	mov	ecx, LP_ADDRESS				;    GUARD_AUTHORITY;
   147 0000101E E912010000          <1> 	jmp	guard_ii_escape				; }							; 
    37                                  	%include	"ii.msm"
     1 00001023 66670986B0040000    <1> _on:	or	word ptr [esi+PSR], ax	; only touch low-order 16 bits
     2 0000102B C3                  <1> 	ret
     3                              <1> 
     4 0000102C 6683F0FF            <1> _off:	xor	ax, 0000FFFFh
     5 00001030 66672186B0040000    <1> 	and	word ptr [esi+PSR], ax	; only touch low-order 16 bits
     6 00001038 C3                  <1> 	ret
     7                              <1> 
     8                              <1> RELOAD_SMPP	equ	1
     9                              <1> III_TRACE	equ	0
    10                              <1> 
    11                              <1> _xi:
    12                              <1> 	%if	RELOAD_SMPP
    13 00001039 480F7EFE            <1> 	movq	rsi, mm7
    14                              <1> ;	mov	rsi, qword ptr [rbp+CORE_INDEX1]
    15                              <1> 	%endif
    16                              <1> 
    17 0000103D 20E4                <1> 	and	ah, ah				; 8 external interrupts?
    18 0000103F 741B                <1> 	jz	_xix_beat?			; nane
    19                              <1> 
    20 00001041 30C9                <1> 	xor	cl, cl
    21                              <1> 
    22                              <1> _xi_next:					; external interrupt pending signals[8]
    23 00001043 88A608060000        <1> 	mov	byte ptr [rsi+IO_PORT+_XI_PENDING], ah	; position for inA|B from port XI_PENDING$	LL.mm.hh.zz
    24 00001049 C686A504000000      <1> 	mov	byte ptr [rsi+INDICATION+1], 0	; clear from platform indications fabric	ll.MM.hh.zz
    25 00001050 31C9                <1> 	xor	ecx, ecx			; clear latent param
    26 00001052 B802000000          <1> 	mov	eax, II_XINT			; select external interrupt
    27                              <1> 
    28 00001057 E907010000          <1> 	jmp	_ii_
    29                              <1> 	
    30                              <1> _xix_beat?:
    31 0000105C A820                <1> 	test	al, TPULSE
    32 0000105E 742C                <1> 	jz	_xix
    33                              <1> 
    34 00001060 48BF-               <1> 	mov	rdi, _core			; i.e. &core[0]
    34 00001062 [0000000000000000]  <1>
    35 0000106A 488B9F58020000      <1> 	mov	rbx, qword ptr [rdi+REGISTER+DAYCLOCK_U]
    36 00001071 48899E58020000      <1> 	mov	qword ptr [rsi+REGISTER+DAYCLOCK_U], rbx
    37 00001078 8B9F74060000        <1> 	mov	ebx, dword ptr [rdi+IO_PORT+_TZONE]
    38 0000107E 899E74060000        <1> 	mov	dword ptr [rsi+IO_PORT+_TZONE], ebx
    39 00001084 6780A6A4040000DF    <1> 	and	byte ptr [esi+INDICATION], TPULSE^255
    40                              <1> 
    41 0000108C A880                <1> _xix:	test	al, ATTENTION			; core2core interrupt
    42 0000108E 0F845B000000        <1> 	jz	near _xiy
    43                              <1> 
    44 00001094 678B9E18060000      <1> 	mov	ebx, dword ptr [esi+IO_PORT+_MCAST_PENDING]
    45 0000109B 67239ED4060000      <1> 	and	ebx, dword ptr [esi+IO_PORT+_CORES_MASK]
    46 000010A2 BAFEFFFFFF          <1> 	mov	edx, -2
    47 000010A7 48BF-               <1> 	mov	rdi, _core
    47 000010A9 [0000000000000000]  <1>
    48                              <1> 
    49                              <1> _xi_atn_sources:
    50 000010B1 D1EB                <1> 	shr	ebx, 1						; source pending
    51 000010B3 7318                <1> 	jnc	_xi_atn_source_next				; no
    52                              <1> 								; yes
    53 000010B5 67219618060000      <1> 	and	[esi+IO_PORT+_MCAST_PENDING], edx		; unpend
    54 000010BC 678B8F1C060000      <1> 	mov	ecx, dword ptr [edi+IO_PORT+_MCAST_TO]		; latent parameter from other core
    55                              <1> 
    56 000010C3 B805000000          <1> 	mov	eax, II_ATTENTION				; no
    57 000010C8 E996000000          <1> 	jmp	_ii_						; _ii_ takes ecx for
    58                              <1> 								; latent parameter
    59                              <1> _xi_atn_source_next:
    60 000010CD 4881C7E0070000      <1> 	add	rdi, CORE_SIZE					; next core
    61 000010D4 D1C2                <1> 	rol	edx, 1						; next flag reset position
    62 000010D6 21DB                <1> 	and	ebx, ebx					; any next attention flags left?
    63 000010D8 75D7                <1> 	jnz	_xi_atn_sources
    64                              <1> 								; any attention flags set anew?
    65 000010DA 67F78618060000FFFF- <1> 	test	dword ptr [esi+IO_PORT+_MCAST_PENDING], 00FFFFFFh
    65 000010E3 FF00                <1>
    66 000010E5 7508                <1> 	jnz	_xi_atn_new_sources				; if so keep ATTENTION request
    67                              <1> 								; for next pass
    68 000010E7 6780A6A40400007F    <1> 	and	byte ptr [esi+INDICATION], ATTENTION^255	; otherwise quiet request
    69                              <1> 
    70                              <1> _xi_atn_new_sources:
    71                              <1> 	
    72                              <1> 
    73 000010EF 8B86A4040000        <1> _xiy:	mov	eax, dword ptr [rsi+INDICATION]			; case we did _xix in the same sweep
    74 000010F5 F686A404000040      <1> 	test	byte ptr [rsi+INDICATION], INCREMENTER_CARRY	; nanosecond or other counter 
    75 000010FC 7410                <1> 	jz	_xiz						; from minus to carrry on zero
    76                              <1> 								; to feed millisecond dayclock
    77 000010FE 80A6A4040000BF      <1> 	and	byte ptr [rsi+INDICATION], INCREMENTER_CARRY^255
    78 00001105 B804000000          <1> 	mov	eax, II_MSECOND
    79 0000110A 31C9                <1> 	xor	ecx, ecx
    80 0000110C EB55                <1> 	jmp	_ii_
    81                              <1> 
    82 0000110E C3                  <1> _xiz:	ret
    83                              <1> 
    84                              <1> _ii_instruction:
    85 0000110F 89C3                <1> 	mov	ebx, eax
    86 00001111 C1EB06              <1> 	shr	ebx, 6
    87 00001114 672B9E00060000      <1> 	sub	ebx, dword ptr [esi+IO_PORT+_APP_THRESHOLD]	; application threshold
    88 0000111B 7913                <1> 	jns	guard_ii_authority	; must have executed a character string
    89                              <1> 					; like 757575
    90 0000111D A9C0FFFFFF          <1> 	test	eax, -64
    91 00001122 7521                <1> 	jnz	_ii			; not in restart page OK
    92 00001124 F786B004000000350C- <1> 	test	dword ptr [rsi+PSR], 00800000
    92 0000112D 00                  <1>
    93 0000112E 7515                <1> 	jnz	_ii			; ISR may interrupt to restart page
    94                              <1> 
    95                              <1> 					; service call application to restart page not allowed
    96                              <1> 					; most likely to be an accident
    97                              <1> 					; drop thru and be quelled
    98                              <1> 
    99                              <1> guard_ii_authority:
   100 00001130 B901000000          <1> 	mov	ecx, LP_AUTHORITY
   101                              <1> guard_ii_escape:
   102 00001135 B85F000000          <1> 	mov	eax, II_GUARD
   103                              <1> _ii_escape:
   104                              <1> 	%if	RELOAD_SMPP
   105 0000113A 480F7EFE            <1> 	movq	rsi, mm7
   106                              <1> ;	mov	rsi, qword ptr [rbp+CORE_INDEX1]	; read register 152 or 280
   107                              <1> 	%endif						; depending ebp -> application / ISR registers
   108                              <1> 
   109 0000113E 488BA678040000      <1> 	mov	rsp, qword ptr [rsi+REGISTER+286*4]	; read esp at start of _execute
   110                              <1> 
   111 00001145 83F85F              <1> _ii:	cmp	eax, II_GUARD
   112 00001148 7519                <1> 	jnz	_ii_
   113 0000114A F60425[19000000]01  <1> 	test	byte ptr [_uflag+'Z'-'A'], 1	; break to debug console?
   114 00001152 740F                <1> 	jz	_ii_					; not if not opted
   115 00001154 808EA404000002      <1> 	or	byte ptr [rsi+INDICATION], LOCKSTEP
   116 0000115B 800C25[00000000]02  <1> 	or	byte ptr [_general_indication], LOCKSTEP
   117                              <1> 	
   118 00001163 488DAE00020000      <1> _ii_:	lea	rbp, [rsi+128*4] 
   119                              <1> 
   120 0000116A 4889AE98040000      <1> 	mov	qword ptr [rsi+REGISTER_SET], rbp
   121 00001171 C786AC040000800000- <1> 	mov	dword ptr [rsi+ISELECT], 128
   121 0000117A 00                  <1>
   122                              <1> 
   123 0000117B 8B5D3C              <1> 	mov	ebx, dword ptr [rbp+S_P]
   124 0000117E 81FB00010000        <1> 	cmp	ebx, 256
   125 00001184 0F87D3010000        <1> 	ja	near guard_stack
   126 0000118A 83C3FC              <1> 	add	ebx, -4
   127                              <1> 
   128 0000118D 81FB9A000000        <1> 	cmp	ebx, 128+24+2
   129 00001193 0F82C4010000        <1> 	jb	near guard_stack
   130 00001199 895D3C              <1> 	mov	dword ptr [rbp+S_P], ebx
   131                              <1> 
   132 0000119C 4C2BA690040000      <1> 	sub	r12, qword ptr [rsi+B0P]		; platform-relative absolute program counter
   133 000011A3 49C1EC02            <1> 	shr	r12, 2
   134 000011A7 4489649E0C          <1> 	mov	dword ptr [rsi+rbx*4+REGISTER+3*4], r12d	; save PC offset
   135 000011AC 8B96B4040000        <1> 	mov	edx, dword ptr [rsi+B0_NAME]
   136 000011B2 89549E08            <1> 	mov	dword ptr [rsi+rbx*4+REGISTER+2*4], edx	; save bank ID
   137 000011B6 8B96B0040000        <1> 	mov	edx, dword ptr [rsi+PSR]
   138 000011BC 89549E04            <1> 	mov	dword ptr [rsi+rbx*4+REGISTER+4], edx	; saved PSR
   139 000011C0 890C9E              <1> 	mov	dword ptr [rsi+rbx*4+REGISTER], ecx	; latent parameter
   140 000011C3 F7C200008000        <1> 	test	edx, 00800000h				; nested interrupt ?
   141 000011C9 7503                <1> 	jnz	_ii_ii
   142 000011CB 895D38              <1> 	mov	dword ptr [rbp+FP], ebx			; if not, mark interrupted
   143                              <1> 							; application stack frame
   144                              <1> _ii_ii:
   145 000011CE 81CA00008000        <1> 	or	edx, 00800000h				; ISR active
   146 000011D4 8996B0040000        <1> 	mov	dword ptr [rsi+PSR], edx
   147                              <1> 
   148 000011DA 89C2                <1> 	mov	edx, eax				; get to the operand
   149 000011DC 83E23F              <1> 	and	edx, 63					; vector offset
   150 000011DF C1E806              <1> 	shr	eax, 6					; vector start page index
   151 000011E2 25FF030000          <1> 	and	eax, 000003FFh				; eax -> page containing ISR ; edx  -> vector
   152 000011E7 31DB                <1> 	xor	ebx, ebx				; single page ISR
   153 000011E9 E979060000          <1> 	jmp	_go2_frame
   154                              <1> 
   155                              <1> ;	_ir	sign extended ea is in eax
   156                              <1> 
   157 000011EE 67F786B00400000000- <1> _ir:	test	dword ptr [esi+PSR], 00800000h		; eax = EA = variation on return offset
   157 000011F7 8000                <1>
   158 000011F9 0F8431FFFFFF        <1> 	jz	guard_ii_authority			; not good to do Interrupt Return from application space
   159                              <1> 
   160                              <1> 							; r12 stays the same until return is finalised
   161                              <1> 							; in case the operation interrupts itself
   162 000011FF 89C2                <1> 	mov	edx, eax				; +- displacement operand, offset in stack added later
   163                              <1> 
   164 00001201 E88F010000          <1> 	call	stack_read4				; [rbp+rbx*4] -> interrupt stack frame
   165                              <1> 							; interrupt stack pointer is already updated ebx+4
   166                              <1> 
   167 00001206 8B449E08            <1> 	mov	eax, dword ptr [rsi+rbx*4+2*4]		; interrupted b0_name
   168                              <1> 
   169 0000120A 8B4C9E04            <1> 	mov	ecx, dword ptr [rsi+rbx*4+1*4]		; interrupted psr
   170                              <1> 
   171 0000120E 03549E0C            <1> 	add	edx, dword ptr [rsi+rbx*4+3*4]		; add interrupted iframe offset to EA
   172 00001212 81E2FFFF3F00        <1> 	and	edx, 03FFFFFh				;
   173                              <1> 
   174 00001218 31DB                <1> 	xor	ebx, ebx				; iframe default page high index  
   175 0000121A A900008000          <1> 	test	eax, 00800000h				; +page[s] flag on b0_name ?
   176 0000121F 7418                <1> 	jz	ir_4k_iframe				; 1-page iframe return target
   177                              <1> 
   178 00001221 89C3                <1> 	mov	ebx, eax
   179 00001223 C1E30A              <1> 	shl	ebx, 2+8				; drop the flag bit from iframe name
   180 00001226 48C1E302            <1> 	shl	rbx, 12-10				; complete the multiplication * page 
   181                              <1> 
   182                              <1> 	%if	__MOVBE
   183                              <1> 	movbe	ebx, dword ptr [rbx*4+64*4+_memory]
   184                              <1> 	%else
   185 0000122A 8B1C9D[00010000]    <1> 	mov	ebx, dword ptr [rbx*4+64*4+_memory]	; read the embedded gate table
   186 00001231 30C0                <1> 	xor	al, al
   187 00001233 0FCB                <1> 	bswap	ebx
   188                              <1> 	%endif
   189                              <1> 
   190 00001235 48C1EB12            <1> 	shr	rbx, 18					; <- iframe page high index
   191                              <1> 
   192                              <1> ir_4k_iframe:
   193 00001239 898EB0040000        <1> 	mov	dword ptr [rsi+PSR], ecx
   194 0000123F F7C100008000        <1> 	test	ecx, 00800000h				; returning ISR -> ISR ?
   195 00001245 741D                <1> 	jz	ir_application				; no
   196                              <1> 
   197 00001247 488DAE00020000      <1> 	lea	rbp, [rsi+REGISTER+128*4]		; for nested interrupts
   198 0000124E 4889AE98040000      <1> 	mov	qword ptr [rsi+REGISTER_SET], rbp	; interrupt register set. presumably already so
   199 00001255 C786AC040000800000- <1> 	mov	dword ptr [rsi+ISELECT], 128		; interrupt register set
   199 0000125E 00                  <1>
   200 0000125F E903060000          <1> 	jmp	_go2_frame				; yes
   201                              <1> 
   202                              <1> ir_application:
   203 00001264 4889F5              <1> 	mov	rbp, rsi				; application register set
   204 00001267 4889AE98040000      <1> 	mov	qword ptr [rsi+REGISTER_SET], rbp
   205 0000126E C786AC040000000000- <1> 	mov	dword ptr [rsi+ISELECT], 0
   205 00001277 00                  <1>
   206 00001278 E9EA050000          <1> 	jmp	_go2_frame				; eax <- reload iframe name
   207                              <1> 							; ebx <- reload iframe page high index
   208                              <1> 							; edx <- return word offset
    38                                  	%include	"stack.msm"
     1                              <1> ;	stack operations call these to add or subract stack
     2                              <1> ;	limits are checked here
     3                              <1> ;	these routines always leave epb -> all registers 0..255
     4                              <1> ;	because both  interrupt internal stack pointer register 128 + 15
     5                              <1> ;		and application internal stack pointer register 15
     6                              <1> 
     7                              <1> ;	are absolute pointers to the entire register stack
     8                              <1> 
     9                              <1> ;	therefore instructions calling here must afterwards
    10                              <1> 
    11                              <1> ;		mov	ebp, dword ptr [_register_set]
    12                              <1> 
    13                              <1> ;	to get ebp back to application registers 0..127
    14                              <1> ;			or interrupt registers 128..255
    15                              <1> 
    16                              <1> ;	ebp governs which r k x y a b mantissa2 mantissa3 fp sp is implied in the instruction opcode
    17                              <1> ;	registers addressed as operand are always absolute in the range 0..255
    18                              <1> 
    19                              <1> ;	these don't move any data but leave [ebp+ebx*4] pointing to the required stack frame
    20                              <1> ;	and update the stack pointer
    21                              <1> 
    22                              <1> ;	although applications can and must read interrupt registers with load instructions
    23                              <1> ;	they can't read interrupt registers with runaway pop instructions
    24                              <1> ;	because the problem is easier to find with an interrupt as soon as 128+ gets popped
    25                              <1> 
    26                              <1> 
    27                              <1> 
    28                              <1> stack1:
    29                              <1> 	%if	0
    30                              <1> 	mov	ebx, dword ptr [ebp+S_P]
    31                              <1> 	dec	ebx
    32                              <1> 	mov	dword ptr [ebp+S_P], ebx
    33                              <1> 	ret
    34                              <1> 	%endif
    35                              <1> 
    36 0000127D 8B5D3C              <1> 	mov	ebx, dword ptr [rbp+S_P]	; read whichever internal sp
    37 00001280 F686B204000080      <1> 	test	byte ptr [rsi+PSR+2], 128	; ISR ?
    38 00001287 742C                <1> 	jz	stack1_a			; no ?
    39 00001289 81FB00010000        <1> 	cmp	ebx, 256			; in upper range ?
    40 0000128F 0F87C8000000        <1> 	ja	near guard_stack		; no ?
    41 00001295 FFCB                <1> 	dec	ebx				; decrement
    42 00001297 0F88C0000000        <1> 	js	near guard_stack		; < 0 ?
    43 0000129D 81FB98000000        <1> 	cmp	ebx, 128+24	; +2		; in clock registers?
    44 000012A3 730C                <1> 	jnb	stack1_j			;
    45 000012A5 81FB80000000        <1> 	cmp	ebx, 128			; in app stack? Allowed for thread switch
    46 000012AB 0F83AC000000        <1> 	jnb	near guard_stack		; in working registers page
    47                              <1> stack1_j:
    48 000012B1 895D3C              <1> 	mov	dword ptr [rbp+S_P], ebx	; new frame
    49 000012B4 C3                  <1> 	ret
    50                              <1> 
    51                              <1> stack1_a:					; this is application
    52 000012B5 81FB80000000        <1> 	cmp	ebx, 128			; > interrupt register range start
    53 000012BB 0F879C000000        <1> 	ja	near guard_stack		; not allowed
    54 000012C1 FFCB                <1> 	dec	ebx				; decrement
    55 000012C3 0F8894000000        <1> 	js	near guard_stack		; < 0 ?
    56 000012C9 83FB18              <1> 	cmp	ebx, 24				; in control registers ?
    57 000012CC 0F828B000000        <1> 	jb	near guard_stack		; not allowed
    58 000012D2 895D3C              <1> 	mov	dword ptr [rbp+S_P], ebx	; new frame
    59 000012D5 C3                  <1> 	ret
    60                              <1> 
    61                              <1> stack2:
    62                              <1> 	%if	0
    63                              <1> 	mov	ebx, dword ptr [ebp+S_P]
    64                              <1> 	add	ebx, -2
    65                              <1> 	mov	dword ptr [ebp+S_P], ebx
    66                              <1> 	ret
    67                              <1> 	%endif
    68                              <1> 
    69 000012D6 8B5D3C              <1> 	mov	ebx, dword ptr [rbp+S_P]
    70 000012D9 F686B204000080      <1> 	test	byte ptr [rsi+PSR+2], 128
    71 000012E0 742A                <1> 	jz	stack2_a
    72 000012E2 81FB00010000        <1> 	cmp	ebx, 256
    73 000012E8 0F876F000000        <1> 	ja	near guard_stack
    74 000012EE 83C3FE              <1> 	add	ebx, -2
    75 000012F1 0F8866000000        <1> 	js	near guard_stack
    76 000012F7 81FB98000000        <1> 	cmp	ebx, 128+24
    77 000012FD 7309                <1> 	jnb	stack2_j
    78 000012FF 83FB7E              <1> 	cmp	ebx, 128-2
    79 00001302 0F8755000000        <1> 	ja	near guard_stack
    80                              <1> 
    81                              <1> stack2_j:
    82 00001308 895D3C              <1> 	mov	dword ptr [rbp+S_P], ebx
    83 0000130B C3                  <1> 	ret
    84                              <1> 
    85                              <1> stack2_a:
    86 0000130C 81FB80000000        <1> 	cmp	ebx, 128			; application push high limit 128,  ISR 256
    87 00001312 7749                <1> 	ja	guard_stack
    88 00001314 83C3FE              <1> 	add	ebx, -2
    89 00001317 7844                <1> 	js	guard_stack
    90 00001319 83FB18              <1> 	cmp	ebx, 24
    91 0000131C 723F                <1> 	jb	guard_stack			; stack top limit zero ISR and application
    92 0000131E 895D3C              <1> 	mov	dword ptr [rbp+S_P], ebx
    93 00001321 C3                  <1> 	ret
    94                              <1> 
    95                              <1> stack4:
    96                              <1> 	%if	0
    97                              <1> 	mov	ebx, dword ptr [ebp+S_P]
    98                              <1> 	add	ebx, -4
    99                              <1> 	mov	dword ptr [ebp+S_P], ebx
   100                              <1> 	ret
   101                              <1> 	%endif
   102                              <1> 
   103 00001322 8B5D3C              <1> 	mov	ebx, dword ptr [rbp+S_P]
   104 00001325 F686B204000080      <1> 	test	byte ptr [rsi+PSR+2], 128	; read psr interrupt bit
   105 0000132C 741C                <1> 	jz	stack4_a			; stack is registers 24..127
   106 0000132E 81FB00010000        <1> 	cmp	ebx, 256			; stack is registers  0..255
   107 00001334 7727                <1> 	ja	guard_stack
   108 00001336 83C3FC              <1> 	add	ebx, -4				; proposed frame
   109 00001339 7822                <1> 	js	guard_stack			; not lower than register zero
   110 0000133B 81FB98000000        <1> 	cmp	ebx, 128+24
   111 00001341 7303                <1> 	jnb	stack4_j
   112 00001343 83FB7C              <1> 	cmp	ebx, 128-4			; in working registers page
   113                              <1> ;	ja	guard_stack			; caller does that
   114                              <1> 
   115                              <1> stack4_j:
   116 00001346 895D3C              <1> 	mov	dword ptr [rbp+S_P], ebx
   117 00001349 C3                  <1> 	ret					; both sp are absolute pointers
   118                              <1> 
   119                              <1> stack4_a:
   120 0000134A 81FB80000000        <1> 	cmp	ebx, 128			; don't push into a higher register than 127
   121 00001350 770B                <1> 	ja	guard_stack
   122 00001352 83C3FC              <1> 	add	ebx, -4
   123 00001355 7806                <1> 	js	guard_stack
   124 00001357 83FB18              <1> 	cmp	ebx, 24				; dont push lower than 24
   125 0000135A 7201                <1> 	jb	guard_stack
   126                              <1> ;	mov	dword ptr [rbp+S_P], ebx	; caller does that
   127 0000135C C3                  <1> 	ret					; return new frame
   128                              <1> 
   129                              <1> guard_stack:
   130                              <1> stack_underflow:
   131 0000135D 8BAE98040000        <1> 	mov	ebp, dword ptr [rsi+REGISTER_SET] ; esi -> core.REGISTER
   132 00001363 F786B0040000000080- <1> 	test	dword ptr [rsi+PSR], 00800000h	; interrupt mode?
   132 0000136C 00                  <1>
   133 0000136D 0F84BDFDFFFF        <1> 	jz	guard_ii_authority		; sideline the application
   134 00001373 C7453C00010000      <1> 	mov	dword ptr [rbp+S_P], 256	; restart the interrupt stack
   135 0000137A B801000000          <1> 	mov	eax, 1				; so the interrupt can be interrupted
   136 0000137F F60425[19000000]01  <1> 	test	byte ptr [_uflag+'Z'-'A'], 1
   137 00001387 7407                <1> 	jz	gsago
   138 00001389 808EA404000002      <1> 	or	byte ptr [rsi+INDICATION], LOCKSTEP
   139 00001390 E9A5FDFFFF          <1> gsago:	jmp	_ii_escape
   140                              <1> 
   141                              <1> stack_read4:
   142 00001395 BB04000000          <1> 	mov	ebx, 4
   143 0000139A 035D3C              <1> 	add	ebx, dword ptr [rbp+S_P]
   144 0000139D 81FB80000000        <1> 	cmp	ebx, 128			; you can have stack locations up to here
   145 000013A3 7611                <1> 	jna	stack_r4			; whoever you are
   146 000013A5 F686B204000080      <1> 	test	byte ptr [rsi+PSR+2], 128	; any higher you have to be an ISR
   147 000013AC 74AF                <1> 	jz	stack_underflow
   148 000013AE 81FB00010000        <1> 	cmp	ebx, 256			; and then not any higher than this
   149 000013B4 77A7                <1> 	ja	stack_underflow
   150                              <1> 
   151                              <1> stack_r4:
   152 000013B6 875D3C              <1> 	xchg	ebx, dword ptr [rbp+S_P]	; write new stack top
   153 000013B9 C3                  <1> 	ret					; return old stack top
   154                              <1> 
   155                              <1> stack_read2:
   156 000013BA BB02000000          <1> 	mov	ebx, 2
   157 000013BF 035D3C              <1> 	add	ebx, dword ptr [rbp+S_P]
   158 000013C2 81FB80000000        <1> 	cmp	ebx, 128			; you can have stack locations up to here
   159 000013C8 7611                <1> 	jna	stack_r2			; whoever you are
   160 000013CA F686B204000080      <1> 	test	byte ptr [rsi+PSR+2], 128	; any higher you have to be an ISR
   161 000013D1 748A                <1> 	jz	stack_underflow
   162 000013D3 81FB00010000        <1> 	cmp	ebx, 256			; and then not any higher than this
   163 000013D9 7782                <1> 	ja	stack_underflow
   164                              <1> 
   165                              <1> stack_r2:
   166 000013DB 875D3C              <1> 	xchg	ebx, dword ptr [rbp+S_P]	; write new stack top
   167 000013DE C3                  <1> 	ret					; return old stack top
   168                              <1> 
   169                              <1> stack_read1:
   170 000013DF BB01000000          <1> 	mov	ebx, 1				; calculate
   171 000013E4 035D3C              <1> 	add	ebx, dword ptr [rbp+S_P]	; new stack top
   172 000013E7 81FB80000000        <1> 	cmp	ebx, 128			; you can have stack locations up to here
   173 000013ED 7619                <1> 	jna	stack_r1			; whoever you are
   174 000013EF F686B204000080      <1> 	test	byte ptr [rsi+PSR+2], 128	; any higher you have to be an ISR
   175 000013F6 0F8461FFFFFF        <1> 	jz	stack_underflow
   176 000013FC 81FB00010000        <1> 	cmp	ebx, 256			; and then not any higher than this
   177 00001402 0F8755FFFFFF        <1> 	ja	stack_underflow
   178                              <1> 
   179                              <1> stack_r1:
   180 00001408 875D3C              <1> 	xchg	ebx, dword ptr [rbp+S_P]	; write new stack top
   181 0000140B C3                  <1> 	ret					; return old stack top
   182                              <1> 
    39                                  	%include	"return.msm"
     1                              <1> _autoexit:
     2 0000140C B846000000          <1> 	mov	eax, II_EXIT
     3 00001411 B90B000000          <1> 	mov	ecx, LP_AUTOEXIT
     4 00001416 E91FFDFFFF          <1> 	jmp	_ii_escape
     5                              <1> 
     6 0000141B F786B0040000000080- <1> _lret:	test	dword ptr [rsi+PSR], 00800000h
     6 00001424 00                  <1>
     7 00001425 7509                <1> 	jnz	_lret_
     8                              <1> 
     9 00001427 817D3C80000000      <1> 	cmp	dword ptr [rbp+S_P], 128
    10 0000142E 74DC                <1> 	jz	_autoexit
    11                              <1> 
    12 00001430 E8AAFFFFFF          <1> _lret_:	call	stack_read1
    13 00001435 03049E              <1> 	add	eax, dword ptr [rsi+rbx*4]
    14 00001438 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
    15 0000143D E92B020000          <1> 	jmp	_j
    16                              <1> 
    17 00001442 F786B0040000000080- <1> _fret:	test	dword ptr [rsi+PSR], 00800000h
    17 0000144B 00                  <1>
    18 0000144C 7509                <1> 	jnz	_fret_
    19                              <1> 
    20 0000144E 817D3C80000000      <1> 	cmp	dword ptr [rbp+S_P], 128
    21 00001455 74B5                <1> 	jz	_autoexit
    22                              <1> 
    23 00001457 E85EFFFFFF          <1> _fret_:	call	stack_read2
    24 0000145C 4C89A680040000      <1> 	mov	qword ptr [rsi+APC],r12
    25 00001463 4889C2              <1> 	mov	rdx, rax
    26 00001466 03549E04            <1> 	add	edx, dword ptr [rsi+rbx*4+1*4]	; add EA as displacement to offset on stack
    27 0000146A 8B049E              <1> 	mov	eax, dword ptr [rsi+rbx*4]	; return b0_name
    28 0000146D 31DB                <1> 	xor	ebx, ebx			; 1-page frame?
    29 0000146F A900008000          <1> 	test	eax, 00800000h			; multipages frame?
    30 00001474 7418                <1> 	jz	_fret_1page
    31                              <1> 
    32 00001476 89C3                <1> 	mov	ebx, eax
    33 00001478 C1E30A              <1> 	shl	ebx, 2+8			; drop flag bit from b0_name
    34 0000147B 48C1E302            <1> 	shl	rbx, 12-10			; complete multiplication * page
    35                              <1> 
    36                              <1> 	%if	__MOVBE				; read the embedded gate table
    37                              <1> 	movbe	ebx, dword ptr [_memory+rbx*4+64*4]
    38                              <1> 	%else
    39 0000147F 8B1C9D[00010000]    <1> 	mov	ebx, dword ptr [_memory+rbx*4+64*4]
    40 00001486 30C0                <1> 	xor	al, al
    41 00001488 0FCB                <1> 	bswap	ebx
    42                              <1> 	%endif
    43                              <1> 
    44 0000148A 48C1EB12            <1> 	shr	rbx, 18				; ebx <- iframe page high index
    45                              <1> 
    46                              <1> _fret_1page:					; eax <- iframe name
    47 0000148E E9D4030000          <1> 	jmp	_go2_frame			; edx <- word offset
    48                              <1> 
    49 00001493 B803000000          <1> _fpxpo:	mov	eax, II_FPXPO
    50 00001498 B90C000000          <1> 	mov	ecx, LP_RANGE
    51 0000149D E998FCFFFF          <1> 	jmp	_ii_escape
    52                              <1> 
    40                                  	%include	"rta.msm"
     1                              <1> 
     2 000014A2 80F904              <1> _sr:	cmp	cl, I
     3 000014A5 0F845FF8FFFF        <1> 	jz	_inA
     4 000014AB 80F905              <1> 	cmp	cl, XI
     5 000014AE 0F846FFBFFFF        <1> 	jz	_on
     6                              <1> 
     7 000014B4 8B5D00              <1> 	mov	ebx, dword ptr [rbp+R]
     8 000014B7 E901F2FFFF          <1> 	jmp	_operand_write
     9                              <1> 
    10 000014BC 80F904              <1> _sk:	cmp	cl, I
    11 000014BF 0F8452F8FFFF        <1> 	jz	_inB
    12 000014C5 80F905              <1> 	cmp	cl, XI
    13 000014C8 0F845EFBFFFF        <1> 	jz	_off
    14                              <1> 
    15 000014CE 8B5D04              <1> 	mov	ebx, dword ptr [rbp+K]
    16 000014D1 E9E7F1FFFF          <1> 	jmp	_operand_write
    17                              <1> 
    18 000014D6 80F904              <1> _sx:	cmp	cl, I
    19 000014D9 0F8445F8FFFF        <1> 	jz	_outA
    20 000014DF 80F905              <1> 	cmp	cl, XI
    21 000014E2 0F842BF7FFFF        <1> 	jz	_rsr
    22                              <1> 
    23 000014E8 8B5D08              <1> 	mov	ebx, dword ptr [rbp+X]
    24 000014EB E9CDF1FFFF          <1> 	jmp	_operand_write
    25                              <1> 
    26 000014F0 80F904              <1> _sy:	cmp	cl, I
    27 000014F3 0F8434F8FFFF        <1> 	jz	_outB
    28 000014F9 80F905              <1> 	cmp	cl, XI
    29 000014FC 0F8482F7FFFF        <1> 	jz	_wsr
    30                              <1> 
    31 00001502 8B5D0C              <1> 	mov	ebx, dword ptr [rbp+Y]
    32 00001505 E9B3F1FFFF          <1> 	jmp	_operand_write;
    33                              <1> 
    34 0000150A 80F904              <1> _sa:	cmp	cl, I
    35 0000150D 0F84DBF8FFFF        <1> 	jz	_reload
    36 00001513 80F905              <1> 	cmp	cl, XI
    37 00001516 744E                <1> 	jz	escape
    38                              <1> 
    39 00001518 8B5D10              <1> 	mov	ebx, dword ptr [rbp+A]
    40 0000151B E99DF1FFFF          <1> 	jmp	_operand_write
    41                              <1> 
    42 00001520 80F904              <1> _sb:	cmp	cl, I
    43 00001523 7441                <1> 	jz	escape
    44 00001525 80F905              <1> 	cmp	cl, XI
    45 00001528 743C                <1> 	jz	escape
    46                              <1> 
    47 0000152A 8B5D14              <1> 	mov	ebx, dword ptr [rbp+B]
    48 0000152D E98BF1FFFF          <1> 	jmp	_operand_write
    49                              <1> 
    50 00001532 80F904              <1> _z:	cmp	cl, I
    51 00001535 0F84D9F8FFFF        <1> 	jz	_sabr
    52 0000153B 80F905              <1> 	cmp	cl, XI
    53 0000153E 0F84D7FEFFFF        <1> 	jz	_lret
    54 00001544 31DB                <1> 	xor	ebx, ebx
    55 00001546 E972F1FFFF          <1> 	jmp	_operand_write
    56                              <1> 
    57 0000154B 80F904              <1> _pop:	cmp	cl, I
    58 0000154E 7416                <1> 	jz	escape
    59 00001550 80F905              <1> 	cmp	cl, XI
    60 00001553 0F84E9FEFFFF        <1> 	jz	_fret
    61                              <1> 
    62 00001559 E881FEFFFF          <1> 	call	stack_read1
    63 0000155E 8B1C9E              <1> 	mov	ebx, dword ptr [rsi+rbx*4]
    64 00001561 E957F1FFFF          <1> 	jmp	_operand_write
    65                              <1> 
    66 00001566 C3                  <1> escape	ret
    67                              <1> 
    68 00001567 E88EEFFFFF          <1> _lr:	call	_operand_read
    69 0000156C 894500              <1> 	mov	dword ptr [rbp+R], eax
    70 0000156F C3                  <1> 	ret
    71                              <1> 
    72 00001570 E885EFFFFF          <1> _lk:	call	_operand_read
    73 00001575 894504              <1> 	mov	dword ptr [rbp+K], eax
    74 00001578 C3                  <1> 	ret
    75 00001579 E87CEFFFFF          <1> _lx:	call	_operand_read
    76 0000157E 894508              <1> 	mov	dword ptr [rbp+X], eax
    77 00001581 C3                  <1> 	ret
    78                              <1> 
    79 00001582 E873EFFFFF          <1> _ly:	call	_operand_read
    80 00001587 89450C              <1> 	mov	dword ptr [rbp+Y], eax
    81 0000158A C3                  <1> 	ret
    82                              <1> 
    83 0000158B E86AEFFFFF          <1> _la:	call	_operand_read
    84 00001590 894510              <1> 	mov	dword ptr [rbp+A], eax
    85 00001593 C3                  <1> 	ret
    86                              <1> 
    87 00001594 E861EFFFFF          <1> _lb:	call	_operand_read
    88 00001599 894514              <1> 	mov	dword ptr [rbp+B], eax
    89 0000159C C3                  <1> 	ret
    90                              <1> 
    91 0000159D 80F904              <1> _tz:	cmp	cl, I
    92 000015A0 0F8417140000        <1> 	jz	near _rex
    93 000015A6 80F905              <1> 	cmp	cl, XI
    94 000015A9 B900000000          <1> 	mov	ecx, 0
    95 000015AE 0F845BFBFFFF        <1> 	jz	_ii_instruction
    96                              <1> 
    97 000015B4 E841EFFFFF          <1> 	call	_operand_read
    98 000015B9 A9FFFFFF00          <1> 	test	eax, 00FFFFFFh
    99 000015BE 7504                <1> 	jnz	_tz_
   100 000015C0 4983C404            <1> 	add	r12, 4
   101 000015C4 C3                  <1> _tz_:	ret
   102                              <1> 
   103 000015C5 80F904              <1> _tp:	cmp	cl, I
   104 000015C8 742C                <1> 	jz	_jdz
   105 000015CA 80F905              <1> 	cmp	cl, XI
   106 000015CD 0F841BFCFFFF        <1> 	jz	_ir
   107                              <1> 
   108 000015D3 E822EFFFFF          <1> 	call	_operand_read
   109 000015D8 A900008000          <1> 	test	eax, 00800000h
   110 000015DD 7504                <1> 	jnz	_tp_
   111 000015DF 4983C404            <1> 	add	r12, 4
   112 000015E3 C3                  <1> _tp_:	ret
   113                              <1> 
   114 000015E4 E811EFFFFF          <1> _push:	call	_operand_read
   115                              <1> 
   116 000015E9 480F7EFE            <1> 	movq	rsi, mm7
   117                              <1> ;	mov	rsi, qword ptr [rbp+CORE_INDEX1]
   118                              <1> 
   119 000015ED E88BFCFFFF          <1> 	call	stack1
   120 000015F2 89049E              <1> 	mov	dword ptr [rsi+rbx*4], eax
   121 000015F5 C3                  <1> 	ret
   122                              <1> 
   123 000015F6 8B5D14              <1> _jdz:	mov	ebx, dword ptr [rbp+B]
   124 000015F9 0B5D10              <1> 	or	ebx, dword ptr [rbp+A]
   125 000015FC 0F846B000000        <1> 	jz	near _j
   126 00001602 C3                  <1> 	ret
   127                              <1> 
   128 00001603 8B5D00              <1> _jdr:	mov	ebx, dword ptr [rbp+R]		; dec r and jump if it passed from zero to -1
   129 00001606 81C3FFFFFF00        <1> 	add	ebx, 00FFFFFFh
   130 0000160C C1C308              <1> 	rol	ebx, 8
   131 0000160F 88D9                <1> 	mov	cl, bl
   132 00001611 C1EB08              <1> 	shr	ebx, 8				; write back to registers only 00000000 thru 00FFFFFF
   133 00001614 895D00              <1> 	mov	dword ptr [rbp+R], ebx
   134 00001617 F6C101              <1> 	test	cl, 1
   135 0000161A 7551                <1> 	jnz	_j
   136 0000161C C3                  <1> 	ret
   137                              <1> 
   138 0000161D E85BFCFFFF          <1> _lcal:	call	stack1
   139 00001622 4C89E2              <1> 	mov	rdx, r12
   140 00001625 482B9690040000      <1> 	sub	rdx, qword ptr [rsi+B0P]
   141 0000162C 48C1EA02            <1> 	shr	rdx, 2
   142 00001630 89149E              <1> 	mov	dword ptr [rsi+rbx*4], edx
   143                              <1> 
   144                              <1> 	%if	0
   145                              <1> 	shl	rax, 2
   146                              <1> 	add	rax, qword ptr [rsi+B0P]
   147                              <1> 	mov	r12, rax
   148                              <1> 	ret
   149                              <1> 	%endif
   150                              <1> 
   151 00001633 EB38                <1> 	jmp	_j				; EA is in eax
   152                              <1> 
   153 00001635 F786B0040000010000- <1> _jnc:	test	dword ptr [rsi+PSR], 1
   153 0000163E 00                  <1>
   154 0000163F 742C                <1> 	jz	_j
   155 00001641 C3                  <1> 	ret
   156                              <1> 
   157 00001642 F786B0040000010000- <1> _jc:	test	dword ptr [rsi+PSR], 1
   157 0000164B 00                  <1>
   158 0000164C 751F                <1> 	jnz	_j
   159 0000164E C3                  <1> 	ret
   160                              <1> 
   161 0000164F F7451001000000      <1> _jao:	test	dword ptr [rbp+A], 1
   162 00001656 7515                <1> 	jnz	_j
   163 00001658 C3                  <1> 	ret
   164                              <1> 
   165 00001659 F7451000008000      <1> _jpa:	test	dword ptr [rbp+A], 00800000h
   166 00001660 740B                <1> 	jz	_j
   167 00001662 C3                  <1> 	ret
   168                              <1> 
   169 00001663 F7451400008000      <1> _jpb:	test	dword ptr [rbp+B], 00800000h
   170 0000166A 7401                <1> 	jz	_j
   171 0000166C C3                  <1> 	ret
   172                              <1> 
   173 0000166D 48C1E002            <1> _j:	shl	rax, 2
   174 00001671 48038690040000      <1> 	add	rax, qword ptr [rsi+B0P]
   175                              <1> 
   176                              <1> ;	cmp	rax, r13			; there is a range check on instr fetch but 
   177                              <1> ;	ja	_j_check			; if a jump goes wrong the come-from address
   178                              <1> 						; is more use in the interrupt frame
   179 00001678 4989C4              <1> 	mov	r12, rax			; than a wild go-to address
   180 0000167B C3                  <1> 	ret
   181                              <1> 
   182                              <1> _j_check:					; apc before is in rdx
   183                              <1> 						; restore updated apc
   184 0000167C B90E000000          <1> 	mov	ecx, LP_ADDRESS
   185 00001681 E9AFFAFFFF          <1> 	jmp	guard_ii_escape			; for interrupt come-from
   186                              <1> 
   187 00001686 E8C1100000          <1> _jpo:	call	NEAR _get_parity
   188 0000168B 7BE0                <1> 	jpo	_j
   189 0000168D C3                  <1> 	ret
   190                              <1> 
   191 0000168E 816510FFFFFF00      <1> _jza:	and	dword ptr [rbp+A], 00FFFFFFh
   192 00001695 74D6                <1> 	jz	_j
   193 00001697 C3                  <1> 	ret
   194                              <1> 
   195 00001698 816514FFFFFF00      <1> _jzb:	and	dword ptr [rbp+B], 00FFFFFFh
   196 0000169F 74CC                <1> 	jz	_j
   197 000016A1 C3                  <1> 	ret
   198                              <1> 
   199 000016A2 816510FFFFFF00      <1> _jnza:	and	dword ptr [rbp+A], 00FFFFFFh
   200 000016A9 75C2                <1> 	jnz	_j
   201 000016AB C3                  <1> 	ret
   202                              <1> 
   203 000016AC 816514FFFFFF00      <1> _jnzb:	and	dword ptr [rbp+B], 00FFFFFFh
   204 000016B3 75B8                <1> 	jnz	_j
   205 000016B5 C3                  <1> 	ret
   206                              <1> 
   207 000016B6 F7451000008000      <1> _jna:	test	dword ptr [rbp+A], 00800000h
   208 000016BD 75AE                <1> 	jnz	_j
   209 000016BF C3                  <1> 	ret
   210                              <1> 
   211 000016C0 F7451400008000      <1> _jnb:	test	dword ptr [rbp+B], 00800000h
   212 000016C7 75A4                <1> 	jnz	_j
   213 000016C9 C3                  <1> 	ret
   214                              <1> 
   215 000016CA 8B5D08              <1> _jxge:	mov	ebx, dword ptr [rbp+X]
   216 000016CD 2B5D00              <1> 	sub	ebx, dword ptr [rbp+R]
   217 000016D0 F7C300000001        <1> 	test	ebx, 01000000h		; microcarry?
   218 000016D6 7495                <1> 	jz	_j			; no:  x <  r,    jump
   219 000016D8 C3                  <1> 	ret				; yes: x >= r, no jump
   220                              <1> 
   221 000016D9 8B5D0C              <1> _jyge:	mov	ebx, dword ptr [rbp+Y]
   222 000016DC 2B5D00              <1> 	sub	ebx, dword ptr [rbp+R]
   223 000016DF F7C300000001        <1> 	test	ebx, 01000000h		; microcarry?
   224 000016E5 7486                <1> 	jz	_j			; no:  y <  r,    jump
   225 000016E7 C3                  <1> 	ret				; yes: y >= r, no jump
   226                              <1> 
   227 000016E8 BB04000000          <1> _qs:	mov	ebx, a
   228 000016ED E955EFFFFF          <1> 	jmp	_burst_write4
   229                              <1> 
   230 000016F2 BB04000000          <1> _ql:	mov	ebx, a
   231 000016F7 E9D1EDFFFF          <1> 	jmp	_burst_read4
   232                              <1> 
   233 000016FC E894FCFFFF          <1> _qpop:	call	stack_read4			; places 4 stack registers in the scope of burst write
   234 00001701 55                  <1> 	push	rbp
   235                              <1> 
   236 00001702 480F7EFD            <1> 	movq	rbp, mm7
   237                              <1> ;	mov	rbp, qword ptr [ebp+CORE_INDEX1] 
   238                              <1> 
   239 00001706 E83CEFFFFF          <1> 	call	_burst_write4
   240 0000170B 5D                  <1> 	pop	rbp
   241 0000170C C3                  <1> 	ret					; stack pointers are absolute
   242                              <1> 
   243 0000170D E810FCFFFF          <1> _qpush:	call	stack4
   244 00001712 55                  <1> 	push	rbp
   245                              <1> 
   246 00001713 480F7EFD            <1> 	movq	rbp, mm7
   247                              <1> ;	mov	rbp, qword ptr [ebp+CORE_INDEX1]
   248 00001717 E8B1EDFFFF          <1> 	call	_burst_read4
   249 0000171C 5D                  <1> 	pop	rbp
   250 0000171D 67895D3C            <1> 	mov	dword ptr [ebp+S_P], ebx	; not done in stack4 in case
   251 00001721 C3                  <1> 	ret					; RTA1 sp is in the pushed frame
   252                              <1> 						; then it would pop wrong
   253 00001722 E893FCFFFF          <1> _dpop:	call	stack_read2
   254 00001727 55                  <1> 	push	rbp
   255                              <1> 
   256 00001728 480F7EFD            <1> 	movq	rbp, mm7
   257                              <1> ;	mov	rbp, qword ptr [ebp+CORE_INDEX1]
   258 0000172C E85BEFFFFF          <1> 	call	_burst_write2
   259 00001731 5D                  <1> 	pop	rbp
   260 00001732 C3                  <1> 	ret
   261                              <1> 
   262 00001733 E880EDFFFF          <1> _dpush:	call	_burst_read2			; do this before changing RTA1 sp
   263 00001738 89DA                <1> 	mov	edx, ebx			; in case that is in pushed pair
   264                              <1> 
   265 0000173A 480F7EFE            <1> 	movq	rsi, mm7
   266                              <1> ;	mov	rsi, qword ptr [rbp+CORE_INDEX1]
   267                              <1> 
   268 0000173E E893FBFFFF          <1> 	call	stack2				
   269 00001743 89549E04            <1> 	mov	dword ptr [rsi+rbx*4+4], edx	; stack the data
   270 00001747 89049E              <1> 	mov	dword ptr [rsi+rbx*4], eax
   271 0000174A C3                  <1> 	ret
   272                              <1> 
   273 0000174B E8AAEDFFFF          <1> _mta:	call	_operand_read
   274 00001750 334510              <1> 	xor	eax, dword ptr [rbp+A]
   275 00001753 234504              <1> 	and	eax, dword ptr [rbp+K]
   276 00001756 7504                <1> 	jnz	_mta_
   277 00001758 4983C404            <1> 	add	r12, 4		; k AND (a XOR operand) = 0, skip 1 instruction
   278 0000175C C3                  <1> _mta_:	ret
   279                              <1> 
   280 0000175D E856EDFFFF          <1> _dte:	call	_burst_read2
   281 00001762 334510              <1> 	xor	eax, dword ptr [rbp+A]
   282 00001765 7509                <1> 	jnz	_dte_
   283 00001767 335D14              <1> 	xor	ebx, dword ptr [rbp+B]
   284 0000176A 7504                <1> 	jnz	_dte_
   285 0000176C 4983C404            <1> 	add	r12, 4
   286 00001770 C3                  <1> _dte_:	ret	
   287                              <1> 
   288 00001771 8B9EB0040000        <1> _sc:	mov	ebx, dword ptr [rsi+PSR]
   289 00001777 83E301              <1> 	and	ebx, 1		; store carry 
   290 0000177A E93EEFFFFF          <1> 	jmp	_operand_write
   291                              <1> 
   292 0000177F E876EDFFFF          <1> _mlb:	call	_operand_read
   293 00001784 8B5D04              <1> 	mov	ebx, dword ptr [rbp+K]
   294 00001787 21D8                <1> 	and	eax, ebx
   295 00001789 81F3FFFFFF00        <1> 	xor	ebx, 00FFFFFFh
   296 0000178F 235D14              <1> 	and	ebx, dword ptr [rbp+B]
   297 00001792 09C3                <1> 	or	ebx, eax
   298 00001794 895D14              <1> 	mov	dword ptr [rbp+B], ebx	; b = (b AND (NOT k)) OR (operand AND k)
   299 00001797 C3                  <1> 	ret
   300                              <1> 
   301 00001798 BB04000000          <1> _ds:	mov	ebx, a
   302 0000179D E9EAEEFFFF          <1> 	jmp	_burst_write2
   303                              <1> 
   304 000017A2 E811EDFFFF          <1> _dl:	call	_burst_read2
   305 000017A7 895D14              <1> 	mov	dword ptr [rbp+B], ebx
   306 000017AA 894510              <1> 	mov	dword ptr [rbp+A], eax
   307 000017AD C3                  <1> 	ret
   308                              <1> 
   309 000017AE C3                  <1> _spare:	ret
   310                              <1> 
   311 000017AF E8ABF0FFFF          <1> _ex:	call	memory_read
   312                              <1> 
   313 000017B4 480F7EFE            <1> 	movq	rsi, mm7
   314                              <1> ;	mov	rsi, qword ptr [rbp+CORE_INDEX1]
   315                              <1> 
   316 000017B8 E9BDE9FFFF          <1> 	jmp	_execute
   317                              <1> 
   318 000017BD E8D9F0FFFF          <1> _ts:	call	memory_lock			; edi + rsi -> memory word
   319 000017C2 66B80080            <1> 	mov	ax, 08000h
   320 000017C6 668704B7            <1> 	xchg	ax, word ptr [rdi+rsi*4]	; swap -> t1 for 080 under lock
   321 000017CA 6621C0              <1> 	and	ax, ax
   322 000017CD 7804                <1> 	js	_ts___				; no action if already locked
   323                              <1> 
   324 000017CF 4983C404            <1> 	add	r12, 4				; skip if ms bit was clear before
   325                              <1> 
   326 000017D3 C3                  <1> _ts___:	ret
   327                              <1> 
   328                              <1> 
   329 000017D4 E893F0FFFF          <1> _sim:	call	memoreg				; edi -> device		edi <- NULL
   330                              <1> 						; rsi -> word	OR	ebx -> register
   331 000017D9 480F7EF9            <1> 	movq	rcx, mm7			; eax <- data
   332                              <1> ;	mov	ecx, dword ptr [rbp+CORE_INDEX1]
   333                              <1> 
   334 000017DD 66C1E008            <1> 	shl	ax, 8
   335 000017E1 8A81B2040000        <1> 	mov	al, byte ptr [rcx+PSR+2]
   336 000017E7 C1C803              <1> 	ror	eax, 3
   337 000017EA C0C003              <1> 	rol	al, 3
   338 000017ED 8881B2040000        <1> 	mov	byte ptr [rcx+PSR+2], al
   339 000017F3 C1E81D              <1> 	shr	eax, 32-3
   340                              <1> 
   341 000017F6 E94EF0FFFF          <1> 	jmp	memoreg_writeback
   342                              <1> 
   343 000017FB 4C89E2              <1> _call:	mov	rdx, r12				; copy [ pc -> ] in case the jump interrupts
   344 000017FE E8D3FAFFFF          <1> 	call	stack2					; frame
   345 00001803 482B9690040000      <1> 	sub	rdx, qword ptr [rsi+B0P]		; pc - page address on platform
   346 0000180A 48C1EA02            <1> 	shr	rdx, 2					; / 4 = RTA1 word offset
   347 0000180E 89549E04            <1> 	mov	dword ptr [rsi+rbx*4+1*4], edx		; -> stack frame + 1
   348 00001812 8B96B4040000        <1> 	mov	edx, dword ptr [rsi+B0_NAME]		; iframe name
   349 00001818 89149E              <1> 	mov	dword ptr [rsi+rbx*4], edx		; -> stack frame + 0
   350                              <1> 
   351 0000181B 4C89A680040000      <1> _go:	mov	qword ptr [rsi+APC], r12		; write back actual platform value up2 here
   352                              <1> 							; of emulated [ program counter -> ]
   353 00001822 E8D3ECFFFF          <1> 	call	_operand_read
   354                              <1> 
   355 00001827 480F7EFE            <1> 	movq	rsi, mm7
   356                              <1> ;	mov	rsi, qword ptr [rbp+CORE_INDEX1]	; regain core pointer
   357                              <1> 
   358 0000182B 89C2                <1> 	mov	edx, eax				; lookaside to calculate the vector
   359 0000182D A900008000          <1> 	test	eax, 00800000h				; gate?			
   360 00001832 7426                <1> 	jz	_go2_4k_frame				; one page fixed target iframe 
   361                              <1> 
   362 00001834 25FFFF7F00          <1> 	and	eax, 007FFFFFh				; read the gate constant / variable
   363 00001839 E87AECFFFF          <1> 	call	_burst_read2				; into eax : ebx
   364                              <1> 
   365 0000183E 480F7EFE            <1> 	movq	rsi, mm7
   366                              <1> ;	mov	rsi, qword ptr [rbp+CORE_INDEX1]	; retrieve core pointer
   367                              <1> 
   368 00001842 89C2                <1> 	mov	edx, eax				; page high index ++ word offset 6.18
   369 00001844 89D8                <1> 	mov	eax, ebx				; iframe name
   370 00001846 C1C20E              <1> 	rol	edx, 6+8				; roll down page high index + 2 flag bits
   371 00001849 89D3                <1> 	mov	ebx, edx				; instruction frame page high index
   372 0000184B 83E33F              <1> 	and	ebx, 63					; remove flag bits 
   373 0000184E 7405                <1> 	jz	_go_gate				; page high index zero -> one page iframe
   374 00001850 0D00008000          <1> 	or	eax, 00800000h				; two+ page iframe
   375                              <1> 
   376                              <1> _go_gate:
   377 00001855 C1EA0E              <1> 	shr	edx, 6+8				; net word offset
   378                              <1> 
   379 00001858 EB0D                <1> 	jmp	_go2_frame
   380                              <1> 	
   381                              <1> _go2_4k_frame:
   382 0000185A 83E23F              <1> 	and	edx, 63					; target is in 4k block, 64 vectors
   383 0000185D C1E806              <1> 	shr	eax, 6					; new b0_name
   384 00001860 25FFFF0000          <1> 	and	eax, 0000FFFFh				; bit 22 of GO / CALL word reserved
   385 00001865 31DB                <1> 	xor	ebx, ebx				; frame high page index
   386                              <1> 
   387                              <1> _go2_frame:
   388 00001867 F686B204000080      <1> 	test	byte ptr [rsi+PSR+2], 128		; already in interrupt code?
   389 0000186E 751C                <1> 	jnz	_go2_base_frame			 	; may branch into interrupt code
   390                              <1> 							; because already interrupt code
   391 00001870 89C1                <1> 	mov	ecx, eax				; iframe name
   392 00001872 81E1FFFF3F00        <1> 	and	ecx, 03FFFFFh				; minus flag bits
   393 00001878 2B8E00060000        <1> 	sub	ecx, dword ptr [rsi+IO_PORT+_APP_THRESHOLD]	; applications lower limit
   394 0000187E 7D0C                <1> 	jnl	_go2_base_frame				; you can
   395                              <1> 
   396 00001880 4C8BA680040000      <1> 	mov	r12, qword ptr [rsi+APC]		; you can't
   397 00001887 E9A4F8FFFF          <1> 	jmp	guard_ii_authority
   398                              <1> 
   399                              <1> _go2_base_frame:
   400                              <1> 
   401 0000188C 8986B4040000        <1> 	mov	dword ptr [rsi+B0_NAME], eax		; iframe name with flags
   402 00001892 25FFFF3F00          <1> 	and	eax, 003FFFFFh				; start page index without flags
   403 00001897 01C3                <1> 	add	ebx, eax				; iframe highest page
   404 00001899 899EE0050000        <1> 	mov	dword ptr [rsi+IO_PORT+_IFRAME_U], ebx	; port 64 <- iframe highest page
   405                              <1> 
   406 0000189F 8B8EE0060000        <1> 	mov	ecx, dword ptr [rsi+IO_PORT+_DEVICE]	; memory page high index
   407 000018A5 81E1FFFF3F00        <1> 	and	ecx, 003FFFFFh				; strip memory type bits
   408 000018AB 29D9                <1> 	sub	ecx, ebx				; iframe high page may be = not >
   409 000018AD 7911                <1> 	jns	_go2_frame_in_range			; you can
   410                              <1> 
   411 000018AF B90E000000          <1> 	mov	ecx, LP_ADDRESS
   412 000018B4 4C8BA680040000      <1> 	mov	r12, qword ptr [rsi+APC]		; you can't
   413 000018BB E975F8FFFF          <1> 	jmp	guard_ii_escape
   414                              <1> 
   415                              <1> _go2_frame_in_range:
   416                              <1> 
   417 000018C0 48C1E30C            <1> 	shl	rbx, 12					; multiply highest page by page size
   418 000018C4 4C8D2C9D[FC3F0000]  <1> 	lea	r13, [_memory+rbx*4+4095*4]		; last instruction word in iframe
   419                              <1> 							; higher = wrong
   420 000018CC 4C89AE88040000      <1> 	mov	qword ptr [rsi+APCZ], r13		; set execution limit pointer
   421                              <1> 
   422 000018D3 8986E0040000        <1> 	mov	dword ptr [rsi+IO_PORT], eax		; write B0 <- iframe start page index
   423 000018D9 48C1E00E            <1> 	shl	rax, 12+2				; 4kword block multiplied by 4 for word
   424 000018DD 4805[00000000]      <1> 	add	rax, _memory				; add the platform location of executable space
   425 000018E3 898690040000        <1> 	mov	dword ptr [rsi+B0P], eax		; store address in platform of B0 page start
   426 000018E9 C1E202              <1> 	shl	edx, 2					; add the vector offset * 4 for word
   427 000018EC 4801C2              <1> 	add	rdx, rax				; absolute apc + _memory
   428 000018EF 4989D4              <1> 	mov	r12, rdx
   429 000018F2 C3                  <1> _go_:	ret
   430                              <1> 
    41                                  	%include	"alu.msm"
     1                              <1> 
     2                              <1> 
     3 000018F3 E802ECFFFF          <1> _ax:	call	_operand_read
     4 000018F8 034508              <1> 	add	eax, dword ptr [rbp+X]
     5 000018FB 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
     6 00001900 894508              <1> 	mov	dword ptr [rbp+X], eax
     7 00001903 C3                  <1> 	ret
     8                              <1> 
     9 00001904 E8F1EBFFFF          <1> _ay:	call	_operand_read
    10 00001909 03450C              <1> 	add	eax, dword ptr [rbp+Y]
    11 0000190C 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
    12 00001911 89450C              <1> 	mov	dword ptr [rbp+Y], eax
    13 00001914 C3                  <1> 	ret
    14                              <1> 
    15 00001915 E8E0EBFFFF          <1> _or:	call	_operand_read
    16 0000191A 094510              <1> 	or	dword ptr [rbp+A], eax
    17 0000191D C3                  <1> 	ret
    18                              <1> 
    19 0000191E E8D7EBFFFF          <1> _orB:	call	_operand_read
    20 00001923 094514              <1> 	or	dword ptr [rbp+B], eax
    21 00001926 C3                  <1> 	ret
    22                              <1> 
    23 00001927 E8CEEBFFFF          <1> _and:	call	_operand_read
    24 0000192C 214510              <1> 	and	dword ptr [rbp+A], eax
    25 0000192F C3                  <1> 	ret
    26                              <1> 
    27 00001930 E8C5EBFFFF          <1> _andB:	call	_operand_read
    28 00001935 214514              <1> 	and	dword ptr [rbp+B], eax
    29 00001938 C3                  <1> 	ret
    30                              <1> 
    31 00001939 E8BCEBFFFF          <1> _xor:	call	_operand_read
    32 0000193E 314510              <1> 	xor	dword ptr [rbp+A], eax
    33 00001941 C3                  <1> 	ret
    34                              <1> 
    35 00001942 E8B3EBFFFF          <1> _xorB:	call	_operand_read
    36 00001947 314514              <1> 	xor	dword ptr [rbp+B], eax
    37 0000194A C3                  <1> 	ret
    38                              <1> 
    39 0000194B E8AAEBFFFF          <1> _aa:	call	_operand_read
    40 00001950 EB0D                <1> 	jmp	_aa_
    41                              <1> 
    42 00001952 E8A3EBFFFF          <1> _ana:	call	_operand_read
    43 00001957 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
    44 0000195C 83C001              <1> 	add	eax, 1
    45                              <1> 
    46 0000195F 034510              <1> _aa_:	add	eax, dword ptr [rbp+A]
    47 00001962 E8B9040000          <1> 	call	_alu_carry
    48                              <1> 
    49 00001967 894510              <1> 	mov	dword ptr [rbp+A], eax
    50 0000196A C3                  <1> 	ret
    51                              <1> 
    52 0000196B E88AEBFFFF          <1> _ab:	call	_operand_read
    53 00001970 EB0D                <1> 	jmp	_ab_
    54                              <1> 
    55 00001972 E883EBFFFF          <1> _anb:	call	_operand_read
    56 00001977 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
    57 0000197C 83C001              <1> 	add	eax, 1
    58                              <1> 
    59 0000197F 034514              <1> _ab_:	add	eax, dword ptr [rbp+B]
    60 00001982 E899040000          <1> 	call	_alu_carry
    61                              <1> 
    62 00001987 894514              <1> 	mov	dword ptr [rbp+B], eax
    63 0000198A C3                  <1> 	ret
    64                              <1> 
    65                              <1> _m:
    66                              <1> ;	push	rdx			; 80386 platform has it ready made, so
    67 0000198B E86AEBFFFF          <1> 	call	_operand_read
    68 00001990 C1E008              <1> 	shl	eax, 8			; prepare multiplier to be multiplicand 
    69 00001993 C1F808              <1> 	sar	eax, 8			; sign it in eax
    70 00001996 8B5D14              <1> 	mov	ebx, dword ptr [rbp+B]	; this is register side multiplicand but
    71                              <1> 					; it makes no difference which is which
    72 00001999 C1E308              <1> 	shl	ebx, 8			; so use it as multiplier if that is OK
    73 0000199C C1FB08              <1> 	sar	ebx, 8			; sign it first
    74                              <1> 
    75 0000199F F7EB                <1> 	imul	ebx
    76                              <1> 
    77 000019A1 C1C008              <1> 	rol	eax, 8			; move 8 bits up from eax to edx
    78 000019A4 C1E208              <1> 	shl	edx, 8
    79 000019A7 88C2                <1> 	mov	dl, al
    80 000019A9 C1E808              <1> 	shr	eax, 8
    81 000019AC 894514              <1> 	mov	dword ptr [rbp+B], eax	; product bits 23..0
    82 000019AF C1E208              <1> 	shl	edx, 8
    83 000019B2 C1EA08              <1> 	shr	edx, 8
    84 000019B5 895510              <1> 	mov	dword ptr [rbp+A], edx	; product high order bits
    85                              <1> ;	pop	rdx
    86 000019B8 C3                  <1> 	ret
    87                              <1> 
    88                              <1> _mf:
    89                              <1> ;	push	rdx		; the multiplier is signed the multiplicand unsigned
    90 000019B9 E83CEBFFFF          <1> 	call	_operand_read
    91 000019BE 89C1                <1> 	mov	ecx, eax	; just to remember the multiplier sign
    92 000019C0 A900008000          <1> 	test	eax, 00800000h
    93 000019C5 7408                <1> 	jz	_mfplusplus
    94 000019C7 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
    95 000019CC 83C001              <1> 	add	eax, 1
    96                              <1> _mfplusplus:
    97 000019CF 8B5D14              <1> 	mov	ebx, dword ptr [rbp+B]	; this is the multiplicand, unsigned
    98 000019D2 F7E3                <1> 	mul	ebx		; two 24-bit unsigned values should be OK here
    99 000019D4 C1C008              <1> 	rol	eax, 8
   100 000019D7 C1E208              <1> 	shl	edx, 8
   101 000019DA 88C2                <1> 	mov	dl, al
   102 000019DC C1E808              <1> 	shr	eax, 8
   103 000019DF C1E208              <1> 	shl	edx, 8
   104 000019E2 C1EA08              <1> 	shr	edx, 8
   105 000019E5 F7C100008000        <1> 	test	ecx, 00800000h	; was the multiplier signed?
   106 000019EB 741F                <1> 	jz	_mfstore
   107 000019ED 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   108 000019F2 81F2FFFFFF00        <1> 	xor	edx, 00FFFFFFh
   109 000019F8 83C001              <1> 	add	eax, 1
   110 000019FB C1C008              <1> 	rol	eax, 8
   111 000019FE 0FB6C8              <1> 	movzx	ecx, al
   112 00001A01 C1E808              <1> 	shr	eax, 8
   113 00001A04 01CA                <1> 	add	edx, ecx
   114 00001A06 81E2FFFFFF00        <1> 	and	edx, 00FFFFFFh
   115                              <1> _mfstore:
   116 00001A0C 894514              <1> 	mov	dword ptr [rbp+B], eax
   117 00001A0F 895510              <1> 	mov	dword ptr [rbp+A], edx
   118                              <1> ;	pop	rdx
   119 00001A12 C3                  <1> 	ret
   120                              <1> 
   121 00001A13 BF04000000          <1> _d:	mov	rdi, a
   122 00001A18 E80A000000          <1> 	call	_divide
   123 00001A1D 895D10              <1> 	mov	dword ptr [rbp+A], ebx
   124 00001A20 894518              <1> 	mov	dword ptr [rbp+MANTISSA2], eax
   125 00001A23 894D14              <1> 	mov	dword ptr [rbp+B], ecx
   126 00001A26 C3                  <1> 	ret
   127                              <1> 
   128                              <1> 	%if	1
   129                              <1> 
   130                              <1> ;	this divide made from 2 Intel divides should be a better method
   131                              <1> ;	than the procession of 1-bit shifts and test subtracts
   132                              <1> ;	which is the %else which it replaces. That also works
   133                              <1> 
   134                              <1> ;	this converts to and from positive magnitude
   135                              <1> ;	because zoning the 2nd divide with a zero 1st remainder
   136                              <1> ;	can't tell +0 from -0 in platform 2s complement
   137                              <1> 
   138                              <1> ;	polarity conversions before and after need no explanation
   139                              <1> 
   140                              <1> ;	1st dividend is 48 zero bits and high order 16 data bits
   141                              <1> ;	of the the 48-bit RTA1 dividend
   142                              <1> 
   143                              <1> ;	2nd dividend is 1st remainder and the remaining 32 bits
   144                              <1> ;	the the RTA1 dividend
   145                              <1> 
   146                              <1> ;	input is compressed from 24-bit words and output unpacked
   147                              <1> ;	to 24-bit words
   148                              <1> 
   149                              <1> ;	64-bit dividend in 386 mode is high order bits in edx, low in eax
   150                              <1> ;	platform faults if quotient carries from eax. Remainder in edx
   151                              <1> 
   152                              <1> ;	RTA1 quotient is 48 bits so it takes 2 divides in 32-bit mode
   153                              <1> 
   154                              <1> _divide:
   155                              <1> ;	push	edx
   156 00001A27 57                  <1> 	push	rdi
   157 00001A28 E8CDEAFFFF          <1> 	call	_operand_read	; read divisor
   158 00001A2D 5F                  <1> 	pop	rdi
   159 00001A2E 31C9                <1> 	xor	ecx, ecx	; final sign
   160 00001A30 A900008000          <1> 	test	eax, 00800000h
   161 00001A35 7409                <1> 	jz	_dsig?
   162 00001A37 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   163 00001A3C F7D1                <1> 	not	ecx		; reverse final sign
   164 00001A3E FFC0                <1> 	inc	eax
   165 00001A40 25FFFFFF00          <1> _dsig?:	and	eax, 00FFFFFFh	; check zerodiv here mebbes
   166 00001A45 89C3                <1> 	mov	ebx, eax	; eax will be used twice as divisor LS word
   167 00001A47 746E                <1> 	jz	_d_ont		; zero results in eax ebx already
   168                              <1> 
   169 00001A49 8B44BD04            <1> 	mov	eax, dword ptr [rbp+rdi*4+4]
   170 00001A4D 8B54BD00            <1> 	mov	edx, dword ptr [rbp+rdi*4]
   171 00001A51 C1E008              <1> 	shl	eax, 8		; pack two 24-bit words to 64 bits 
   172 00001A54 88D0                <1> 	mov	al, dl
   173 00001A56 C1C808              <1> 	ror	eax, 8
   174 00001A59 C1E208              <1> 	shl	edx, 8
   175 00001A5C C1EA10              <1> 	shr	edx, 16
   176 00001A5F 6689D1              <1> 	mov	cx, dx		; save dividend sign
   177 00001A62 6621D2              <1> 	and	dx, dx		; bit 47 on?
   178 00001A65 7912                <1> 	jns	_dive_in
   179                              <1> 
   180 00001A67 81F10000FFFF        <1> 	xor	ecx, 0FFFF0000h	; reverse final sign
   181 00001A6D F7D0                <1> 	not	eax
   182 00001A6F 66F7D2              <1> 	not	dx
   183 00001A72 83C001              <1> 	add	eax, 1
   184 00001A75 6683D200            <1> 	adc	dx, 0
   185                              <1> 
   186                              <1> _dive_in:
   187 00001A79 89C6                <1> 	mov	esi, eax	; reserve 2nd dividend
   188 00001A7B 89D0                <1> 	mov	eax, edx	; position 1st dividend
   189 00001A7D 31D2                <1> 	xor	edx, edx	; with leading zero
   190 00001A7F F7F3                <1> 	div	ebx
   191 00001A81 96                  <1> 	xchg	eax, esi	; save 1st quotient
   192 00001A82 F7F3                <1> 	div	ebx		; generate 2nd quotient
   193                              <1> 
   194 00001A84 6621C9              <1> 	and	cx, cx		; dividend negative?
   195 00001A87 7904                <1> 	jns	_d_remainder_plus
   196 00001A89 F7D2                <1> 	not	edx
   197 00001A8B FFC2                <1> 	inc	edx
   198                              <1> 
   199                              <1> _d_remainder_plus:
   200 00001A8D 81E2FFFFFF00        <1> 	and	edx, 00FFFFFFh
   201 00001A93 87D1                <1> 	xchg	edx, ecx	; remainder -> ecx / final sign -> edx
   202                              <1> 
   203 00001A95 89C3                <1> 	mov	ebx, eax	; low order quotient
   204 00001A97 89F0                <1> 	mov	eax, esi	; high order quotient
   205                              <1> 
   206 00001A99 21D2                <1> 	and	edx, edx	; final sign?
   207 00001A9B 790C                <1> 	jns	_d_quotient_plus
   208                              <1> 
   209 00001A9D F7D3                <1> 	not	ebx		; invert + increment quotient
   210 00001A9F 66F7D0              <1> 	not	ax		; RTA1 integer is also 2s complement
   211 00001AA2 83C301              <1> 	add	ebx, 1
   212 00001AA5 6683D000            <1> 	adc	ax, 0
   213                              <1> 
   214                              <1> _d_quotient_plus:
   215 00001AA9 0FB7C0              <1> 	movzx	eax, ax		; unpack from 32-bit words to 24-bit words
   216 00001AAC C1E008              <1> 	shl	eax, 8		; move 8 bits up
   217 00001AAF C1C308              <1> 	rol	ebx, 8
   218 00001AB2 88D8                <1> 	mov	al, bl
   219 00001AB4 C1EB08              <1> 	shr	ebx, 8		; quotient in eax:ebx
   220                              <1> 
   221                              <1> _d_ont:
   222                              <1> ;	pop	edx		; give back the emulated program counter
   223 00001AB7 C3                  <1> 	ret
   224                              <1> 
   225                              <1> 	%else
   226                              <1> 
   227                              <1> _divide:
   228                              <1> 	xor	ebx, ebx
   229                              <1> 	push	ebx		;
   230                              <1> 	push	ebx		; quotient
   231                              <1> 	push	ebx		; dividend[b]
   232                              <1> 	push	ebx		; dividend[a]
   233                              <1> 	push	ebx		; trailing divisor
   234                              <1> 	push	ebx		; divisor
   235                              <1> 	push	ebx		; signs2 
   236                              <1> 	push	ebx		; signs1
   237                              <1> 	mov	ebx, 24
   238                              <1> 	push	ebx		; beats
   239                              <1> 
   240                              <1> 
   241                              <1> _D_BEATS	equ	0
   242                              <1> _D_SIGNS1	equ	1*4
   243                              <1> _D_SIGNS2	equ	2*4
   244                              <1> _D_DIVISORU	equ	3*4
   245                              <1> _D_DIVISORL	equ	4*4
   246                              <1> _D_DIVIDENDU	equ	5*4
   247                              <1> _D_DIVIDENDL	equ	6*4
   248                              <1> _D_QUOTIENTU	equ	7*4
   249                              <1> _D_QUOTIENTL	equ	8*4
   250                              <1> 
   251                              <1> 	push	edi
   252                              <1> 	call	_operand_read
   253                              <1> 	pop	edi
   254                              <1> 
   255                              <1> 	test	eax, 00800000h
   256                              <1> 	jnz	_d_nmagnitude1			; must be stored negative
   257                              <1> 	xor	eax, 00FFFFFFh
   258                              <1> 	jmp	_d_nmagnitude2
   259                              <1> _d_nmagnitude1:
   260                              <1> 	add	eax, -1				; if it's already negative
   261                              <1> 	mov	dword ptr [rsp+_D_SIGNS2], 0FFFFFFFFh
   262                              <1> _d_nmagnitude2:
   263                              <1> 	call	qscale
   264                              <1> 	cmp	bl, 24
   265                              <1> 	jz	_d_allsigns
   266                              <1> 	add	dword ptr [rsp+_D_BEATS], ebx
   267                              <1> _d_allsigns:
   268                              <1> 	mov	ebx, 00FFFFFF00h ; make the divisor 48 bits contiguous	
   269                              <1> 	mov	bl, al
   270                              <1> 	ror	ebx, 8
   271                              <1> 	shl	eax, 8
   272                              <1> 	mov	ax, 65535
   273                              <1> 	ror	eax, 16
   274                              <1> 
   275                              <1> 	mov	dword ptr [rsp+_D_DIVISORL], ebx
   276                              <1> 	mov	dword ptr [rsp+_D_DIVISORU], eax
   277                              <1> 
   278                              <1> 	mov	ecx, 1				; precarry
   279                              <1> 
   280                              <1> ;	mov	ebx, dword ptr [rbp+B]	; dividend
   281                              <1> ;	mov	eax, dword ptr [rbp+A]
   282                              <1> 
   283                              <1> 	mov	ebx, dword ptr [rbp+edi*4+4]
   284                              <1> 	mov	eax, dword ptr [rbp+edi*4] 
   285                              <1> 
   286                              <1> 	test	eax, 00800000h
   287                              <1> 	jz	_d_pmagnitude			; must be stored positive
   288                              <1> 	mov	dword ptr [rsp+_D_SIGNS1], 00FFFFFFFFh
   289                              <1> 	xor	ebx, 00FFFFFFh
   290                              <1> 	xor	eax, 00FFFFFFh
   291                              <1> 	add	ecx, ebx
   292                              <1> 	mov	ebx, ecx
   293                              <1> 	and	ebx, 00FFFFFFh
   294                              <1> 	shr	ecx, 24
   295                              <1> 	add	eax, ecx
   296                              <1> 	and	eax, 00FFFFFFh
   297                              <1> 
   298                              <1> _d_pmagnitude:
   299                              <1> 	shl	ebx, 8
   300                              <1> 	mov	bl, al
   301                              <1> 	ror	ebx, 8
   302                              <1> 	shl	eax, 8
   303                              <1> 	shr	eax, 16
   304                              <1> 	mov	dword ptr [rsp+_D_DIVIDENDL], ebx
   305                              <1> 	mov	dword ptr [rsp+_D_DIVIDENDU], eax
   306                              <1> 
   307                              <1> 	mov	ecx, dword ptr [rsp+_D_BEATS]
   308                              <1> 
   309                              <1> 	add	ecx, -1
   310                              <1> _d_beat:			; iterative part as quick as possible
   311                              <1> 				; could study doing a pair of Intel divides here
   312                              <1> 	stc
   313                              <1> 	rcr	dword ptr [rsp+_D_DIVISORU], 1
   314                              <1> 	rcr	dword ptr [rsp+_D_DIVISORL], 1
   315                              <1> 
   316                              <1> 	stc
   317                              <1> 	adc	ebx, dword ptr [rsp+_D_DIVISORL]
   318                              <1> 	adc	eax, dword ptr [rsp+_D_DIVISORU]
   319                              <1> 
   320                              <1> 	jc	_d_carried
   321                              <1> 	mov	ebx, dword ptr [rsp+_D_DIVIDENDL]
   322                              <1> 	mov	eax, dword ptr [rsp+_D_DIVIDENDU]
   323                              <1> 	jmp	_d_carried_or_not
   324                              <1> 
   325                              <1> _d_carried:
   326                              <1> 	mov	dword ptr [rsp+_D_DIVIDENDL], ebx
   327                              <1> 	mov	dword ptr [rsp+_D_DIVIDENDU], eax
   328                              <1> 
   329                              <1> _d_carried_or_not:
   330                              <1> 	rcl	dword ptr [rsp+_D_QUOTIENTL], 1
   331                              <1> 	rcl	dword ptr [rsp+_D_QUOTIENTU], 1
   332                              <1> 	
   333                              <1> 	add	ecx, -1
   334                              <1> 	jc	_d_beat
   335                              <1> 
   336                              <1> 	pop	ecx		; BEATS
   337                              <1> 	pop	ecx		; SIGNS1
   338                              <1> 	pop	eax		; SIGNS2
   339                              <1> 	pop	ebx		; DIVISORU
   340                              <1> 	pop	ebx		; DIVISORL
   341                              <1> 	pop	ebx		; DIVIDENDU
   342                              <1> 	pop	ebx		; DIVIDENDL
   343                              <1> 
   344                              <1> 	xor	ebx, ecx	; set remainder to sign of dividend
   345                              <1> 	jns	_d_remplus
   346                              <1> 	inc	ebx		; set -remainder 2s complement
   347                              <1> 
   348                              <1> _d_remplus:
   349                              <1> 	and	ebx, 00FFFFFFh	; store remainder
   350                              <1> ;	mov	dword ptr [rbp+B], ebx
   351                              <1> 
   352                              <1> 	xor	ecx, eax	; set sign of quotient to difference of signs
   353                              <1> 	mov	ecx, ebx	; remainder for return
   354                              <1> 	pop	eax		; QUOTIENTU
   355                              <1> 	pop	ebx		; QUOTIENTL
   356                              <1> 
   357                              <1> 	jns	_d_quotient_plus		; cc set from xor of signy
   358                              <1> 
   359                              <1> 	not	eax
   360                              <1> 	not	ebx
   361                              <1> 	add	ebx, 1
   362                              <1> 	adc	eax, 0
   363                              <1> 
   364                              <1> _d_quotient_plus:
   365                              <1> 	shl	eax, 8
   366                              <1> 	rol	ebx, 8
   367                              <1> 	mov	al, bl
   368                              <1> 	shr	ebx, 8
   369                              <1> 	shl	eax, 8
   370                              <1> 	shr	eax, 8
   371                              <1> 
   372                              <1> ;	mov	dword ptr [rbp+A], ebx
   373                              <1> ;	mov	dword ptr [rbp+MANTISSA2], eax
   374                              <1> 	ret
   375                              <1> 
   376                              <1> 	%endif
   377                              <1> 
   378                              <1> 
   379 00001AB8 88C1                <1> _sar:	mov	cl, al			; eax shift radix is 31
   380 00001ABA 8B4510              <1> 	mov	eax, dword ptr [rbp+A]
   381 00001ABD F6C1E0              <1> 	test	cl, -32
   382 00001AC0 7402                <1> 	jz	_sardo
   383 00001AC2 31C0                <1> 	xor	eax, eax		; shift 32+ clears same as 24+
   384 00001AC4 D3E8                <1> _sardo:	shr	eax, cl
   385 00001AC6 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   386 00001ACB 894510              <1> 	mov	dword ptr [rbp+A], eax
   387 00001ACE C3                  <1> 	ret
   388                              <1> 
   389 00001ACF 88C1                <1> _sbr:	mov	cl, al
   390 00001AD1 8B4514              <1> 	mov	eax, dword ptr [rbp+B]
   391 00001AD4 F6C1E0              <1> 	test	cl, -32
   392 00001AD7 7402                <1> 	jz	_sbrdo
   393 00001AD9 31C0                <1> 	xor	eax, eax		; shift 32+ clears same as 24+
   394 00001ADB D3E8                <1> _sbrdo:	shr	eax, cl
   395 00001ADD 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   396 00001AE2 894514              <1> 	mov	dword ptr [rbp+B], eax
   397 00001AE5 C3                  <1> 	ret
   398                              <1> 
   399                              <1> 
   400 00001AE6 88C1                <1> _dsr:	mov	cl, al
   401 00001AE8 8B5D14              <1> 	mov	ebx, dword ptr [rbp+B]
   402 00001AEB 8B4510              <1> 	mov	eax, dword ptr [rbp+A]
   403 00001AEE E875000000          <1> 	call	dsr
   404 00001AF3 895D14              <1> 	mov	dword ptr [rbp+B], ebx
   405 00001AF6 894510              <1> 	mov	dword ptr [rbp+A], eax
   406 00001AF9 C3                  <1> 	ret
   407                              <1> 
   408 00001AFA 88C1                <1> _sal:	mov	cl, al			; shift radix eax is 31
   409 00001AFC 8B4510              <1> 	mov	eax, dword ptr [rbp+A]
   410 00001AFF F6C1E0              <1> 	test	cl, -32
   411 00001B02 7402                <1> 	jz	_saldo
   412 00001B04 31C0                <1> 	xor	eax, eax		; shift 32+ clears same as 24+
   413 00001B06 D3E0                <1> _saldo:	shl	eax, cl
   414 00001B08 25FFFFFF00          <1> 	and	eax, 00FFFFFFh		; write back to registers only 00000000 thru 00FFFFFF
   415 00001B0D 894510              <1> 	mov	dword ptr [rbp+A], eax
   416 00001B10 C3                  <1> 	ret
   417                              <1> 
   418 00001B11 88C1                <1> _sbl:	mov	cl, al
   419 00001B13 8B4514              <1> 	mov	eax, dword ptr [rbp+B]
   420 00001B16 F6C1E0              <1> 	test	cl,-32
   421 00001B19 7402                <1> 	jz	_sbldo
   422 00001B1B 31C0                <1> 	xor	eax, eax		; shift 32+ clears same as 24+
   423 00001B1D D3E0                <1> _sbldo:	shl	eax, cl
   424 00001B1F 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   425 00001B24 894514              <1> 	mov	dword ptr [rbp+B], eax
   426 00001B27 C3                  <1> 	ret
   427                              <1> 
   428 00001B28 88C1                <1> _dsl	mov	cl, al
   429 00001B2A 8B5D14              <1> 	mov	ebx, dword ptr [rbp+B]
   430 00001B2D 8B4510              <1> 	mov	eax, dword ptr [rbp+A]
   431 00001B30 E868000000          <1> 	call	dsl
   432 00001B35 895D14              <1> 	mov	dword ptr [rbp+B], ebx
   433 00001B38 894510              <1> 	mov	dword ptr [rbp+A], eax
   434 00001B3B C3                  <1> 	ret
   435                              <1> 
   436 00001B3C 8B5D10              <1> _rar:	mov	ebx, dword ptr [rbp+A]
   437 00001B3F E8C6000000          <1> 	call	rr
   438 00001B44 895D10              <1> 	mov	dword ptr [rbp+A], ebx
   439 00001B47 C3                  <1> 	ret
   440                              <1> 
   441 00001B48 8B5D14              <1> _rbr:	mov	ebx, dword ptr [rbp+B]
   442 00001B4B E8BA000000          <1> 	call	rr
   443 00001B50 895D14              <1> 	mov	dword ptr [rbp+B], ebx
   444 00001B53 C3                  <1> 	ret
   445                              <1> 
   446 00001B54 88C1                <1> _drr:	mov	cl, al
   447 00001B56 8B5D14              <1> 	mov	ebx, dword ptr [rbp+B]
   448 00001B59 8B4510              <1> 	mov	eax, dword ptr [rbp+A]
   449 00001B5C E8F7000000          <1> 	call	drr
   450 00001B61 895D14              <1> 	mov	dword ptr [rbp+B], ebx
   451 00001B64 894510              <1> 	mov	dword ptr [rbp+A], eax
   452 00001B67 C3                  <1> 	ret
   453                              <1> 
   454                              <1> 
   455 00001B68 C1E008              <1> dsr:	shl	eax, 8
   456 00001B6B C1E308              <1> 	shl	ebx, 8
   457 00001B6E 80C1E8              <1> dsru:	add	cl, -24
   458 00001B71 7306                <1> 	jnc	dsrl
   459 00001B73 89C3                <1> 	mov	ebx, eax
   460 00001B75 31C0                <1> 	xor	eax, eax
   461 00001B77 EBF5                <1> 	jmp	dsru
   462 00001B79 80C110              <1> dsrl:	add	cl, 16
   463 00001B7C 730D                <1> 	jnc	dsr7
   464 00001B7E C1E808              <1> dsr8:	shr	eax, 8
   465 00001B81 88C3                <1> 	mov	bl, al
   466 00001B83 C1CB08              <1> 	ror	ebx, 8
   467 00001B86 80C1F8              <1> 	add	cl,-8
   468 00001B89 72F3                <1> 	jc	dsr8
   469 00001B8B 80E107              <1> dsr7:	and	cl, 7
   470 00001B8E D3E8                <1> 	shr	eax, cl
   471 00001B90 88C3                <1> 	mov	bl, al		; bits from al in high-order positions bl
   472 00001B92 D2C3                <1> 	rol	bl, cl		; roll them to low-order positions
   473 00001B94 D3CB                <1> 	ror	ebx, cl
   474 00001B96 C1EB08              <1> 	shr	ebx, 8
   475 00001B99 C1E808              <1> 	shr	eax, 8
   476 00001B9C C3                  <1> 	ret
   477                              <1> 
   478 00001B9D C1E008              <1> dsl:	shl	eax, 8
   479 00001BA0 C1E308              <1> 	shl	ebx, 8
   480 00001BA3 80C1E8              <1> dslu:	add	cl, -24
   481 00001BA6 7306                <1> 	jnc	dsll
   482 00001BA8 89D8                <1> 	mov	eax, ebx
   483 00001BAA 31DB                <1> 	xor	ebx, ebx
   484 00001BAC EBF5                <1> 	jmp	dslu
   485 00001BAE 80C110              <1> dsll:	add	cl, 16
   486 00001BB1 730F                <1> 	jnc	dsl7
   487 00001BB3 C1C308              <1> dsl8:	rol	ebx, 8
   488 00001BB6 88D8                <1> 	mov	al, bl
   489 00001BB8 30DB                <1> 	xor	bl, bl
   490 00001BBA C1E008              <1> 	shl	eax, 8
   491 00001BBD 80C1F8              <1> 	add	cl, -8
   492 00001BC0 72F1                <1> 	jc	dsl8
   493 00001BC2 80E107              <1> dsl7:	and	cl, 7
   494 00001BC5 D3C3                <1> 	rol	ebx, cl
   495 00001BC7 88D8                <1> 	mov	al, bl		; bits from bl in low-order positions al
   496 00001BC9 D2C8                <1> 	ror	al, cl		; roll them to high-order positions
   497 00001BCB D3E0                <1> 	shl	eax, cl
   498 00001BCD C1EB08              <1> 	shr	ebx, 8
   499 00001BD0 C1E808              <1> 	shr	eax, 8
   500 00001BD3 C3                  <1> 	ret
   501                              <1> 
   502 00001BD4 C1E008              <1> dsa:	shl	eax, 8
   503 00001BD7 C1E308              <1> 	shl	ebx, 8
   504 00001BDA 80C1E8              <1> dsa24:	add	cl, -24
   505 00001BDD 7307                <1> 	jnc	dsa16
   506 00001BDF 89C3                <1> 	mov	ebx, eax
   507 00001BE1 C1F818              <1> 	sar	eax, 24
   508 00001BE4 EBF4                <1> 	jmp	dsa24
   509 00001BE6 80C110              <1> dsa16:	add	cl, 16
   510 00001BE9 730D                <1> 	jnc	dsa7
   511 00001BEB C1F808              <1> dsa8:	sar	eax, 8
   512 00001BEE 88C3                <1> 	mov	bl, al
   513 00001BF0 C1CB08              <1> 	ror	ebx, 8
   514 00001BF3 80C1F8              <1> 	add	cl, -8
   515 00001BF6 72F3                <1> 	jc	dsa8
   516 00001BF8 80E107              <1> dsa7:	and	cl, 7
   517 00001BFB D3F8                <1> 	sar	eax, cl
   518 00001BFD 88C3                <1> 	mov	bl, al		; bits from al in high-order positions bl
   519 00001BFF D2C3                <1> 	rol	bl, cl		; roll them to low-order positions
   520 00001C01 D3CB                <1> 	ror	ebx, cl
   521 00001C03 C1E808              <1> 	shr	eax, 8
   522 00001C06 C1EB08              <1> 	shr	ebx, 8
   523 00001C09 C3                  <1> 	ret	
   524                              <1> 
   525                              <1> 
   526 00001C0A 88C1                <1> rr:	mov	cl, al
   527 00001C0C C1E308              <1> 	shl	ebx, 8
   528 00001C0F F6C118              <1> 	test	cl, 24		; bits 16:8 are self-cancelling
   529 00001C12 7A11                <1> 	jpe	rr7
   530 00001C14 F6C110              <1> 	test	cl, 16
   531 00001C17 7407                <1> 	jz	rr8		; 16 is off so 8 is on
   532 00001C19 C1C308              <1> 	rol	ebx, 8		; 8 left in 24-bit ring = 16 right
   533 00001C1C 88DF                <1> 	mov	bh, bl		; compress 32-bit ring to 24-bit
   534 00001C1E EB05                <1> 	jmp	short rr7
   535 00001C20 88FB                <1> rr8:	mov	bl, bh		; extend 24-bit ring to 32-bit
   536 00001C22 C1CB08              <1> 	ror	ebx, 8
   537 00001C25 80E107              <1> rr7:	and	cl, 7		; isolate remaining count bits
   538 00001C28 88FB                <1> 	mov	bl, bh		; don't ask, just do it
   539 00001C2A D3CB                <1> 	ror	ebx, cl
   540 00001C2C C1EB08              <1> 	shr	ebx, 8
   541 00001C2F C3                  <1> 	ret
   542                              <1> 
   543 00001C30 88C1                <1> rl:	mov	cl, al
   544 00001C32 C1E308              <1> 	shl	ebx, 8
   545 00001C35 F6C118              <1> 	test	cl, 24		; bits 16:8 are self-cancelling
   546 00001C38 7A11                <1> 	jpe	rl7
   547 00001C3A F6C110              <1> 	test	cl, 16
   548 00001C3D 7407                <1> 	jz	rl8		; 16 is off so 8 is on
   549 00001C3F 88FB                <1> 	mov	bl, bh		; extend 24-bit ring to 32-bit
   550 00001C41 C1CB08              <1> 	ror	ebx, 8		; 8 right in 24-bit ring = 16 left
   551 00001C44 EB05                <1> 	jmp	short rl7
   552 00001C46 C1C308              <1> rl8:	rol	ebx, 8
   553 00001C49 88DF                <1> 	mov	bh, bl		; compress 32-bit ring to 24-bit	
   554 00001C4B 80E107              <1> rl7:	and	cl, 7
   555 00001C4E 30DB                <1> 	xor	bl, bl
   556 00001C50 D3C3                <1> 	rol	ebx, cl
   557 00001C52 08DF                <1> 	or	bh, bl
   558 00001C54 C1EB08              <1> 	shr	ebx, 8
   559 00001C57 C3                  <1> 	ret
   560                              <1> 
   561 00001C58 C1E008              <1> drr:	shl	eax, 8
   562 00001C5B C1E308              <1> 	shl	ebx, 8
   563                              <1> 
   564 00001C5E F6C130              <1> 	test	cl, 48		; bits 32:16 are self-cancelling
   565 00001C61 7B07                <1> 	jpo	drr24		; rotate 48 = zero or 56 = 8 positions
   566 00001C63 F6C108              <1> 	test	cl, 8		; parity = pe dans le pays d'Intel
   567 00001C66 741C                <1> 	jz	drr7
   568 00001C68 EB15                <1> 	jmp	drr_cdrr8
   569                              <1> 
   570 00001C6A 93                  <1> drr24:	xchg	eax, ebx	; rotate 24 right or left as you wish
   571 00001C6B F6C118              <1> 	test	cl, 24
   572 00001C6E 7A0D                <1> 	jpe	drr24_32	; pattern is 100xxx or 011xxx
   573 00001C70 F6C108              <1> 	test	cl, 8		; pattern is 010xxx or 101xxx
   574 00001C73 7401                <1> 	jz	drrl8		; pattern is 010
   575 00001C75 93                  <1> 	xchg	eax, ebx	; swap back, pattern 101 = 40 right = 8 left 
   576 00001C76 E828000000          <1> drrl8:	call	near drl8	; pattern is 010
   577 00001C7B EB07                <1> 	jmp	short drr7 	; already rotated 24 right, now 8 left
   578                              <1> 
   579                              <1> drr24_32:
   580 00001C7D 7505                <1> 	jnz	drr7		; pattern is 011 = rotate 24. We did
   581                              <1> drr_cdrr8:
   582 00001C7F E814000000          <1> 	call	near drr8	; pattern is 100 = rotate 32
   583 00001C84 80E107              <1> drr7:	and	cl, 7
   584 00001C87 7408                <1> 	jz	drrx
   585 00001C89 88E3                <1> 	mov	bl, ah		; rotate low bits ebx 31:8 to eax high positions
   586 00001C8B 88F8                <1> 	mov	al, bh		; rotate low bits eax 31:8 to ebx high positions
   587 00001C8D D3C8                <1> 	ror	eax, cl		; bits from bh in low order positions al
   588 00001C8F D3CB                <1> 	ror	ebx, cl		; bits from ah in low order positions bl
   589 00001C91 C1E808              <1> drrx:	shr	eax, 8
   590 00001C94 C1EB08              <1> 	shr	ebx, 8
   591 00001C97 C3                  <1> 	ret
   592                              <1> 
   593 00001C98 88E3                <1> drr8:   mov     bl, ah          ; cross 8 bits from one 32-bit ring to another
   594 00001C9A 88F8                <1>         mov     al, bh		
   595 00001C9C C1C808              <1>         ror     eax, 8
   596 00001C9F C1CB08              <1>         ror     ebx, 8
   597 00001CA2 C3                  <1>         ret
   598                              <1> 
   599 00001CA3 C1C008              <1> drl8:   rol     eax, 8
   600 00001CA6 C1C308              <1>         rol     ebx, 8
   601 00001CA9 88DC                <1>         mov     ah, bl          ; cross 8 bits from one 32-bit ring to another
   602 00001CAB 88C7                <1>         mov     bh, al
   603 00001CAD C3                  <1>         ret
   604                              <1> 
   605 00001CAE C1E008              <1> drl:	shl	eax, 8
   606 00001CB1 C1E308              <1> 	shl	ebx, 8
   607 00001CB4 F6C130              <1> 	test	cl, 48		; values 32:16 cancel each other
   608 00001CB7 7B07                <1> 	jpo	drl24
   609 00001CB9 F6C108              <1> 	test	cl, 8
   610 00001CBC 741C                <1> 	jz	drl7
   611 00001CBE EB15                <1> 	jmp	short drl_cdrl8
   612                              <1> 
   613 00001CC0 93                  <1> drl24:	xchg	eax, ebx
   614 00001CC1 F6C118              <1> 	test	cl, 24
   615 00001CC4 7A0D                <1> 	jpe	drl24_32	; pattern is 011xxx or 100xxx
   616 00001CC6 F6C108              <1> 	test	cl, 8		; pattern is 010xxx or 101xxx
   617 00001CC9 7401                <1> 	jz	drlr8		; pattern is 010 = 16 left = 8 right
   618 00001CCB 93                  <1> 	xchg	eax, ebx	; swap back, pattern = 101 = 40 left = 8 right
   619 00001CCC E8C7FFFFFF          <1> drlr8:	call	drr8
   620 00001CD1 EB07                <1> 	jmp	short drl7
   621                              <1> 
   622                              <1> drl24_32:
   623 00001CD3 7505                <1> 	jnz	drl7		; pattern is 011 = rotate24. We did
   624                              <1> drl_cdrl8:			; pattern = 100xxx or 001xxx, rotate 8 more
   625 00001CD5 E8C9FFFFFF          <1> 	call	drl8
   626 00001CDA 80E107              <1> drl7:	and	cl, 7		; rotate positions 0..7
   627 00001CDD 30C0                <1> 	xor	al, al
   628 00001CDF 30DB                <1> 	xor	bl, bl
   629 00001CE1 D3C0                <1> 	rol	eax, cl
   630 00001CE3 D3C3                <1> 	rol	ebx, cl
   631 00001CE5 08DC                <1> 	or	ah, bl
   632 00001CE7 08C7                <1> 	or	bh, al
   633 00001CE9 C1E808              <1> 	shr	eax, 8
   634 00001CEC C1EB08              <1> 	shr	ebx, 8
   635 00001CEF C3                  <1> 	ret
   636                              <1> 
   637 00001CF0 8B5D10              <1> _ral:	mov	ebx, dword ptr [rbp+A]
   638 00001CF3 E838FFFFFF          <1> 	call	rl
   639 00001CF8 895D10              <1> 	mov	dword ptr [rbp+A], ebx
   640 00001CFB C3                  <1> 	ret
   641                              <1> 
   642 00001CFC 8B5D14              <1> _rbl:	mov	ebx, dword ptr [rbp+B]
   643 00001CFF E82CFFFFFF          <1> 	call	rl
   644 00001D04 895D14              <1> 	mov	dword ptr [rbp+B], ebx
   645 00001D07 C3                  <1> 	ret	
   646                              <1> 
   647 00001D08 88C1                <1> _drl:	mov	cl, al
   648 00001D0A 8B4510              <1> 	mov	eax, dword ptr [rbp+A]
   649 00001D0D 8B5D14              <1> 	mov	ebx, dword ptr [rbp+B]
   650 00001D10 E899FFFFFF          <1> 	call	drl
   651 00001D15 895D14              <1> 	mov	dword ptr [rbp+B], ebx
   652 00001D18 894510              <1> 	mov	dword ptr [rbp+A], eax
   653 00001D1B C3                  <1> 	ret
   654                              <1> 
   655 00001D1C 88C1                <1> _saa:	mov	cl, al
   656 00001D1E 8B4510              <1> 	mov	eax, dword ptr [rbp+A]
   657 00001D21 C1E008              <1> 	shl	eax, 8
   658 00001D24 D3F8                <1> 	sar	eax, cl
   659 00001D26 C1E808              <1> 	shr	eax, 8
   660 00001D29 894510              <1> 	mov	dword ptr [rbp+A], eax
   661 00001D2C C3                  <1> 	ret
   662                              <1> 
   663 00001D2D 88C1                <1> _sba:	mov	cl, al
   664 00001D2F 8B5D14              <1> 	mov	ebx, dword ptr [rbp+B]
   665 00001D32 C1E308              <1> 	shl	ebx, 8
   666 00001D35 D3FB                <1> 	sar	ebx, cl
   667 00001D37 C1EB08              <1> 	shr	ebx, 8
   668 00001D3A 895D14              <1> 	mov	dword ptr [rbp+B], ebx
   669 00001D3D C3                  <1> 	ret
   670                              <1> 
   671 00001D3E 88C1                <1> _dsa:	mov	cl, al
   672 00001D40 8B5D14              <1> 	mov	ebx, dword ptr [rbp+B]
   673 00001D43 8B4510              <1> 	mov	eax, dword ptr [rbp+A]
   674 00001D46 E889FEFFFF          <1> 	call	dsa
   675 00001D4B 895D14              <1> 	mov	dword ptr [rbp+B], ebx
   676 00001D4E 894510              <1> 	mov	dword ptr [rbp+A], eax
   677 00001D51 C3                  <1> 	ret
   678                              <1> 
   679 00001D52 E815EBFFFF          <1> _n:	call	memoreg
   680 00001D57 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   681 00001D5C E9E8EAFFFF          <1> 	jmp	memoreg_writeback
   682                              <1> 
   683 00001D61 E806EBFFFF          <1> _inc:	call	memoreg
   684 00001D66 FFC0                <1> 	inc	eax
   685 00001D68 E9DCEAFFFF          <1> 	jmp	memoreg_writeback
   686                              <1> 
   687 00001D6D E8FAEAFFFF          <1> _dec:	call	memoreg
   688 00001D72 FFC8                <1> 	dec	eax
   689 00001D74 E9D0EAFFFF          <1> 	jmp	memoreg_writeback
   690                              <1> 
   691 00001D79 E8EEEAFFFF          <1> _src:	call	memoreg
   692 00001D7E C1E008              <1> 	shl	eax, 8
   693 00001D81 8A86B0040000        <1> 	mov	al, byte ptr [rsi+PSR]
   694 00001D87 D1C8                <1> 	ror	eax, 1
   695 00001D89 D0C0                <1> 	rol	al, 1
   696 00001D8B 8886B0040000        <1> 	mov	byte ptr [rsi+PSR], al
   697 00001D91 C1E808              <1> 	shr	eax, 8
   698 00001D94 E9B0EAFFFF          <1> 	jmp	memoreg_writeback
   699                              <1> 
   700 00001D99 E8CEEAFFFF          <1> _slc:	call	memoreg
   701 00001D9E C1E008              <1> 	shl	eax, 8
   702 00001DA1 8A86B0040000        <1> 	mov	al, byte ptr [rsi+PSR]
   703 00001DA7 D0C8                <1> 	ror	al, 1
   704 00001DA9 D1C0                <1> 	rol	eax, 1
   705 00001DAB 8886B0040000        <1> 	mov	byte ptr [rsi+PSR], al
   706 00001DB1 C1E808              <1> 	shr	eax, 8
   707 00001DB4 E990EAFFFF          <1> 	jmp	memoreg_writeback
   708                              <1> 
   709                              <1> 	%if	0
   710                              <1> _popA:	call	stack_read1				; ebx <- stack pointer
   711                              <1> 	mov	ebx, dword ptr [rsi+ebx*4+REGISTER]	; stack word
   712                              <1> 
   713                              <1> 	mov	ecx, rsi				; keep core.REGISTER *
   714                              <1> 	push	ebx
   715                              <1> 	call	memoreg					; reply is memory edi + rsi ->
   716                              <1> 							;     or register rsi + ebx ->
   717                              <1> 	add	eax, dword ptr [rsp]
   718                              <1> 	add	rsp, 4
   719                              <1> 
   720                              <1> 	rol	eax, 8					; carry -> LS bit
   721                              <1> 	and	al, 1
   722                              <1> 
   723                              <1> 	and	byte ptr [ecx+PSR], 254
   724                              <1> 	or	byte ptr [ecx+PSR], al
   725                              <1> 	shr	eax, 8					; resulting value without carry
   726                              <1> 	jmp	memoreg_writeback			; eax -> target
   727                              <1> 							; [ edi ] + rsi -> memory / register
   728                              <1> 	%else
   729                              <1> 
   730 00001DB9 E8AEEAFFFF          <1> _popA:	call	memoreg					; eax <- addend for update
   731 00001DBE 53                  <1> 	push	rbx					; ebx -> writeback register
   732 00001DBF 56                  <1> 	push	rsi					; or [ edi esi ] -> writeback memory word
   733                              <1> 
   734 00001DC0 480F7EFE            <1> 	movq	rsi, mm7
   735                              <1> ;	mov	rsi, qword ptr [rbp+CORE_INDEX1]	; get back the smp core for PSR and...
   736                              <1> 							; total register array and...
   737                              <1> 							; whichever of [ 2 * RTA1 sp ] is in ebx *
   738                              <1> 							; that is simple position in register list
   739                              <1> 							; not application / ISR relative as in rbp
   740                              <1> 							; although each (RTA1 sp) MOSTLY operates
   741                              <1> 							; its own portions of the register array
   742                              <1> 							; CORE_INDEX is in both scopes of rbp :-)
   743                              <1> 
   744 00001DC4 E816F6FFFF          <1> 	call	stack_read1				; ebx -> old (RTA1 internal stack) sp
   745 00001DC9 03049E              <1> 	add	eax, dword ptr [rsi+rbx*4+REGISTER]	; add word from internal stack
   746                              <1> 
   747 00001DCC C1C008              <1> 	rol	eax, 8					; isolate carry out of bit 23
   748 00001DCF 2401                <1> 	and	al, 1
   749 00001DD1 8B9EB0040000        <1> 	mov	ebx, dword ptr [rsi+PSR]		; platform memory read then write MIGHT
   750 00001DD7 80E3FE              <1> 	and	bl, 254					; be better than 2 * read : write cycle
   751 00001DDA 08C3                <1> 	or	bl, al
   752 00001DDC 899EB0040000        <1> 	mov	dword ptr [rsi+PSR], ebx		; write PSR back
   753                              <1> 
   754 00001DE2 C1E808              <1> 	shr	eax, 8					; reposition and clean result
   755                              <1> 
   756 00001DE5 5E                  <1> 	pop	rsi					; retrieve possible storage offset
   757 00001DE6 5B                  <1> 	pop	rbx					; retrieve possible register writeback
   758 00001DE7 E95DEAFFFF          <1> 	jmp	memoreg_writeback
   759                              <1> 
   760                              <1> 	%endif
   761                              <1> 	
   762 00001DEC E8C7E6FFFF          <1> _da:	call	_burst_read2
   763 00001DF1 EB12                <1> 	jmp	_da_
   764                              <1> 
   765 00001DF3 E8C0E6FFFF          <1> _dan:	call	_burst_read2
   766 00001DF8 81F3FFFFFF00        <1> 	xor	ebx, 00FFFFFFh
   767 00001DFE 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   768 00001E03 FFC3                <1> 	inc	ebx			; carry from bit 23 
   769                              <1> 					; remains in bit 24 for now
   770                              <1> 
   771 00001E05 035D14              <1> _da_:	add	ebx, [rbp+B]
   772 00001E08 C1E308              <1> 	shl	ebx, 8
   773 00001E0B 83D000              <1> 	adc	eax, 0
   774 00001E0E C1EB08              <1> 	shr	ebx, 8
   775 00001E11 895D14              <1> 	mov	[rbp+B], ebx
   776 00001E14 034510              <1> 	add	eax, [rbp+A]
   777 00001E17 E804000000          <1> 	call	_alu_carry
   778 00001E1C 894510              <1> 	mov	[rbp+A], eax
   779 00001E1F C3                  <1> 	ret
   780                              <1> 
   781                              <1> _alu_carry:
   782 00001E20 480F7EFE            <1> 	movq	rsi, mm7
   783                              <1> ;	mov	rsi, qword ptr [rbp+CORE_INDEX1]
   784 00001E24 C1C008              <1> 	rol	eax, 8
   785 00001E27 2401                <1> 	and	al, 1
   786 00001E29 80A6B0040000FE      <1> 	and	byte ptr [rsi+PSR], 254
   787 00001E30 0886B0040000        <1> 	or	byte ptr [rsi+PSR], al
   788 00001E36 C1E808              <1> 	shr	eax, 8
   789 00001E39 C3                  <1> 	ret
   790                              <1> 
   791 00001E3A 040302020101010100- <1> scalex	db	4,3,2,2, 1,1,1,1, 0,0,0,0, 0,0,0,0
   791 00001E43 00000000000000      <1>
   792                              <1> 
   793                              <1> field_scale:			; examine 24-bit integer in 8-position steps
   794 00001E4A C1C008              <1> 	rol	eax, 8		; until high-order 8 bits are not all signs
   795 00001E4D 88C4                <1> 	mov	ah, al
   796 00001E4F 30E8                <1> 	xor	al, ch
   797 00001E51 7509                <1> 	jnz	not8signs
   798 00001E53 80C108              <1> 	add	cl, 8
   799 00001E56 80F918              <1> 	cmp	cl, 24
   800 00001E59 72EF                <1> 	jb	field_scale
   801 00001E5B C3                  <1> 	ret			; 24 signs = the RTA1 computer word
   802                              <1> not8signs:			; al = 0 indicates it
   803 00001E5C A8F0                <1> 	test	al, 240		; move back some positions but keep counting up
   804 00001E5E 7506                <1> 	jnz	scale_u
   805 00001E60 80C104              <1> 	add	cl, 4
   806 00001E63 C0C004              <1> 	rol	al, 4
   807                              <1> scale_u:
   808 00001E66 C0E804              <1> 	shr	al, 4
   809 00001E69 480FB6F0            <1> 	movzx	rsi, al		; add to count-up 1..7
   810 00001E6D 028E[3A1E0000]      <1> 	add	cl, [rsi+scalex]
   811 00001E73 51                  <1> 	push	rcx		; roll back 7..1 positions
   812 00001E74 80E107              <1> 	and	cl, 7
   813 00001E77 80F107              <1> 	xor	cl, 7
   814 00001E7A 80C101              <1> 	add	cl, 1
   815 00001E7D 88E0                <1> 	mov	al, ah
   816 00001E7F D3C8                <1> 	ror	eax, cl
   817 00001E81 59                  <1> 	pop	rcx
   818 00001E82 C3                  <1> 	ret
   819                              <1> 
   820 00001E83 C1E008              <1> qscale:	shl	eax, 8		; 1.2.3
   821 00001E86 C1F808              <1> 	sar	eax, 8		; s.1.2.3
   822 00001E89 C1C008              <1> 	rol	eax, 8		; 1.2.3.s
   823 00001E8C 6631C9              <1> 	xor	cx, cx
   824 00001E8F 88C5                <1> 	mov	ch, al		; keep 8 sign bits
   825 00001E91 E8B4FFFFFF          <1> 	call	field_scale
   826                              <1> 
   827 00001E96 0FB6D9              <1> 	movzx	ebx, cl
   828                              <1> 
   829 00001E99 C1E808              <1> 	shr	eax, 8
   830 00001E9C C3                  <1> 	ret
   831                              <1> 
   832 00001E9D E858E6FFFF          <1> _lsc:	call	_operand_read
   833 00001EA2 E8DCFFFFFF          <1> 	call	qscale
   834 00001EA7 895D14              <1> 	mov	dword ptr [rbp+B], ebx	; store the scale
   835 00001EAA 894510              <1> 	mov	dword ptr [rbp+A], eax	; store the rotated value
   836 00001EAD C3                  <1> 	ret
   837                              <1> 
   838 00001EAE E805E6FFFF          <1> _dlsc:	call	_burst_read2
   839 00001EB3 894510              <1> 	mov	dword ptr [rbp+A], eax		; keep original 1st word
   840 00001EB6 C1E008              <1> 	shl	eax, 8
   841 00001EB9 C1F808              <1> 	sar	eax, 8
   842 00001EBC C1C008              <1> 	rol	eax, 8
   843 00001EBF 6631C9              <1> 	xor	cx, cx
   844 00001EC2 88C5                <1> 	mov	ch, al				; keep 8 sign bits
   845 00001EC4 E881FFFFFF          <1> 	call	field_scale
   846 00001EC9 20C0                <1> 	and	al, al
   847 00001ECB 7415                <1> 	jz	_dlsc24				; if the first word is all signs
   848                              <1> 
   849 00001ECD 0FB6C1              <1> 	movzx	eax, cl
   850 00001ED0 894518              <1> 	mov	dword ptr [rbp+MANTISSA2], eax	; store the scale
   851 00001ED3 8B4510              <1> 	mov	eax, dword ptr [rbp+A]		; retrieve the input high order word
   852 00001ED6 E8D3FDFFFF          <1> 	call	drl				; scale the two input words per cl
   853 00001EDB 895D14              <1> 	mov	dword ptr [rbp+B], ebx
   854 00001EDE 894510              <1> 	mov	dword ptr [rbp+A], eax  	; store the rotated value
   855 00001EE1 C3                  <1> 	ret
   856                              <1> 
   857                              <1> _dlsc24:				; different when high order word is all signs
   858 00001EE2 C1E808              <1> 	shr	eax, 8			; one result word of signs
   859 00001EE5 894514              <1> 	mov	dword ptr [rbp+B], eax	; into the low-order result word
   860 00001EE8 89D8                <1> 	mov	eax, ebx		; scale the low-order input
   861 00001EEA C1E008              <1> 	shl	eax, 8
   862 00001EED 30C9                <1> 	xor	cl, cl			; restart the scale count-up
   863 00001EEF E856FFFFFF          <1> 	call	field_scale
   864 00001EF4 80C118              <1> 	add	cl, 24			; restore the early part of the count-up
   865                              <1> 
   866 00001EF7 0FB6D9              <1> 	movzx	ebx, cl
   867 00001EFA 895D18              <1> 	mov	dword ptr [rbp+MANTISSA2], ebx	; store the scale
   868                              <1> 
   869 00001EFD C1E808              <1> 	shr	eax, 8
   870 00001F00 894510              <1> 	mov	dword ptr [rbp+A], eax	; store the rotated value
   871 00001F03 C3                  <1> 	ret
   872                              <1> 
   873                              <1> 	%if	0
   874                              <1> 
   875                              <1> _fpx:	call	_burst_read2		; data read in eax ebx
   876                              <1> 
   877                              <1> 	movq	rsi, mm7
   878                              <1> ;	mov	rsi, dword ptr [rbp+CORE_INDEX1]
   879                              <1> 
   880                              <1> 	push	ebx			; ebx is used in RTA1 stack frame
   881                              <1> 	call	stack4			; construct RTA1 stack frame
   882                              <1> 
   883                              <1> 	shl	eax, 4			; move 12 mantissa bits out of eax
   884                              <1> 	movsx	ecx, ax			; and extend the normalising bit
   885                              <1> 
   886                              <1> 	rol	eax, 4+1		; shelter sign in eax bit 0
   887                              <1> 	shl	ax, 12			; better still in eax bit 12
   888                              <1> 	sar	eax, 12			; propagate the value at midpoint position
   889                              <1> 	ror	eax, 1			; have the sign back
   890                              <1> 	shr	eax, 8			; clear eax 31..24
   891                              <1> 	xor	eax, 003ffc00h		; reverse the 12 copies of midpoint bit
   892                              <1> 					; yon's ra complicated bit done
   893                              <1> 	mov	dword ptr [rbp+ebx*4], eax
   894                              <1> 
   895                              <1> 	xor	eax, ecx		; is the normalising bit opposite to signs ?
   896                              <1> 	test	eax, 00800000h
   897                              <1> 	jz	_fpx_allsigns		; no so unnormalised = zero
   898                              <1> 
   899                              <1> 	pop	eax			; the 2nd operand word, ya remember?
   900                              <1> 	shl	eax, 4			; get them 2 halves over the centre
   901                              <1> 
   902                              <1> 	shr	cx, 4			; zero quartets at high order of 16 bits
   903                              <1> 	shr	ax, 4
   904                              <1> 
   905                              <1> 	xchg	ax, cx			; low-order mantissa bits with unsigns in ecx
   906                              <1> 					; high-order mantissa bits with middle part in eax
   907                              <1> 
   908                              <1> 	shl	eax, 4			; LLLz | HHHz
   909                              <1> 	shr	ax, 4			; LLLz | zHHH
   910                              <1> 	rol	eax, 12			; zzHH | HLLL
   911                              <1> 
   912                              <1> 	mov	dword ptr [rbp+ebx*4+1*4], eax
   913                              <1> 	rol	ecx, 12
   914                              <1> 	xor	ecx, 0FFFh		; 12 normalising bits = 12 inverted signs
   915                              <1> 	mov	dword ptr [rbp+ebx*4+2*4], ecx
   916                              <1> 	not	ecx			; convert high order quartet to signs
   917                              <1> 	sar	ecx, 20			; 24 of them
   918                              <1> 	shr	ecx, 8
   919                              <1> 	mov	dword ptr [rbp+ebx*4+3*4], ecx
   920                              <1> ;	mov	rbp, dword ptr [rsi+REGISTER_SET]
   921                              <1> 	mov	dword ptr [rbp+S_P], ebx	; update whichever sp that is
   922                              <1> 	ret
   923                              <1> 
   924                              <1> _fpx_allsigns:
   925                              <1> 	add	rsp, 4			; take saved operand word back from stack
   926                              <1> 	sar	ecx, 8			; 16 unnormalised normalising bits
   927                              <1> 	shr	ecx, 8			; = 24 sign bits
   928                              <1> 
   929                              <1> 	mov	dword ptr [rbp+ebx*4], ecx
   930                              <1> 	mov	dword ptr [rbp+ebx*4+1*4], ecx
   931                              <1> 	mov	dword ptr [rbp+ebx*4+2*4], ecx
   932                              <1> 	mov	dword ptr [rbp+ebx*4+3*4], ecx
   933                              <1> 
   934                              <1> ;	mov	rbp, dword ptr [_register_set]
   935                              <1> 	mov	dword ptr [rbp+S_P], ebx	; update whichever sp that is
   936                              <1> 	ret
   937                              <1> 
   938                              <1> _fpp:	call	stack_read4
   939                              <1> 	push	eax				; thats EA
   940                              <1> 
   941                              <1> 	mov	eax, dword ptr [rbp+ebx*4]	; s + 23 exponent bits
   942                              <1> 	rol	eax, 8+2			; save sign and midpoint
   943                              <1> 	shl	eax, 12				; squeeze out 12 exponent bits
   944                              <1> 	shr	ax, 12				; bring sign + midpoint back
   945                              <1> 	ror	eax, 2				; and roll them back in
   946                              <1> 	shr	eax, 4				; position 12 bits low in 16 bits
   947                              <1> 	mov	ecx, dword ptr [rbp+ebx*4+1*4]	; take 1st mantissa word from the stack
   948                              <1> 	ror	ecx, 12				; rotate 12 bits down
   949                              <1> 	shl	cx, 4				; position 12 bits high in 16 bits
   950                              <1> 	mov	ax, cx				; merge
   951                              <1> 	shr	eax, 4				; position 24 bits low in 32 bits
   952                              <1> 	mov	dword ptr [rbp+ebx*4], eax	; place back in RTA1 stack frame
   953                              <1> 						; next 12 mantissa bits in ecx 31..20
   954                              <1> 
   955                              <1> 	mov	eax, dword ptr [rbp+ebx*4+2*4]	; read 24 more
   956                              <1> 	shr	eax, 12-4			; position 12 bits at ax 15..4
   957                              <1> 	shr	ecx, 4				;				
   958                              <1> 	mov	cx, ax				; juxtapose with mantissa 23..12
   959                              <1> 	shr	ecx, 4				; wirraff
   960                              <1> 
   961                              <1> 	mov	dword ptr [rbp+ebx*4+1*4], ecx	; making 2nd and final output word
   962                              <1> 
   963                              <1> 	pop	eax				; recover EA
   964                              <1> 	jmp	_burst_write2
   965                              <1> 
   966                              <1> 	%endif
    42                                  	%include	"fpu.msm"
     1                              <1> compress4to8:			; readout floating operand
     2                              <1> 				; and pack to 32-bit words
     3                              <1> 				; for 1 bit-distance shifting
     4                              <1> 				; acquired operand is in 1st half of 
     5                              <1> 				; 8-register block [rdi]
     6                              <1> 
     7 00001F04 8B07                <1> 	mov	eax, dword ptr [rdi]	; 1s-complement scale field
     8 00001F06 C1E008              <1> 	shl	eax, 8			; 1st data bit reveals sign
     9 00001F09 C1F808              <1> 	sar	eax, 8			; propagate that sign some
    10 00001F0C 89C3                <1> 	mov	ebx, eax
    11 00001F0E C1F818              <1> 	sar	eax, 24			; propagate signs to 32 bits
    12 00001F11 31C3                <1> 	xor	ebx, eax		; change scale to unsigned magnitude
    13 00001F13 891F                <1> 	mov	dword ptr [rdi], ebx	; position scale magnitude in 1st register
    14 00001F15 89471C              <1> 	mov	dword ptr [rdi+7*4], eax	; 96 trailing signs
    15 00001F18 894718              <1> 	mov	dword ptr [rdi+6*4], eax
    16 00001F1B 894714              <1> 	mov	dword ptr [rdi+5*4], eax
    17 00001F1E 8B5F0C              <1> 	mov	ebx, dword ptr [rdi+3*4]	; read low-order mantissa word
    18 00001F21 88D8                <1> 	mov	al, bl				; low-order octet
    19 00001F23 C1C808              <1> 	ror	eax, 8				; is followed by 24 signs
    20 00001F26 894710              <1> 	mov	dword ptr [rdi+4*4], eax	; ebx also contains mantissa 23..8
    21                              <1> 						; in positions 23..8
    22                              <1> 
    23 00001F29 8B4708              <1> 	mov	eax, dword ptr [rdi+2*4]	; eax now contains mantissa 47..24
    24 00001F2C C1E308              <1> 	shl	ebx, 8
    25 00001F2F 6689C3              <1> 	mov	bx, ax				; mantissa 39..24 -> ebx
    26 00001F32 C1C310              <1> 	rol	ebx, 16				; ebx now contains mantissa 40..8
    27 00001F35 895F0C              <1> 	mov	dword ptr [rdi+3*4], ebx
    28 00001F38 8B5F04              <1> 	mov	ebx, dword ptr [rdi+1*4]	; mantissa 71..48
    29 00001F3B C1E308              <1> 	shl	ebx, 8
    30 00001F3E C1E810              <1> 	shr	eax, 16				; mantissa 47..40
    31 00001F41 88C3                <1> 	mov	bl, al
    32 00001F43 895F08              <1> 	mov	dword ptr [rdi+2*4], ebx	; mantissa 71..40
    33 00001F46 8B4714              <1> 	mov	eax, dword ptr [rdi+5*4]	; copy 32 signs
    34 00001F49 894704              <1> 	mov	dword ptr [rdi+1*4], eax	; to 2nd word of register block
    35 00001F4C C3                  <1> 	ret
    36                              <1> 
    37                              <1> 
    38                              <1> ;	___________________________________
    39                              <1> ;	| magnitude scale|     32 signs   |
    40                              <1> ;	|________________|________________|
    41                              <1> ;	| platform word 7| platform word 6|
    42                              <1> 
    43                              <1> 
    44                              <1> ;	<------------ 168-bit mantissa 167..72-------------|
    45                              <1> ;	<------------  72-bit mantissa ------>
    46                              <1> ;	_____________|___________|____________|____________________________
    47                              <1> ;	|      24    | 8 |   16  |   16   | 8 |    24 signs|96 more signs for
    48                              <1> ;	|____________|___|______ |________|___|____________|rrsidue calculation
    49                              <1> ;	| platform word 5| platform word 4|   +rounding <--- @  96-bit operation
    50                              <1> 
    51                              <1> ;	                 <---------------------------------[ platform words 2..0
    52                              <1> ;	                 :
    53                              <1> ;	                 [                                                  ]
    54                              <1> 
    55                              <1> ;	                 |--- 168-bit mantissa 71:0   -------->
    56                              <1> ;	                      rounding @ 192-bit operation --->+
    57                              <1> ;      	                 _________________________|____________|_____________
    58                              <1> ;	                 |      24    | 8 |   16  |   16   | 8 |    24 signs|
    59                              <1> ;	                 |____________|___|_______|________|___|____________|
    60                              <1> ;	                 | platform word 2| platform word 1| platform word 0|
    61                              <1> 
    62                              <1> ;	                 |    rrsidue rounding -->+
    63                              <1> ;	                 |--- 144-bit mantissa -->	                                    
    64                              <1> 
    65                              <1> _deliver_:
    66 00001F4D 480F7EFE            <1> 	movq	rsi, mm7
    67                              <1> ;	mov	rsi, qword ptr [rbp+CORE_INDEX1]
    68                              <1> 
    69 00001F51 F786B0040000080000- <1> 	test	dword ptr [rsi+PSR], FP_R
    69 00001F5A 00                  <1>
    70 00001F5B 0F847E000000        <1> 	jz	near _deliver
    71 00001F61 53                  <1> 	push	rbx		; save result register index
    72 00001F62 8B1F                <1> 	mov	ebx, dword ptr [rdi]		; read scale unsigned magnitude
    73                              <1> 						; not yet signed
    74                              <1> 
    75                              <1> 				; all results except scale have been polarised
    76                              <1> 				; ebx = positive magnitude of major exponent
    77                              <1> 				; deliver floating rrsidue
    78 00001F64 83C3B8              <1> 	add	ebx, -72	; calculate exponent of rrsidue
    79 00001F67 B148                <1> 	mov	cl, 72
    80                              <1> 
    81 00001F69 8B4710              <1> 	mov	eax, dword ptr [rdi+4*4]	; mantissa */ 64 bits
    82 00001F6C C1E008              <1> 	shl	eax, 8		; separate rrsidual mantissa
    83 00001F6F C1E808              <1> 	shr	eax, 8
    84 00001F72 50                  <1> 	push	rax
    85 00001F73 8B4714              <1> 	mov	eax, dword ptr [rdi+5*4]	; mantissa */ 96 bits
    86 00001F76 50                  <1> 	push	rax
    87 00001F77 8B4718              <1> 	mov	eax, dword ptr [rdi+6*4]	; mantissa */ 128 bits
    88 00001F7A 668B4704            <1> 	mov	ax, word ptr [rdi+1*4]		; change low-order half trailing word to signs
    89 00001F7E 50                  <1> 	push	rax				; before normalising
    90                              <1> 
    91                              <1> _normalise_residue:
    92 00001F7F 8B442410            <1> 	mov	eax, dword ptr [rsp+2*8]	; residual mantissa high-order word
    93 00001F83 334704              <1> 	xor	eax, dword ptr [rdi+1*4]	; signs
    94 00001F86 2500008000          <1> 	and	eax, 00800000h			; normalising position
    95 00001F8B 751A                <1> 	jnz	_residue_normalised
    96 00001F8D 8B4704              <1> 	mov	eax, dword ptr [rdi+1*4]	; signs again
    97 00001F90 D1D0                <1> 	rcl	eax, 1				; place a sign in carry				
    98 00001F92 D11424              <1> 	rcl	dword ptr [rsp], 1		; rotate 96 bits rrsidual mantissa
    99 00001F95 D1542408            <1> 	rcl	dword ptr [rsp+1*8], 1
   100 00001F99 D1542410            <1> 	rcl	dword ptr [rsp+2*8], 1		; thirdly the high-order word
   101 00001F9D 83C3FF              <1> 	add	ebx, -1
   102 00001FA0 80C1FF              <1> 	add	cl, -1
   103 00001FA3 72DA                <1> 	jc	_normalise_residue
   104 00001FA5 31DB                <1> 	xor	ebx, ebx			; rrsidue all signs zero -> scale
   105                              <1> _residue_normalised:
   106 00001FA7 F7C3000080FF        <1> 	test	ebx, 0FF800000h
   107 00001FAD 0F85E0F4FFFF        <1> 	jnz	_fpxpo				; nonzero mantissa
   108                              <1> 						; and exponent underflow / overflow
   109                              <1> 						
   110                              <1> ;			rrsidual mantissa on the stack now is
   111                              <1> ;			______________________________________________
   112                              <1> ;	sp------------->| mantissa bits 15..0 | 16 sign bits discard |
   113                              <1> ;			|_____________________|______________________|
   114                              <1> ;			|            mantissa bits 47..16            |
   115                              <1> ;			|____________________________________________| 
   116                              <1> ;			| 0000 0000  mantissa bits 71..48            |
   117                              <1> ;			|____________________________________________|
   118                              <1> ;			|	     result register indication      |
   119                              <1> ;			|____________________________________________|
   120                              <1> 
   121 00001FB3 8B4704              <1> 	mov	eax, dword ptr [rdi+1*4]	; signs
   122 00001FB6 31D8                <1> 	xor	eax, ebx			; sign rrsidue exponent now
   123 00001FB8 C1E008              <1> 	shl	eax, 8				; trim characteristic to RTA1 24-bit word
   124 00001FBB C1E808              <1> 	shr	eax, 8
   125 00001FBE 894520              <1> 	mov	dword ptr [rbp+8*4], eax	; scale XOR signs -> rrsidue characteristic
   126                              <1> 
   127 00001FC1 5B                  <1> 	pop	rbx				; low order mantissa part
   128 00001FC2 58                  <1> 	pop	rax				; middle order mantissa part
   129 00001FC3 88C3                <1> 	mov	bl, al				; donate 8 bits
   130 00001FC5 C1CB08              <1> 	ror	ebx, 8				; distribute as RTA1 24-bit words
   131 00001FC8 C1EB08              <1> 	shr	ebx, 8				; mantissa 23..0
   132 00001FCB C1E808              <1> 	shr	eax, 8				; mantissa 47..24
   133 00001FCE 895D2C              <1> 	mov	dword ptr [rbp+11*4], ebx
   134 00001FD1 894528              <1> 	mov	dword ptr [rbp+10*4], eax
   135 00001FD4 58                  <1> 	pop	rax				; high order rrsidual mantissa part
   136 00001FD5 5B                  <1> 	pop	rbx				; saved result register index
   137 00001FD6 C1E008              <1> 	shl	eax, 8
   138 00001FD9 C1E808              <1> 	shr	eax, 8				; normalising position is bit 23
   139 00001FDC 894524              <1> 	mov	dword ptr [rbp+9*4], eax	; mantissa 71..48
   140                              <1> 
   141                              <1> _deliver:					; deliver floating result
   142                              <1> 						; ebx = target register index
   143                              <1> 						; result register index [rbp+]ebx*4
   144 00001FDF 8B07                <1> 	mov	eax, dword ptr [rdi]		; unsigned scale magnitude
   145 00001FE1 A9000080FF          <1> 	test	eax, 0FF800000h
   146 00001FE6 0F85A7F4FFFF        <1> 	jnz	_fpxpo				; exponent underflow / overflow
   147 00001FEC 334704              <1> 	xor	eax, dword ptr [rdi+1*4]	; sign it
   148 00001FEF C1E008              <1> 	shl	eax, 8
   149 00001FF2 C1E808              <1> 	shr	eax, 8
   150                              <1> 
   151                              <1> _store_float:
   152 00001FF5 89449D00            <1>         mov     dword ptr [rbp+rbx*4], eax      ; store characteristic = scale XOR signs
   153 00001FF9 8B4708              <1>         mov     eax, dword ptr [rdi+2*4]	; read bits 71..40 major mantissa
   154 00001FFC 0FB6C8              <1>         movzx   ecx, al
   155 00001FFF C1E808              <1>         shr     eax, 8
   156 00002002 89449D04            <1>         mov     dword ptr [rbp+rbx*4+4], eax	; store mantissa bits 71..48
   157 00002006 8B470C              <1>         mov     eax, dword ptr [rdi+3*4]	; read mantissa bits 39..8
   158 00002009 C1E110              <1>         shl     ecx, 16				; position mantissa bits 47..40
   159 0000200C C1C810              <1>         ror     eax, 16
   160 0000200F 6689C1              <1>         mov     cx, ax				; position mantissa bits 39..24
   161 00002012 894C9D08            <1>         mov     dword ptr [rbp+rbx*4+8], ecx	; store mantissa bits 47..24
   162 00002016 8B4F10              <1>         mov     ecx, dword ptr [rdi+4*4]	; read mantissa bits 7..0 plus 24 trailing bits
   163 00002019 C1E910              <1>         shr     ecx, 16				; position after mantissa 23..8
   164 0000201C 6689C8              <1>         mov     ax, cx
   165 0000201F C1E808              <1>         shr     eax, 8				; store mantissa bits 23..0
   166 00002022 89449D0C            <1>         mov     dword ptr [rbp+rbx*4+12], eax
   167 00002026 C3                  <1> 	ret
   168                              <1> 
   169                              <1> ;	_output equ	272
   170                              <1> ;	_inputr equ	264
   171                              <1> ;	_input2 equ	256
   172                              <1> 
   173                              <1> ;	_OUTPUT	equ	__register+_output*4
   174                              <1> ;	_INPUTR equ	__register+_inputr*4
   175                              <1> ;	_INPUT2 equ	__register+_input2*4
   176                              <1> ;	_BIAS	equ	_OUTPUT
   177                              <1> 
   178                              <1> zoutput:
   179 00002027 31C0                <1> 	xor	eax, eax
   180 00002029 8907                <1> 	mov	dword ptr [rdi], eax
   181 0000202B 894704              <1> 	mov	dword ptr [rdi+1*4], eax
   182 0000202E 894708              <1> 	mov	dword ptr [rdi+2*4], eax
   183 00002031 89470C              <1> 	mov	dword ptr [rdi+3*4], eax
   184 00002034 894710              <1> 	mov	dword ptr [rdi+4*4], eax
   185 00002037 894714              <1> 	mov	dword ptr [rdi+5*4], eax
   186 0000203A 894718              <1> 	mov	dword ptr [rdi+6*4], eax
   187 0000203D 89471C              <1> 	mov	dword ptr [rdi+7*4], eax
   188 00002040 C3                  <1> 	ret
   189                              <1> 
   190                              <1> 
   191                              <1> ;	round before add or divide
   192                              <1> ;	XOR rounding pattern to guard field
   193                              <1> 
   194 00002041 0FB6DD              <1> round1:	movzx	ebx, ch
   195                              <1> 
   196 00002044 480F7EF8            <1> 	movq	rax, mm7
   197                              <1> ;	mov	eax, dword ptr [rbp+CORE_INDEX1]
   198                              <1> 
   199 00002048 8B804C020000        <1> 	mov	eax, dword ptr [rax+REGISTER+FP_GUARD]
   200 0000204E D3E8                <1> 	shr	eax, cl
   201 00002050 C1E008              <1> 	shl	eax, 8
   202 00002053 31449F08            <1> 	xor	dword ptr [rdi+rbx*4+2*4], eax
   203                              <1> 
   204 00002057 C3                  <1> 	ret
   205                              <1> 
   206 00002058 0FB6DD              <1> round2:	movzx	ebx, ch
   207                              <1> 
   208 0000205B 480F7EFE            <1> 	movq	rsi, mm7
   209                              <1> ;	mov	eax, dword ptr [rbp+CORE_INDEX1]	; ? can't have mattered much	
   210                              <1> 
   211 0000205F 8B864C020000        <1> 	mov	eax, dword ptr [rsi+REGISTER+FP_GUARD]
   212 00002065 D3E8                <1> 	shr	eax, cl
   213 00002067 C1E008              <1> 	shl	eax, 8
   214 0000206A 01449F08            <1> 	add	dword ptr [rdi+rbx*4+2*4], eax
   215                              <1> round2more:
   216 0000206E 83549F0400          <1> 	adc	dword ptr [rdi+rbx*4+1*4], 0
   217 00002073 FFCB                <1> 	dec	ebx
   218 00002075 75F7                <1> 	jnz	round2more
   219 00002077 C3                  <1> 	ret
   220                              <1> 
   221                              <1> __FLAT_STAC	equ	1
   222                              <1> 
   223                              <1> end_around_carry:
   224                              <1> 
   225                              <1> 	%if	__FLAT_STAC
   226 00002078 F7D2                <1> 	not	edx				; signs B4
   227 0000207A 0FB6C3              <1> 	movzx	eax, bl				; carry saved from add
   228 0000207D 21D2                <1> 	and	edx, edx			; test new polarity
   229                              <1> 	%else
   230                              <1> 
   231                              <1> 	not	dword ptr [rsi+2*4]		; seems to vary or be vaguely documented
   232                              <1> 	movzx	eax, byte ptr [rsi+1*4]		; what size the call return stack frame is
   233                              <1> 						; so we push ei and copy rsp to it
   234                              <1> 						; to see stuff near the stack top
   235                              <1> 
   236                              <1> 	test	byte ptr dword ptr [rsi+2*4], 128
   237                              <1> 	%endif
   238                              <1> 
   239 0000207F 790B                <1> 	jns	end_around_carry_plus		; updated signs +
   240                              <1> 
   241 00002081 B8FFFFFFFF          <1> 	mov	eax, -1				; 1 -> -1 in 1s complement
   242 00002086 D3E8                <1> 	shr	eax, cl
   243 00002088 F7D0                <1> 	not	eax
   244 0000208A EB06                <1> 	jmp	eoc1
   245                              <1> 
   246                              <1> end_around_carry_plus:
   247 0000208C 21C0                <1> 	and	eax, eax
   248 0000208E 7417                <1> 	jz	eox1				; ? don't call this if there is no carry
   249 00002090 D3C8                <1> 	ror	eax, cl
   250                              <1> 
   251 00002092 0FB6DD              <1> eoc1:	movzx	ebx, ch
   252 00002095 01449F08            <1> 	add	dword ptr [rdi+rbx*4+2*4], eax
   253                              <1> 
   254 00002099 9C                  <1> 	pushfq
   255 0000209A C1F81F              <1> 	sar	eax, 31				; shift leave carry alone
   256 0000209D 9D                  <1> 	popfq
   257                              <1> 
   258 0000209E FFC3                <1> 	inc	ebx				; but reference displacements - 2
   259                              <1> 
   260 000020A0 11049F              <1> eoc:	adc	dword ptr [rdi+rbx*4], eax	; referencing displacements - 2
   261 000020A3 FFCB                <1> 	dec	ebx
   262 000020A5 75F9                <1> 	jnz	eoc
   263 000020A7 C3                  <1> eox1:	ret
   264                              <1> 
   265                              <1> restore_trailing_signs:
   266 000020A8 0FB6DD              <1> 	movzx	ebx, ch
   267 000020AB 8B4704              <1> 	mov	eax, dword ptr [rdi+1*4]
   268                              <1> 
   269 000020AE 89471C              <1> 	mov	dword ptr [rdi+7*4], eax
   270                              <1> 
   271 000020B1 21C0                <1> 	and	eax, eax
   272 000020B3 780B                <1> 	js	restore_trailing_ones
   273 000020B5 F7D0                <1> 	not	eax
   274 000020B7 D3E8                <1> 	shr	eax, cl
   275 000020B9 F7D0                <1> 	not	eax
   276 000020BB 21449F08            <1> 	and	dword ptr [rdi+rbx*4+2*4], eax
   277 000020BF C3                  <1> 	ret
   278                              <1> 
   279                              <1> restore_trailing_ones:
   280 000020C0 D3E8                <1> 	shr	eax, cl
   281 000020C2 09449F08            <1> 	or	dword ptr [rdi+rbx*4+2*4], eax
   282                              <1> 
   283 000020C6 C3                  <1> 	ret
   284                              <1> 	
   285                              <1> bias_addend:					; input mantissa [rsi] is biased into location _BIAS
   286 000020C7 57                  <1> 	push	rdi
   287 000020C8 4889F7              <1> 	mov	rdi, rsi
   288                              <1> 
   289 000020CB 480F7EFE            <1> 	movq	rsi, mm7
   290                              <1> ;	mov	rsi, qword ptr[rbp+CORE_INDEX1]
   291                              <1> 
   292 000020CF 488DB640040000      <1> 	lea	rsi, [rsi+_BIAS]
   293                              <1> 
   294 000020D6 56                  <1> 	push	rsi
   295 000020D7 E803000000          <1> 	call	biasfp
   296                              <1> 
   297 000020DC 5E                  <1> 	pop	rsi
   298 000020DD 5F                  <1> 	pop	rdi
   299 000020DE C3                  <1> 	ret
   300                              <1> 
   301 000020DF 52                  <1> biasfp:	push	rdx
   302 000020E0 51                  <1> 	push	rcx
   303                              <1> 
   304 000020E1 BB01000000          <1> 	mov	ebx, 1				; output index
   305 000020E6 66C1E003            <1> 	shl	ax, 3				; words sign fill
   306 000020EA C0E803              <1> 	shr	al, 3				; bits sign fill
   307 000020ED 6689C1              <1> 	mov	cx, ax
   308 000020F0 4883C704            <1> 	add	rdi, 4				; input pointer
   309 000020F4 8B07                <1> 	mov	eax, dword ptr [rdi]		; there shall be this word of signs at least
   310                              <1> 
   311 000020F6 89049E              <1> bias32:	mov	dword ptr [rsi+rbx*4], eax	; write 1 word of signs
   312 000020F9 FFC3                <1> 	inc	ebx				; consider the next output word
   313 000020FB FECD                <1> 	dec	ch				; any more words of signs?
   314 000020FD 79F7                <1> 	jns	bias32
   315                              <1> 
   316 000020FF 20C9                <1> 	and	cl, cl
   317 00002101 7423                <1> 	jz	bias_fast			; there is no 32-bit shift
   318                              <1> 
   319 00002103 B520                <1> 	mov	ch, 32				; demonstrate the missing advantage
   320 00002105 28CD                <1> 	sub	ch, cl				; of instruction architectures
   321                              <1> 						; with 2-register shifts
   322                              <1> biasup2:
   323 00002107 83FB08              <1> 	cmp	ebx, 8
   324 0000210A 742D                <1> 	jz	bias_addx
   325 0000210C 4883C704            <1> 	add	rdi, 4				; read new mantissa word
   326 00002110 8B17                <1> 	mov	edx, dword ptr [rdi]		; it becomes word # new in edx
   327 00002112 86E9                <1> 	xchg	ch, cl
   328 00002114 D3E0                <1> 	shl	eax, cl				; shift buffered word left 32 - bit offset
   329 00002116 86E9                <1> 	xchg	ch, cl
   330 00002118 D3EA                <1> 	shr	edx, cl				; shift new mantissa word right bit offset
   331 0000211A 09D0                <1> 	or	eax, edx
   332 0000211C 89049E              <1> 	mov	dword ptr [rsi+rbx*4], eax	; write 1 merged word
   333 0000211F 8B07                <1> 	mov	eax, dword ptr [rdi]		; read the same mantissa word again
   334 00002121 83C301              <1> 	add	ebx, 1				; it becomes word # previous in eax
   335 00002124 EBE1                <1> 	jmp	biasup2
   336                              <1> 
   337                              <1> bias_fast:
   338 00002126 83FB08              <1> 	cmp	ebx, 8
   339 00002129 740E                <1> 	jz	bias_addx
   340 0000212B 4883C704            <1> 	add	rdi, 4
   341 0000212F 8B07                <1> 	mov	eax, dword ptr [rdi]
   342 00002131 89049E              <1> 	mov	dword ptr [rsi+rbx*4], eax
   343 00002134 83C301              <1> 	add	ebx, 1
   344 00002137 EBED                <1> 	jmp	bias_fast
   345                              <1> 
   346                              <1> bias_addx:
   347 00002139 59                  <1> 	pop	rcx
   348 0000213A 5A                  <1> 	pop	rdx				; restore the program counter
   349 0000213B C3                  <1> 	ret
   350                              <1> 
   351                              <1> frame_mantissa:
   352                              <1> ;	ror	ecx, 16				; words count is up, beats index down
   353 0000213C 80C501              <1> 	add	ch, 1				; up the beats index to beats count
   354 0000213F 66C1E905            <1> 	shr	cx, 5				; positions / 32 in ch
   355 00002143 C0E903              <1> 	shr	cl, 3				; positions /// 32 in cl
   356 00002146 0FB6DD              <1> 	movzx	ebx, ch				; derive platform words rounded down
   357 00002149 C3                  <1> 	ret
   358                              <1> 
   359                              <1> renormalise:					; rule 1: restore sign fill in
   360                              <1> 						; low-order containing platform word
   361                              <1> ; done before end-around-carry, and saved
   362                              <1> ;;	call	frame_mantissa			; it was mashed by rounding and adding
   363 0000214A E859FFFFFF          <1> 	call	restore_trailing_signs
   364 0000214F C1C910              <1> 	ror	ecx, 16				; the governing parameter is now
   365                              <1> 						; the containing words count in cx
   366                              <1> renormalise32:
   367 00002152 8B4708              <1> 	mov	eax, dword ptr [rdi+2*4]	; sample 32 mantissa bits
   368 00002155 3B4704              <1> 	cmp	eax, dword ptr [rdi+1*4]	; compare it with 32 signs
   369 00002158 750C                <1> 	jnz	renormalise8
   370 0000215A E83E000000          <1> 	call	rotate32left			; this also discovers if it's ALL signs = 0
   371 0000215F 21C0                <1> 	and	eax, eax			; and is the only place that needs examined
   372 00002161 75EF                <1> 	jnz	renormalise32
   373                              <1> 
   374 00002163 8907                <1> 	mov	dword ptr [rdi], eax		; mantissa is signed zero, +0 -> scale
   375                              <1> renormalised:
   376 00002165 C3                  <1> 	ret
   377                              <1> 
   378                              <1> renormalise8:					; from this point on the value is nonzero
   379 00002166 C1C008              <1> 	rol	eax, 8				; are there 8 signs at head of mantissa?
   380 00002169 3A4707              <1> 	cmp	al, byte ptr [rdi+1*4+3]	; this is Intel and the 4th byte is high-order
   381 0000216C 750A                <1> 	jnz	renormalise1			; you have found the 8 bits containing the
   382                              <1> 						; normalising bit
   383 0000216E E84A000000          <1> 	call	rotate8left			; or else you haven't
   384 00002173 8B4708              <1> 	mov     eax, dword ptr [rdi+2*4]	; sample the moved mantissa
   385 00002176 EBEE                <1> 	jmp	renormalise8
   386                              <1> 
   387                              <1> renormalise1:
   388                              <1> ;	movzx	ebx, cx	
   389 00002178 8B4704              <1> 	mov	eax, dword ptr [rdi+1*4]		
   390                              <1> ;	mov	dword ptr [rdi+rbx*4+1*4], eax	; in case polarity has changed
   391 0000217B 334708              <1> 	xor	eax, dword ptr [rdi+2*4]	; normalising bit opposite polarity to sign?
   392 0000217E 78E5                <1> 	js	renormalised			; arrived
   393 00002180 E802000000          <1> 	call	bitwise_scale			; almost arrived
   394 00002185 EBF1                <1> 	jmp	renormalise1
   395                              <1> 
   396                              <1> 
   397                              <1> bitwise_scale:
   398 00002187 D1571C              <1> 	rcl	dword ptr [rdi+7*4], 1	; so it doesn't matter whether 0 or 1
   399 0000218A D15718              <1> 	rcl	dword ptr [rdi+6*4], 1	; gets shifted into the 192nd bit
   400 0000218D D15714              <1> 	rcl	dword ptr [rdi+5*4], 1
   401 00002190 D15710              <1> 	rcl	dword ptr [rdi+4*4], 1	; it's quicker to shift 6 words
   402 00002193 D1570C              <1> 	rcl	dword ptr [rdi+3*4], 1	; than a counted loop of 4 or 5 or 6 words
   403 00002196 D15708              <1> 	rcl	dword ptr [rdi+2*4], 1
   404                              <1> 
   405 00002199 8307FF              <1> 	add	dword ptr [rdi], -1	; scale down
   406 0000219C C3                  <1> 	ret
   407                              <1> 
   408                              <1> rotate32left:				; rotate all containing platform words of mantissa
   409 0000219D 52                  <1> 	push	rdx			; 32 bit positions left and report if all signs
   410 0000219E 51                  <1> 	push	rcx
   411 0000219F 0FB7D9              <1> 	movzx	ebx, cx
   412 000021A2 31D2                <1> 	xor	edx, edx		; initialise equality = all signs
   413                              <1> 
   414                              <1> rotate32next:				; the word initially loaded in eax is all signs
   415 000021A4 FFCB                <1> 	dec	ebx
   416 000021A6 87449F08            <1> 	xchg	eax, dword ptr [rdi+rbx*4+2*4]
   417 000021AA 89C1                <1> 	mov	ecx, eax
   418 000021AC 334F04              <1> 	xor	ecx, dword ptr [rdi+1*4] ; difference between this word and signs
   419 000021AF 09CA                <1> 	or	edx, ecx		; sum of differences
   420 000021B1 21DB                <1> 	and	ebx, ebx
   421 000021B3 75EF                <1> 	jnz	rotate32next
   422 000021B5 8307E0              <1> 	add	dword ptr [rdi], -32	; scale down
   423 000021B8 89D0                <1> 	mov	eax, edx
   424 000021BA 59                  <1> 	pop	rcx
   425 000021BB 5A                  <1> 	pop	rdx
   426 000021BC C3                  <1> 	ret
   427                              <1> 
   428                              <1> rotate8left:				; rotate all containing platform words of mantissa
   429 000021BD 51                  <1> 	push	rcx			; 8 bit positions left. 1st word is rotated already
   430 000021BE 0FB7D9              <1> 	movzx	ebx, cx			; and contains signs in 8 low-order bit positions
   431                              <1> rotate8next:
   432 000021C1 8B4C9F08            <1> 	mov	ecx, dword ptr [rdi+rbx*4+2*4]
   433 000021C5 C1C108              <1> 	rol	ecx, 8
   434 000021C8 86C1                <1> 	xchg	al, cl
   435 000021CA 894C9F08            <1> 	mov	dword ptr [rdi+rbx*4+2*4], ecx
   436 000021CE 83C3FF              <1> 	add	ebx, -1
   437 000021D1 72EE                <1> 	jc	rotate8next
   438 000021D3 8307F8              <1> 	add	dword ptr [rdi], -8	; scale down
   439 000021D6 59                  <1> 	pop	rcx
   440 000021D7 C3                  <1> 	ret
   441                              <1> 
   442 000021D8 F75708              <1> zover:	not	dword ptr [rdi+2*4]
   443 000021DB F7570C              <1> 	not	dword ptr [rdi+3*4]
   444 000021DE F75710              <1> 	not	dword ptr [rdi+4*4]
   445 000021E1 F75714              <1> 	not	dword ptr [rdi+5*4]
   446 000021E4 F75718              <1> 	not	dword ptr [rdi+6*4]
   447 000021E7 F7571C              <1> 	not	dword ptr [rdi+7*4]
   448 000021EA C3                  <1> 	ret
   449                              <1> 
   450                              <1> _add_low:
   451 000021EB 8B961C040000        <1>         mov     edx, dword ptr [rsi+_INPUT2+7*4]
   452 000021F1 13963C040000        <1>         adc     edx, dword ptr [rsi+_INPUTR+7*4]
   453 000021F7 8B9E18040000        <1>         mov     ebx, dword ptr [rsi+_INPUT2+6*4]
   454 000021FD 139E38040000        <1>         adc     ebx, dword ptr [rsi+_INPUTR+6*4]
   455 00002203 8B8614040000        <1>         mov     eax, dword ptr [rsi+_INPUT2+5*4]
   456 00002209 138634040000        <1>         adc     eax, dword ptr [rsi+_INPUTR+5*4]
   457 0000220F C3                  <1>         ret
   458                              <1> 
   459                              <1> _add_high:
   460 00002210 8B9610040000        <1>         mov     edx, dword ptr [rsi+_INPUT2+4*4]
   461 00002216 139630040000        <1>         adc     edx, dword ptr [rsi+_INPUTR+4*4]
   462 0000221C 8B9E0C040000        <1>         mov     ebx, dword ptr [rsi+_INPUT2+3*4]
   463 00002222 139E2C040000        <1>         adc     ebx, dword ptr [rsi+_INPUTR+3*4]
   464 00002228 8B8608040000        <1>         mov     eax, dword ptr [rsi+_INPUT2+2*4]
   465 0000222E 138628040000        <1>         adc     eax, dword ptr [rsi+_INPUTR+2*4]
   466 00002234 C3                  <1>         ret
   467                              <1> 
   468 00002235 488DBE00040000      <1> fan:	lea	rdi, [rsi+_INPUT2]
   469 0000223C E897FFFFFF          <1> 	call	zover				; mantissa
   470 00002241 F79604040000        <1> 	not	dword ptr [rsi+_INPUT2+1*4]	; 32 signs
   471                              <1> 
   472 00002247 488DBE20040000      <1> fa:	lea	rdi, [rsi+_INPUTR]
   473 0000224E 67488DB600040000    <1> 	lea	rsi, [esi+_INPUT2]
   474                              <1> 
   475 00002256 8B4604              <1> 	mov	eax, dword ptr [rsi+1*4]	; normalised?
   476 00002259 334608              <1> 	xor	eax, dword ptr [rsi+2*4]	; normalising bit must ^ signs
   477 0000225C 7801                <1> 	js	fa_addend_normalised		; yes
   478 0000225E C3                  <1> fa_nop:	ret					; accumulator block unchanged
   479                              <1> 
   480                              <1> fa_addend_normalised:
   481 0000225F 8B4704              <1> 	mov	eax, dword ptr [rdi+1*4]	; register side operand normalised?
   482 00002262 334708              <1> 	xor	eax, dword ptr [rdi+2*4]	; normalising bit must ^ signs
   483 00002265 7804                <1> 	js	fa_promote_magnitude		; normalised, get on with it
   484 00002267 4889F7              <1> 	mov	rdi, rsi			; accumulator block is not normalised
   485 0000226A C3                  <1> 	ret					; storage addend zero-added
   486                              <1> 
   487                              <1> fa_promote_magnitude:
   488 0000226B 8B07                <1> 	mov	eax, dword ptr [rdi]
   489 0000226D 2B06                <1> 	sub	eax, dword ptr [rsi]
   490                              <1> 
   491 0000226F 7905                <1> 	jns	fa_add				; register-side operand is not lower
   492                              <1> 
   493 00002271 4887F7              <1> 	xchg	rsi, rdi			;
   494 00002274 F7D8                <1> 	neg	eax
   495                              <1> 
   496                              <1> fa_add:	;	call	frame_mantissa
   497 00002276 50                  <1> 	push	rax				; exponent difference
   498 00002277 E8C5FDFFFF          <1> 	call	round1
   499                              <1> 
   500 0000227C 58                  <1> 	pop	rax				; exponent difference
   501 0000227D 21C0                <1> 	and	eax, eax			; is + and either zero or not
   502 0000227F 740C                <1> 	jz	fa_addfast
   503                              <1> 
   504 00002281 3DBF000000          <1> 	cmp	eax, 191			; do they touch?
   505 00002286 77D6                <1> 	ja	fa_nop
   506                              <1> 
   507 00002288 E83AFEFFFF          <1> 	call	bias_addend
   508                              <1> ;	mov	rsi, dword ptr [rbp+CORE_INDEX1] ; done inside bias_addend
   509                              <1> ;	from mm7 anyway
   510                              <1> ;	lea	rsi, [esi+_BIAS]		; shifted added
   511                              <1> 
   512                              <1> fa_addfast:
   513 0000228D 8B4704              <1> 	mov	eax, dword ptr [rdi+1*4]	; before look signs
   514                              <1> 
   515                              <1> 	%if	__FLAT_STAC
   516 00002290 89C2                <1> 	mov	edx, eax
   517                              <1> 	%else
   518                              <1> 	push	rax				; near stack top until fa_normalised
   519                              <1> 	%endif
   520                              <1> 
   521 00002292 C1C910              <1> 	ror	ecx, 16				; get containing compute words
   522 00002295 0FB7D9              <1> 	movzx	ebx, cx				; index / count
   523 00002298 C1C910              <1> 	ror	ecx, 16
   524                              <1> 
   525 0000229B F8                  <1> 	clc
   526                              <1> 
   527                              <1> fa_action:
   528 0000229C 8B049E              <1> 	mov	eax, dword ptr [rsi+rbx*4]
   529 0000229F 11049F              <1> 	adc	dword ptr [rdi+rbx*4], eax
   530 000022A2 FFCB                <1> 	dec	ebx				; process word 1
   531 000022A4 75F6                <1> 	jnz	fa_action			; leave word 0 alone
   532                              <1> 
   533 000022A6 0F92C3              <1> 	setc	bl				; boolean instructions following
   534                              <1> 
   535                              <1> 	%if	__FLAT_STAC
   536                              <1> 	%else
   537                              <1> 	push	rbx				; should not change carry but
   538                              <1> 	%endif
   539                              <1> 
   540 000022A9 480F7EFE            <1> 	movq	rsi, mm7
   541                              <1> ;	mov	rsi, qword ptr [rbp+CORE_INDEX1]
   542                              <1> 	
   543 000022AD 8B4704              <1> 	mov	eax, dword ptr [rdi+1*4]	; has sign switched ?
   544                              <1> 
   545                              <1> 	%if	__FLAT_STAC
   546 000022B0 31D0                <1> 	xor	eax, edx
   547                              <1> 	%else
   548                              <1> 	xor	eax, dword ptr [rsp+1*4]
   549                              <1> 	%endif
   550                              <1> 	
   551 000022B2 7917                <1> 	jns	fa_testcarry
   552                              <1> 
   553                              <1> ;	not	dword ptr [rsi+7*4]
   554                              <1> 
   555 000022B4 F686B004000008      <1> 	test	byte ptr [rsi+PSR], FP_R	; flag 8 = store residue
   556 000022BB 7509                <1> 	jnz	switch_long
   557                              <1> 
   558 000022BD F7561C              <1> 	not	dword ptr [rsi+7*4]
   559 000022C0 F75718              <1> 	not	dword ptr [rdi+6*4]		; if double size (+ residue)
   560 000022C3 F75714              <1> 	not	dword ptr [rdi+5*4]		; these are written in the add loop
   561                              <1> switch_long:
   562                              <1> 
   563                              <1> ;	not	dword ptr [rdi+7*4]		; thru zero
   564                              <1> 
   565                              <1> 	%if	__FLAT_STAC
   566                              <1> 	%else
   567                              <1> 	push	rsi				; have a clear expectation
   568                              <1> 	mov	rsi, rsp			; where the first stack words are
   569                              <1> 	%endif
   570                              <1> 
   571 000022C6 E8ADFDFFFF          <1> 	call	end_around_carry
   572                              <1> 
   573                              <1> 	%if	__FLAT_STAC
   574                              <1> 	%else
   575                              <1> 	pop	rsi
   576                              <1> 	%endif
   577                              <1> 
   578                              <1> fa_testcarry:
   579                              <1> 
   580                              <1> 	%if	__FLAT_STAC
   581 000022CB 89D0                <1> 	mov	eax, edx
   582                              <1> 	%else
   583                              <1> 	mov	eax, dword ptr [rsp+1*4]		; [ rsp + 1L ] -> updated signs
   584                              <1> 	%endif
   585                              <1> 
   586 000022CD 334704              <1> 	xor	eax, dword ptr [rdi+1*4]		; carry from normalising position?
   587                              <1> 
   588 000022D0 2401                <1> 	and	al, 1
   589 000022D2 7420                <1> 	jz	fa_normalise
   590                              <1> 
   591 000022D4 FF07                <1> 	inc	dword ptr [rdi]				; exponent magnitude++
   592                              <1> 
   593                              <1> 	%if	 __FLAT_STAC
   594 000022D6 89D0                <1> 	mov	eax, edx
   595                              <1> 	%else
   596                              <1> 	mov	eax, dword ptr [rsp+1*4]	 	; read 32 signs
   597                              <1> 	%endif
   598                              <1> 
   599 000022D8 D1C8                <1> 	ror	eax, 1					; move a sign to carry	
   600                              <1> 
   601 000022DA D15F04              <1> 	rcr	dword ptr [rdi+1*4], 1			; shift from signs word
   602 000022DD D15F08              <1> 	rcr	dword ptr [rdi+2*4], 1			; to normalising position
   603 000022E0 D15F0C              <1> 	rcr	dword ptr [rdi+3*4], 1			; keep going
   604 000022E3 D15F10              <1> 	rcr	dword ptr [rdi+4*4], 1
   605 000022E6 D15F14              <1> 	rcr	dword ptr [rdi+5*4], 1
   606 000022E9 D15F18              <1> 	rcr	dword ptr [rdi+6*4], 1
   607 000022EC D15F1C              <1> 	rcr	dword ptr [rdi+7*4], 1
   608                              <1> 
   609 000022EF 894704              <1> 	mov	dword ptr [rdi+1*4], eax		; write all signs back to signs word
   610                              <1> 
   611 000022F2 EB05                <1> 	jmp	fa_normalised
   612                              <1> 
   613                              <1> fa_normalise:
   614 000022F4 E851FEFFFF          <1> 	call	renormalise				; in case the sum is plenty positions
   615                              <1> 
   616                              <1> fa_normalised:
   617                              <1> 	%if	__FLAT_STAC
   618                              <1> 	%else
   619                              <1> 	pop	rbx
   620                              <1> 	pop	rax					; below the fractional point
   621                              <1> 	%endif
   622 000022F9 C3                  <1> 	ret
   623                              <1> 	
   624 000022FA 488DBE40040000      <1> fm:	lea	rdi, [rsi+_OUTPUT]			; initialise final accumulation
   625 00002301 E821FDFFFF          <1> 	call	zoutput
   626                              <1> 
   627 00002306 8B9E24040000        <1> 	mov	ebx, dword ptr [rsi+_INPUTR+1*4]	; read register-side signs
   628 0000230C 8B8628040000        <1> 	mov	eax, dword ptr [rsi+_INPUTR+2*4]	; and high-end mantissa
   629 00002312 31D8                <1> 	xor	eax, ebx	 			; cache if-normalised in eax
   630 00002314 339E04040000        <1> 	xor	ebx, dword ptr [rsi+_INPUT2+1*4]	; multiply signs
   631 0000231A 899E44040000        <1> 	mov	dword ptr [rsi+_OUTPUT+1*4], ebx	; save the output sign
   632 00002320 21C0                <1> 	and	eax, eax				; test the cached if-normalised
   633 00002322 790E                <1> 	jns	fmdont
   634                              <1> 
   635 00002324 8B8604040000        <1> 	mov	eax, dword ptr [rsi+_INPUT2+1*4]	; is the multiplier normalised?
   636 0000232A 338608040000        <1> 	xor	eax, dword ptr [rsi+_INPUT2+2*4]	; sign XOR normalising bit?
   637 00002330 782F                <1> 	js	fmgo					; yes, proceed
   638                              <1> 
   639 00002332 899E48040000        <1> fmdont:	mov	dword ptr [rsi+_OUTPUT+2*4], ebx
   640 00002338 899E4C040000        <1> 	mov	dword ptr [rsi+_OUTPUT+3*4], ebx
   641 0000233E 899E50040000        <1> 	mov	dword ptr [rsi+_OUTPUT+4*4], ebx
   642 00002344 899E54040000        <1> 	mov	dword ptr [rsi+_OUTPUT+5*4], ebx
   643 0000234A 899E58040000        <1> 	mov	dword ptr [rsi+_OUTPUT+6*4], ebx
   644 00002350 899E5C040000        <1> 	mov	dword ptr [rsi+_OUTPUT+7*4], ebx
   645 00002356 C78640040000000000- <1> 	mov	dword ptr [rsi+_OUTPUT], 0		; mantissa to go
   645 0000235F 00                  <1>
   646                              <1> 
   647 00002360 C3                  <1> 	ret					; no, effective zero multiplier
   648                              <1> 
   649 00002361 51                  <1> fmgo:	push	rcx
   650 00002362 8B8624040000        <1> 	mov	eax, dword ptr [rsi+_INPUTR+1*4]
   651 00002368 B148                <1> 	mov	cl, 72				; beats count exactly 72
   652 0000236A 21C0                <1> 	and	eax, eax
   653                              <1> 
   654 0000236C 790C                <1> 	jns	fmp1
   655 0000236E 488DBE20040000      <1> 	lea	rdi, [rsi+_INPUTR]
   656 00002375 E85EFEFFFF          <1> 	call	zover
   657                              <1> 
   658 0000237A 8B8604040000        <1> fmp1:	mov	eax, dword ptr [rsi+_INPUT2+1*4]
   659 00002380 21C0                <1> 	and	eax, eax
   660 00002382 790C                <1> 	jns	fmadd
   661 00002384 488DBE00040000      <1> 	lea	rdi, [rsi+_INPUT2]
   662 0000238B E848FEFFFF          <1> 	call	zover
   663                              <1> 
   664 00002390 F8                  <1> fmadd:	clc
   665                              <1> 
   666 00002391 488DBE20040000      <1> 	lea	rdi, [rsi+_INPUTR]
   667 00002398 D15F08              <1> 	rcr	dword ptr [rdi+2*4], 1		; addend shift right
   668 0000239B D15F0C              <1> 	rcr	dword ptr [rdi+3*4], 1
   669 0000239E D15F10              <1> 	rcr	dword ptr [rdi+4*4], 1
   670 000023A1 D15F14              <1> 	rcr	dword ptr [rdi+5*4], 1
   671 000023A4 D15F18              <1> 	rcr	dword ptr [rdi+6*4], 1
   672 000023A7 D15F1C              <1> 	rcr	dword ptr [rdi+7*4], 1
   673                              <1> 
   674 000023AA 488DBE00040000      <1> 	lea	rdi, [rsi+_INPUT2]
   675                              <1> ;	rcl	dword ptr [rdi+7*4], 1		; multiplier shift left
   676                              <1> ;	rcl	dword ptr [rdi+6*4], 1
   677                              <1> ;	rcl	dword ptr [rdi+5*4], 1		; multiplier mantissa is only 72 bits
   678 000023B1 D15710              <1> 	rcl	dword ptr [rdi+4*4], 1
   679 000023B4 D1570C              <1> 	rcl	dword ptr [rdi+3*4], 1
   680 000023B7 D15708              <1> 	rcl	dword ptr [rdi+2*4], 1
   681                              <1> 
   682 000023BA 488DBE40040000      <1> 	lea	rdi, [rsi+_OUTPUT]
   683 000023C1 7336                <1> 	jnc	fmadx
   684                              <1> 						; 1 shifted from multiplier
   685 000023C3 8B863C040000        <1> fmadc:	mov	eax, dword ptr [rsi+_INPUTR+7*4]	
   686 000023C9 01471C              <1> 	add	dword ptr [rdi+7*4], eax	; do not use carry
   687 000023CC 8B8638040000        <1> 	mov	eax, dword ptr [rsi+_INPUTR+6*4]
   688 000023D2 114718              <1> 	adc	dword ptr [rdi+6*4], eax	; start using carry
   689 000023D5 8B8634040000        <1> 	mov	eax, dword ptr [rsi+_INPUTR+5*4]
   690 000023DB 114714              <1> 	adc	dword ptr [rdi+5*4], eax
   691 000023DE 8B8630040000        <1> 	mov	eax, dword ptr [rsi+_INPUTR+4*4]
   692 000023E4 114710              <1> 	adc	dword ptr [rdi+4*4], eax
   693 000023E7 8B862C040000        <1> 	mov	eax, dword ptr [rsi+_INPUTR+3*4]
   694 000023ED 11470C              <1> 	adc	dword ptr [rdi+3*4], eax
   695 000023F0 8B8628040000        <1> 	mov	eax, dword ptr [rsi+_INPUTR+2*4]
   696 000023F6 114708              <1> 	adc	dword ptr [rdi+2*4], eax
   697                              <1> 
   698 000023F9 FEC9                <1> fmadx:	dec	cl
   699 000023FB 7593                <1> 	jnz	fmadd
   700                              <1> 
   701 000023FD 59                  <1> fmadz:	pop	rcx
   702                              <1> 
   703 000023FE 8B4708              <1> 	mov	eax, dword ptr [rdi+2*4] 	; normalised?
   704 00002401 D1D0                <1> 	rcl	eax, 1
   705 00002403 721B                <1> 	jc	fm_normalised
   706                              <1> 
   707 00002405 838620040000FF      <1> 	add	dword ptr [rsi+_INPUTR], -1		; take 1 from scale
   708 0000240C D1571C              <1> 	rcl	dword ptr [rdi+7*4], 1
   709 0000240F D15718              <1> 	rcl	dword ptr [rdi+6*4], 1
   710 00002412 D15714              <1> 	rcl	dword ptr [rdi+5*4], 1
   711 00002415 D15710              <1> 	rcl	dword ptr [rdi+4*4], 1
   712 00002418 D1570C              <1> 	rcl	dword ptr [rdi+3*4], 1
   713 0000241B D15708              <1> 	rcl	dword ptr [rdi+2*4], 1
   714                              <1> 
   715 0000241E EB27                <1> 	jmp	fm_inrange
   716                              <1> 
   717                              <1> fm_normalised:
   718 00002420 488DBE40040000      <1> 	lea	rdi, [rsi+_OUTPUT]
   719 00002427 E82CFCFFFF          <1> 	call	round2
   720 0000242C 7319                <1> 	jnc	fm_inrange
   721                              <1> 
   722 0000242E D15F08              <1> 	rcr	dword ptr [rdi+2*4], 1
   723 00002431 D15F0C              <1> 	rcr	dword ptr [rdi+3*4], 1
   724 00002434 D15F10              <1> 	rcr	dword ptr [rdi+4*4], 1
   725 00002437 D15F14              <1> 	rcr	dword ptr [rdi+5*4], 1
   726 0000243A D15F18              <1> 	rcr	dword ptr [rdi+6*4], 1
   727 0000243D D15F1C              <1> 	rcr	dword ptr [rdi+7*4], 1
   728 00002440 83862004000001      <1> 	add	dword ptr [rsi+_INPUTR], 1
   729                              <1> 
   730                              <1> fm_inrange:
   731 00002447 8B8620040000        <1> 	mov	eax, dword ptr [rsi+_INPUTR]
   732 0000244D 038600040000        <1> 	add	eax, dword ptr [rsi+_INPUT2]
   733 00002453 050000C0FF          <1> 	add	eax, -00400000h
   734 00002458 8907                <1> 	mov	dword ptr [rdi], eax		; insert unsigned magnitude product scale
   735 0000245A 8B4704              <1> 	mov	eax, dword ptr [rdi+1*4]
   736 0000245D 314708              <1> 	xor	dword ptr [rdi+2*4], eax	; the mantissa gets polarised here
   737 00002460 31470C              <1> 	xor	dword ptr [rdi+3*4], eax
   738 00002463 314710              <1> 	xor	dword ptr [rdi+4*4], eax
   739 00002466 314714              <1> 	xor	dword ptr [rdi+5*4], eax
   740 00002469 314718              <1> 	xor	dword ptr [rdi+6*4], eax
   741 0000246C 31471C              <1> 	xor	dword ptr [rdi+7*4], eax
   742 0000246F C3                  <1> 	ret
   743                              <1> 
   744 00002470 488DBE40040000      <1> fd:	lea	rdi, [rsi+_OUTPUT]
   745 00002477 E8ABFBFFFF          <1> 	call	zoutput				; result which may stay zero
   746 0000247C 8B8604040000        <1> 	mov	eax, dword ptr [rsi+_INPUT2+1*4]	; signs
   747 00002482 89C3                <1> 	mov	ebx, eax
   748 00002484 338608040000        <1> 	xor	eax, dword ptr [rsi+_INPUT2+2*4]	; normalising bit 31
   749 0000248A 780C                <1> 	js	fdgo
   750 0000248C F79644040000        <1> 	not	dword ptr [rsi+_OUTPUT+1*4]		; divisor 0 or otherwise unnormalised
   751 00002492 E841FDFFFF          <1> 	call	zover				; return -0.0
   752 00002497 C3                  <1> fdnop:	ret					; not normalised = zero divisor
   753                              <1> 
   754 00002498 8B8624040000        <1> fdgo:	mov     eax, dword ptr [rsi+_INPUTR+1*4]	; make sure the dividend is present
   755 0000249E 338628040000        <1> 	xor	eax, dword ptr [rsi+_INPUTR+2*4]	; normalising bit must be not sign
   756 000024A4 783B                <1> 	js	fdop				; go after all
   757                              <1> 						; unnormalised = 0 = unnormalised
   758 000024A6 8B8624040000        <1> 	mov	eax, dword ptr [rsi+_INPUTR+1*4]	; read the signs I tell you
   759 000024AC C78640040000000000- <1> 	mov	dword ptr [rsi+_OUTPUT], 0		; exponent magnitude of nowhere
   759 000024B5 00                  <1>
   760 000024B6 898644040000        <1> 	mov	dword ptr [rsi+_OUTPUT+1*4], eax	; signs
   761 000024BC 898648040000        <1> 	mov	dword ptr [rsi+_OUTPUT+2*4], eax	; and as much mantissa as you like
   762 000024C2 89864C040000        <1> 	mov	dword ptr [rsi+_OUTPUT+3*4], eax
   763 000024C8 898650040000        <1> 	mov	dword ptr [rsi+_OUTPUT+4*4], eax
   764 000024CE 898654040000        <1> 	mov	dword ptr [rsi+_OUTPUT+5*4], eax
   765 000024D4 898658040000        <1> 	mov	dword ptr [rsi+_OUTPUT+6*4], eax
   766 000024DA 89865C040000        <1> 	mov	dword ptr [rsi+_OUTPUT+7*4], eax
   767 000024E0 C3                  <1> 	ret
   768                              <1> 
   769 000024E1 21DB                <1> fdop:	and	ebx, ebx				; divisor either is negative magnitude
   770 000024E3 780C                <1> 	js	fd_comp1	
   771 000024E5 488DBE00040000      <1> 	lea	rdi, [rsi+_INPUT2]			; or shall be
   772 000024EC E8E7FCFFFF          <1> 	call	zover
   773                              <1> fd_comp1:
   774 000024F1 F78624040000000000- <1> 	test	dword ptr [rsi+_INPUTR+1*4], 080000000h
   774 000024FA 80                  <1>
   775 000024FB 740C                <1> 	jz	fd_upright			; dividend must be positive magnitude
   776 000024FD 488DBE20040000      <1> 	lea	rdi, [rsi+_INPUTR]
   777 00002504 E8CFFCFFFF          <1> 	call	zover
   778                              <1> fd_upright:
   779 00002509 488DBE20040000      <1> 	lea	rdi, [rsi+_INPUTR]
   780                              <1> 
   781 00002510 E82CFBFFFF          <1> 	call	round1				; this also sets counters
   782                              <1> 
   783 00002515 52                  <1> 	push	rdx
   784 00002516 51                  <1> 	push	rcx
   785                              <1> 
   786                              <1> ;	add	cx, 01818h		; a divide needs 24 more beats
   787                              <1> 					; than a multiply
   788                              <1> 
   789 00002517 89C8                <1> 	mov	eax, ecx		; save words count in add range
   790 00002519 B15F                <1> 	mov	cl, 95
   791                              <1> 
   792 0000251B C1E810              <1> 	shr	eax, 16			; isolate words count in add range
   793 0000251E 6683C0FA            <1> 	add	ax, -6			; is it big?
   794 00002522 0F8393000000        <1> 	jnc	near fd_72
   795                              <1> 
   796                              <1> ;	test	ch, 128
   797                              <1> ;	jz	near fd_72
   798                              <1> 
   799 00002528 4889E7              <1> 	mov	rdi, rsp
   800                              <1> 
   801 0000252B B1BF                <1> 	mov	cl, 191			; maybe
   802                              <1> 
   803 0000252D F9                  <1> fd_144:	stc				; add negative mantissa
   804 0000252E E8B8FCFFFF          <1> 	call	_add_low		; to positive dividend
   805 00002533 52                  <1> 	push	rdx			; save the low half in the stack
   806 00002534 53                  <1> 	push	rbx
   807 00002535 50                  <1> 	push	rax
   808 00002536 E8D5FCFFFF          <1> 	call	_add_high			; add the high half in eax edx ebx
   809                              <1> 
   810 0000253B 7327                <1> 	jnc	fd_144level			; no carry = drop the result
   811                              <1> 
   812 0000253D 898628040000        <1> 	mov	dword ptr [rsi+_INPUTR+2*4], eax	; carry = update the dividend
   813 00002543 899E2C040000        <1> 	mov	dword ptr [rsi+_INPUTR+3*4], ebx
   814 00002549 899630040000        <1> 	mov	dword ptr [rsi+_INPUTR+4*4], edx
   815                              <1> 
   816 0000254F 58                  <1> 	pop	rax
   817 00002550 898634040000        <1> 	mov	dword ptr [rsi+_INPUTR+5*4], eax
   818 00002556 58                  <1> 	pop	rax
   819 00002557 898638040000        <1> 	mov	dword ptr [rsi+_INPUTR+6*4], eax
   820 0000255D 58                  <1> 	pop	rax
   821 0000255E 89863C040000        <1> 	mov	dword ptr [rsi+_INPUTR+7*4], eax
   822                              <1> fd_144level:
   823 00002564 4889FC              <1> 	mov	rsp, rdi	; clear stack whether popped or not
   824 00002567 D1965C040000        <1> 	rcl	dword ptr [rsi+_OUTPUT+7*4], 1	; shift value of carry into quotient
   825 0000256D D19658040000        <1> 	rcl	dword ptr [rsi+_OUTPUT+6*4], 1
   826 00002573 D19654040000        <1> 	rcl	dword ptr [rsi+_OUTPUT+5*4], 1
   827 00002579 D19650040000        <1> 	rcl	dword ptr [rsi+_OUTPUT+4*4], 1
   828 0000257F D1964C040000        <1> 	rcl	dword ptr [rsi+_OUTPUT+3*4], 1
   829 00002585 D19648040000        <1> 	rcl	dword ptr [rsi+_OUTPUT+2*4], 1
   830                              <1> 
   831 0000258B F9                  <1> 	stc
   832 0000258C D19E08040000        <1> 	rcr	dword ptr [rsi+_INPUT2+2*4], 1	; shift negative addend
   833 00002592 D19E0C040000        <1> 	rcr	dword ptr [rsi+_INPUT2+3*4], 1	; 1 position starboard
   834 00002598 D19E10040000        <1> 	rcr	dword ptr [rsi+_INPUT2+4*4], 1
   835 0000259E D19E14040000        <1> 	rcr	dword ptr [rsi+_INPUT2+5*4], 1
   836 000025A4 D19E18040000        <1> 	rcr	dword ptr [rsi+_INPUT2+6*4], 1
   837 000025AA D19E1C040000        <1> 	rcr	dword ptr [rsi+_INPUT2+7*4], 1
   838                              <1> 
   839 000025B0 80C1FF              <1> 	add	cl, -1
   840 000025B3 0F8274FFFFFF        <1> 	jc	fd_144
   841 000025B9 EB44                <1> 	jmp	fd_restore	
   842                              <1> 
   843 000025BB F9                  <1> fd_72:	stc					; add negative mantissa
   844 000025BC E84FFCFFFF          <1> 	call	_add_high			; to positive dividend
   845 000025C1 7312                <1> 	jnc	fd_72level			; no carry = drop the result
   846                              <1> 
   847 000025C3 898628040000        <1> 	mov	dword ptr [rsi+_INPUTR+2*4], eax	; carry = update the dividend
   848 000025C9 899E2C040000        <1> 	mov	dword ptr [rsi+_INPUTR+3*4], ebx
   849 000025CF 899630040000        <1> 	mov	dword ptr [rsi+_INPUTR+4*4], edx
   850                              <1> fd_72level:
   851 000025D5 D19650040000        <1> 	rcl	dword ptr [rsi+_OUTPUT+4*4], 1	; shift value of carry into quotient
   852 000025DB D1964C040000        <1> 	rcl	dword ptr [rsi+_OUTPUT+3*4], 1
   853 000025E1 D19648040000        <1> 	rcl	dword ptr [rsi+_OUTPUT+2*4], 1
   854                              <1> 
   855 000025E7 F9                  <1> 	stc
   856 000025E8 D19E08040000        <1> 	rcr	dword ptr [rsi+_INPUT2+2*4], 1	; shift negative addend
   857 000025EE D19E0C040000        <1> 	rcr	dword ptr [rsi+_INPUT2+3*4], 1	; 1 position starboard
   858 000025F4 D19E10040000        <1> 	rcr	dword ptr [rsi+_INPUT2+4*4], 1	;
   859                              <1> 
   860 000025FA 80C1FF              <1> 	add	cl, -1
   861 000025FD 72BC                <1> 	jc	fd_72
   862                              <1> 
   863 000025FF 59                  <1> fd_restore:	pop	rcx
   864 00002600 5A                  <1> 		pop	rdx				; hand the program counter back
   865                              <1> 
   866                              <1> 
   867                              <1> ;		mov	rsi, dword ptr [rbp+CORE_INDEX1] ; fd kept esi -> core state
   868                              <1> ;	from mm7 anyway
   869                              <1> 
   870 00002601 8B8620040000        <1> 		mov	eax, dword ptr [rsi+_INPUTR]	; + magnitude dividend exponent
   871 00002607 2B8600040000        <1> 		sub	eax, dword ptr [rsi+_INPUT2]	; + magnitude divisor exponent
   872 0000260D 0501004000          <1> 		add	eax, 00400001h			; midpoint + 1
   873 00002612 898640040000        <1> 		mov	dword ptr [rsi+_OUTPUT], eax	; magnitude of quotient scale
   874                              <1> 							; -> front of delivery string
   875 00002618 488DBE40040000      <1> 		lea	rdi, [rsi+_OUTPUT]
   876                              <1> 
   877 0000261F E826FBFFFF          <1> 		call	renormalise
   878                              <1> 
   879 00002624 488DBE40040000      <1> 		lea	rdi, [rsi+_OUTPUT]			; tell rewrite where it is
   880 0000262B 8B8624040000        <1> 		mov	eax, dword ptr [rsi+_INPUTR+1*4]	; determine sign of quotient
   881 00002631 338604040000        <1> 		xor	eax, dword ptr [rsi+_INPUT2+1*4]
   882 00002637 894704              <1> 		mov	[rdi+1*4], eax			; output 32 signs
   883                              <1> 							; _deliver_ polarises the quotient scale
   884 0000263A 314708              <1> 		xor	dword ptr [rdi+2*4], eax	; switch quotient mantissa
   885 0000263D 31470C              <1> 		xor	dword ptr [rdi+3*4], eax
   886 00002640 314710              <1> 		xor	dword ptr [rdi+4*4], eax
   887 00002643 314714              <1> 		xor	dword ptr [rdi+5*4], eax	; switch the long mantissa
   888 00002646 314718              <1> 		xor	dword ptr [rdi+6*4], eax
   889 00002649 31471C              <1> 		xor	dword ptr [rdi+7*4], eax
   890                              <1> 
   891 0000264C C3                  <1> fd_z:		ret
   892                              <1> 
   893                              <1> 	;	these instructions take the left-side + target as
   894                              <1> 	;	[register_set]->a:b:mantissa2:mantissa3
   895                              <1> 	;	and the right side as [ea]
   896                              <1> 
   897                              <1> 	;	after acquisition and before delivery they call modules
   898                              <1> ;	fa fan fm fd
   899                              <1> ;	which may be used in extended instruction sets
   900                              <1> ;	using source and target registers in the internal stack
   901                              <1> ;	with maximum mantissa size 168 bits
   902                              <1> 
   903                              <1> 
   904                              <1> ;	rsi -> core state but must also be used dynamically a lot
   905                              <1> ;	rbp -> always points at either one of two locations
   906                              <1> 
   907                              <1> ;		RTA1 application registers [ 0..127 ] modeled in 128 integers
   908                              <1> ;		RTA1 interrupt registers [ 128..255 ] modeled in 128 integers
   909                              <1> ;
   910                              <1> ;	there is always a copy of rsi for retrieval at [ rbp + 152 integers ] ->
   911                              <1> 
   912                              <1> ;	_________________________.------ rsi and rbp in application mode
   913                              <1> ;	|  RTA1 register 0	|					|
   914                              <1> ;	|_______________________|					|
   915                              <1> ;									|
   916                              <1> ;	________________________.------- rbp in ISR mode		|
   917                              <1> ;	|  RTA1 register 128	|			|		|
   918                              <1> ;	|_______________________|			|		|
   919                              <1> ;							|		|
   920                              <1> ;							|		|
   921                              <1> ;							|		|
   922                              <1> ;	_________________________.______________________________________|
   923                              <1> ;	| RTA register 152 = rsi| offset rbp + 152 integers 
   924                              <1> ;	|_______________________|			|
   925                              <1> ;							|
   926                              <1> ;	.________________________.______________________|
   927                              <1> ;	| RTA register 280 = rsi| offset rbp + 152 integers
   928                              <1> ;	|_______________________|
   929                              <1> 
   930 0000264D BB04000000          <1> _fa:	mov 	ebx, a
   931 00002652 53                  <1> _far:	push	rbx
   932 00002653 E86F000000          <1> 	call	fp_operands
   933 00002658 E89D000000          <1> 	call	fp_registers_a
   934 0000265D E8E5FBFFFF          <1> 	call	fa
   935 00002662 5B                  <1> 	pop	rbx
   936 00002663 E9E5F8FFFF          <1> 	jmp	_deliver_
   937                              <1> 
   938 00002668 BB04000000          <1> _fan:	mov	ebx, a
   939 0000266D 53                  <1> _fanr:	push	rbx
   940 0000266E E854000000          <1> 	call	fp_operands
   941 00002673 E882000000          <1> 	call	fp_registers_a
   942 00002678 E8B8FBFFFF          <1> 	call	fan
   943 0000267D 5B                  <1> 	pop	rbx
   944 0000267E E9CAF8FFFF          <1> 	jmp	_deliver_
   945                              <1> 
   946 00002683 BB04000000          <1> _fm:	mov	ebx, a
   947 00002688 53                  <1> _fmr:	push	rbx
   948 00002689 E839000000          <1> 	call	fp_operands
   949 0000268E E882000000          <1> 	call	fp_registers_m
   950 00002693 E862FCFFFF          <1> 	call	fm
   951 00002698 5B                  <1> 	pop	rbx
   952 00002699 488DBE40040000      <1> 	lea	rdi, [rsi+_OUTPUT]
   953 000026A0 E9A8F8FFFF          <1> 	jmp	 _deliver_
   954                              <1> 
   955 000026A5 BB04000000          <1> _fd:	mov	ebx, a				; default target register
   956 000026AA 53                  <1> _fdr:	push	rbx
   957 000026AB E817000000          <1> 	call	fp_operands
   958 000026B0 E860000000          <1> 	call	fp_registers_m
   959 000026B5 E8B6FDFFFF          <1> 	call	fd
   960 000026BA 5B                  <1> 	pop	rbx
   961 000026BB 488DBE40040000      <1> 	lea	rdi, [rsi+_OUTPUT]
   962 000026C2 E986F8FFFF          <1> 	jmp	_deliver_
   963                              <1> 
   964                              <1> fp_operands:
   965 000026C7 488DBE20040000      <1> 	lea	rdi, [rsi+_INPUTR]
   966 000026CE 50                  <1> 	push	rax				; save effective address
   967 000026CF E85C000000          <1> 	call	_load_quad
   968 000026D4 E82BF8FFFF          <1> 	call	compress4to8
   969 000026D9 58                  <1> 	pop	rax				; restore effective address
   970                              <1> 
   971 000026DA 55                  <1> 	push	rbp				; ebp must momentarily
   972 000026DB 4889F5              <1> 	mov	rbp, rsi			; -> start of all register list
   973 000026DE BB00010000          <1> 	mov	ebx, _input2			; into starboard buffer
   974 000026E3 E8E5DDFFFF          <1> 	call	_burst_read4			; memory or registers @ ea
   975 000026E8 5D                  <1> 	pop	rbp				; App / Int register context
   976                              <1> 
   977 000026E9 480F7EFE            <1> 	movq	rsi, mm7
   978                              <1> ;	mov	rsi, qword ptr [rbp+CORE_INDEX1]
   979                              <1> 
   980 000026ED 488DBE00040000      <1> 	lea	rdi, [rsi+_INPUT2]		; but still in rbp
   981 000026F4 E80BF8FFFF          <1> 	call	compress4to8
   982 000026F9 C3                  <1> 	ret
   983                              <1> 
   984                              <1> fp_registers_a:
   985 000026FA 480F7EFE            <1> 	movq	rsi, mm7
   986                              <1> ;	mov	rsi, qword ptr [rbp+CORE_INDEX1]
   987 000026FE B908020400          <1> 	mov	ecx, 00040208h
   988 00002703 F786B0040000080000- <1> 	test	dword ptr [rsi+PSR], FP_R
   988 0000270C 00                  <1>
   989 0000270D 7405                <1> 	jz	fp_registers_x
   990 0000270F B910040600          <1> 	mov	ecx, 00060410h
   991                              <1> fp_registers_x:
   992 00002714 C3                  <1> 	ret
   993                              <1> 
   994                              <1> fp_registers_m:
   995 00002715 480F7EFE            <1> 	movq	rsi, mm7
   996                              <1> ;	mov	rsi, qword ptr [rbp+CORE_INDEX1]
   997 00002719 B908020400          <1> 	mov	ecx, 00040208h
   998 0000271E F786B0040000080000- <1> 	test	dword ptr [rsi+PSR], FP_R
   998 00002727 00                  <1>
   999 00002728 7405                <1> 	jz	fp_registers_z
  1000 0000272A B910040600          <1> 	mov	ecx, 00060410h
  1001                              <1> fp_registers_z:
  1002 0000272F C3                  <1> 	ret
  1003                              <1> 
  1004                              <1> _load_quad:
  1005 00002730 8B449D0C            <1> 	mov	eax, dword ptr[rbp+rbx*4+3*4]
  1006 00002734 89470C              <1> 	mov	dword ptr [rdi+3*4], eax
  1007 00002737 8B449D08            <1> 	mov	eax, dword ptr  [rbp+rbx*4+2*4]
  1008 0000273B 894708              <1> 	mov	dword ptr [rdi+2*4], eax
  1009 0000273E 8B449D04            <1> 	mov	eax, dword ptr [rbp+rbx*4+1*4]
  1010 00002742 894704              <1> 	mov	dword ptr [rdi+1*4], eax
  1011 00002745 8B449D00            <1> 	mov	eax, dword ptr [rbp+rbx*4]
  1012 00002749 8907                <1> 	mov	dword ptr [rdi], eax
  1013 0000274B C3                  <1> 	ret
  1014                              <1> 
  1015                              <1> 
  1016                              <1> 	%if	0
  1017                              <1> ultrate:
  1018                              <1> 	mov	eax, dword ptr [rdi]
  1019                              <1> 	mov	dword ptr [_ultra], eax
  1020                              <1>  
  1021                              <1> 	mov     eax, dword ptr [rdi+1*4]
  1022                              <1> 	mov     dword ptr [_ultra1], eax
  1023                              <1> 
  1024                              <1>         mov     eax, dword ptr [rdi+2*4]
  1025                              <1>         mov     dword ptr [_ultra2], eax
  1026                              <1> 
  1027                              <1>         mov     eax, dword ptr [rdi+3*4]
  1028                              <1>         mov     dword ptr [_ultra3], eax
  1029                              <1> 
  1030                              <1>         mov     eax, dword ptr [rdi+4*4]
  1031                              <1>         mov     dword ptr [_ultra4], eax
  1032                              <1> 
  1033                              <1>         mov     eax, dword ptr [rdi+5*4]
  1034                              <1>         mov     dword ptr [_ultra5], eax
  1035                              <1> 
  1036                              <1>         mov     eax, dword ptr [rdi+6*4]
  1037                              <1>         mov     dword ptr [_ultra6], eax
  1038                              <1> 
  1039                              <1>         mov     eax, dword ptr [rdi+7*4]
  1040                              <1>         mov     dword ptr [_ultra7], eax
  1041                              <1> 
  1042                              <1> 	ret
  1043                              <1> 
  1044                              <1> zultrate:
  1045                              <1> 	push	rdi
  1046                              <1> 	mov	rdi, __ZERO
  1047                              <1> 	call	ultrate
  1048                              <1> 	pop	rdi
  1049                              <1> 	ret
  1050                              <1> 
  1051                              <1> __ZERO	dd	0, 0, 0, 0, 0, 0, 0, 0
  1052                              <1> 	%endif
    43                                  	%include	"parity.msm"
     1                              <1> _get_parity:
     2 0000274C 8B5D10              <1>         mov     ebx, dword ptr [rbp+A]
     3 0000274F 235D04              <1>         and     ebx, dword ptr [rbp+K]
     4                              <1> _fold_parity:
     5 00002752 30DF                <1>         xor     bh, bl
     6 00002754 C1EB08              <1>         shr     ebx, 8
     7 00002757 30FB                <1>         xor     bl, bh
     8 00002759 C3                  <1>         ret
     9                              <1> 
    44                                  	%include	"margin.msm"
     1                              <1> read_straddle_12b?:
     2                              <1> 
     3 0000275A F6C101              <1> 	test	cl, 1				; 4 words? You are here because
     4 0000275D 753A                <1> 	jnz	split_read4w			; offset is within last 3 of page
     5                              <1> 						; 2 words then
     6 0000275F 81FEFF0F0000        <1> 	cmp	esi, 0FFFh			; starting @ last word of page?
     7 00002765 7231                <1> 	jb	readout				; not so, go ahead with burst read
     8                              <1> 
     9                              <1> split_read2w:
    10 00002767 480F7EFE            <1> 	movq	rsi, mm7
    11                              <1> ;	mov	rsi, qword ptr [rbp+CORE_INDEX1]
    12                              <1> 
    13 0000276B 48893C24            <1> 	mov	qword ptr [rsp], rdi		; delete 1st return address + save EA
    14 0000276F 4889F8              <1> 	mov	rax, rdi			; recover EA
    15 00002772 30C9                <1> 	xor	cl, cl				; request 1 word
    16 00002774 E899DDFFFF          <1> 	call	_bus_read			;
    17 00002779 48870424            <1> 	xchg	rax, qword ptr [rsp]		; save 1st word read + load updated EA
    18 0000277D FFC0                <1> 	inc	eax				; advance EA onto next page
    19 0000277F 30C9                <1> 	xor	cl, cl				; request 1 word
    20 00002781 E88CDDFFFF          <1> 	call	_bus_read			; read new page or block
    21 00002786 89C3                <1> 	mov	ebx, eax
    22 00002788 58                  <1> 	pop	rax				; recover 1st read word
    23 00002789 C3                  <1> 	ret					; return to caller of operand_read
    24                              <1> 
    25                              <1> read_straddle_18b?:
    26 0000278A F6C101              <1> 	test	cl, 1				; 4 words? You are here because 
    27 0000278D 750A                <1> 	jnz	split_read4w			; offset is within last 3 of of bank
    28                              <1> 						; 2 words then
    29 0000278F 4881FEFFFF0300      <1> 	cmp	rsi, 0003FFFFh			; starting @ last word of bank?
    30 00002796 73CF                <1> 	jnb	split_read2w			; otherwise fall thru to burst read
    31                              <1> 
    32                              <1> readout:
    33 00002798 C3                  <1> 	ret					; burst read in order
    34                              <1> 
    35                              <1> split_read4w:					; write EA over stack top return address
    36 00002799 480F7EFE            <1> 	movq	rsi, mm7
    37                              <1> ;	mov	rsi, qword ptr [rbp+CORE_INDEX1]
    38                              <1> 
    39 0000279D 48893C24            <1> 	mov	qword ptr [rsp], rdi		; one or other of these 2-word reads
    40 000027A1 89F8                <1> 	mov	eax, edi			; splits down to 1-word reads
    41 000027A3 E807000000          <1> 	call	read2				; when offset is [3F]FFD
    42 000027A8 E802000000          <1> 	call	read2				;             or [3F]FFF
    43 000027AD 58                  <1> 	pop	rax				;   but not when [3F]FFE
    44 000027AE C3                  <1> 	ret					; return to caller of caller
    45                              <1> 	
    46 000027AF 50                  <1> read2:	push	rax				; EA
    47 000027B0 53                  <1> 	push	rbx				; destination index on stack top
    48 000027B1 B106                <1> 	mov	cl, 6				; ask bus for 2 words
    49 000027B3 E85ADDFFFF          <1> 	call	_bus_read			; replaces eax and ebx
    50 000027B8 48871C24            <1> 	xchg	rbx, qword ptr [rsp]		; get destination index up again
    51 000027BC 89449D00            <1> 	mov	dword ptr [rbp+rbx*4], eax	; write 1st result word
    52 000027C0 58                  <1> 	pop	rax				; recover 2nd result word
    53 000027C1 89449D04            <1> 	mov	dword ptr [rbp+rbx*4+1*4], eax	; write 2nd result word
    54 000027C5 58                  <1> 	pop	rax				; EA
    55 000027C6 4883C002            <1> 	add	rax, 2
    56 000027CA 4883C302            <1> 	add	rbx, 2
    57 000027CE C3                  <1> 	ret	
    58                              <1> 
    45                                  	%include	"margin_w.msm"
     1                              <1> write_straddle_12b?:				; multiword write request
     2                              <1> write_straddle12b?:				; in last 3 words of block
     3 000027CF F6C101              <1> 	test	cl, 1				; 4-word write request?
     4 000027D2 753E                <1> 	jnz	split_write4w			;
     5 000027D4 81FEFF0F0000        <1> 	cmp	esi, 0FFFH			; 2 words then. In last word?
     6 000027DA 7235                <1> 	jb	writeout			; no
     7                              <1> 						; yes
     8                              <1> split_write2w:
     9 000027DC 480F7EFE            <1> 	movq	rsi, mm7
    10                              <1> ;	mov	rsi, qword ptr [rbp+CORE_INDEX1]
    11                              <1> 
    12 000027E0 48891C24            <1> 	mov	qword ptr [rsp], rbx		; not returning to there
    13 000027E4 57                  <1> 	push	rdi				; esp -> saved eax [ea], saved ebx
    14 000027E5 4889F8              <1> 	mov	rax, rdi			; place ea in eax
    15 000027E8 30C9                <1> 	xor	cl, cl				; request 1-word write
    16 000027EA 8B5C9D00            <1> 	mov	ebx, dword ptr [rbp+rbx*4]	; data from register array
    17 000027EE E8EDDEFFFF          <1> 	call	bus_write
    18 000027F3 58                  <1> 	pop	rax				; retrieve ea from stack
    19 000027F4 5B                  <1> 	pop	rbx				; retrieve register index
    20 000027F5 48FFC0              <1> 	inc	rax				; advance ea to next block
    21 000027F8 8B5C9D04            <1> 	mov	ebx, dword ptr [rbp+rbx*4+4]	; data from register array
    22 000027FC 30C9                <1> 	xor	cl, cl				; request 1-word write
    23 000027FE E8DDDEFFFF          <1> 	call	bus_write
    24 00002803 C3                  <1> 	ret					; return caller of caller
    25                              <1> 
    26                              <1> write_straddle_18b?:				; multiword write request
    27                              <1> write_straddle18b?:				; in last 3 words of block
    28 00002804 F6C101              <1> 	test	cl, 1				; 4 words?
    29 00002807 7509                <1> 	jnz	split_write4w
    30 00002809 81FEFFFF0300        <1> 	cmp	esi, 0003FFFFh			; 2 words then. In last word?
    31 0000280F 73CB                <1> 	jnb	split_write2w			; yes
    32                              <1> 						; no
    33                              <1> writeout:
    34 00002811 C3                  <1> 	ret					; return to burst write
    35                              <1> 
    36                              <1> split_write4w:
    37 00002812 480F7EFE            <1> 	movq	rsi, mm7
    38                              <1> ;	mov	rsi, qword ptr [rbp+CORE_INDEX1]
    39                              <1> 
    40 00002816 48893C24            <1> 	mov	qword ptr [rsp], rdi		; return address at stack top not used
    41 0000281A 4889F8              <1> 	mov	rax, rdi			; copy ea
    42 0000281D E807000000          <1> 	call	write2				; request 2 writes word pairs
    43 00002822 E802000000          <1> 	call	write2				; if 1 of them straddles it splits again
    44 00002827 58                  <1> 	pop	rax				; this is ea
    45 00002828 C3                  <1> 	ret					; return to caller of caller
    46                              <1> 
    47                              <1> 
    48 00002829 B106                <1> write2:	mov	cl, 6				; request 2-word bus write
    49 0000282B 50                  <1> 	push	rax				; save ea
    50 0000282C 53                  <1> 	push	rbx				; save register array index
    51 0000282D E8AEDEFFFF          <1> 	call	bus_write			; send write pair request
    52 00002832 5B                  <1> 	pop	rbx				; retrieve register index
    53 00002833 58                  <1> 	pop	rax				; and ea
    54 00002834 4883C302            <1> 	add	rbx, 2				; update register index
    55 00002838 4883C002            <1> 	add	rax, 2				; and ea
    56 0000283C C3                  <1> 	ret
    46                                  	%include	"rex.msm"
     1                              <1> 
     2                              <1> _rextable_1
     2          ******************  <1>  warning: label alone on a line without a colon might be in error [-w+orphan-labels]
     3 0000283D 000000000000000000- <1> 	dd	0, 0, 0, 0,		r_sa, r_sb, r_z, 0
     3 00002846 00000000000000-     <1>
     3 0000284D [802B0000]-         <1>
     3 00002851 [772B0000]-         <1>
     3 00002855 [992B0000]00000000  <1>
     4 0000285D 000000000000000000- <1> 	dd	0, 0, 0, 0,		r_la, r_lb, r_tz, r_tp
     4 00002866 00000000000000-     <1>
     4 0000286D [B42B0000]-         <1>
     4 00002871 [AB2B0000]-         <1>
     4 00002875 [402B0000]-         <1>
     4 00002879 [5B2B0000]          <1>
     5 0000287D 0000000000000000-   <1> 	dd	0, 0, r_or, r_orB,	r_and, r_andB, r_xor, r_xorB
     5 00002885 [D22B0000]-         <1>
     5 00002889 [C92B0000]-         <1>
     5 0000288D [F42B0000]-         <1>
     5 00002891 [EB2B0000]-         <1>
     5 00002895 [162C0000]-         <1>
     5 00002899 [0D2C0000]          <1>
     6 0000289D [382C0000]-         <1> 	dd	r_aa, r_ab, r_ana, r_anb, r_m, r_mf, r_d, 0
     6 000028A1 [2F2C0000]-         <1>
     6 000028A5 [562C0000]-         <1>
     6 000028A9 [4D2C0000]-         <1>
     6 000028AD [932C0000]-         <1>
     6 000028B1 [722C0000]-         <1>
     6 000028B5 [3F2D0000]00000000  <1>
     7                              <1> 
     8                              <1> _rextable_6
     8          ******************  <1>  warning: label alone on a line without a colon might be in error [-w+orphan-labels]
     9 000028BD [7F2D0000]-         <1> 	dd	r_sar, r_sbr, r_dsr, 0, r_sal, r_sbl, r_dsl, 0
     9 000028C1 [762D0000]-         <1>
     9 000028C5 [9A2D0000]00000000- <1>
     9 000028CD [C62D0000]-         <1>
     9 000028D1 [BD2D0000]-         <1>
     9 000028D5 [E12D0000]00000000  <1>
    10 000028DD [0D2E0000]-         <1> 	dd	r_rar, r_rbr, r_drr, 0, r_ral, r_rbl, r_drl, 0
    10 000028E1 [042E0000]-         <1>
    10 000028E5 [262E0000]00000000- <1>
    10 000028ED [522E0000]-         <1>
    10 000028F1 [492E0000]-         <1>
    10 000028F5 [6B2E0000]00000000  <1>
    11 000028FD [972E0000]-         <1> 	dd	r_saa, r_sba, r_dsa, 0, 0, 0, 0, 0
    11 00002901 [8E2E0000]-         <1>
    11 00002905 [B32E0000]00000000- <1>
    11 0000290D 000000000000000000- <1>
    11 00002916 00000000000000      <1>
    12 0000291D 000000000000000000- <1> 	dd	0, 0, 0, 0, 		0, 0, 0, 0
    12 00002926 000000000000000000- <1>
    12 0000292F 000000000000000000- <1>
    12 00002938 0000000000          <1>
    13                              <1> 
    14                              <1> _rextable_7
    14          ******************  <1>  warning: label alone on a line without a colon might be in error [-w+orphan-labels]
    15 0000293D 000000000000000000- <1> 	dd	0, 0, 0, 0,		0, 0, 0, 0
    15 00002946 000000000000000000- <1>
    15 0000294F 000000000000000000- <1>
    15 00002958 0000000000          <1>
    16 0000295D [D62E0000]-         <1> 	dd	r_qs, r_ql, r_dte, 0,	r_fa, r_fan, r_fm, r_fd
    16 00002961 [E52E0000]-         <1>
    16 00002965 [F42E0000]00000000- <1>
    16 0000296D [102B0000]-         <1>
    16 00002971 [1C2B0000]-         <1>
    16 00002975 [282B0000]-         <1>
    16 00002979 [342B0000]          <1>
    17 0000297D 000000000000000000- <1> 	dd	0, 0, 0, 0, 		0, r_mta, 0, 0
    17 00002986 000000000000000000- <1>
    17 0000298F 0000[0A2F0000]0000- <1>
    17 00002997 000000000000        <1>
    18 0000299D [292F0000]-         <1> 	dd	r_ds, r_dl, r_da, r_dan, 0, 0, 0, 0
    18 000029A1 [382F0000]-         <1>
    18 000029A5 [6C2F0000]-         <1>
    18 000029A9 [512F0000]00000000- <1>
    18 000029B1 000000000000000000- <1>
    18 000029BA 000000              <1>
    19                              <1> 
    20                              <1> 
    21 000029BD F686B204000080      <1> _rex:	test	byte ptr [rsi+PSR+2], 128
    22 000029C4 0F88D8000000        <1> 	js	near _rex_z				; ISRs can't do this
    23                              <1> 
    24 000029CA E890DEFFFF          <1> 	call	memory_read				; ea -> instruction for repeat	
    25                              <1> 
    26 000029CF 480F7EFE            <1> 	movq	rsi, mm7
    27                              <1> ;	mov	rsi, qword ptr [rbp+CORE_INDEX1]	; retrieve smp core ->
    28                              <1> 
    29 000029D3 898668040000        <1> 	mov	dword ptr [rsi+REGISTER+282*4], eax	; save instruction word
    30 000029D9 E843D7FFFF          <1> 	call	__ea					; get initial ea of repeated  instruction
    31 000029DE 0FB6DD              <1> 	movzx	ebx, ch					; spin-off is opcode index in ch
    32                              <1> 							; and operand type in cl
    33 000029E1 80F906              <1> 	cmp	cl, 6
    34 000029E4 7214                <1> 	jb	_rex_itable1
    35 000029E6 7709                <1> 	ja	_rex_itable7
    36                              <1> 							; instruction list 6
    37 000029E8 8B1C9D[BD280000]    <1> 	mov	ebx, dword ptr [_rextable_6+rbx*4]	; shifts and jumps
    38 000029EF EB10                <1> 	jmp	_rex_evaluate
    39                              <1> 
    40                              <1> _rex_itable7:						; instruction list 7
    41 000029F1 8B1C9D[3D290000]    <1> 	mov	ebx, dword ptr [_rextable_7+rbx*4]	; large arithmetic
    42 000029F8 EB07                <1> 	jmp	_rex_evaluate
    43                              <1> 
    44                              <1> _rex_itable1:						; instruction list 1
    45 000029FA 8B1C9D[3D280000]    <1> 	mov	ebx, dword ptr [_rextable_1+rbx*4]	; single integer arithmetic
    46                              <1> 
    47                              <1> _rex_evaluate:
    48 00002A01 21DB                <1> 	and	ebx, ebx				; instruction for repeat execute?
    49 00002A03 0F8499000000        <1> 	jz	near _rex_z				; no
    50 00002A09 899E74040000        <1> 	mov	dword ptr [rsi+REGISTER+285*4], ebx	; yes: save execution logic pointer
    51                              <1> 
    52                              <1> 							; if repeat instruction is indexed:
    53                              <1> 							; quick lookup tag for index increment
    54 00002A0F C78670040000000000- <1> 	mov	dword ptr [rsi+REGISTER+284*4], 0		; default no index register referenced
    54 00002A18 00                  <1>
    55 00002A19 8B9E68040000        <1> 	mov	ebx, dword ptr [rsi+REGISTER+282*4]	; identify any index register tag
    56 00002A1F 6621DB              <1> 	and	bx, bx					; in the instruction word
    57 00002A22 791A                <1> 	jns	_rex_ready				; by testing bit 15
    58 00002A24 66C1EB0C            <1> 	shr	bx, 12
    59                              <1> 							; must be > indirection tags *B0+ *B1+
    60 00002A28 80FB0A              <1> 	cmp	bl, 10					; pointers in storage not incremented
    61 00002A2B 7211                <1> 	jb	_rex_ready				; index registers may increment
    62 00002A2D 80FB0E              <1> 	cmp	bl, 14
    63 00002A30 7303                <1> 	jnb	_rex_indexed				; [   fp sp ]  registers   [ 14 15 ]
    64 00002A32 80E307              <1> 	and	bl, 7					; [ x y a b ]  registers [ 2 3 4 5 ]
    65                              <1> 
    66                              <1> _rex_indexed:
    67 00002A35 83E30F              <1> 	and	ebx, 15					; make 32-bit index value
    68 00002A38 899E70040000        <1> 	mov	dword ptr [rsi+REGISTER+284*4], ebx	; write quick lookup
    69                              <1> 
    70                              <1> _rex_ready:
    71 00002A3E 8B5E34              <1> 	mov	ebx, dword ptr [rsi+REGISTER+Q]		; default target register [ q ] ->	
    72 00002A41 8B9674040000        <1> 	mov	edx, dword ptr [rsi+REGISTER+285*4]	; execute logic ->
    73 00002A47 FFD2                <1> 	call	rdx
    74                              <1> 
    75 00002A49 8B8670040000        <1> 	mov	eax, dword ptr [rsi+REGISTER+284*4]	; index register tag?
    76 00002A4F 6621C0              <1> 	and	ax, ax
    77 00002A52 7417                <1> 	jz	_rex_count				; no
    78                              <1> 
    79 00002A54 8B4E5C              <1> 	mov	ecx, dword ptr [rsi+REGISTER+WDATA]
    80 00002A57 81E1FFFFFF00        <1> 	and	ecx, 00FFFFFFh				; index register increment configured?
    81 00002A5D 740C                <1> 	jz	_rex_count				; no
    82                              <1> 
    83 00002A5F 030C86              <1> 	add	ecx, dword ptr [rsi+REGISTER+rax*4]	; calculate index + increment
    84 00002A62 81E1FFFFFF00        <1> 	and	ecx, 00FFFFFFh				; 
    85 00002A68 890C86              <1> 	mov	dword ptr [rsi+REGISTER+rax*4], ecx	; write back to tagged index register
    86                              <1> 
    87                              <1> _rex_count:
    88 00002A6B 8B4650              <1> 	mov	eax, dword ptr [rsi+REGISTER+RDATAC]
    89 00002A6E FFC8                <1> 	dec	eax
    90 00002A70 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
    91                              <1> 
    92 00002A75 894650              <1> 	mov	dword ptr [rsi+REGISTER+RDATAC], eax
    93 00002A78 A900008000          <1> 	test	eax, 00800000h
    94 00002A7D 7523                <1> 	jnz	_rex_z					; reached -1 end
    95                              <1> 
    96 00002A7F 66F786A4040000E0FF  <1> 	test	word ptr [rsi+INDICATION], EXTERNAL_INDICATIONS
    97 00002A88 7405                <1> 	jz	_rex_along
    98                              <1> 
    99 00002A8A 83C2FC              <1> 	add	edx, -4					; restart after
   100 00002A8D EB13                <1> 	jmp	_rex_z					; yielding to interrupt
   101                              <1> 
   102                              <1> _rex_along:
   103 00002A8F 8B8668040000        <1> 	mov	eax, [rsi+REGISTER+282*4]			; instruction encoding
   104 00002A95 E887D6FFFF          <1> 	call	__ea
   105 00002A9A 8B9E74040000        <1> 	mov	ebx, [rsi+REGISTER+285*4]			; command pointer
   106 00002AA0 EB9C                <1> 	jmp	_rex_ready
   107 00002AA2 C3                  <1> _rex_z:	ret
   108                              <1> 
   109                              <1> _rex_prime_final_count:
   110 00002AA3 F7455000008000      <1> 	test	dword ptr [rbp+RDATAC], 00800000h
   111 00002AAA 7422                <1> 	jz	_rex_primed
   112 00002AAC 8B5D58              <1> 	mov	ebx, dword ptr [rbp+WDATAC]
   113 00002AAF 895D50              <1> 	mov	dword ptr [rbp+RDATAC], ebx
   114 00002AB2 C3                  <1> 	ret
   115                              <1> 
   116                              <1> _rex_prime:
   117 00002AB3 F7455000008000      <1> 	test	dword ptr [rbp+RDATAC], 00800000h
   118 00002ABA 7412                <1> 	jz	_rex_primed
   119 00002ABC 8B5D58              <1> 	mov	ebx, dword ptr [rbp+WDATAC]
   120 00002ABF 895D50              <1> 	mov	dword ptr [rbp+RDATAC], ebx
   121 00002AC2 8B5D3C              <1> 	mov	ebx, dword ptr [rbp+S_P]
   122 00002AC5 81E3FFFFFF00        <1> 	and	ebx, 00FFFFFFh
   123 00002ACB 895D34              <1> 	mov	dword ptr [rbp+Q], ebx
   124                              <1> _rex_primed:
   125 00002ACE C3                  <1> 	ret
   126                              <1> 
   127                              <1> _rex_accumulate:
   128 00002ACF 480F7EFE            <1> 	movq	rsi, mm7
   129                              <1> ;	mov	rsi, qword ptr [rbp+CORE_INDEX1]
   130                              <1> 
   131 00002AD3 8B5E54              <1> 	mov	ebx, dword ptr [rsi+RDATA]
   132 00002AD6 035D34              <1> 	add	ebx, dword ptr [rbp+Q]
   133 00002AD9 81E3FFFFFF00        <1> 	and	ebx, 00FFFFFFh
   134 00002ADF 895D34              <1> 	mov	dword ptr [rbp+Q], ebx
   135 00002AE2 C3                  <1> 	ret
   136                              <1> 
   137                              <1> _rex_chex_127:
   138 00002AE3 E8CBFFFFFF          <1> 	call	_rex_prime
   139 00002AE8 83FB7F              <1> 	cmp	ebx, 127
   140 00002AEB 7618                <1> 	jna	_rex_chex_low
   141 00002AED EB1C                <1> 	jmp	_rex_chexit
   142                              <1> 
   143                              <1> _rex_chex_126:
   144 00002AEF E8BFFFFFFF          <1> 	call	_rex_prime
   145 00002AF4 83FB7E              <1> 	cmp	ebx, 126
   146 00002AF7 760C                <1> 	jna	_rex_chex_low
   147 00002AF9 EB10                <1> 	jmp	_rex_chexit
   148                              <1> 
   149                              <1> _rex_chex_124:
   150 00002AFB E8B3FFFFFF          <1> 	call	_rex_prime
   151 00002B00 83FB7C              <1> 	cmp	ebx, 124
   152 00002B03 7706                <1> 	ja	_rex_chexit
   153                              <1> _rex_chex_low:
   154 00002B05 83FB18              <1> 	cmp	ebx, 24
   155 00002B08 7201                <1> 	jb	_rex_chexit
   156 00002B0A C3                  <1> 	ret
   157                              <1> 
   158                              <1> _rex_chexit:
   159 00002B0B E920E6FFFF          <1> 	jmp	guard_ii_authority
   160                              <1> 
   161                              <1> ;	eax = EA
   162                              <1> ;	q -> target register selected
   163                              <1> 
   164 00002B10 E8E6FFFFFF          <1> r_fa:	call	_rex_chex_124
   165 00002B15 E838FBFFFF          <1> 	call	_far
   166 00002B1A EBB3                <1> 	jmp	_rex_accumulate
   167                              <1> 
   168 00002B1C E8DAFFFFFF          <1> r_fan:	call	_rex_chex_124
   169 00002B21 E847FBFFFF          <1> 	call	_fanr
   170 00002B26 EBA7                <1> 	jmp	_rex_accumulate
   171                              <1> 
   172 00002B28 E8CEFFFFFF          <1> r_fm:	call	_rex_chex_124
   173 00002B2D E856FBFFFF          <1> 	call	_fmr
   174 00002B32 EB9B                <1> 	jmp	_rex_accumulate
   175                              <1> 
   176 00002B34 E8C2FFFFFF          <1> r_fd:	call	_rex_chex_124
   177 00002B39 E86CFBFFFF          <1> 	call	_fdr
   178 00002B3E EB8F                <1> 	jmp	_rex_accumulate
   179                              <1> 
   180 00002B40 E85EFFFFFF          <1> r_tz:	call	_rex_prime_final_count
   181 00002B45 80F904              <1> 	cmp	cl, 4			; may not be [ i xi ]
   182 00002B48 732C                <1> 	jnb	r_noskip		; but pointers are updated on no_op
   183 00002B4A E8ABD9FFFF          <1> 	call	_operand_read
   184 00002B4F 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   185 00002B54 7520                <1> 	jnz	r_noskip
   186                              <1> 
   187 00002B56 E9C3030000          <1> 	jmp	r_skipout		; stop search repeat
   188                              <1> 
   189 00002B5B E843FFFFFF          <1> r_tp:	call	_rex_prime_final_count
   190 00002B60 80F904              <1> 	cmp	cl, 4			; may not be [ i xi ]
   191 00002B63 7311                <1> 	jnb	r_noskip		; but pointers are updated on no_op
   192 00002B65 E890D9FFFF          <1> 	call	_operand_read
   193 00002B6A A900008000          <1> 	test	eax, 00800000h
   194 00002B6F 7505                <1> 	jnz	r_noskip
   195                              <1> 
   196 00002B71 E9A8030000          <1> 	jmp	r_skipout		; stop search repeat
   197                              <1> 
   198 00002B76 C3                  <1> r_noskip:	ret
   199                              <1> 
   200 00002B77 E873FFFFFF          <1> r_sb:	call	_rex_chex_126
   201 00002B7C FFC3                <1> 	inc	ebx			; starboard lane
   202 00002B7E EB05                <1> 	jmp	r_s
   203 00002B80 E85EFFFFFF          <1> r_sa:	call	_rex_chex_127
   204 00002B85 80F904              <1> r_s:	cmp	cl, 4			; may not be [ i xi ]
   205 00002B88 7309                <1> 	jnb	r_no_op_s		; but pointers are updated 
   206 00002B8A 8B5C9D00            <1> 	mov	ebx, dword ptr [rbp+rbx*4]
   207 00002B8E E82ADBFFFF          <1> 	call	_operand_write
   208                              <1> r_no_op_s:
   209 00002B93 E937FFFFFF          <1> 	jmp	_rex_accumulate
   210 00002B98 C3                  <1> 	ret
   211                              <1> 
   212 00002B99 E805FFFFFF          <1> r_z:	call	_rex_prime_final_count
   213 00002B9E 80F904              <1> 	cmp	cl, 4			; may not be [ i xi ]
   214 00002BA1 7307                <1> 	jnb	r_no_op_z		; but pointers are updated
   215 00002BA3 31DB                <1> 	xor	ebx, ebx
   216 00002BA5 E913DBFFFF          <1> 	jmp	_operand_write
   217                              <1> r_no_op_z:
   218 00002BAA C3                  <1> 	ret
   219                              <1> 
   220 00002BAB E83FFFFFFF          <1> r_lb:	call	_rex_chex_126
   221 00002BB0 FFC3                <1> 	inc	ebx			; starboard lane
   222 00002BB2 EB05                <1> 	jmp	r_l
   223 00002BB4 E82AFFFFFF          <1> r_la:	call	_rex_chex_127
   224 00002BB9 53                  <1> r_l:	push	rbx
   225 00002BBA E83BD9FFFF          <1> 	call	_operand_read
   226 00002BBF 5B                  <1> 	pop	rbx
   227 00002BC0 89449D00            <1> 	mov	dword ptr [rbp+rbx*4], eax
   228 00002BC4 E906FFFFFF          <1> 	jmp	_rex_accumulate
   229                              <1> 
   230 00002BC9 E821FFFFFF          <1> r_orB:	call	_rex_chex_126
   231 00002BCE FFC3                <1> 	inc	ebx			; starboard lane
   232 00002BD0 EB05                <1> 	jmp	r_OR
   233 00002BD2 E80CFFFFFF          <1> r_or:	call	_rex_chex_127
   234 00002BD7 53                  <1> r_OR:	push	rbx
   235 00002BD8 E81DD9FFFF          <1> 	call	_operand_read
   236 00002BDD 5B                  <1> 	pop	rbx
   237 00002BDE 0B449D00            <1> 	or	eax, dword ptr [rbp+rbx*4]
   238 00002BE2 89449D00            <1> 	mov	dword ptr [rbp+rbx*4], eax
   239 00002BE6 E9E4FEFFFF          <1> 	jmp	_rex_accumulate
   240                              <1> 
   241 00002BEB E8FFFEFFFF          <1> r_andB:	call	_rex_chex_126
   242 00002BF0 FFC3                <1> 	inc	ebx		; starboard lane
   243 00002BF2 EB05                <1> 	jmp	r_AND
   244 00002BF4 E8EAFEFFFF          <1> r_and:	call	_rex_chex_127
   245 00002BF9 53                  <1> r_AND:	push	rbx
   246 00002BFA E8FBD8FFFF          <1> 	call	_operand_read
   247 00002BFF 5B                  <1> 	pop	rbx
   248 00002C00 23449D00            <1> 	and	eax, dword ptr [rbp+rbx*4]
   249 00002C04 89449D00            <1> 	mov	dword ptr [rbp+rbx*4], eax
   250 00002C08 E9C2FEFFFF          <1> 	jmp	_rex_accumulate
   251                              <1> 
   252 00002C0D E8DDFEFFFF          <1> r_xorB:	call	_rex_chex_126
   253 00002C12 FFC3                <1> 	inc	ebx		; starboard lane
   254 00002C14 EB05                <1> 	jmp	r_XOR
   255 00002C16 E8C8FEFFFF          <1> r_xor:	call	_rex_chex_127
   256 00002C1B 53                  <1> r_XOR:	push	rbx
   257 00002C1C E8D9D8FFFF          <1> 	call	_operand_read
   258 00002C21 5B                  <1> 	pop	rbx
   259 00002C22 33449D00            <1> 	xor	eax, dword ptr [rbp+rbx*4]
   260 00002C26 89449D00            <1> 	mov	dword ptr [rbp+rbx*4], eax
   261 00002C2A E9A0FEFFFF          <1> 	jmp	_rex_accumulate
   262                              <1> 
   263 00002C2F E8BBFEFFFF          <1> r_ab:	call	_rex_chex_126
   264 00002C34 FFC3                <1> 	inc	ebx		; starboard lane
   265 00002C36 EB05                <1> 	jmp	r_a
   266 00002C38 E8A6FEFFFF          <1> r_aa:	call	_rex_chex_127
   267 00002C3D 53                  <1> r_a:	push	rbx
   268 00002C3E E8B7D8FFFF          <1> 	call	_operand_read
   269 00002C43 5F                  <1> 	pop	rdi
   270 00002C44 0344BD00            <1> 	add	eax, dword ptr [rbp+rdi*4]
   271 00002C48 E940030000          <1> 	jmp	r_store_carry
   272                              <1> 
   273 00002C4D E89DFEFFFF          <1> r_anb:	call	_rex_chex_126
   274 00002C52 FFC3                <1> 	inc	ebx		; starboard lane
   275 00002C54 EB05                <1> 	jmp	r_an
   276 00002C56 E888FEFFFF          <1> r_ana:	call	_rex_chex_127
   277 00002C5B 53                  <1> r_an:	push	rbx
   278 00002C5C E899D8FFFF          <1> 	call	_operand_read
   279 00002C61 5F                  <1> 	pop	rdi
   280 00002C62 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   281 00002C67 FFC0                <1> 	inc	eax
   282 00002C69 0344BD00            <1> 	add	eax, dword ptr [rbp+rdi*4]
   283 00002C6D E91B030000          <1> 	jmp	r_store_carry
   284                              <1> 
   285 00002C72 E86CFEFFFF          <1> r_mf:	call    _rex_chex_127
   286 00002C77 52                  <1> 	push	rdx
   287 00002C78 53                  <1> 	push	rbx
   288 00002C79 E87CD8FFFF          <1> 	call	_operand_read
   289 00002C7E 5F                  <1> 	pop	rdi
   290 00002C7F 0FAF44BD00          <1> 	imul	eax, dword ptr [rbp+rdi*4]
   291 00002C84 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   292 00002C89 8944BD00            <1> 	mov	dword ptr [rbp+rdi*4], eax
   293 00002C8D 5A                  <1> 	pop	rdx
   294 00002C8E E93CFEFFFF          <1> 	jmp	_rex_accumulate
   295                              <1> 
   296                              <1> ; use the platform unsigned multiply
   297                              <1> ; work in positive magnitude
   298                              <1> ; adjust the final sign after offset-adding products
   299                              <1> 
   300 00002C93 E857FEFFFF          <1> r_m:	call	_rex_chex_126
   301 00002C98 52                  <1> 	push	rdx
   302 00002C99 53                  <1> 	push	rbx			; register stack cursor
   303 00002C9A E85BD8FFFF          <1> 	call	_operand_read
   304 00002C9F 5F                  <1> 	pop	rdi			; recover register stack cursor
   305                              <1> 
   306 00002CA0 31C9                <1> 	xor	ecx, ecx		; final sign
   307 00002CA2 A900008000          <1> 	test	eax, 00800000h		;
   308 00002CA7 740E                <1> 	jz	r_msigu?		; negative multiplier?
   309 00002CA9 F7D1                <1> 	not	ecx			; final sign reverse
   310 00002CAB 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   311 00002CB0 FFC0                <1> 	inc	eax			; 2s complement
   312 00002CB2 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   313                              <1> 
   314                              <1> r_msigu?:
   315 00002CB7 89C3                <1> 	mov	ebx, eax		; multiplier 2b used twice
   316 00002CB9 8B44BD00            <1> 	mov	eax, dword ptr [rbp+rdi*4]
   317 00002CBD A900008000          <1> 	test	eax, 00800000h		; multiply high order part 1st
   318 00002CC2 7429                <1> 	jz	r_mgoferit_yall
   319                              <1> 
   320 00002CC4 F7D1                <1> 	not	ecx			; final sign reverse
   321 00002CC6 8B54BD04            <1> 	mov	edx, dword ptr [rbp+rdi*4+4]
   322 00002CCA 81F2FFFFFF00        <1> 	xor	edx, 00FFFFFFh
   323 00002CD0 FFC2                <1> 	inc	edx			; 2s complement
   324 00002CD2 C1C208              <1> 	rol	edx, 8
   325 00002CD5 480FB6F2            <1> 	movzx	rsi, dl
   326 00002CD9 C1EA08              <1> 	shr	edx, 8
   327 00002CDC 8954BD04            <1> 	mov	dword ptr [rbp+rdi*4+4], edx
   328 00002CE0 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh		; ms register long multiplicand
   329 00002CE5 4801F0              <1> 	add	rax, rsi
   330 00002CE8 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   331                              <1> 
   332                              <1> r_mgoferit_yall:
   333 00002CED F7E3                <1> 	mul	ebx			; multiply high order part
   334 00002CEF 8944BD00            <1> 	mov	dword ptr [rbp+rdi*4], eax	; save lower half of product
   335 00002CF3 8B44BD04            <1> 	mov	eax, dword ptr [rbp+rdi*4+4]	; multiply low order part
   336 00002CF7 F7E3                <1> 	mul	ebx
   337 00002CF9 C1E208              <1> 	shl	edx, 8			; 8 bits of eax must shift up to edx
   338 00002CFC C1C008              <1> 	rol	eax, 8
   339 00002CFF 88C2                <1> 	mov	dl, al
   340 00002D01 C1E808              <1> 	shr	eax, 8			; leaving 8 zeros in eax high end
   341 00002D04 0354BD00            <1> 	add	edx, dword ptr [rbp+rdi*4]	; add2 lower half of 1st product
   342 00002D08 21C9                <1> 	and	ecx, ecx		; final sign?
   343 00002D0A 791A                <1> 	jns	r_m_writeback
   344                              <1> 
   345 00002D0C 81F2FFFFFF00        <1> 	xor	edx, 00FFFFFFh
   346 00002D12 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   347 00002D17 FFC0                <1> 	inc	eax			; 2s complement
   348 00002D19 C1C008              <1> 	rol	eax, 8			; carried out single bit?
   349 00002D1C 480FB6F0            <1> 	movzx	rsi, al			; must add to edx
   350 00002D20 C1E808              <1> 	shr	eax, 8
   351 00002D23 4801F2              <1> 	add	rdx, rsi
   352                              <1> 
   353                              <1> r_m_writeback:
   354 00002D26 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   355 00002D2B 81E2FFFFFF00        <1> 	and	edx, 00FFFFFFh
   356 00002D31 8944BD04            <1> 	mov	dword ptr [rbp+rdi*4+4], eax	
   357 00002D35 8954BD00            <1> 	mov	dword ptr [rbp+rdi*4], edx
   358 00002D39 5A                  <1> 	pop	rdx
   359 00002D3A E990FDFFFF          <1> 	jmp	_rex_accumulate
   360                              <1> 
   361 00002D3F E8ABFDFFFF          <1> r_d:	call	_rex_chex_126
   362 00002D44 89DF                <1> 	mov	edi, ebx		; register cursor
   363 00002D46 E8DCECFFFF          <1> 	call	_divide
   364 00002D4B 895CBD04            <1> 	mov	dword ptr [rbp+rdi*4+4], ebx
   365 00002D4F 8944BD00            <1> 	mov	dword ptr [rbp+rdi*4], eax
   366                              <1> 
   367 00002D53 480F7EFE            <1> 	movq	rsi, mm7
   368                              <1> ;	mov	rsi, qword ptr [rbp+CORE_INDEX1]
   369                              <1> 
   370 00002D57 F686B004000008      <1> 	test	byte ptr [rsi+PSR], FP_R
   371 00002D5E 0F846BFDFFFF        <1> 	jz	_rex_accumulate
   372 00002D64 83FF7D              <1> 	cmp	edi, 125
   373 00002D67 0F8762FDFFFF        <1> 	ja	_rex_accumulate
   374 00002D6D 894CBD08            <1> 	mov	dword ptr [rbp+rdi*4+8], ecx
   375 00002D71 E959FDFFFF          <1> r_dnor:	jmp	_rex_accumulate
   376                              <1> 
   377 00002D76 E874FDFFFF          <1> r_sbr:	call	_rex_chex_126
   378 00002D7B FFC3                <1> 	inc	ebx		; starboard lane
   379 00002D7D EB05                <1> 	jmp	r_lsr
   380 00002D7F E85FFDFFFF          <1> r_sar:	call	_rex_chex_127
   381 00002D84 88C1                <1> r_lsr	mov	cl, al
   382 00002D86 8B449D00            <1> 	mov	eax, dword ptr [rbp+rbx*4]
   383 00002D8A D3E8                <1> 	shr	eax, cl
   384 00002D8C 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   385 00002D91 89449D00            <1> 	mov	dword ptr [rbp+rbx*4], eax
   386 00002D95 E935FDFFFF          <1> 	jmp	_rex_accumulate
   387                              <1> 
   388 00002D9A E850FDFFFF          <1> r_dsr:	call	_rex_chex_126
   389 00002D9F 88C1                <1> 	mov	cl, al
   390 00002DA1 89DF                <1> 	mov	edi, ebx
   391 00002DA3 8B44BD00            <1> 	mov	eax, dword ptr [rbp+rdi*4]
   392 00002DA7 8B5CBD04            <1> 	mov	ebx, dword ptr [rbp+rdi*4+4]
   393 00002DAB E8B8EDFFFF          <1> 	call	dsr
   394 00002DB0 8944BD00            <1> 	mov	dword ptr [rbp+rdi*4], eax
   395 00002DB4 895CBD04            <1> 	mov	dword ptr [rbp+rdi*4+4], ebx
   396 00002DB8 E912FDFFFF          <1> 	jmp	_rex_accumulate
   397                              <1> 
   398 00002DBD E82DFDFFFF          <1> r_sbl:	call	_rex_chex_126
   399 00002DC2 FFC3                <1> 	inc	ebx		; starboard lane
   400 00002DC4 EB05                <1> 	jmp	r_lsl
   401 00002DC6 E818FDFFFF          <1> r_sal:	call	_rex_chex_127
   402 00002DCB 88C1                <1> r_lsl:	mov	cl, al
   403 00002DCD 8B449D00            <1> 	mov	eax, dword ptr [rbp+rbx*4]
   404 00002DD1 D3E0                <1> 	shl	eax, cl
   405 00002DD3 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   406 00002DD8 89449D00            <1> 	mov	dword ptr [rbp+rbx*4], eax
   407 00002DDC E9EEFCFFFF          <1> 	jmp	_rex_accumulate
   408                              <1> 
   409 00002DE1 E809FDFFFF          <1> r_dsl:	call	_rex_chex_126
   410 00002DE6 88C1                <1> 	mov	cl, al
   411 00002DE8 89DF                <1> 	mov	edi, ebx
   412 00002DEA 8B44BD00            <1> 	mov	eax, dword ptr [rbp+rdi*4]
   413 00002DEE 8B5CBD04            <1> 	mov	ebx, dword ptr [rbp+rdi*4+4]
   414 00002DF2 E8A6EDFFFF          <1> 	call	dsl
   415 00002DF7 8944BD00            <1> 	mov	dword ptr [rbp+rdi*4], eax
   416 00002DFB 895CBD04            <1> 	mov	dword ptr [rbp+rdi*4+4], ebx
   417 00002DFF E9CBFCFFFF          <1> 	jmp	_rex_accumulate
   418                              <1> 
   419 00002E04 E8E6FCFFFF          <1> r_rbr:	call	_rex_chex_126
   420 00002E09 FFC3                <1> 	inc	ebx		; starboard lane
   421 00002E0B EB05                <1> 	jmp	r_rr
   422 00002E0D E8D1FCFFFF          <1> r_rar:	call	_rex_chex_127
   423 00002E12 89DF                <1> r_rr:	mov	edi, ebx
   424 00002E14 8B5CBD00            <1> 	mov	ebx, dword ptr [rbp+rdi*4]
   425 00002E18 E8EDEDFFFF          <1> 	call	rr
   426 00002E1D 895CBD00            <1> 	mov	dword ptr [rbp+rdi*4], ebx
   427 00002E21 E9A9FCFFFF          <1> 	jmp	_rex_accumulate
   428                              <1> 
   429 00002E26 E8C4FCFFFF          <1> r_drr:	call	_rex_chex_126
   430 00002E2B 88C1                <1> 	mov	cl, al
   431 00002E2D 89DF                <1> 	mov	edi, ebx
   432 00002E2F 8B44BD00            <1> 	mov	eax, dword ptr [rbp+rdi*4]
   433 00002E33 8B5CBD04            <1> 	mov	ebx, dword ptr [rbp+rdi*4+4]
   434 00002E37 E81CEEFFFF          <1> 	call	drr
   435 00002E3C 8944BD00            <1> 	mov	dword ptr [rbp+rdi*4], eax
   436 00002E40 895CBD04            <1> 	mov	dword ptr [rbp+rdi*4+4], ebx
   437 00002E44 E986FCFFFF          <1> 	jmp	_rex_accumulate
   438                              <1> 
   439 00002E49 E8A1FCFFFF          <1> r_rbl:	call	_rex_chex_126
   440 00002E4E FFC3                <1> 	inc	ebx		; starboard lane
   441 00002E50 EB05                <1> 	jmp	r_rl
   442 00002E52 E88CFCFFFF          <1> r_ral:	call	_rex_chex_127
   443 00002E57 89DF                <1> r_rl:	mov	edi, ebx
   444 00002E59 8B5CBD00            <1> 	mov	ebx, dword ptr [rbp+rdi*4]
   445 00002E5D E8CEEDFFFF          <1> 	call	rl
   446 00002E62 895CBD00            <1> 	mov	dword ptr [rbp+rdi*4], ebx
   447 00002E66 E964FCFFFF          <1> 	jmp	_rex_accumulate
   448                              <1> 
   449 00002E6B E87FFCFFFF          <1> r_drl:	call	_rex_chex_126
   450 00002E70 88C1                <1> 	mov	cl, al
   451 00002E72 89DF                <1> 	mov	edi, ebx
   452 00002E74 8B44BD00            <1> 	mov	eax, dword ptr [rbp+rdi*4]
   453 00002E78 8B5CBD04            <1> 	mov	ebx, dword ptr [rbp+rdi*4+4]
   454 00002E7C E82DEEFFFF          <1> 	call	drl
   455 00002E81 8944BD00            <1> 	mov	dword ptr [rbp+rdi*4], eax
   456 00002E85 895CBD04            <1> 	mov	dword ptr [rbp+rdi*4+4], ebx
   457 00002E89 E941FCFFFF          <1> 	jmp	_rex_accumulate
   458                              <1> 
   459 00002E8E E85CFCFFFF          <1> r_sba:	call	_rex_chex_126
   460 00002E93 FFC3                <1> 	inc	ebx		; starboard lane
   461 00002E95 EB05                <1> 	jmp	r_asr
   462 00002E97 E847FCFFFF          <1> r_saa:	call	_rex_chex_127
   463 00002E9C 88C1                <1> r_asr:	mov	cl, al
   464 00002E9E 8B449D00            <1> 	mov	eax, dword ptr [rbp+rbx*4]
   465 00002EA2 C1E008              <1> 	shl	eax, 8
   466 00002EA5 D3F8                <1> 	sar	eax, cl
   467 00002EA7 C1E808              <1> 	shr	eax, 8
   468 00002EAA 89449D00            <1> 	mov	dword ptr [rbp+rbx*4], eax
   469 00002EAE E91CFCFFFF          <1> 	jmp	_rex_accumulate
   470                              <1> 
   471 00002EB3 E837FCFFFF          <1> r_dsa:	call	_rex_chex_126
   472 00002EB8 88C1                <1> 	mov	cl, al
   473 00002EBA 89DF                <1> 	mov	edi, ebx
   474 00002EBC 8B44BD00            <1> 	mov	eax, dword ptr [rbp+rdi*4]
   475 00002EC0 8B5CBD04            <1> 	mov	ebx, dword ptr [rbp+rdi*4+4]
   476 00002EC4 E80BEDFFFF          <1> 	call	dsa
   477 00002EC9 8944BD00            <1> 	mov	dword ptr [rbp+rdi*4], eax
   478 00002ECD 895CBD04            <1> 	mov	dword ptr [rbp+rdi*4+4], ebx
   479 00002ED1 E9F9FBFFFF          <1> 	jmp	_rex_accumulate
   480                              <1> 
   481 00002ED6 E820FCFFFF          <1> r_qs:	call	_rex_chex_124
   482 00002EDB E867D7FFFF          <1> 	call	_burst_write4	; eax -> ea / ebx -> register cursor
   483 00002EE0 E9EAFBFFFF          <1> 	jmp	_rex_accumulate
   484                              <1> 
   485 00002EE5 E811FCFFFF          <1> r_ql:	call	_rex_chex_124
   486 00002EEA E8DED5FFFF          <1> 	call	_burst_read4	; eax -> ea / ebx -> register cursor
   487 00002EEF E9DBFBFFFF          <1> 	jmp	_rex_accumulate
   488                              <1> 
   489 00002EF4 E8AAFBFFFF          <1> r_dte:	call	_rex_prime_final_count
   490 00002EF9 E8BAD5FFFF          <1> 	call	_burst_read2
   491 00002EFE 334510              <1> 	xor	eax, dword ptr [rbp+A]
   492 00002F01 7525                <1> 	jnz	r_mtax
   493 00002F03 335D14              <1> 	xor	ebx, dword ptr [rbp+B]
   494 00002F06 7520                <1> 	jnz	r_mtax
   495 00002F08 EB14                <1> 	jmp	r_skipout		; stop search repeat
   496                              <1> 
   497 00002F0A E894FBFFFF          <1> r_mta:	call	_rex_prime_final_count
   498 00002F0F B100                <1> 	mov	cl, 0		; operand size 1 word
   499 00002F11 E8E4D5FFFF          <1> 	call	_operand_read
   500 00002F16 334510              <1> 	xor	eax, dword ptr [rbp+A]
   501 00002F19 234504              <1> 	and	eax, dword ptr [rbp+K]
   502 00002F1C 750A                <1> 	jnz	r_mtax
   503                              <1> 
   504                              <1> r_skipout:				; stop search repeat
   505 00002F1E 83C204              <1> 	add	edx, 4
   506 00002F21 488BA568040000      <1> 	mov	rsp, qword ptr [rbp+282*4]
   507 00002F28 C3                  <1> r_mtax:	ret
   508                              <1> 
   509 00002F29 E8C1FBFFFF          <1> r_ds:	call	_rex_chex_126
   510 00002F2E E859D7FFFF          <1> 	call	_burst_write2	; eax -> ea / ebx -> register cursor
   511 00002F33 E997FBFFFF          <1> 	jmp	_rex_accumulate
   512                              <1> 
   513 00002F38 E8B2FBFFFF          <1> r_dl:	call	 _rex_chex_126
   514 00002F3D 53                  <1> 	push	rbx
   515 00002F3E E875D5FFFF          <1> 	call	_burst_read2
   516 00002F43 5F                  <1> 	pop	rdi
   517 00002F44 895CBD04            <1> 	mov	dword ptr [rbp+rdi*4+4], ebx
   518 00002F48 8944BD00            <1> 	mov	dword ptr [rbp+rdi*4], eax
   519 00002F4C E97EFBFFFF          <1> 	jmp	_rex_accumulate
   520                              <1> 
   521 00002F51 E899FBFFFF          <1> r_dan:	call	 _rex_chex_126
   522 00002F56 53                  <1> 	push	rbx
   523 00002F57 E85CD5FFFF          <1> 	call	_burst_read2
   524 00002F5C 5F                  <1> 	pop	rdi
   525 00002F5D 81F3FFFFFF00        <1> 	xor	ebx, 00FFFFFFh
   526 00002F63 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   527 00002F68 FFC3                <1> 	inc	ebx
   528 00002F6A EB0C                <1> 	jmp	r_danad
   529                              <1> 
   530 00002F6C E87EFBFFFF          <1> r_da:	call	 _rex_chex_126
   531 00002F71 53                  <1> 	push	rbx
   532 00002F72 E841D5FFFF          <1> 	call	_burst_read2
   533 00002F77 5F                  <1> 	pop	rdi
   534                              <1> 
   535                              <1> r_danad:
   536 00002F78 035CBD04            <1> 	add	ebx, dword ptr [rbp+rdi*4+4]
   537 00002F7C C1E308              <1> 	shl	ebx, 8
   538 00002F7F 83D000              <1> 	adc	eax, 0
   539 00002F82 C1EB08              <1> 	shr	ebx, 8
   540 00002F85 895CBD04            <1> 	mov	dword ptr [rbp+rdi*4+4], ebx
   541 00002F89 0344BD00            <1> 	add	eax, dword ptr [rbp+rdi*4]
   542                              <1> 
   543                              <1> r_store_carry:
   544 00002F8D E88EEEFFFF          <1> 	call	_alu_carry
   545 00002F92 8944BD00            <1> 	mov	dword ptr [rbp+rdi*4], eax
   546 00002F96 E934FBFFFF          <1> 	jmp	_rex_accumulate
   547                              <1> 
    47                                  					; data follows here
    48                                  					; if it is in this assembly
    49                                  	%if	RTA_MBANKS
    50                                  
    51                                  	section		.data
    52                                  	%include	"rta_data.msm"
    53                                  
    54                                  	section		.bss
    55                                  _memory	resd	MEMORY
    56                                  
    57                                  	%endif
    58                                  
    59                                  	end
    59          ******************       warning: label alone on a line without a colon might be in error [-w+orphan-labels]
    60                                  
