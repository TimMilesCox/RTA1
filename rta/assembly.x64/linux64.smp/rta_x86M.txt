     1                                  
     2                                  	%include	"rta_x86n.def"
     1                              <1> 
     2                              <1> __SMP		equ	8
     3                              <1> 
     4                              <1> TIME_UPDATE	equ     1
     5                              <1> LOCKSTEP	equ	2
     6                              <1> BREAKPOINT	equ	4
     7                              <1> CHILLDOWN	equ	8
     8                              <1> TOUCHPOINT	equ	16
     9                              <1> 
    10                              <1> EXTERNAL_INTERRUPT 	equ	00FF00h
    11                              <1> ATTENTION		equ	128
    12                              <1> INCREMENTER_CARRY	equ	64
    13                              <1> TPULSE			equ	32
    14                              <1> 
    15                              <1> 		%if	DRANG & 2
    16                              <1> INDICATIONS	equ	CHILLDOWN|TIME_UPDATE|LOCKSTEP
    17                              <1> 		%else
    18                              <1> INDICATIONS	equ	CHILLDOWN|TIME_UPDATE|LOCKSTEP|BREAKPOINT
    19                              <1> 		%endif
    20                              <1> 
    21                              <1> EXTERNAL_INDICATIONS equ EXTERNAL_INTERRUPT|ATTENTION|INCREMENTER_CARRY|TPULSE
    22                              <1> 
    23                              <1> IO_PORTS	equ	192
    24                              <1> 
    25                              <1> 	%if	RTA_MBANKS
    26                              <1> global	_metric
    27                              <1> global	_indication
    28                              <1> global	_iselect
    29                              <1> global	_iselectu
    30                              <1> global	_readout
    31                              <1> global	_readoutx
    32                              <1> global	_readoutp
    33                              <1> global	_psr
    34                              <1> global	_apc
    35                              <1> global	_apcz
    36                              <1> global	_breakpoint
    37                              <1> global	_b0_name
    38                              <1> global	_b0p
    39                              <1> global	_devices
    40                              <1> global	_base
    41                              <1> global	_register_set
    42                              <1> global	__register
    43                              <1> global	_memory
    44                              <1> 
    45                              <1> 	%if	RTA_MBANKS<1
    46                              <1> RTA_MPAGES	equ	32
    47                              <1> 	%else
    48                              <1> RTA_MPAGES	equ	RTA_MBANKS*64
    49                              <1> 	%endif
    50                              <1> 
    51                              <1> 	%else
    52                              <1> ;	extern	_metric
    53                              <1> extern	_general_indication
    54                              <1> ;	extern	_iselect
    55                              <1> ;	extern	_iselectu
    56                              <1> ;	extern	_psr
    57                              <1> ;	extern	_apc
    58                              <1> ;	extern	_apcu
    59                              <1> ;	extern	_apcz
    60                              <1> 
    61                              <1> extern	_breakpoint
    62                              <1> extern	_touchpoint
    63                              <1> extern	_touchpoint2
    64                              <1> 
    65                              <1> ;	extern	_b0_name
    66                              <1> ;	extern	_b0p
    67                              <1> extern	_devices
    68                              <1> ;	extern	_base
    69                              <1> ;	extern	_register_set
    70                              <1> ;	extern	__register
    71                              <1> extern	_memory
    72                              <1> 
    73                              <1> _output equ     272
    74                              <1> _inputr equ     264
    75                              <1> _input2 equ     256
    76                              <1> 
    77                              <1> _OUTPUT	equ	_output*4
    78                              <1> _INPUTR	equ	_inputr*4
    79                              <1> _INPUT2 equ	_input2*4
    80                              <1> _BIAS	equ	_OUTPUT
    81                              <1> 
    82                              <1> 	%endif
    83                              <1> 
    84                              <1> 	extern	_flag
    85                              <1> 	extern	_uflag
    86                              <1> 
    87                              <1> HALF_W	equ	128
    88                              <1> FP_R	equ	8
    89                              <1> B_STREAMZR  equ 64
    90                              <1> B_STREAM16R equ 32
    91                              <1> B_STREAM16W equ 16
    92                              <1> 
    93                              <1> r	equ	0
    94                              <1> k	equ	1
    95                              <1> x	equ	2
    96                              <1> y	equ	3
    97                              <1> a	equ	4
    98                              <1> b	equ	5
    99                              <1> mantissa2 equ	6
   100                              <1> mantissa3 equ	7
   101                              <1> residue	equ	8
   102                              <1> p	equ	12
   103                              <1> q	equ	13
   104                              <1> fp	equ	14
   105                              <1> s_p	equ	15
   106                              <1> 
   107                              <1> rdatac	equ	20
   108                              <1> rdata	equ	21
   109                              <1> wdatac	equ	22
   110                              <1> wdata	equ	23
   111                              <1> 
   112                              <1> 
   113                              <1> fp_guard equ	128+19
   114                              <1> 
   115                              <1> rt_clock equ	128+20
   116                              <1> priority equ	128+21
   117                              <1> dayclock_u equ	128+22
   118                              <1> dayclock equ	128+23
   119                              <1> 
   120                              <1> R	equ	r*4
   121                              <1> K	equ	k*4
   122                              <1> X	equ	x*4
   123                              <1> Y	equ	y*4
   124                              <1> A	equ	a*4
   125                              <1> B	equ	b*4
   126                              <1> MANTISSA2 equ	mantissa2*4
   127                              <1> MANTISSA3 equ	mantissa3*4
   128                              <1> RESIDUE	equ	residue*4
   129                              <1> 
   130                              <1> P	equ	p*4
   131                              <1> Q	equ	q*4
   132                              <1> FP	equ	fp*4
   133                              <1> S_P	equ	s_p*4
   134                              <1> 
   135                              <1> RDATAC	equ	rdatac*4
   136                              <1> RDATA	equ	rdata*4
   137                              <1> WDATAC	equ	wdatac*4
   138                              <1> WDATA	equ	wdata*4
   139                              <1> 
   140                              <1> FP_GUARD equ	fp_guard*4
   141                              <1> 
   142                              <1> RT_CLOCK equ	rt_clock*4
   143                              <1> PRIORITY equ	priority*4
   144                              <1> DAYCLOCK_U equ	dayclock_u*4
   145                              <1> DAYCLOCK equ	dayclock*4
   146                              <1> 
   147                              <1> I	equ	4
   148                              <1> XI	equ	5
   149                              <1> 
   150                              <1> DEVICE  equ	32768
   151                              <1> SYSMEM  equ	16384
   152                              <1> DATA16  equ	1
   153                              <1> FSYS24  equ	2
   154                              <1> 
   155                              <1> II_GUARD equ	64+31
   156                              <1> II_EXIT	equ	64+6
   157                              <1> II_YIELD equ	64+1
   158                              <1> II_SPAWN equ	64+2
   159                              <1> II_BANK equ	64+3
   160                              <1> II_ARRAY equ	64+4
   161                              <1> II_BANK_FREE equ 64+5
   162                              <1> II_TWAIT equ	64+27
   163                              <1> II_EVENT_WAIT equ 64+28
   164                              <1> II_FPXPO equ	0+3
   165                              <1> 
   166                              <1> II_XINT		equ	0+2
   167                              <1> II_MSECOND	equ	0+4
   168                              <1> II_ATTENTION	equ	0+5
   169                              <1> 
   170                              <1> LP_AUTHORITY	equ	1		; latent parameters GUARD$
   171                              <1> LP_ADDRESS	equ	14
   172                              <1> 
   173                              <1> LP_TIMESLICE	equ	10		; latent parameter timeslice -> yield
   174                              <1> LP_RANGE	equ	12		; latent parameter FP$XPO
   175                              <1> LP_AUTOEXIT	equ	11		; latent parameter return -> EXIT$
     3                                  	%include	"rta_smp.def"
     1                              <1> __POINTER	equ	8
     2                              <1> 
     3                              <1> REGISTER	equ	0			; /*	288	int	*/
     4                              <1> 
     5                              <1> APC		equ	REGISTER+288*4		; /*	1	->	*/
     6                              <1> APCZ		equ	APC+__POINTER		; /*	1	->	*/
     7                              <1> B0P		equ	APCZ+__POINTER		; /*	1	->	*/
     8                              <1> REGISTER_SET	equ	B0P+__POINTER 
     9                              <1> 
    10                              <1> RESTART_VECTOR	equ	REGISTER_SET+__POINTER	; /*	1	int	*/
    11                              <1> INDICATION	equ	RESTART_VECTOR+4	; /*	1	int	*/	
    12                              <1> LATENT_PARAMETER equ	INDICATION+4		; /*	1	int	*/
    13                              <1> ISELECT		equ	LATENT_PARAMETER+4	; /*	1	int	*/	
    14                              <1> 
    15                              <1> PSR		equ	ISELECT+4		; /*	1	int	*/
    16                              <1> B0_NAME		equ	PSR+4			; /*	1	int	*/
    17                              <1> B0_SCOPE	equ	B0_NAME+4		; /*	1	int	*/
    18                              <1> 
    19                              <1> spare		equ	B0_SCOPE+4		; align with C structure
    20                              <1> 						; and align metric block 
    21                              <1> 
    22                              <1> DELTA		equ	spare+4			; /*	1	int	*/
    23                              <1> __METRIC	equ	DELTA+4			; /*	1	int	*/
    24                              <1> 
    25                              <1> DELTA_BASE	equ	__METRIC+4		; /*	1	long	*/
    26                              <1> TOTAL_DELTA	equ	DELTA_BASE+8		; /*	1	long	*/
    27                              <1> TOTAL_METRIC	equ	TOTAL_DELTA+8		; /*	1	long	*/
    28                              <1> 
    29                              <1> IO_PORT		equ	TOTAL_METRIC+8		; /*	192	int	*/
    30                              <1> DATAFRAME	equ	IO_PORT+192*4		; /*	nothing		*/
    31                              <1> 
    32                              <1> CORE_SIZE	equ	DATAFRAME+0
    33                              <1> 
    34                              <1> 		%if	0
    35                              <1> CORE_INDEX2	equ	4*280
    36                              <1> CORE_INDEX1	equ	4*(280-128)
    37                              <1> 		%endif
     4                                  	%include	"rw.def"
     1                              <1> __REGFOR	equ	0
     2                              <1> __MOVBE		equ	0
     3                              <1> 
     4                              <1> 		default	abs
     5                                  	%include	"io.def"
     1                              <1> 
     2                              <1> ;	_NAMES of ports as referenced in implementation or emulation 
     3                              <1> 
     4                              <1> _CORE_PIN		equ	73*4	; read-only port 1 */ _CORE_SOCKET
     5                              <1> 
     6                              <1> _XI_PENDING		equ	74*4	; mask of external interrupt sources
     7                              <1> _XI_ACK			equ	75*4	; writeable ack to quench pending signals
     8                              <1> _INCREMENTER_RESTART	equ	76*4
     9                              <1> _CORE_SOCKET		equ	77*4	; socket index this core read only
    10                              <1> 
    11                              <1> _MCAST_PENDING		equ	78*4	; mask of cores which have multicast to here
    12                              <1> _MCAST_TO		equ	79*4	; -> latent parameter
    13                              <1> 					; destinations mask in register k
    14                              <1> _TZONE			equ	101*4
    15                              <1> 
    16                              <1> _APP_THRESHOLD		equ	72*4	; lowest application code page / limit ISRs
    17                              <1> _INDICATE		equ	102*4	; control commands powersave + others
    18                              <1> _CHILLDOWN		equ	103*4	; powersave microseconds
    19                              <1> 
    20                              <1> _SYS_SWITCH		equ	126*4	; if a switch block is connected
    21                              <1> _SYS_LEDS		equ	127*4	; if a LEDs block is connected
    22                              <1> 
    23                              <1> _DEVICE			equ	128*4	; descriptors 64 devices starting executable space
    24                              <1> _RAM_THRESHOLD		equ	124*4	; 1st writeable page executable space
    25                              <1> _IFRAME_U		equ	64*4	; highest page instruction frame B0 + iframe pages - 1
    26                              <1> 
    27                              <1> _I_DATA			equ	80*4	; external data read port
    28                              <1> _O_DATA			equ	88*4	; external daza write port
    29                              <1> 
    30                              <1> _CORES_MASK		equ	125*4	; bit map cores present +(1*/RTA_SMP)-1
     6                                  
     7                                  ;	this is not PIC code
     8                                  ;	but does relative jumps for compactness
     9                                  
    10                                  %define ptr
    11                                  %define include
    12                                  %define .model
    13                                  %define .code
    14                                  
    15                                  SYSMEM_FLAG	equ	00800000h
    16                                  DATA16_FLAG	equ	00400000h
    17                                  FSYS24_FLAG	equ	00C00000h
    18                                  
    19                                  					; instruction code starts here
    20                                  	section		.text
    21                                  	global		_leloup
    22                                  	global		_execute
    23                                  	global		_device_readp
    24                                  	global		_bus_readp
    25                                  	global		_memory_read
    26                                  	global		_bus_read
    27                                  	global		_device_read
    28                                  
    29                                  	%include	"leloup.msm"
     1                              <1> 
     2                              <1> 	extern	_ultra
     3                              <1> 	extern	_ultra1
     4                              <1> 	extern	_ultra2
     5                              <1> 	extern	_ultra3
     6                              <1> 	extern	_ultra4
     7                              <1> 	extern	_ultra5
     8                              <1> 	extern	_ultra6
     9                              <1> 	extern	_ultra7
    10                              <1> 	extern	_core
    11                              <1> 
    12                              <1> _save_ebp	equ	0
    13                              <1> _save_return	equ	4
    14                              <1> _1st_param	equ	8
    15                              <1> 
    16                              <1> _leloup:
    17 00000000 55                  <1> 	push	rbp
    18                              <1> 
    19                              <1> 	%if	0
    20                              <1> 	push	rsi
    21                              <1> 	push	rdi
    22                              <1> 	push	rax
    23                              <1> 	push	rcx
    24                              <1> 	push	rdx
    25                              <1> 	%endif
    26                              <1> 
    27 00000001 53                  <1> 	push	rbx
    28                              <1> 
    29 00000002 4889FE              <1> 	mov	rsi, rdi			; structure smp ->
    30                              <1> 
    31 00000005 4157                <1> 	push	r15
    32 00000007 4156                <1> 	push	r14
    33 00000009 4155                <1> 	push	r13
    34 0000000B 4154                <1> 	push	r12
    35                              <1> 
    36 0000000D 4C8BA680040000      <1> 	mov	r12, qword ptr [rsi+APC]
    37 00000014 488BAE98040000      <1> 	mov	rbp, qword ptr [rsi+REGISTER_SET]
    38 0000001B 4C8BAE88040000      <1> 	mov	r13, qword ptr [rsi+APCZ]
    39 00000022 4C8B3425[00000000]  <1> 	mov	r14, qword ptr [_breakpoint]
    40 0000002A 4C8B3C25[00000000]  <1> 	mov	r15, qword ptr [_touchpoint]
    41                              <1> 						; balance core state pointer
    42 00000032 56                  <1> 	push	rsi				; on stack top
    43 00000033 480F6EFE            <1> 	movq	mm7, rsi			; refresh source
    44                              <1> 
    45 00000037 4D39EC              <1> loup:	cmp	r12, r13			; [rsi+APCZ]
    46 0000003A 7744                <1> 	ja	off_limits
    47                              <1> 
    48                              <1> 	%if	__MOVBE
    49                              <1> 	movbe	eax, dword ptr [r12]
    50                              <1> 	%else
    51 0000003C 418B0424            <1> 	mov	eax, dword ptr [r12]
    52 00000040 0FC8                <1> 	bswap	eax
    53                              <1> 	%endif
    54                              <1> 
    55 00000042 4983C404            <1> 	add	r12, 4
    56                              <1> 
    57 00000046 E82F010000          <1> 	call	_execute
    58                              <1> 
    59 0000004B 488B3424            <1> 	mov	rsi, qword ptr [rsp] 		; core pointer needed all the way round
    60                              <1> 
    61                              <1> 	%if	TSLICE
    62 0000004F F786B0040000000087- <1> 	test	dword ptr [rsi+PSR], 00870000h	; not while ISR or interrupt mask
    62 00000058 00                  <1>
    63 00000059 752F                <1> 	jnz	louping
    64 0000005B F78650020000FFFFFF- <1> 	test	dword ptr [rsi+RT_CLOCK], 00FFFFFFh
    64 00000064 00                  <1>
    65 00000065 7423                <1> 	jz	louping
    66                              <1> 
    67 00000067 FF8E50020000        <1> 	dec	dword ptr [rsi+RT_CLOCK]
    68 0000006D 751B                <1> 	jnz	louping
    69                              <1> 
    70 0000006F B841000000          <1> 	mov	eax, II_YIELD
    71                              <1> 
    72 00000074 B90A000000          <1> 	mov	ecx, LP_TIMESLICE
    73 00000079 E8C5100000          <1> 	call	_ii
    74                              <1> 
    75                              <1> 	%endif
    76                              <1> 
    77 0000007E EB0A                <1> 	jmp	louping
    78                              <1> 
    79                              <1> off_limits:
    80 00000080 B85F000000          <1> 	mov	eax, II_GUARD
    81 00000085 E8B9100000          <1> 	call	_ii
    82                              <1> 
    83                              <1> louping:
    84 0000008A 4D39F4              <1> 	cmp	r12, r14			; [ _breakpoint ]
    85 0000008D 7519                <1> 	jnz	loup_count
    86                              <1> 
    87 0000008F 800C25[00000000]02  <1> 	or	byte ptr [_general_indication], LOCKSTEP
    88 00000097 808EA404000002      <1> 	or	byte ptr [rsi+INDICATION], LOCKSTEP
    89 0000009E 800C25[12000000]01  <1> 	or	byte ptr [_flag+'s'-'a'], 1
    90 000000A6 EB51                <1> 	jmp	indicated
    91                              <1> 
    92                              <1> loup_count:
    93 000000A8 FF8E6C040000        <1> 	dec	dword ptr [rsi+283*4]		; decrement from quantity RATIO
    94 000000AE 7908                <1> 	jns	loup_away
    95 000000B0 66838EA404000001    <1> 	or	word ptr [rsi+INDICATION], TIME_UPDATE
    96                              <1> loup_away:
    97                              <1> 
    98 000000B8 668B86A4040000      <1> 	mov	ax, word ptr [rsi+INDICATION]
    99 000000BF 8A8EB2040000        <1> 	mov	cl, byte ptr [rsi+PSR+2]
   100 000000C5 80E107              <1> 	and	cl, 7				; highest interrupt mask?
   101 000000C8 80F107              <1> 	xor	cl, 7
   102                              <1> 
   103 000000CB 7422                <1> 	jz	internal_indications?		; maskable interrupts are masked
   104                              <1> 
   105 000000CD 66A9EBFF            <1>         test	ax, INDICATIONS|EXTERNAL_INDICATIONS	; 1 or both of internal++external
   106 000000D1 0F8460FFFFFF        <1> 	jz	loup					; indications? No?
   107 000000D7 66A9E0FF            <1> 	test	ax, EXTERNAL_INDICATIONS	; external indications among the yes?
   108                              <1> 
   109 000000DB 741C                <1> 	jz	indicated			; external indications there are not
   110                              <1> 						; therefore internal indications there are
   111                              <1> ;	push	rsi				; therefore raise their interrupts
   112 000000DD E85D0F0000          <1> 	call	_xi
   113 000000E2 488B3424            <1> 	mov	rsi, qword ptr [rsp]
   114                              <1> 
   115 000000E6 80A6A40400007F      <1> 	and	byte ptr [rsi+INDICATION], 127
   116 000000ED EB9B                <1> 	jmp	louping				; keep going intil pending flags are off
   117                              <1> 
   118                              <1> internal_indications?:
   119 000000EF 66A90B00            <1> 	test	ax, INDICATIONS			; just read from esi->INDICATION
   120 000000F3 0F843EFFFFFF        <1> 	jz	loup
   121                              <1> 
   122                              <1> indicated:
   123 000000F9 80A6A4040000FD      <1> 	and	byte ptr [rsi+INDICATION], LOCKSTEP^255
   124                              <1> 
   125 00000100 4889AE98040000      <1> 	mov	qword ptr [rsi+REGISTER_SET], rbp
   126 00000107 4C89A680040000      <1> 	mov	qword ptr [rsi+APC], r12
   127 0000010E 4C89AE88040000      <1> 	mov	qword ptr [rsi+APCZ], r13
   128                              <1> 
   129 00000115 5F                  <1> 	pop	rdi				; take core pointer off stack
   130                              <1> 						; was passed in rdi, should not matter
   131 00000116 415C                <1> 	pop	r12
   132 00000118 415D                <1> 	pop	r13
   133 0000011A 415E                <1> 	pop	r14
   134 0000011C 415F                <1> 	pop	r15
   135                              <1> 
   136 0000011E 5B                  <1> 	pop	rbx				; caller values
   137                              <1> 
   138                              <1> 	%if	0
   139                              <1> 	pop	rdx
   140                              <1> 	pop	rcx
   141                              <1> 	pop	rax
   142                              <1> 	pop	rdi
   143                              <1> 	pop	rsi
   144                              <1> 	%endif
   145                              <1> 
   146 0000011F 5D                  <1> 	pop	rbp
   147 00000120 C3                  <1> 	ret
   148                              <1> 
    30                                  	%include	"execute.msm"
     1                              <1> ;	include	rta_x86.h
     2                              <1> .model	small
     2          ******************  <1>  warning: label alone on a line without a colon might be in error [-w+orphan-labels]
     3                              <1> .code
     4                              <1> 
     5 00000121 89C1                <1> __ea:	mov	ecx, eax
     6 00000123 C1E108              <1> 	shl	ecx, 8
     7 00000126 C1E913              <1> 	shr	ecx, 24-5		; instruction index in ch
     8 00000129 C0E905              <1> 	shr	cl, 5			; operand designator in cl
     9                              <1> 
    10 0000012C C1E010              <1> 	shl	eax, 16
    11 0000012F 80F905              <1> 	cmp	cl, XI			; sign extended immediate?
    12 00000132 7508                <1> 	jnz	derive_ea
    13                              <1> 
    14 00000134 C1F808              <1> 	sar	eax, 8			; different from other EAs
    15 00000137 C1E808              <1> 	shr	eax, 8
    16 0000013A EB3D                <1> 	jmp	ea_derived
    17                              <1> 
    18                              <1> derive_ea:
    19 0000013C C1E810              <1> 	shr	eax, 16			; no sign of it
    20 0000013F 6621C0              <1> 	and	ax, ax			; indexing / indirection ?
    21 00000142 7935                <1> 	jns	ea_derived		; no
    22                              <1> 
    23 00000144 89C3                <1> 	mov	ebx, eax
    24 00000146 80E47F              <1> 	and	ah, 127			; ie: and ax 32767
    25 00000149 66C1EB0C            <1> 	shr	bx, 12			; position index tag
    26 0000014D F6C306              <1> 	test	bl, 6			; indirect or indexed ?
    27 00000150 7415                <1> 	jz	indirect
    28                              <1> 					; pe = PF set
    29                              <1> 					; can only be tested on b7..0
    30 00000152 7A03                <1> 	jpe	indexed_4bit		; indexed fp / sp
    31                              <1> 					; indexed x / y / a / b
    32 00000154 80E307              <1> 	and	bl, 7			; zero bit 3
    33                              <1> 
    34                              <1> indexed_4bit:
    35 00000157 6625FF0F            <1> 	and	ax, 4095		; isolate adqress offset
    36 0000015B 03449D00            <1> 	add	eax, dword ptr [rbp+rbx*4]
    37                              <1> 
    38 0000015F C1E008              <1> 	shl	eax, 8			; truncate any overflow
    39 00000162 C1E808              <1> 	shr	eax, 8
    40                              <1> 
    41 00000165 EB12                <1> 	jmp	ea_derived
    42                              <1> 
    43                              <1> indirect:				; indirect via page B0 / B1
    44 00000167 6689CB              <1> 	mov	bx, cx
    45 0000016A 6631C9              <1> 	xor	cx, cx			; cl <- zero to read 1-word indirection pointer
    46 0000016D E888030000          <1> 	call	_operand_read
    47 00000172 6689D9              <1> 	mov	cx, bx			; retrieve instruction:class into cx
    48                              <1> 
    49 00000175 480F7EFE            <1> 	movq	rsi, mm7
    50                              <1> ;	mov	rsi, qword ptr [rbp+CORE_INDEX1]	; retrieve smp core ->
    51                              <1> 
    52                              <1> ea_derived:
    53 00000179 C3                  <1> 	ret
    54                              <1> 
    55                              <1> _execute:
    56 0000017A 4889A678040000      <1> 	mov	qword ptr [rsi+REGISTER+286*4], rsp
    57 00000181 E89BFFFFFF          <1> 	call	__ea
    58                              <1> 
    59 00000186 0FB6DD              <1> 	movzx	ebx, ch			; instruction index
    60 00000189 80F906              <1> 	cmp	cl, 6
    61 0000018C 0F8410010000        <1> 	jz	near shifts_jumps
    62 00000192 0F8714020000        <1> 	ja	near large_operations
    63                              <1> 
    64                              <1> integer_operations:
    65 00000198 488B1CDD[A2010000]  <1> 	mov	rbx, qword ptr [operations1+rbx*8]
    66 000001A0 FFE3                <1> 	jmp	rbx
    67                              <1> 
    68                              <1> operations1:
    69 000001A2 [A214000000000000]  <1>         dq	_sr
    70 000001AA [BC14000000000000]  <1>         dq	_sk
    71 000001B2 [D614000000000000]  <1>         dq	_sx
    72 000001BA [F014000000000000]  <1>         dq	_sy
    73 000001C2 [0A15000000000000]  <1>         dq	_sa
    74 000001CA [2015000000000000]  <1>         dq	_sb
    75 000001D2 [3215000000000000]  <1>         dq	_z
    76 000001DA [4B15000000000000]  <1>         dq	_pop
    77                              <1> 
    78 000001E2 [6715000000000000]  <1>         dq	_lr
    79 000001EA [7015000000000000]  <1>         dq	_lk
    80 000001F2 [7915000000000000]  <1>         dq	_lx
    81 000001FA [8215000000000000]  <1>         dq	_ly
    82 00000202 [8B15000000000000]  <1>         dq	_la
    83 0000020A [9415000000000000]  <1>         dq	_lb
    84 00000212 [9D15000000000000]  <1>         dq	_tz
    85 0000021A [C515000000000000]  <1>         dq	_tp
    86                              <1> 
    87 00000222 [F418000000000000]  <1>         dq	_ax
    88 0000022A [0519000000000000]  <1>         dq	_ay
    89 00000232 [1619000000000000]  <1>         dq	_or
    90 0000023A [1F19000000000000]  <1>         dq	_orB
    91 00000242 [2819000000000000]  <1>         dq	_and
    92 0000024A [3119000000000000]  <1>         dq	_andB
    93 00000252 [3A19000000000000]  <1>         dq	_xor
    94 0000025A [4319000000000000]  <1>         dq	_xorB
    95                              <1> 
    96 00000262 [4C19000000000000]  <1>         dq	_aa
    97 0000026A [6C19000000000000]  <1>         dq	_ab
    98 00000272 [5319000000000000]  <1>         dq	_ana
    99 0000027A [7319000000000000]  <1>         dq	_anb
   100 00000282 [8C19000000000000]  <1>         dq	_m
   101 0000028A [BA19000000000000]  <1>         dq	_mf
   102 00000292 [141A000000000000]  <1>         dq	_d
   103 0000029A [E415000000000000]  <1>         dq	_push
   104                              <1> 
   105                              <1> shifts_jumps:
   106 000002A2 488B1CDD[AC020000]  <1> 	mov	rbx, qword ptr [operations6+rbx*8]
   107 000002AA FFE3                <1> 	jmp	rbx
   108                              <1> 
   109                              <1> operations6:
   110 000002AC [B91A000000000000]  <1>         dq	_sar
   111 000002B4 [D01A000000000000]  <1>         dq	_sbr
   112 000002BC [E71A000000000000]  <1>         dq	_dsr
   113 000002C4 [0316000000000000]  <1>         dq	_jdr
   114 000002CC [FB1A000000000000]  <1>         dq	_sal
   115 000002D4 [121B000000000000]  <1>         dq	_sbl
   116 000002DC [291B000000000000]  <1>         dq	_dsl
   117 000002E4 [1D16000000000000]  <1>         dq	_lcal
   118                              <1> 
   119 000002EC [3D1B000000000000]  <1>         dq	_rar
   120 000002F4 [491B000000000000]  <1>         dq	_rbr
   121 000002FC [551B000000000000]  <1>         dq	_drr
   122 00000304 [3516000000000000]  <1>         dq	_jnc
   123 0000030C [F11C000000000000]  <1>         dq	_ral
   124 00000314 [FD1C000000000000]  <1>         dq	_rbl
   125 0000031C [091D000000000000]  <1>         dq	_drl
   126 00000324 [4216000000000000]  <1>         dq	_jc
   127                              <1> 
   128 0000032C [1D1D000000000000]  <1>         dq	_saa
   129 00000334 [2E1D000000000000]  <1>         dq	_sba
   130 0000033C [3F1D000000000000]  <1>         dq	_dsa
   131 00000344 [4F16000000000000]  <1>         dq	_jao
   132 0000034C [5916000000000000]  <1>         dq	_jpa
   133 00000354 [6316000000000000]  <1>         dq	_jpb
   134 0000035C [6D16000000000000]  <1>         dq	_j
   135 00000364 [8616000000000000]  <1>         dq	_jpo
   136                              <1> 
   137 0000036C [8E16000000000000]  <1>         dq	_jza
   138 00000374 [9816000000000000]  <1>         dq	_jzb
   139 0000037C [A216000000000000]  <1>         dq	_jnza
   140 00000384 [AC16000000000000]  <1>         dq	_jnzb
   141 0000038C [B616000000000000]  <1>         dq	_jna
   142 00000394 [C016000000000000]  <1>         dq	_jnb
   143 0000039C [CA16000000000000]  <1>         dq	_jxge
   144 000003A4 [D916000000000000]  <1>         dq	_jyge
   145                              <1> 
   146                              <1> 
   147                              <1> large_operations:
   148 000003AC 488B1CDD[B8030000]  <1> 	mov	rbx, qword ptr [operations7+rbx*8]
   149 000003B4 B100                <1> 	mov	cl, 0		; default size large operand
   150 000003B6 FFE3                <1> 	jmp	rbx		; 1 word
   151                              <1> 
   152                              <1> operations7:
   153 000003B8 [BD17000000000000]  <1>         dq	_ts
   154 000003C0 [531D000000000000]  <1>         dq	_n
   155 000003C8 [621D000000000000]  <1>         dq	_inc
   156 000003D0 [6E1D000000000000]  <1>         dq	_dec
   157 000003D8 [D417000000000000]  <1>         dq	_sim
   158 000003E0 [BA1D000000000000]  <1>         dq	_popA
   159 000003E8 [7A1D000000000000]  <1>         dq	_src
   160 000003F0 [9A1D000000000000]  <1>         dq	_slc
   161                              <1> 
   162 000003F8 [E816000000000000]  <1>         dq	_qs
   163 00000400 [F216000000000000]  <1>         dq	_ql
   164 00000408 [5D17000000000000]  <1>         dq	_dte
   165 00000410 [2217000000000000]  <1>         dq	_dpop
   166 00000418 [6026000000000000]  <1>         dq	_fa
   167 00000420 [7B26000000000000]  <1>         dq	_fan
   168 00000428 [9626000000000000]  <1>         dq	_fm
   169 00000430 [B826000000000000]  <1>         dq	_fd
   170                              <1> 
   171 00000438 [FC16000000000000]  <1>         dq	_qpop
   172 00000440 [0D17000000000000]  <1>         dq	_qpush
   173 00000448 [AF17000000000000]  <1>         dq	_ex
   174 00000450 [3317000000000000]  <1>         dq	_dpush
   175 00000458 [9E1E000000000000]  <1>         dq	_lsc
   176 00000460 [4B17000000000000]  <1>         dq	_mta
   177 00000468 [7117000000000000]  <1>         dq	_sc
   178 00000470 [7F17000000000000]  <1>         dq	_mlb
   179                              <1> 
   180 00000478 [9817000000000000]  <1>         dq	_ds
   181 00000480 [A217000000000000]  <1>         dq	_dl
   182 00000488 [ED1D000000000000]  <1>         dq	_da
   183 00000490 [F41D000000000000]  <1>         dq	_dan
   184 00000498 [AF1E000000000000]  <1>         dq	_dlsc
   185 000004A0 [AE17000000000000]  <1>         dq	_spare
   186 000004A8 [1B18000000000000]  <1>         dq	_go
   187 000004B0 [FB17000000000000]  <1>         dq	_call
   188                              <1> 
    31                                  	%include	"rw.msm"
     1                              <1> 
     2                              <1> 
     3                              <1> ;	include	rta_x86.h
     4                              <1> ;	.model	large
     5                              <1> ;	.code
     6                              <1> 
     7                              <1> ;	this is the operand reader / writer
     8                              <1> ;	for emulated RTA1 on x86
     9                              <1> 
    10                              <1> ;	layout is
    11                              <1> 
    12                              <1> ;	RTA1 24-bit registers are modeled in an array of
    13                              <1> ;	platform-endian integers. In x86 these are 32-bit
    14                              <1> ;	little-endian integers
    15                              <1> 
    16                              <1> ;	platform-endian doesn't affect registers
    17                              <1> ;	because endianness is not at the CPU
    18                              <1> ;	side of the bus, but at the memory side
    19                              <1> 
    20                              <1> ;	when Intel circuitry in the x86 CPU staticises the value
    21                              <1> ;	of an emulated register, that value is big endian
    22                              <1> 
    23                              <1> ;	the stored integers where emulated registers are modeled
    24                              <1> ;	are platform-endian, with identical effect on big and
    25                              <1> ;	little endian emulator platforms
    26                              <1> 
    27                              <1> ;	RTA1 24-bit executable space storage words are modeled in
    28                              <1> ;	another array of platform-endian 32-bit integers. Emulation
    29                              <1> ;	on x86 swaps the byte order of storage words on read and
    30                              <1> ;	before write to conform with RTA1 canonical storage order
    31                              <1> 
    32                              <1> ;       RTA1 architecture has registers in the first 256 locations
    33                              <1> ;       of address space and access differentiates registers from
    34                              <1> ;       from memory according to effective address
    35                              <1> 
    36                              <1> ;	location of registers and storage are handed to read / write
    37                              <1> ;	routines as RTA1 word linear effective addresses
    38                              <1> 
    39                              <1> ;	These routines maintain the RTA1 linear addresses passed
    40                              <1> ;	in x86 registers and apply them with shifted scale plus
    41                              <1> ;	displacement, for example
    42                              <1> 
    43                              <1> ;		mov	eax, dword ptr [edi+esi*4+_memory]
    44                              <1> ;		bswap	eax
    45                              <1> ;		mov	dword_ptr [ebp+ebx*4], eax
    46                              <1> 
    47                              <1> ;	RTA1 register addresses are already absolute in terms of
    48                              <1> ;	the emulated RTA1 machine
    49                              <1> 
    50                              <1> ;	ebp points at the context register frame. There are two
    51                              <1> ;	register frames, application and interrupt. Registers
    52                              <1> ;	addressed as storage operand are in a single list
    53                              <1> 
    54                              <1> ;		mov	eax, dword ptr [esi*4+__register]
    55                              <1> 
    56                              <1> ;	RTA1 storage addresses are translated by RTA1 relocation
    57                              <1> ;	architecture before application. The updated linear addresses
    58                              <1> ;	of the emulated machine are in esi
    59                              <1> 
    60                              <1> ;	The operand routines in this file point edi to the x86 platform
    61                              <1> ;	storage array start of the storage device, most often emulated
    62                              <1> ;	RTA1 executable space
    63                              <1> 
    64                              <1> ;	instructions call these operand routines with RTA1 effective 
    65                              <1> ;	address in eax
    66                              <1> 
    67                              <1> ;	instructions receive load operand values in eax and ebx, or in
    68                              <1> ;	a list of RTA1 emulated register locations pointed by ebp+ebx
    69                              <1> 
    70                              <1> ;	store instructions submit a value in ebx, or values in list of
    71                              <1> ;	RTA1 emulated register locations pointed by ebp+ebx
    72                              <1> 
    73                              <1> ;	to preserve linear address consistency, application instruction
    74                              <1> ;	work areas, where needed in addition to x86 registers, are
    75                              <1> ;	implemented as sub-architectural extra RTA1 registers at the end
    76                              <1> ;	of the 256-longword register stack. x86 register ebp+ebx*4 identify
    77                              <1> ;	these locations by linear RTA1 word quantum as "registers"
    78                              <1> 
    79                              <1> ;	RTA1 registers and storage alike are in 24-bit word address quantum space
    80                              <1> 
    81                              <1> ;	emulated instructions loading or storing multiple hidden extra work
    82                              <1> ;	registers should unconditionally set ebp to the start or application
    83                              <1> ;	frame of the emulated register array, so that [ebp+ebx*4] accesses the
    84                              <1> ;	correct locations at register occurence 256+
    85                              <1> 
    86                              <1> ;               _floating_operand2 equ  256+12
    87                              <1> 
    88                              <1> ;		push	ebp
    89                              <1> ;		mov	ebp, __register	; point to application register frame[0]
    90                              <1> ;		mov	ebx, 256+_floating_operand2
    91                              <1> ;		call	_burst_read4
    92                              <1> 
    93                              <1> ;		pop	ebp		; return to previous register frame[0] application
    94                              <1> 					;                          or frame[1] interrupt
    95                              <1> 
    96                              <1> ;	Both internal stack pointers are also absolute, so for stack operations
    97                              <1> ;	ebp should be momentarily forced to the lower-addressed (application) stack
    98                              <1> ;	frame after being used to point the stack location of reference
    99                              <1> 
   100                              <1> ;		mov	ebx, dword ptr [ebp+S_P]	; read one of the two stack pointers
   101                              <1> ;		cmp	ebx, ebp+STACK_LOWER_LIMIT	; 24*4 within context of either stack
   102                              <1> ;		jl	II_GUARD
   103                              <1> ;		add	ebx, -1				; new stack top
   104                              <1> ;		mov	dword ptr [ebp+S_P], ebx
   105                              <1> ;		push	ebp				; which ever stack pointer it is, it points
   106                              <1> ;		mov	ebp,__register			; relative to all the register stack
   107                              <1> ;		call	_operand_read			; for I am the single-word push instruction
   108                              <1> ;		pop	ebp				;
   109                              <1> 
   110                              <1> ;	register identities supplied from emulated instructions to these routines
   111                              <1> ;	are their lowercase names equated to RTA1 word addresses
   112                              <1> 
   113                              <1> ;	There exist also uppercase spellings which instruction routines may
   114                              <1> ;	access internally. The uppercase names are four times in value the
   115                              <1> ;	equivalent lowercase ordinal names to give x86 platform offset values
   116                              <1> 
   117                              <1> ;       Assembly language equate is like parentheses! What's in a label
   118                              <1> ;       is not an expression but its value. Nothing like C preprocessor.
   119                              <1> ;       Just in case you're developing enhancements in assembly using
   120                              <1> ;       preprocessor and #define
   121                              <1> 
   122                              <1> ;		_floating_operand2 equ	256+12
   123                              <1> ;		FLOATING_OPERAND2 equ	_floating_operand2*4
   124                              <1> 
   125                              <1> 
   126                              <1> ;		a	equ	4
   127                              <1> ;		b	equ	5
   128                              <1> ;		mantissa2 equ	6
   129                              <1> 
   130                              <1> ;		A	equ	a*4
   131                              <1> ;		B	equ	b*4
   132                              <1> ;		MANTISSA2 equ	mantissa2*4
   133                              <1> 
   134                              <1> ;		mov	ebx, dword ptr [bp+MANTISSA2]	; the very same!
   135                              <1> ;		mov	ebx, dword ptr [bp+mantissa2*4]	; the very same
   136                              <1> 
   137                              <1> ;	but to identify an instruction-implied register to these operand routines
   138                              <1> 
   139                              <1> ;		mov	ebx, mantissa2		; bp already says which register set
   140                              <1> 
   141                              <1> ;	instruction evaluation supplies right-hand side operand EA in eax
   142                              <1> ;	Instruction implementation needs not examine EA. Call _operand_read
   143                              <1> ;	or _operand_write. eax must be as supplied to the instruction routine
   144                              <1> ;	on on operand retrieve and store
   145                              <1> 
   146                              <1> ;	simple instructions receive operand mode in cl from instruction
   147                              <1> ;	evaluation
   148                              <1> 
   149                              <1> ;	shifts and jumps use the ea which is already indexed or indirected
   150                              <1> ;	if necessary and make no operand call
   151                              <1> 
   152                              <1> ;	instructions call _burst_read2 or _burst_write2 for two-word operand cycles
   153                              <1> ;	instructions call _burst_read4 or _burst_write4 for four-word operand cycles
   154                              <1> 
   155                              <1> ;	operand reads of 1 or 2 words return values in eax:ebx
   156                              <1> 
   157                              <1> ;		call	_burst_read2
   158                              <1> ;		mov	dword ptr [ebp+A], eax
   159                              <1> ;		mov	dword ptr [ebp+B], ebx
   160                              <1> 
   161                              <1> ;	to store one operand word place it in ebx
   162                              <1> 
   163                              <1> ;	_sc	mov	ebx, dword ptr[_psr]	; I am the store carry instruction sc
   164                              <1> ;		and	ebx, 1			; CARRY
   165                              <1> ;		call	_operand_write
   166                              <1> 
   167                              <1> ;	to store two or four words or to load four words, point bx to register
   168                              <1> 
   169                              <1> ;	_qpop	mov	ebx, dword ptr [ebp+S_P] ; internal stack pointer
   170                              <1> ;						; either application sp or interrupt sp
   171                              <1> ;
   172                              <1> ;		add	dword ptr [ebp+S_P], 4	; internal stack+= 4
   173                              <1> ;		push	ebp			;
   174                              <1> ;		mov	ebp, __register		; in case context is interrupt registers
   175                              <1> ;		call	_burst_write4		; both internal stack pointers are absolute
   176                              <1> ;		pop	ebp			; point epb back to application registers
   177                              <1> ;						;                or interrupt registers
   178                              <1> 
   179                              <1> ;	more complex instructions do something to the registers after
   180                              <1> ;	acquiring operands
   181                              <1> 
   182                              <1> ;		call	_operand_read
   183                              <1> ;		add	eax, dword ptr [ebp+A]
   184                              <1> ;		rol	eax
   185                              <1> ;		and	al, CARRY		; 1
   186                              <1> ;		or	byte ptr [_psr], al	; low-order byte of longword _psr
   187                              <1> ;		shr	eax, 8
   188                              <1> ;		mov	dword ptr [ebp+A], eax
   189                              <1> 
   190                              <1> ;	emulated RTA1 instructions which both read and write (modify)
   191                              <1> ;	storage use the address in [edi+esi*4] to rewrite. edi is
   192                              <1> ;	NULL if it's not a suitable memory for a modify operation
   193                              <1> 
   194                              <1> ;	modify instructions which may have a register operand (not TS)
   195                              <1> ;	call _operand_write to rewrite a register. This guards aganst
   196                              <1> ;	applications writing interrupt registers.
   197                              <1>  
   198                              <1> ;	the effect of storage buses characteristically different
   199                              <1> ;	from RTA1 executable space is emulated in the routines
   200                              <1> ;	device_read and device_write
   201                              <1> 
   202                              <1> ;	Peripheral bus types implemented are
   203                              <1> 
   204                              <1> ;		filestore containing extents of up to 768K octets
   205                              <1> ;		accessible to RTA1 as up to 256K words in each extent.
   206                              <1> ;		The 3-octet words are in canonical order and packed
   207                              <1> 
   208                              <1> ;		network interface buffer store shared with the emulator
   209                              <1> ;		platform and reading out to RTA1 at 16 data bits per word
   210                              <1> ;		with eight high-order zero bits. RTA writes 16 data bits
   211                              <1> ;		to these locations from register low-order bit positions.
   212                              <1> ;		Storage byte order is canonical. These buffers are normal
   213                              <1> ;		and contiguous byte arrays of the emulator platform.
   214                              <1> ;		To RTA1 they are an attached device array of 16-bit words
   215                              <1> 
   216                              <1> ;	Device array types are
   217                              <1> 
   218                              <1> ;		executable space
   219                              <1> ;		24-bit filestore array
   220                              <1> ;		16-bit network interface array
   221                              <1> 
   222                              <1> ;	devices are identified in RTA1 memory relocation pointers and
   223                              <1> ;	tagged with device type. Executable space is device zero
   224                              <1> 
   225                              <1> ;	esi -> core.REGISTER
   226                              <1> 
   227                              <1> _burst_read2:
   228 000004B8 66B90600            <1> 	mov	cx, 6
   229 000004BC A900FFFF00          <1> 	test	eax, 00FFFF00h
   230 000004C1 7402                <1> 	jz	read2_registers
   231 000004C3 EB4D                <1> 	jmp	_bus_read
   232                              <1> 
   233                              <1> read2_registers:				; load registers from registers
   234                              <1> 	%if	__REGFOR
   235                              <1> 
   236                              <1> 	mov	rax, qword ptr [rsi+rax*4]	; swap the halves of r8 if computing in r8
   237                              <1> 	ret					; just mov for double register load
   238                              <1> 						; do this load inline anyway
   239                              <1> 	%else	
   240                              <1> 
   241 000004C5 8B5C8604            <1> 	mov	ebx, dword ptr [rsi+rax*4+4]
   242 000004C9 8B0486              <1> 	mov	eax, dword ptr [rsi+rax*4]
   243 000004CC C3                  <1> 	ret
   244                              <1> 
   245                              <1> 	%endif
   246                              <1> 	
   247                              <1> ;	rsi -> core.REGISTER
   248                              <1> 
   249                              <1> _burst_read4:					; buffered read
   250 000004CD 66B90700            <1> 	mov	cx, 7				; that will help the caller
   251 000004D1 A900FFFF00          <1> 	test	eax, 00FFFF00h			; ebp+ebx contains a register number
   252 000004D6 7402                <1> 	jz	read4_registers			; may also identify extra
   253 000004D8 EB38                <1> 	jmp	_bus_read
   254                              <1> 						; workspace registers
   255                              <1> read4_registers:				; at register stack tail
   256                              <1> 
   257                              <1> 	%if	__REGFOR			; registers are modelled
   258                              <1> 						; platform endian in storage
   259                              <1> 	mov	rax, qword ptr [rsi+rax*4+2*4]	; core-ways round individually but reverse order
   260                              <1> 	mov	rdx, qword ptr [rsi+rax*4]	; into correct register order individually platform-ordered 
   261                              <1> 	ret
   262                              <1> 
   263                              <1> 	%else
   264                              <1> 
   265 000004DA 8B4C860C            <1> 	mov	ecx, dword ptr [rsi+rax*4+3*4]
   266 000004DE 894C9D0C            <1> 	mov	dword ptr [rbp+rbx*4+3*4], ecx
   267 000004E2 8B4C8608            <1> 	mov	ecx, dword ptr [rsi+rax*4+2*4]
   268 000004E6 894C9D08            <1> 	mov	dword ptr [rbp+rbx*4+2*4], ecx
   269 000004EA 8B4C8604            <1> 	mov	ecx, dword ptr [rsi+rax*4+4]
   270 000004EE 894C9D04            <1> 	mov	dword ptr [rbp+rbx*4+4], ecx
   271 000004F2 8B0C86              <1> 	mov	ecx, dword ptr [rsi+rax*4]
   272 000004F5 894C9D00            <1> 	mov	dword ptr [rbp+rbx*4], ecx
   273 000004F9 C3                  <1> 	ret
   274                              <1> 
   275                              <1> 	%endif
   276                              <1> 
   277                              <1> ;	esi -> core.REGISTER
   278                              <1> 
   279                              <1> _operand_read:			; call here with designator coded in cx
   280 000004FA 80E107              <1> 	and	cl, 7		; and ea in eax
   281 000004FD 80F904              <1> 	cmp	cl, 4
   282 00000500 740F                <1> 	je	immediate	; EA is operand
   283 00000502 80F905              <1> 	cmp	cl, 5
   284 00000505 740A                <1> 	je	immediate_xi	; EA is operand
   285                              <1> 
   286 00000507 A900FFFF00          <1> 	test	eax, 00FFFF00h
   287 0000050C 7504                <1> 	jnz	_bus_read	; ea does not point to registers
   288 0000050E 8B0486              <1> 	mov	eax, dword ptr [rsi+rax*4]
   289                              <1> 
   290                              <1> immediate:
   291                              <1> immediate_xi:
   292 00000511 C3                  <1> 	ret 
   293                              <1> 
   294                              <1> _bus_read:				; readout any memory
   295                              <1> 
   296 00000512 E82F060000          <1> 	call	base_read_pointer	; returns eax <- storage block
   297                              <1> 					; 	  esi <- word offset
   298                              <1> 					;	  edi <- EA
   299                              <1> 
   300 00000517 A900004000          <1> 	test	eax, 00400000h		; big block?
   301 0000051C 7420                <1> 	je	memory_read_4k_block
   302                              <1> 
   303 0000051E 80F906              <1> 	cmp	cl, 6			; multiword operation?
   304 00000521 720D                <1> 	jb	_bus_read_256k_block
   305                              <1> 
   306 00000523 81FEFCFF0300        <1> 	cmp	esi, 03FFFCh		; near the edge?
   307 00000529 7605                <1> 	jna	_bus_read_256k_block	; no
   308                              <1> 
   309 0000052B E86D220000          <1> 	call	read_straddle_18b?
   310                              <1> 
   311                              <1> _bus_read_256k_block:
   312 00000530 25FFFF3F00          <1> 	and	eax, 003FFFFFh		; 64-bit shift to page won't brush off 00400000 bit
   313 00000535 A83F                <1> 	test	al, 63
   314 00000537 742A                <1> 	jz	memory_read_page
   315                              <1> 
   316 00000539 E916040000          <1> 	jmp	device_read
   317                              <1> 
   318                              <1> memory_read_4k_block:
   319 0000053E F7C600F00300        <1> 	test	esi, 0003F000h		; inside 4k block?
   320 00000544 740A                <1> 	jz	memory_read_thru
   321                              <1> 
   322 00000546 B90E000000          <1> 	mov	ecx, LP_ADDRESS
   323 0000054B E9E30B0000          <1> 	jmp	guard_ii_escape		; no
   324                              <1> 
   325                              <1> memory_read_thru:
   326 00000550 80F906              <1> 	cmp	cl, 6
   327 00000553 720E                <1> 	jb	memory_read_page
   328                              <1> 
   329 00000555 4881FEFC0F0000      <1> 	cmp	rsi, 0FFCh		; near the edge?
   330 0000055C 7605                <1> 	jna	memory_read_page	; no
   331                              <1> 
   332 0000055E E80A220000          <1> 	call	read_straddle_12b?
   333                              <1> 
   334                              <1> memory_read_page:
   335 00000563 48C1E00C            <1> 	shl	rax, 12			; multiply by page and lose bit 00400000
   336 00000567 4801C6              <1> 	add	rsi, rax
   337                              <1> ;	mov	ch, byte ptr [edi+PSR]	; field of PSR with byte options
   338 0000056A 48BF-               <1> 	mov	rdi, _memory		; byte address
   338 0000056C [0000000000000000]  <1>
   339                              <1> 
   340                              <1> memory_read_on:
   341 00000574 488D3CB7            <1> 	lea	rdi, [rdi+rsi*4]
   342                              <1> 
   343 00000578 480F7EFE            <1> 	movq	rsi, mm7
   344                              <1> ;	mov	rsi, qword ptr [rbp+CORE_INDEX1]
   345 0000057C 480FB6C1            <1> 	movzx	rax, cl
   346 00000580 488B04C5[8A050000]  <1> 	mov	rax, qword ptr [read_action+rax*8]
   347 00000588 FFE0                <1> 	jmp	rax
   348                              <1> 
   349                              <1> read_action:
   350 0000058A [CA05000000000000]  <1> 	dq	memory_read_w0
   351 00000592 [0B06000000000000]  <1> 	dq	memory_t1
   352 0000059A [1206000000000000]  <1> 	dq	memory_t2	; or h1
   353 000005A2 [2206000000000000]  <1> 	dq	memory_t3	; or h2
   354 000005AA [1105000000000000]  <1> 	dq	immediate	; don't get here
   355 000005B2 [1105000000000000]  <1> 	dq	immediate_xi	; don't get here
   356 000005BA [D105000000000000]  <1> 	dq	memory_read2
   357 000005C2 [DF05000000000000]  <1> 	dq	memory_read4
   358                              <1> 
   359                              <1> memory_read_w0:			; readout system memory 1 word
   360                              <1> 
   361                              <1> 	%if	__MOVBE
   362                              <1> 	movbe	eax, dword ptr [rdi]
   363                              <1> 	%else
   364 000005CA 8B07                <1> 	mov	eax, dword ptr [rdi]
   365 000005CC B000                <1> 	mov	al, 0
   366 000005CE 0FC8                <1> 	bswap	eax
   367                              <1> 	%endif
   368                              <1> ; immediate:
   369                              <1> ; immediate_xi:
   370 000005D0 C3                  <1>  	ret
   371                              <1> 
   372                              <1> memory_read2:			; readout system memory 2 words
   373                              <1> 	%if	__MOVBE
   374                              <1> 
   375                              <1> 	movbe	rax, qword ptr [rdi]
   376                              <1> 	ret
   377                              <1> 
   378                              <1> 	%else
   379                              <1> 
   380 000005D1 8B5F04              <1> 	mov	ebx, dword ptr [rdi+4]
   381 000005D4 8B07                <1> 	mov	eax, dword ptr [rdi]
   382                              <1> 
   383 000005D6 B000                <1> 	mov	al, 0
   384 000005D8 B300                <1> 	mov	bl, 0
   385 000005DA 0FC8                <1> 	bswap	eax
   386 000005DC 0FCB                <1> 	bswap	ebx
   387 000005DE C3                  <1> 	ret
   388                              <1> 
   389                              <1> 	%endif
   390                              <1> 				; readout system memory 4 words
   391                              <1> memory_read4:			; store by pointer
   392                              <1> 				; this will be useful to the caller
   393                              <1> 
   394                              <1> 	%if	__MOVBE
   395                              <1> 	
   396                              <1> 	movbe	rax, qword ptr [rdi+2*4]
   397                              <1> 	movbe	rdx, qword ptr [rdi]
   398                              <1> 	ret
   399                              <1> 
   400                              <1> 	%else
   401                              <1> 
   402 000005DF 8B07                <1> 	mov	eax, dword ptr [rdi]
   403 000005E1 B000                <1> 	mov	al, 0
   404 000005E3 0FC8                <1> 	bswap	eax
   405 000005E5 89449D00            <1> 	mov	dword ptr [rbp+rbx*4], eax
   406 000005E9 8B4704              <1> 	mov	eax, dword ptr [rdi+4]
   407 000005EC B000                <1> 	mov	al, 0
   408 000005EE 0FC8                <1> 	bswap	eax
   409 000005F0 89449D04            <1> 	mov	dword ptr [rbp+rbx*4+4], eax
   410 000005F4 8B4708              <1> 	mov	eax, dword ptr [rdi+2*4]
   411 000005F7 B000                <1> 	mov	al, 0
   412 000005F9 0FC8                <1> 	bswap	eax
   413 000005FB 89449D08            <1> 	mov	dword ptr [rbp+rbx*4+2*4], eax
   414 000005FF 8B470C              <1> 	mov	eax, dword ptr [rdi+3*4]
   415 00000602 B000                <1> 	mov	al, 0
   416 00000604 0FC8                <1> 	bswap	eax
   417 00000606 89449D0C            <1> 	mov	dword ptr [rbp+rbx*4+3*4], eax
   418 0000060A C3                  <1> 	ret
   419                              <1> 
   420                              <1> 	%endif
   421                              <1> 
   422                              <1> memory_t1:
   423 0000060B 8B07                <1> 	mov	eax, dword ptr [rdi]
   424 0000060D C1E010              <1> 	shl	eax, 16		; t1 = 3.2.THIS.zero
   425 00000610 EB1B                <1> 	jmp	memory_tw
   426                              <1> 
   427                              <1> memory_t2:
   428 00000612 8B07                <1> 	mov	eax, dword ptr [rdi]
   429 00000614 F686B004000080      <1> 	test	byte ptr [rsi+PSR], HALF_W
   430 0000061B 7517                <1> 	jnz	memory_h1
   431 0000061D C1E008              <1> 	shl	eax, 8		; t2 = 3.THIS.1.zero
   432 00000620 EB0B                <1> 	jmp	memory_tw
   433                              <1> 
   434                              <1> memory_t3:
   435 00000622 8B07                <1> 	mov	eax, dword ptr [rdi]
   436 00000624 F686B004000080      <1> 	test	byte ptr [rsi+PSR], HALF_W
   437 0000062B 750E                <1> 	jnz	memory_h2
   438                              <1> memory_tw:
   439 0000062D C1F810              <1> 	sar	eax, 16		; t3 = THIS.2.1.zero
   440 00000630 C1E808              <1> 	shr	eax, 8
   441 00000633 C3                  <1> 	ret
   442                              <1> 
   443                              <1> memory_h1:
   444 00000634 0FC8                <1> 	bswap	eax		; already loaded but not swapped
   445 00000636 C1E008              <1> 	shl	eax, 8		; h1 = zero.HERE.2.3
   446 00000639 EB05                <1> 	jmp	memory_hw
   447                              <1> 
   448                              <1> memory_h2:
   449 0000063B 0FC8                <1> 	bswap	eax		; already loaded but not swapped
   450 0000063D C1E014              <1> 	shl	eax, 8+12
   451                              <1> memory_hw:
   452 00000640 C1F80C              <1> 	sar	eax, 12
   453 00000643 C1E808              <1> 	shr	eax, 8
   454 00000646 C3                  <1> 	ret
   455                              <1> 
   456                              <1> ;	esi -> core.REGISTER
   457                              <1> 				; store system memory
   458                              <1> _burst_write4:
   459 00000647 66B90700            <1> 	mov	cx, 7
   460 0000064B A900FFFF00          <1> 	test	eax, 00FFFF00h
   461 00000650 0F858A000000        <1> 	jnz	NEAR bus_write
   462                              <1> 
   463                              <1> 	; store emulated registers to emulated registers
   464                              <1> 
   465 00000656 F786B0040000000080- <1> 	test	dword ptr [rsi+PSR], 0800000h	; ISR ?
   465 0000065F 00                  <1>
   466 00000660 750A                <1> 	jnz	write4_registers	; ISRs may write some spare registers
   467 00000662 83F87C              <1> 	cmp	eax, 124
   468 00000665 7605                <1> 	jna	write4_registers
   469 00000667 E9C20A0000          <1> 	jmp	guard_ii_authority	; but applications may not write
   470                              <1> 					; any interrupt registers
   471                              <1> 
   472                              <1> write4_registers:
   473                              <1> ;	mov	edi, eax		; eax can be freed
   474                              <1> 
   475                              <1> 	%if	__REGFOR
   476                              <1> 	mov	rdx, qword ptr [rbp+rbx*4]
   477                              <1> 	ror	rdx, 32
   478                              <1> 	mov	qword ptr [rsi+REGISTER+rax*4], rdx
   479                              <1> 
   480                              <1> 	mov	rdx, qword ptr [rbp+rbx*4+2*4]
   481                              <1> 	ror	rdx, 32
   482                              <1> 	mov	qword ptr [rsi+REGISTERrax*4+2*4], rdx
   483                              <1> 	ret
   484                              <1> 
   485                              <1> 	%else
   486                              <1> 
   487 0000066C 8B4C9D00            <1> 	mov	ecx, dword ptr [rbp+rbx*4]	; data for store
   488                              <1> 					; ebp+ebx is a register number
   489                              <1> 					; which can be extra register locations
   490                              <1> 					; serving as workspace at the tail of
   491                              <1> 					; the register stack
   492                              <1> 
   493 00000670 890C86              <1> 	mov	dword ptr [rsi+rax*4], ecx
   494 00000673 8B4C9D04            <1> 	mov	ecx, dword ptr [rbp+rbx*4+4]
   495 00000677 894C8604            <1> 	mov	dword ptr [rsi+rax*4+4], ecx
   496                              <1> 
   497 0000067B 8B4C9D08            <1> 	mov	ecx, dword ptr [rbp+rbx*4+2*4]
   498 0000067F 894C8608            <1> 	mov	dword ptr [rsi+rax*4+2*4], ecx
   499 00000683 8B4C9D0C            <1> 	mov	ecx, dword ptr [rbp+rbx*4+3*4]
   500 00000687 894C860C            <1> 	mov	dword ptr [rsi+rax*4+3*4], ecx
   501 0000068B C3                  <1> 	ret
   502                              <1> 
   503                              <1> 	%endif
   504                              <1> 
   505                              <1> ;	esi -> core.REGISTER
   506                              <1> 
   507                              <1> _burst_write2:
   508 0000068C 66B90600            <1> 	mov	cx, 6
   509 00000690 A900FFFF00          <1> 	test	eax, 00FFFF00h
   510 00000695 7549                <1> 	jnz	bus_write
   511                              <1> 
   512                              <1> 	; store to emulated registers
   513                              <1> 
   514 00000697 F786B0040000000080- <1> 	test	dword ptr [rsi+PSR], 0800000h	; ISR ?
   514 000006A0 00                  <1>
   515 000006A1 750A                <1> 	jnz	write2_registers	; there are spare registers at the end
   516 000006A3 83F87E              <1> 	cmp	eax, 126		; but applications may not write
   517 000006A6 7605                <1> 	jna	write2_registers	; any interrupt registers
   518 000006A8 E9810A0000          <1> 	jmp	guard_ii_authority
   519                              <1> 
   520                              <1> write2_registers:
   521                              <1> ;	mov	edi, eax			; time to free eax
   522                              <1> 
   523                              <1> 	%if	__REGFOR
   524                              <1> 
   525                              <1> 	mov	rdx, qword ptr [rbp+rbx*4]
   526                              <1> 	ror	rdx, 32
   527                              <1> 	mov	qword ptr [rsi+REGISTER+rax*4], rdx
   528                              <1> 	ret 
   529                              <1> 
   530                              <1> 	%else
   531                              <1> 
   532 000006AD 8B4C9D00            <1> 	mov	ecx, dword ptr [rbp+rbx*4]
   533 000006B1 890C86              <1> 	mov	dword ptr [rsi+rax*4], ecx
   534 000006B4 8B4C9D04            <1> 	mov	ecx, dword ptr [rbp+rbx*4+4]
   535 000006B8 894C8604            <1> 	mov	dword ptr [rsi+rax*4++4], ecx
   536 000006BC C3                  <1> 	ret
   537                              <1> 
   538                              <1> 	%endif
   539                              <1> 
   540                              <1> ;	esi -> core.REGISTER
   541                              <1> 
   542                              <1> _operand_write:
   543 000006BD A900FFFF00          <1> 	test	eax, 00FFFF00h
   544 000006C2 751C                <1> 	jnz	bus_write
   545                              <1> 
   546                              <1> _operand_write_register:
   547 000006C4 A980000000          <1> 	test	eax, 80h		; in the interrupt registers?
   548 000006C9 7411                <1> 	jz	write1_register
   549 000006CB F786B0040000000080- <1> 	test	dword ptr [rsi+PSR], 0800000h
   549 000006D4 00                  <1>
   550 000006D5 7505                <1> 	jnz	write1_register
   551 000006D7 E9520A0000          <1> 	jmp	guard_ii_authority
   552                              <1> 
   553                              <1> write1_register:
   554 000006DC 891C86              <1> 	mov	dword ptr [rsi+rax*4], ebx
   555 000006DF C3                  <1> 	ret
   556                              <1> 
   557                              <1> bus_write:				; write any memory
   558                              <1> 					;	eax <- EA
   559                              <1> 					;	ebx <- data | [ ebp + ebx * 4] -> 1st data word
   560                              <1> 					;	cl  <- encoding [ word * 1 / 2 / 4 ] / byte
   561                              <1> 					;	esi <- core
   562                              <1> 
   563 000006E0 E8B3040000          <1> 	call	base_write_pointer	; returns eax <- block
   564                              <1> 					;         edi <- EA
   565                              <1> 					;	  esi <- word offset
   566                              <1> 
   567 000006E5 A900004000          <1> 	test	eax, 00400000h		; big block?
   568 000006EA 7423                <1> 	jz	memory_write_4k_block	; no
   569 000006EC 80F906              <1> 	cmp	cl, 6			; multiword operation?
   570 000006EF 720D                <1> 	jb	bus_write_256k_block	; no
   571                              <1> 
   572 000006F1 81FEFCFF0300        <1> 	cmp	esi, 03FFFCh		; near the edge?
   573 000006F7 7605                <1> 	jna	bus_write_256k_block	; no
   574                              <1> 
   575 000006F9 E819210000          <1> 	call	write_straddle_18b?
   576                              <1> 
   577                              <1> bus_write_256k_block:
   578 000006FE 25FFFF3F00          <1> 	and	eax, 003FFFFFh		; 64-bit shift to page size won't rub off 00400000 bit
   579 00000703 A93F000000          <1> 	test	eax, 63			; a device array?
   580 00000708 7429                <1> 	jz	memory_write_page	; no. scaling shift will scrub bit 400000
   581 0000070A E951030000          <1> 	jmp	_device_write		; yes a device array
   582                              <1> 
   583                              <1> memory_write_4k_block:
   584 0000070F F7C600F00300        <1> 	test	esi, 0003F000h		; inside a 4k page?
   585 00000715 740A                <1> 	jz	memory_write_thru
   586 00000717 B90E000000          <1> 	mov	ecx, LP_ADDRESS
   587 0000071C E9120A0000          <1> 	jmp	guard_ii_escape		; no
   588                              <1> 
   589                              <1> memory_write_thru:
   590 00000721 80F906              <1> 	cmp	cl, 6			; multiword operation?
   591 00000724 720D                <1> 	jb	memory_write_page	; no
   592                              <1> 
   593 00000726 81FEFC0F0000        <1> 	cmp	esi, 0FFCh		; near the edge?
   594 0000072C 7605                <1> 	jna	memory_write_page	; no
   595                              <1> 
   596 0000072E E8AF200000          <1> 	call	write_straddle_12b?
   597                              <1> 
   598                              <1> memory_write_page:
   599 00000733 480F7EFF            <1> 	movq	rdi, mm7
   600                              <1> ;	mov	rdi, qword ptr [rbp+CORE_INDEX1]
   601                              <1> 
   602 00000737 3B87D0060000        <1> 	cmp	eax, dword ptr [rdi+IO_PORT+_RAM_THRESHOLD] ; edi -> core registers
   603 0000073D 0F88EB090000        <1> 	js	near guard_ii_authority	; guard the NVRAM whether real or emulated
   604                              <1> 
   605 00000743 48C1E00C            <1> 	shl	rax, 12			; multiply by page and lose bit 00400000
   606 00000747 4801C6              <1> 	add	rsi, rax		; add offset
   607                              <1> 
   608                              <1> ;	mov	ch, byte ptr [edi+PSR]	; field of PSR with byte options
   609 0000074A 48BF-               <1> 	mov	rdi, _memory
   609 0000074C [0000000000000000]  <1>
   610                              <1> 
   611                              <1> memory_write_on:
   612 00000754 488D3CB7            <1> 	lea	rdi, [rdi+rsi*4]
   613                              <1> 
   614 00000758 480F7EFE            <1> 	movq	rsi, mm7
   615                              <1> ;	mov	rsi, qword ptr [ebp+CORE_INDEX1]
   616                              <1> 
   617                              <1> 	%if	1
   618 0000075C 4D21FF              <1> 	and	r15, r15		; is there any touchpoint?
   619 0000075F 7414                <1> 	jz	memory_write_on_go
   620 00000761 4C39FF              <1> 	cmp	rdi, r15		; value of TOUCHPOINT
   621 00000764 780F                <1> 	js	memory_write_on_go	; below range
   622 00000766 483B3C25[00000000]  <1> 	cmp	rdi, qword ptr [_touchpoint2]
   623 0000076E 7905                <1> 	jns	memory_write_on_go	; above range
   624 00000770 E9B9090000          <1> 	jmp	guard_ii_authority
   625                              <1> 
   626                              <1> 	%else
   627                              <1> 
   628                              <1> 	test	dword ptr [_general_indication], TOUCHPOINT
   629                              <1> 	jz	memory_write_on_go
   630                              <1> 
   631                              <1> 	cmp	edi, dword ptr [_touchpoint]
   632                              <1> 	js	memory_write_on_go
   633                              <1> 	cmp	edi, dword ptr [_touchpoint2]
   634                              <1> 	jns	memory_write_on_go
   635                              <1> 	jmp	guard_ii_authority
   636                              <1> 
   637                              <1> 	%endif
   638                              <1> 
   639                              <1> memory_write_on_go:
   640 00000775 480FB6C1            <1> 	movzx	rax, cl
   641 00000779 488B04C5[83070000]  <1> 	mov	rax, qword ptr [write_action+rax*8]
   642 00000781 FFE0                <1> 	jmp	rax
   643                              <1> 
   644                              <1> write_action:
   645 00000783 [C307000000000000]  <1> 	dq	memory_write
   646 0000078B [C807000000000000]  <1> 	dq	write_t1
   647 00000793 [CC07000000000000]  <1> 	dq	write_t2	; or h1
   648 0000079B [D907000000000000]  <1> 	dq	write_t3	; or h2
   649 000007A3 [C707000000000000]  <1> 	dq	just_dont
   650 000007AB [C707000000000000]  <1> 	dq	just_dont
   651 000007B3 [1308000000000000]  <1> 	dq	memory_write2
   652 000007BB [2508000000000000]  <1> 	dq	memory_write4
   653                              <1> 
   654                              <1> memory_write:					; store system memory 1 word
   655                              <1> 
   656                              <1> 	%if	__MOVBE
   657                              <1> 
   658                              <1> 	movbe	dword ptr [rdi], ebx
   659                              <1> 
   660                              <1> 	%else
   661                              <1> 
   662 000007C3 0FCB                <1> 	bswap	ebx
   663 000007C5 891F                <1> 	mov	dword ptr [rdi], ebx
   664                              <1> 
   665                              <1> 	%endif
   666                              <1> 
   667                              <1> just_dont:
   668 000007C7 C3                  <1> 	ret
   669                              <1> 
   670                              <1> write_t1:
   671 000007C8 885F01              <1> 	mov	byte ptr [rdi+1], bl
   672 000007CB C3                  <1> 	ret
   673                              <1> 
   674                              <1> write_t2:
   675 000007CC F686B004000080      <1> 	test	byte ptr [rsi+PSR], HALF_W
   676 000007D3 7511                <1> 	jnz	write_h1
   677 000007D5 885F02              <1> 	mov	byte ptr [rdi+2], bl
   678 000007D8 C3                  <1> 	ret
   679                              <1> 
   680                              <1> write_t3:
   681 000007D9 F686B004000080      <1> 	test	byte ptr [rsi+PSR], HALF_W
   682 000007E0 751A                <1> 	jnz	write_h2
   683 000007E2 885F03              <1> 	mov	byte ptr [rdi+3], bl
   684 000007E5 C3                  <1> 	ret
   685                              <1> 
   686                              <1> write_h1:
   687                              <1> 	%if	__MOVBE
   688                              <1> 	movbe	eax, dword ptr [rdi]
   689                              <1> 	%else
   690 000007E6 8B07                <1> 	mov	eax, dword ptr [rdi]
   691 000007E8 0FC8                <1> 	bswap	eax
   692                              <1> 	%endif
   693                              <1> 
   694 000007EA 81E3FF0F0000        <1> 	and	ebx, 4095
   695 000007F0 C1E30C              <1> 	shl	ebx, 12
   696 000007F3 25FF0F0000          <1> 	and	eax, 4095
   697 000007F8 09D8                <1> 	or	eax, ebx
   698 000007FA EB12                <1> 	jmp	write_hw
   699                              <1> 
   700                              <1> write_h2:
   701                              <1> 	%if	__MOVBE
   702                              <1> 	movbe	eax, dword ptr [rdi]
   703                              <1> 	%else
   704 000007FC 8B07                <1> 	mov	eax, dword ptr [rdi]
   705 000007FE 0FC8                <1> 	bswap	eax
   706                              <1> 	%endif
   707                              <1> 
   708 00000800 C1E80C              <1> 	shr	eax, 12
   709 00000803 C1E00C              <1> 	shl	eax, 12
   710 00000806 81E3FF0F0000        <1> 	and	ebx, 4095
   711 0000080C 09D8                <1> 	or	eax, ebx
   712                              <1> 
   713                              <1> write_hw:
   714                              <1> 	%if	__MOVBE
   715                              <1> 	movbe	dword ptr [rdi], eax
   716                              <1> 	ret
   717                              <1> 
   718                              <1> 	%else
   719                              <1> 
   720 0000080E 0FC8                <1> 	bswap	eax
   721 00000810 8907                <1> 	mov	dword ptr [rdi], eax
   722 00000812 C3                  <1> 	ret
   723                              <1> 
   724                              <1> 	%endif
   725                              <1> 
   726                              <1> 	%if	__MOVBE
   727                              <1> 
   728                              <1> memory_write2:
   729                              <1> 	movbe	qword ptr [rdi], rax
   730                              <1> 	ret	
   731                              <1> 
   732                              <1> memory_write4:
   733                              <1> 	movbe	qword ptr [rdi+2*4], rax
   734                              <1> 	movbe	qword ptr [rdi], rdx
   735                              <1> 	ret
   736                              <1> 
   737                              <1> 	%else
   738                              <1> 
   739                              <1> 					; store system memory 2 words
   740                              <1> memory_write2:				; eax is already free
   741 00000813 8B449D00            <1> 	mov	eax, dword ptr [rbp+rbx*4]
   742 00000817 0FC8                <1> 	bswap	eax
   743 00000819 8907                <1> 	mov	dword ptr [rdi], eax
   744                              <1> 
   745 0000081B 8B449D04            <1> 	mov	eax, dword ptr [rbp+rbx*4+4]
   746 0000081F 0FC8                <1> 	bswap	eax
   747 00000821 894704              <1> 	mov	dword ptr [rdi+4], eax
   748 00000824 C3                  <1> 	ret
   749                              <1> 
   750                              <1> memory_write4:					; store system memory 4 words
   751 00000825 8B449D00            <1> 	mov	eax, dword ptr [rbp+rbx*4]	; bx is a register number and may
   752                              <1> 						; identify extra workspace registers
   753                              <1> 						; at register stack tail
   754 00000829 0FC8                <1> 	bswap	eax
   755 0000082B 8907                <1> 	mov	dword ptr [rdi], eax
   756 0000082D 8B449D04            <1> 	mov	eax, dword ptr [rbp+rbx*4+4]
   757 00000831 0FC8                <1> 	bswap	eax
   758 00000833 894704              <1> 	mov	dword ptr [rdi+4], eax
   759 00000836 8B449D08            <1> 	mov	eax, dword ptr [rbp+rbx*4+8]
   760 0000083A 0FC8                <1> 	bswap	eax
   761 0000083C 894708              <1> 	mov	dword ptr [rdi+2*4], eax
   762 0000083F 8B449D0C            <1> 	mov	eax, dword ptr [rbp+rbx*4+12]
   763 00000843 0FC8                <1> 	bswap	eax
   764 00000845 89470C              <1> 	mov	dword ptr [rdi+3*4], eax
   765 00000848 C3                  <1> 	ret
   766                              <1> 
   767                              <1> ;	modify instructions n inc dec src slc sim popA
   768                              <1> ;	rewrite here
   769                              <1> 
   770                              <1> 	%endif
   771                              <1> 
   772                              <1> memoreg_writeback:
   773                              <1> 	%if	1
   774 00000849 4821FF              <1> 	and	rdi, rdi
   775 0000084C 7509                <1> 	jnz	memory_direct
   776 0000084E 25FFFFFF00          <1> 	and	eax, 00FFFFFFh			; unchanged esi -> core.REGISTER	
   777 00000853 89049E              <1> 	mov	[rsi+rbx*4+REGISTER], eax	; platform endian
   778                              <1> 						; register writeback index ebx ->
   779 00000856 C3                  <1> 	ret
   780                              <1> 	%else
   781                              <1> 
   782                              <1> 
   783                              <1> 	test	ebx, -256			; save EA is ?
   784                              <1> 	jnz	memory_direct			; a memory device
   785                              <1> 	xchg	eax, ebx			; a register
   786                              <1> 	and	ebx, 00FFFFFFh
   787                              <1> 	jmp	_operand_write_register		; esi -> core.REGISTER
   788                              <1> 
   789                              <1> ;	if not a register rewrite
   790                              <1> ;	n inc dec src slc sim popA
   791                              <1> ;	write RTA memory at its saved platform address
   792                              <1> 	%endif
   793                              <1> 
   794                              <1> memory_direct:					; esi <- memory_offset
   795                              <1> 	%if	__MOVBE
   796                              <1> 	movbe	dword ptr [rdi+rsi*4], eax
   797                              <1> 	%else
   798 00000857 0FC8                <1> 	bswap	eax				; write components edi esi kept from base_read
   799 00000859 30C0                <1> 	xor	al, al				
   800 0000085B 8904B7              <1> 	mov	dword ptr [rdi+rsi*4], eax
   801                              <1> 	%endif
   802 0000085E C3                  <1> 	ret
   803                              <1> 
   804                              <1> 
   805                              <1> ;	execute calls memory read
   806                              <1> ;	ea < 256 is not for execute a register
   807                              <1> ;	operand is at a readable address in system memory or array
   808                              <1> 
   809                              <1> memory_read:					; for execute and modify instructions:
   810 0000085F E872000000          <1> 	call	memory_point			; read only executable space
   811                              <1> 	%if	__MOVBE
   812                              <1> 	movbe	eax, dword ptr [rdi+rsi*4]
   813                              <1> 	%else
   814 00000864 8B04B7              <1> 	mov	eax, dword ptr [rdi+rsi*4]	; and similar memory types
   815 00000867 B000                <1> 	mov	al, 0
   816 00000869 0FC8                <1> 	bswap	eax
   817                              <1> 	%endif
   818 0000086B C3                  <1> 	ret
   819                              <1> 
   820                              <1> ;	modify instructions n inc dec src slc sim popA call here
   821                              <1> ;	ea < 256 is a register
   822                              <1> 
   823                              <1> memoreg:					; read-modify-write registers / system memory
   824 0000086C A900FFFFFF          <1> 	test	eax, -256			; but nothing marked as a peripheral bus
   825 00000871 751B                <1> 	jnz	memory_read_lock
   826 00000873 A880                <1> 	test	al, 128				; interrupt register?
   827 00000875 740E                <1> 	jz	register_read_for_write		; no, clear to update
   828 00000877 F686B204000080      <1> 	test	byte ptr [rsi+PSR+2], 128	; ISR ?
   829 0000087E 7505                <1> 	jnz	register_read_for_write
   830 00000880 E9A9080000          <1> 	jmp	guard_ii_authority
   831                              <1> 
   832                              <1> register_read_for_write:			; unchanged esi -> core.REGISTER
   833 00000885 89C3                <1>         mov     ebx, eax                        ; copy of ea -> registers to memoreg_writeback
   834 00000887 4831FF              <1>         xor     rdi, rdi                        ; tell memoreg->writeback that's how it is, no device
   835 0000088A 8B0486              <1>         mov     eax, dword ptr [rsi+REGISTER+rax*4]
   836 0000088D C3                  <1>         ret					; register writeback index ebx ->
   837                              <1> 
   838                              <1> 
   839                              <1> ;	RAM boundary in port 124 defines the upper page limit
   840                              <1> ;	of a real or emulated NVRAM containing the fixed system image
   841                              <1> 
   842                              <1> ;	fixed system image may be kernel + loader in a dozen pages
   843                              <1> ;	or it may be the entire application
   844                              <1> 
   845                              <1> ;	emulated machine applies the update limit
   846                              <1> ;	whether NVRAM is emulated or real
   847                              <1> 
   848                              <1> ;	if not a register
   849                              <1> ;	n inc dec src slc sim popA read a memory word which is legal to write
   850                              <1> ;	and keep the platform address to write the modified value
   851                              <1> ;	modify instructions do not lock memory between read and rewrite
   852                              <1> 
   853                              <1> memory_read_lock:
   854 0000088E E808000000          <1> 	call	memory_lock
   855                              <1> 	%if	__MOVBE
   856                              <1> 	movbe	eax, dword ptr [rdi+rsi*4]
   857                              <1> 	%else
   858 00000893 8B04B7              <1> 	mov	eax, dword ptr [rdi+rsi*4]
   859 00000896 B000                <1> 	mov	al, 0
   860 00000898 0FC8                <1> 	bswap	eax
   861                              <1> 	%endif
   862 0000089A C3                  <1> 	ret
   863                              <1> 
   864                              <1> ;	memory_read_lock calls here for modify instructions if ea > registers
   865                              <1> ;	ts calls here with ea whatever range always -> memory
   866                              <1> 
   867                              <1> ;	ea must be a legally writable memory word
   868                              <1> ;	memory_lock does not lock but identifies a platform write address  
   869                              <1> ;	ts reads / unconditionally replaces word.t1
   870                              <1> ;	under platform locking protocol, xchg platform instruction
   871                              <1> 
   872                              <1> memory_lock:					; point for update
   873                              <1> 						; barred below RAM boundary as write is
   874 0000089B E8F8020000          <1> 	call	base_write_pointer		; resolve device:block:offset from EA
   875                              <1> 						; edi <- core.REGISTERS <- esi
   876                              <1> 						; eax <- memory block index
   877                              <1> 						; esi <- memory word offset
   878 000008A0 480F7EFF            <1> 	movq	rdi, mm7
   879                              <1> ;	mov	rdi, qword ptr [rbp+CORE_INDEX1]
   880                              <1> 
   881 000008A4 A900004000          <1> 	test	eax, 00400000h			; update block name is a big bank ?
   882 000008A9 741E                <1> 	jz	memory_lock_page		; no
   883                              <1> 
   884 000008AB 25FFFF3F00          <1> 	and	eax, 003FFFFFh			; 64-bit shift won't rub off 00400000 bit
   885                              <1> 						; on shift to page size
   886                              <1> 
   887 000008B0 A93F000000          <1> 	test	eax, 63				; a device outside executable space ?
   888 000008B5 7557                <1> 	jnz	_yspace_read			; yes
   889 000008B7 25FFFF3F00          <1> 	and	eax, 003FFFFFh			; bit 0400000 is gets stripped later anyway
   890 000008BC 3B87D0060000        <1> 	cmp	eax, dword ptr [rdi+IO_PORT+_RAM_THRESHOLD]	; below RAM boundary?
   891 000008C2 733E                <1> 	jnb	_xspace_read			; no, go ahead
   892 000008C4 E965080000          <1> 	jmp	guard_ii_authority
   893                              <1> 
   894                              <1> memory_lock_page:
   895 000008C9 3B87D0060000        <1> 	cmp	eax, dword ptr [rdi+IO_PORT+_RAM_THRESHOLD]	; below RAM boundary?
   896 000008CF 731F                <1> 	jnb	_xspace_read4K			; no, go head if offset < 1000 hex
   897 000008D1 E958080000          <1> 	jmp	guard_ii_authority
   898                              <1> 
   899                              <1> 
   900                              <1> ;	memory_read calls here for execute
   901                              <1> ;	identify a platform read address of an RTA memory word
   902                              <1> 
   903                              <1> memory_point:
   904 000008D6 E86B020000          <1> 	call	base_read_pointer		; edi <- core.REGISTERS <- esi
   905                              <1> 						; esi <- word offset in memory block
   906 000008DB A900004000          <1> 	test	eax, 00400000h			; eax <- page index
   907 000008E0 740E                <1> 	jz	_xspace_read4K
   908                              <1> 
   909 000008E2 25FFFF3F00          <1> 	and	eax, 003FFFFFh			; 64-bit shift won't rub off 00400000 bit
   910                              <1> 						; on shift to page size
   911 000008E7 A93F000000          <1> 	test	eax, 63
   912 000008EC 7414                <1> 	jz	_xspace_read
   913 000008EE EB1E                <1> 	jmp	_yspace_read			; ie a device either appropriate or not
   914                              <1> 
   915                              <1> _xspace_read4K:
   916 000008F0 F7C600F00300        <1> 	test	esi, 003F000h
   917 000008F6 740A                <1> 	jz	_xspace_read
   918 000008F8 B90E000000          <1> 	mov	ecx, LP_ADDRESS
   919 000008FD E931080000          <1> 	jmp	guard_ii_escape
   920                              <1> 
   921                              <1> _xspace_read:					; must be a read in a sysmem-like device
   922 00000902 48BF-               <1> 	mov	rdi, _memory
   922 00000904 [0000000000000000]  <1>
   923 0000090C EB39                <1> 	jmp	_memory_deliver			; device array zero
   924                              <1> 
   925                              <1> _yspace_read:
   926 0000090E A900008000          <1> 	test	eax, 00800000h			; a tripsy non-space?
   927 00000913 753A                <1> 	jnz	_zspace_read			; not allowed
   928                              <1> 
   929 00000915 4889C7              <1> 	mov	rdi, rax
   930 00000918 4883E73F            <1> 	and	rdi, 63
   931 0000091C 8BBCBEE0060000      <1> 	mov	edi, dword ptr [rsi+IO_PORT+_DEVICE+rdi*4]
   932 00000923 F7C700008000        <1> 	test	edi, SYSMEM_FLAG		; _DEVICE are 32-bit descriptors
   933 00000929 7424                <1> 	jz	_zspace_read
   934 0000092B F7C700004000        <1> 	test	edi, DATA16_FLAG
   935 00000931 751C                <1> 	jnz	_zspace_read
   936                              <1> 
   937 00000933 C1E002              <1> 	shl	eax, 2				; al = 4 * device index
   938 00000936 480FB6F8            <1> 	movzx	rdi, al
   939                              <1> 
   940 0000093A 488BBC3F[00000000]  <1> 	mov	rdi, qword ptr [_devices+rdi*2]	; _devices are 64-bit pointers
   941 00000942 30C0                <1> 	xor	al, al				; necessary to lose the device bits now
   942 00000944 C1E802              <1> 	shr	eax, 2				; eax = bank * 64 = page in 28 bits
   943                              <1> _memory_deliver:
   944 00000947 48C1E00C            <1> 	shl	rax, 12				; multiply by page
   945 0000094B 4801C6              <1> 	add	rsi, rax			; bit 00400000 aleady removed
   946                              <1> 
   947                              <1> 	%if	__SMP
   948                              <1> 	%else
   949                              <1> 	mov	eax, dword ptr [edi+esi*4]
   950                              <1> 	bswap	eax
   951                              <1> 	%endif
   952 0000094E C3                  <1> 	ret
   953                              <1> 
   954                              <1> _zspace_read:
   955 0000094F E9DA070000          <1> 	jmp	guard_ii_authority
   956                              <1> 
   957                              <1> 
   958                              <1> ;	sub-architectural measure on sabr and reload instructions
   959                              <1> 
   960                              <1> ;	check the target memory block is in range and the bus characteristic
   961                              <1> ;	of the memory device when selecting blocks of memory, not when
   962                              <1> ;	accessing them. Use 8 spare bits in the word containing _base[]
   963                              <1> ;	for a quick recall of the emulated bus attribute on reference
   964                              <1> 
   965                              <1> ;	because this software emulation needs to act differently for
   966                              <1> 
   967                              <1> ;		executable space	rta1 24-bit words canonical memory
   968                              <1> ;					modeled in platform 32-bit words
   969                              <1> 
   970                              <1> ;		shared network buffers	16-bit words canonical in memory
   971                              <1> ;					and zero extend on readout to RTA1
   972                              <1> 
   973                              <1> ;		24-bit filestore array	3-octet words stored big-endian
   974                              <1> ;					in packed array
   975                              <1> 
   976                              <1> ;	concept RTA1 device arrays with bus behaviour differences are completely
   977                              <1> ;	emulated on PC emulations because device arrays are modeled in PC RAM.
   978                              <1> 
   979                              <1> ;	Various bus behaviours are emulated transparently to RTA1 target software
   980                              <1> ;	in anticipation	that different memories for different uses may be attached
   981                              <1> ;	on product boards, making core-emulated RTA1s much more efficient for not
   982                              <1> ;	needing this part of emulation
   983                              <1> 
   984                              <1> ;	devices
   985                              <1> 
   986                              <1> ;	device 0 is always executable space, but there may be more devices
   987                              <1> ;	with bus characteristics like device 0. The device descriptors are
   988                              <1> 
   989                              <1> ;		_________________________________________________________________
   990                              <1> ;		| 16 bits flags	| 16 bits banks	|       32 bits pointer		|
   991                              <1> ;		|_______________|____high index_|_______________________________|
   992                              <1> 
   993                              <1> 
   994                              <1> ;	[out]	sabr	[go]	[call]	reload instructions call here
   995                              <1> ;	go and call can probably check quicker themself
   996                              <1> ;	out can be trusted because applications don't out memory _base[] ports
   997                              <1> 
   998                              <1> ;	a big block in an RTA1 address window is 262144 words.
   999                              <1> ;	this checking concerns address windows tagged 2..63
  1000                              <1> ;	a device is an array up to 65536 big blocks or banks
  1001                              <1> 
  1002                              <1> ;	you get here with the relocation handle in ebx
  1003                              <1> ;	and the target window tag in eax, because that is the EA of a sabr instruction
  1004                              <1> 
  1005                              <1> device_read:				; readout device arrays
  1006 00000954 A900008000          <1>         test    eax, 0800000h           ; the vilainous bank index?
  1007 00000959 753C                <1>         jnz     device_read_escape
  1008                              <1> 
  1009                              <1> 					; edi -> core.REGISTER
  1010 0000095B 48C1E002            <1> 	shl	rax, 2			; al is device index * 4
  1011 0000095F 50                  <1> 	push	rax			; rest of eax is block index * 4
  1012 00000960 480FB6C0            <1> 	movzx	rax, al			; extend device number
  1013                              <1> 					; sense device descriptor
  1014 00000964 480F7EFF            <1> 	movq	rdi, mm7
  1015                              <1> ;	mov	rdi, qword ptr [rbp+CORE_INDEX1]
  1016 00000968 F68438E2060000C0    <1> 	test	byte ptr [rdi+rax+IO_PORT+_DEVICE+2], 192
  1017                              <1> 
  1018 00000970 58                  <1> 	pop	rax			; recover storage block index
  1019                              <1> 
  1020 00000971 7424                <1> 	jz	device_read_escape	; neither type flag set
  1021                              <1> 
  1022 00000973 9C                  <1> 	pushfq				; sign is set for descriptor bit 23	
  1023                              <1> 					; parity is set if both bits are
  1024                              <1> 
  1025                              <1> ;	mov	ch, byte ptr [rdi+PSR]	; flag field with byte options for memory read
  1026 00000974 480FB6F8            <1> 	movzx	rdi, al			; device select
  1027                              <1> 
  1028 00000978 30C0                <1> 	xor	al, al			; add storage block to offset
  1029 0000097A C1E008              <1> 	shl	eax, 8			; brush of bit 00400000 (now bit 01000000)
  1030 0000097D 48C1E002            <1> 	shl	rax, 10-8		; block index * 64 * 4 now times 262144
  1031 00000981 4801C6              <1> 	add	rsi, rax		; offset += <-
  1032                              <1> 
  1033                              <1> 
  1034 00000984 488BBC3F[00000000]  <1> 	mov	rdi,  qword ptr [_devices+rdi*2]	; rdi = device id * 4
  1035                              <1> 							; pointers in array are * 8 bytes
  1036                              <1> 
  1037                              <1> 					; known that one or two bits is set
  1038 0000098C 58                  <1> 	pop	rax			; flags from test of device	
  1039                              <1> 
  1040 0000098D A804                <1> 	test	al, 4			; parity flag?
  1041 0000098F 7560                <1> 	jnz	device_read_array24	; parity -> 2 bits set -> FSYS24 bus
  1042                              <1> 
  1043 00000991 A880                <1> 	test	al, 128			; sign -> descriptor bit 23 -> SYSMEM
  1044 00000993 7411                <1> 	jz	device_read_data16	; otherwise NET16 trunk
  1045 00000995 EB0A                <1> 	jmp	device_read_sysmem	; system memory type if yes				
  1046                              <1> 
  1047                              <1> device_read_escape:
  1048 00000997 B90E000000          <1> 	mov	ecx, LP_ADDRESS
  1049 0000099C E992070000          <1> 	jmp	guard_ii_escape
  1050                              <1> 
  1051                              <1> 
  1052                              <1> device_read_sysmem:			; readout system memory array
  1053 000009A1 E9CEFBFFFF          <1> 	jmp	memory_read_on		; allow all variations partial word / multiword
  1054                              <1> 
  1055                              <1> device_read_data16:			; readout 16-bit array
  1056                              <1> 
  1057 000009A6 80F907              <1> 	cmp	cl, 7
  1058 000009A9 7419                <1> 	jz	device_read_data16_4
  1059 000009AB 80F906              <1> 	cmp	cl, 6
  1060 000009AE 7407                <1> 	jz	device_read_data16_2
  1061                              <1> ;	jmp	device_read_data16_1
  1062                              <1> 
  1063                              <1> device_read_data16_1:			; readout 1 word of 16-bit array
  1064 000009B0 0FB70477            <1> 	movzx	eax, word ptr [rdi+rsi*2]
  1065 000009B4 86E0                <1> 	xchg	ah, al
  1066 000009B6 C3                  <1> 	ret
  1067                              <1> 
  1068                              <1> device_read_data16_2:			; readout 2 words of 16-bit array
  1069 000009B7 8B0477              <1> 	mov	eax, dword ptr [rdi+rsi*2]	; 4.3.2.1
  1070 000009BA 0FC8                <1> 	bswap	eax				; 1.2.3.4
  1071 000009BC 480FB7D8            <1> 	movzx	rbx, ax				; 0.0.3.4
  1072 000009C0 C1E810              <1> 	shr	eax, 16				; 0.0.1.2
  1073 000009C3 C3                  <1> 	ret
  1074                              <1> 
  1075                              <1> device_read_data16_4:			; readout 4 words of 16-bit array
  1076 000009C4 488B0477            <1> 	mov	rax, qword ptr [rdi+rsi*2]
  1077 000009C8 480FC8              <1> 	bswap	rax				; 1.2.3.4
  1078 000009CB 0FB7C8              <1> 	movzx	ecx, ax
  1079 000009CE 894C9D0C            <1> 	mov	dword ptr [rbp+rbx*4+12], ecx
  1080 000009D2 48C1E810            <1> 	shr	rax, 16
  1081 000009D6 0FB7C8              <1> 	movzx	ecx, ax
  1082 000009D9 894C9D08            <1> 	mov	dword ptr [rbp+rbx*4+8], ecx
  1083 000009DD 48C1E810            <1> 	shr	rax, 16
  1084 000009E1 0FB7C8              <1> 	movzx	ecx, ax
  1085 000009E4 48C1E810            <1> 	shr	rax, 16
  1086 000009E8 894C9D04            <1> 	mov	dword ptr [rbp+rbx*4+4], ecx
  1087 000009EC 89449D00            <1> 	mov	dword ptr [rbp+rbx*4], eax
  1088 000009F0 C3                  <1> 	ret
  1089                              <1> 
  1090                              <1> device_read_array24:			; readout from packed 24-bit array
  1091 000009F1 E846010000          <1> 	call	device_array24_setpointer
  1092                              <1> 
  1093 000009F6 80F907              <1> 	cmp	cl, 7
  1094 000009F9 7440                <1> 	jz	device_read_array24_4
  1095 000009FB 80F906              <1> 	cmp	cl, 6
  1096 000009FE 7430                <1> 	jz	device_read_array24_2
  1097                              <1> ;	jmp	device_read_array24_1
  1098                              <1> 
  1099                              <1> device_read_array24_1:			; readout a word of packed 24-bit array
  1100 00000A00 660FB60437          <1> 	movzx	ax, byte ptr [rdi+rsi]
  1101 00000A05 C1E008              <1> 	shl	eax, 8
  1102 00000A08 8A443701            <1> 	mov	al, byte ptr [rdi+rsi+1]
  1103 00000A0C C1E008              <1> 	shl	eax, 8
  1104 00000A0F 8A443702            <1> 	mov	al, byte ptr [rdi+rsi+2]
  1105 00000A13 4883C603            <1> 	add	rsi, 3
  1106 00000A17 C3                  <1> 	ret
  1107                              <1> 
  1108                              <1> device_read_array24_1R:
  1109 00000A18 660FB61C37          <1> 	movzx	bx, byte ptr [rdi+rsi]
  1110 00000A1D C1E308              <1> 	shl	ebx, 8
  1111 00000A20 8A5C3701            <1> 	mov	bl, byte ptr [rdi+rsi+1]
  1112 00000A24 C1E308              <1> 	shl	ebx, 8
  1113 00000A27 8A5C3702            <1> 	mov	bl, byte ptr [rdi+rsi+2]
  1114 00000A2B 4883C603            <1> 	add	rsi, 3
  1115 00000A2F C3                  <1> 	ret
  1116                              <1> 
  1117                              <1> device_read_array24_2:			; readout 2 words of packed 24-bit array
  1118 00000A30 E8CBFFFFFF          <1> 	call	device_read_array24_1
  1119 00000A35 E8DEFFFFFF          <1> 	call	device_read_array24_1R
  1120 00000A3A C3                  <1> 	ret
  1121                              <1> 
  1122                              <1> device_read_array24_4:			; readout 4 words of packed 24-bit array
  1123 00000A3B E8C0FFFFFF          <1> 	call	device_read_array24_1
  1124 00000A40 89449D00            <1> 	mov	dword ptr [rbp+rbx*4], eax
  1125 00000A44 E8B7FFFFFF          <1> 	call	device_read_array24_1
  1126 00000A49 89449D04            <1> 	mov	dword ptr [rbp+rbx*4+4], eax
  1127 00000A4D E8AEFFFFFF          <1> 	call	device_read_array24_1
  1128 00000A52 89449D08            <1> 	mov	dword ptr [rbp+rbx*4+8], eax
  1129 00000A56 E8A5FFFFFF          <1> 	call	device_read_array24_1
  1130 00000A5B 89449D0C            <1> 	mov	dword ptr [rbp+rbx*4+12], eax
  1131 00000A5F C3                  <1> 	ret
  1132                              <1> 
  1133                              <1> _device_write:				; store device arrays
  1134 00000A60 A900008000          <1> 	test	eax, 0800000h		; the vilainous bank index?
  1135 00000A65 7542                <1> 	jnz	device_write_escape
  1136                              <1> 
  1137                              <1>                                         ; edi -> core.REGISTER
  1138 00000A67 48C1E002            <1>         shl     rax, 2                  ; al is device index * 4
  1139 00000A6B 50                  <1>         push    rax                     ; rest of eax is block index * 4
  1140 00000A6C 480FB6C0            <1>         movzx   rax, al                 ; extend device number
  1141                              <1>                                         ; sense device descriptor
  1142 00000A70 480F7EFF            <1> 	movq	rdi, mm7
  1143                              <1> ;	mov	rdi, qword ptr [rbp+CORE_INDEX1]
  1144 00000A74 F68438E2060000C0    <1>         test    byte ptr [rdi+rax+IO_PORT+_DEVICE+2], 192
  1145                              <1> 
  1146 00000A7C 58                  <1>         pop     rax                     ; recover storage block index
  1147                              <1> 
  1148 00000A7D 742A                <1>         jz      device_write_escape      ; neither type flag set
  1149                              <1> 
  1150 00000A7F 9C                  <1>         pushfq                          ; sign is set for descriptor bit 23     
  1151                              <1>                                         ; parity is set if both bits are
  1152                              <1> 
  1153 00000A80 8AAFB0040000        <1>         mov     ch, byte ptr [rdi+PSR]  ; flag field with byte options for memory read
  1154 00000A86 480FB6F8            <1>         movzx   rdi, al                 ; device select
  1155                              <1> 
  1156 00000A8A 30C0                <1>         xor     al, al                  ; add storage block to offset
  1157 00000A8C C1E008              <1> 	shl	eax, 8			; brush off bit 00400000 (now bit 01000000)
  1158 00000A8F 48C1E002            <1>         shl     rax, 10-8		; block index * 64 * 4 now times 262144
  1159 00000A93 4801C6              <1>         add     rsi, rax                ; offset += <-
  1160                              <1> 
  1161 00000A96 488BBC3F[00000000]  <1>         mov     rdi,  qword ptr [_devices+rdi*2]	; rdi = device id * 4
  1162                              <1> 							; pointers in array are * 8 octets
  1163                              <1> 
  1164                              <1>                                         ; known that one or two bits is set
  1165 00000A9E 58                  <1>         pop     rax                     ; flags from test of device     
  1166                              <1> 
  1167 00000A9F A804                <1>         test    al, 4                   ; parity?
  1168 00000AA1 754C                <1>         jnz     device_write_array24    ; parity -> 2 bits set -> FSYS24 bus
  1169 00000AA3 A880                <1>         test    al, 128                 ; sign -> descriptor bit 23 -> SYSMEM
  1170 00000AA5 7411                <1>         jz      device_write_data16     ; otherwise NET16 trunk
  1171 00000AA7 EB0A                <1>         jmp     device_write_sysmem     ; system memory type if yes                     
  1172                              <1> 
  1173                              <1> 
  1174                              <1> device_write_escape:
  1175 00000AA9 B90E000000          <1> 	mov	ecx, LP_ADDRESS
  1176 00000AAE E980060000          <1> 	jmp	guard_ii_escape
  1177                              <1> 
  1178                              <1> 
  1179                              <1> device_write_sysmem:
  1180 00000AB3 E99CFCFFFF          <1> 	jmp	memory_write_on		; allow all variations partial word / multiword
  1181                              <1> 
  1182                              <1> 
  1183                              <1> device_write_data16:
  1184                              <1> 
  1185 00000AB8 80F907              <1> 	cmp	cl, 7
  1186 00000ABB 740C                <1> 	jz	device_write_data16_4
  1187 00000ABD 80F906              <1> 	cmp	cl, 6
  1188 00000AC0 741A                <1> 	jz	device_write_data16_2
  1189                              <1> ;	jmp	device_write_data16_1
  1190                              <1> 
  1191                              <1> 	%if	__MOVBE
  1192                              <1> 
  1193                              <1> 	movbe	word ptr [rdi+rsi*2], bx
  1194                              <1> 	ret
  1195                              <1> 
  1196                              <1> device_write_data16_2:
  1197                              <1> 	mov	ax, word ptr [rbp+rbx*4]
  1198                              <1> 	shl	eax, 16
  1199                              <1> 	mov	ax, word ptr [rbp+rbx*4+4]
  1200                              <1> 	movbe	dword ptr [rdi+rsi*2], ax
  1201                              <1> 	
  1202                              <1> 	ret
  1203                              <1> 
  1204                              <1> device_write_data16_4:
  1205                              <1> 	mov	ax, word ptr [rbp+rbx*4]
  1206                              <1> 	shl	rax, 16
  1207                              <1> 	mov	ax, word ptr [rbp+rbx*4+4]
  1208                              <1> 	shl	rax, 16
  1209                              <1> 	mov	ax, word ptr [rbp+rbx*4+4*2]
  1210                              <1> 	shl	rax, 16
  1211                              <1> 	mov	ax, word ptr [rbp+rbx*4+4*3]
  1212                              <1> 	movbe	qword ptr [rdi+rsi*2], rax
  1213                              <1> 	ret
  1214                              <1> 
  1215                              <1> 	%else
  1216                              <1> 
  1217                              <1> device_write_data16_1:			; store 16-bit array
  1218 00000AC2 86FB                <1> 	xchg	bh, bl
  1219 00000AC4 66891C77            <1> 	mov	word ptr [rdi+rsi*2], bx
  1220 00000AC8 C3                  <1> 	ret
  1221                              <1> 
  1222                              <1> 
  1223                              <1> device_write_data16_4:			; store 4 words in 16-bit array
  1224                              <1> 					; low-order half is swapped on bus read
  1225                              <1> 					; and canonical in eax
  1226 00000AC9 668B449D08          <1> 	mov	ax, word ptr [rbp+rbx*4+8]	; get low-order half 3rd register
  1227 00000ACE C1E010              <1> 	shl	eax, 16				; 5.6.0.0
  1228 00000AD1 668B449D0C          <1> 	mov	ax, word ptr [rbp+rbx*4+12]	; 5.6.7.8
  1229 00000AD6 0FC8                <1> 	bswap	eax				; it's correct so swap for bus write
  1230 00000AD8 89447704            <1> 	mov	dword ptr [rdi+rsi*2+4], eax
  1231                              <1> 
  1232                              <1> 
  1233                              <1> device_write_data16_2:			; store 2 words in 16-bit array
  1234                              <1> 					; registers are modeled in storage
  1235                              <1> 					; so each bus read corrects an octet pair
  1236                              <1> 
  1237 00000ADC 668B449D00          <1> 	mov	ax, word ptr [rbp+rbx*4]	; get low-order half 1st register
  1238 00000AE1 C1E010              <1> 	shl	eax, 16				; 1.2.0.0
  1239 00000AE4 668B449D04          <1> 	mov	ax, word ptr [rbp+rbx*4+4]	; 1.2.3.4
  1240 00000AE9 0FC8                <1> 	bswap	eax				; it's correct, so swap for bus write
  1241 00000AEB 890477              <1> 	mov	dword ptr [rdi+rsi*2], eax
  1242 00000AEE C3                  <1> 	ret
  1243                              <1> 
  1244                              <1> 	%endif
  1245                              <1> 
  1246                              <1> device_write_array24:			; store 24-bit packed array
  1247 00000AEF E848000000          <1> 	call	device_array24_setpointer
  1248                              <1> 
  1249 00000AF4 80F907              <1> 	cmp	cl, 7
  1250 00000AF7 7435                <1> 	jz	device_write_array24_4
  1251 00000AF9 80F906              <1> 	cmp	cl, 6
  1252 00000AFC 741D                <1> 	jz	device_write_array24_2
  1253 00000AFE EB00                <1> 	jmp	device_write_array24_1
  1254                              <1> 
  1255                              <1> device_write_array24_1:			; store 1 word in packed 24-bit array
  1256 00000B00 89D8                <1> 	mov	eax, ebx
  1257                              <1> device_write_array24_x:
  1258 00000B02 C1C010              <1> 	rol	eax, 16
  1259 00000B05 880437              <1> 	mov	byte ptr [rdi+rsi], al
  1260 00000B08 C1C008              <1> 	rol	eax, 8
  1261 00000B0B 88443701            <1> 	mov	byte ptr [rdi+rsi+1], al
  1262 00000B0F C1C008              <1> 	rol	eax, 8
  1263 00000B12 88443702            <1> 	mov	byte ptr [rdi+rsi+2], al
  1264 00000B16 4883C603            <1> 	add	rsi, 3
  1265 00000B1A C3                  <1> 	ret
  1266                              <1> 
  1267                              <1> device_write_array24_2:			; store 2 words in packed 24-bit array
  1268 00000B1B 8B449D00            <1> 	mov	eax, [rbp+rbx*4]
  1269 00000B1F E8DEFFFFFF          <1> 	call	device_write_array24_x
  1270 00000B24 8B449D04            <1> 	mov	eax, [rbp+rbx*4+4]
  1271 00000B28 E8D5FFFFFF          <1> 	call	device_write_array24_x
  1272                              <1> ;	add	ebx, 2
  1273 00000B2D C3                  <1> 	ret
  1274                              <1> 
  1275                              <1> device_write_array24_4:			; store 4 words in packed 24-bit array
  1276 00000B2E E8E8FFFFFF          <1> 	call	device_write_array24_2
  1277 00000B33 83C302              <1> 	add	ebx, 2
  1278 00000B36 E8E0FFFFFF          <1> 	call	device_write_array24_2
  1279 00000B3B C3                  <1> 	ret
  1280                              <1> 
  1281                              <1> device_array24_setpointer:
  1282 00000B3C 4889F0              <1> 	mov	rax, rsi			; think of a number
  1283 00000B3F 48D1E0              <1> 	shl	rax, 1				; double it
  1284 00000B42 4801C6              <1> 	add	rsi, rax			; add it to the number you first thought of...
  1285 00000B45 C3                  <1> 	ret
  1286                              <1> 
    32                                  	%include	"base_map.msm"
     1                              <1> 
     2                              <1> base_read_pointer:
     3 00000B46 4889C7              <1> 	mov	rdi, rax		; keep EA for +words reads
     4                              <1> 					; straddling storage blocks
     5 00000B49 C1C910              <1> 	ror	ecx, 16			; conserve designator / word counts
     6                              <1> 
     7 00000B4C C1C812              <1> 	ror	eax, 18
     8 00000B4F A83F                <1> 	test	al, 63
     9 00000B51 750C                <1> 	jnz	read_address18
    10 00000B53 C1C006              <1> 	rol	eax, 6
    11 00000B56 660FB6C8            <1> 	movzx	cx, al
    12 00000B5A C1E814              <1> 	shr	eax, 32-12
    13                              <1> 					; advise caller address 6.12
    14 00000B5D EB07                <1> 	jmp	resolve_read_tag	; this path is  most storage reads
    15                              <1> 	
    16                              <1> read_address18:
    17 00000B5F 660FB6C8            <1> 	movzx	cx, al
    18 00000B63 C1E80E              <1> 	shr	eax, 32-18
    19                              <1> 
    20                              <1> resolve_read_tag:
    21                              <1> 
    22 00000B66 80E13F              <1> 	and	cl, 63
    23 00000B69 7418                <1> 	jz	read_window_free	; everyone may read B0
    24 00000B6B F6C138              <1> 	test	cl, 56
    25 00000B6E 7513                <1> 	jnz	read_window_free
    26 00000B70 80F10F              <1> 	xor	cl, 8+7			; [ 1 2 3 4 5 6 7 ] -> 8 + [ 6 5 4 3 2 1 0]
    27 00000B73 660FA38EB0040000    <1> 	bt	word ptr [rsi+PSR], cx	; in memory bytes ffff f00c 0xxx xxxx
    28 00000B7B 7303                <1> 	jnc	read_application_window	; x86 bus read -> 0xxx xxxx ffff f00c
    29 00000B7D 80C940              <1> 	or	cl, 64
    30                              <1> 
    31                              <1> read_application_window:
    32 00000B80 80F10F              <1> 	xor	cl, 8+7			; [ 1 2 3 4 5 6 7 ] <- 8 + [ 6 5 4 3 2 1 0]
    33                              <1> 
    34                              <1> read_window_free:
    35 00000B83 4889C2              <1> 	mov	rdx,rax
    36 00000B86 480FB6C1            <1> 	movzx	rax, cl
    37 00000B8A 8B8486E0040000      <1> 	mov	eax, dword ptr [rsi+rax*4+IO_PORT]
    38 00000B91 4889D6              <1> 	mov	rsi, rdx
    39                              <1> 
    40 00000B94 C1C910              <1> 	ror	ecx, 16
    41 00000B97 C3                  <1> 	ret
    42                              <1> 
    43                              <1> base_write_pointer:
    44                              <1> 
    45 00000B98 4889C7              <1> 	mov	rdi, rax		; keep EA for +words writes
    46 00000B9B C1C910              <1> 	ror	ecx, 16			; straddling storage blocks
    47                              <1> 					; protect designators in ecx
    48 00000B9E C1C812              <1> 	ror	eax, 18			
    49                              <1> 
    50 00000BA1 A83F                <1> 	test	al, 63
    51 00000BA3 750C                <1> 	jnz	write_address18
    52 00000BA5 C1C006              <1> 	rol	eax, 6
    53 00000BA8 660FB6C8            <1> 	movzx	cx, al
    54 00000BAC C1E814              <1> 	shr	eax, 32-12
    55 00000BAF EB07                <1> 	jmp	resolve_write_tag	; this path is
    56                              <1> 					; most storge writes
    57                              <1> write_address18:
    58 00000BB1 660FB6C8            <1> 	movzx	cx, al
    59 00000BB5 C1E80E              <1> 	shr	eax, 32-18
    60                              <1> 	
    61                              <1> resolve_write_tag:
    62                              <1> 
    63 00000BB8 80E13F              <1> 	and	cl, 63
    64 00000BBB 0F846D050000        <1> 	jz	near guard_ii_authority	; no-one may write B0
    65 00000BC1 F6C138              <1> 	test	cl, 56
    66 00000BC4 7538                <1> 	jnz	write_window_free
    67 00000BC6 80F10F              <1> 	xor	cl, 8+7			; [ 1 2 3 4 5 6 7 ] -> 8 + [ 6 5 4 3 2 1 0]
    68 00000BC9 660FA38EB0040000    <1> 	bt	word ptr [rsi+PSR], cx		; in memory bytes ffff f00c 0xxx xxxx
    69 00000BD1 7313                <1> 	jnc	write_application_window	; x86 bus read -> 0xxx xxxx ffff f00c
    70 00000BD3 F786B0040000000080- <1> 	test	dword ptr [rsi+PSR], 00800000h 
    70 00000BDC 00                  <1>
    71 00000BDD 0F844B050000        <1> 	jz	near guard_ii_authority
    72 00000BE3 80C940              <1> 	or	cl, 64
    73                              <1> 
    74                              <1> write_application_window:
    75 00000BE6 80F10F              <1> 	xor	cl, 8+7			; [ 1 2 3 4 5 6 7 ] <- 8 + [ 6 5 4 3 2 1 0]
    76                              <1> 
    77                              <1> write_window_known:
    78 00000BE9 80F902              <1> 	cmp	cl, 2			; application dnw vector page
    79 00000BEC 7510                <1> 	jnz	write_window_free
    80 00000BEE F786B0040000000080- <1> 	test	dword ptr [rsi+PSR], 00800000h			; ISR ?
    80 00000BF7 00                  <1>
    81 00000BF8 0F8430050000        <1> 	jz	near guard_ii_authority		; the unbalanced push is harmless
    82                              <1> 						; stack is reset on faults
    83                              <1> write_window_free:
    84 00000BFE 4889C2              <1> 	mov	rdx, rax
    85 00000C01 480FB6C1            <1> 	movzx	rax, cl
    86 00000C05 8B8486E0040000      <1> 	mov	eax, dword ptr [rsi+rax*4+IO_PORT]
    87 00000C0C 4889D6              <1> 	mov	rsi, rdx
    88                              <1> 
    89 00000C0F C1C910              <1> 	ror	ecx, 16		; restore designator information
    90 00000C12 C3                  <1> 	ret
    91                              <1> 
    33                                  	%include	"sr.msm"
     1                              <1> 
     2                              <1> ;	read staging register
     3                              <1> ;	read bits from a stream of bits
     4                              <1> 
     5 00000C13 8B4E50              <1> _rsr:	mov	ecx, dword ptr [rsi+RDATAC]
     6 00000C16 88CD                <1> 	mov	ch, cl
     7 00000C18 88C1                <1> 	mov	cl, al
     8                              <1> 
     9 00000C1A 31C0                <1> 	xor	eax, eax
    10 00000C1C F786B0040000400000- <1> 	test	dword ptr [rsi+PSR], B_STREAMZR
    10 00000C25 00                  <1>
    11 00000C26 7503                <1> 	jnz	_rsr_zadd
    12 00000C28 8B4510              <1> 	mov	eax, dword ptr [rbp+A]
    13                              <1> _rsr_zadd:
    14 00000C2B 20C9                <1> 	and	cl, cl
    15 00000C2D 7451                <1> 	jz	_rsr_x
    16 00000C2F 8B5E54              <1> 	mov	ebx, dword ptr [rsi+RDATA]
    17                              <1> 
    18 00000C32 20ED                <1> 	and	ch, ch			; any data loaded yet?
    19 00000C34 740F                <1> 	jz	_rsr_read		; if not read first no question 
    20 00000C36 38CD                <1> 	cmp	ch, cl			; otherwise, already enough for request?
    21 00000C38 7331                <1> 	jnb	_rsr_draw		; if so deliver data
    22 00000C3A 28E9                <1> 	sub	cl, ch			; if not trim the oustanding count
    23 00000C3C 86CD                <1> 	xchg	cl, ch			
    24 00000C3E E85B0F0000          <1> 	call	dsl			; and deliver available data
    25 00000C43 86E9                <1> 	xchg	ch, cl			; before reading some more
    26                              <1> _rsr_read:
    27 00000C45 E896000000          <1> 	call	stream_read
    28                              <1> 
    29 00000C4A 480F7EFE            <1> 	movq	rsi, mm7
    30                              <1> ;	mov	rsi, qword ptr [rbp+CORE_INDEX1]	; after call to operand_read
    31                              <1> 
    32 00000C4E C7465018000000      <1> 	mov	dword ptr [rsi+RDATAC], 24
    33 00000C55 F786B0040000200000- <1> 	test	dword ptr [rsi+PSR], B_STREAM16R
    33 00000C5E 00                  <1>
    34 00000C5F 740A                <1> 	jz	_rsr_draw
    35 00000C61 C7465010000000      <1> 	mov	dword ptr [rsi+RDATAC], 16
    36 00000C68 C1E308              <1> 	shl	ebx, 8
    37                              <1> _rsr_draw:
    38 00000C6B 6651                <1> 	push	cx
    39 00000C6D E82C0F0000          <1> 	call	dsl
    40 00000C72 6659                <1> 	pop	cx
    41 00000C74 81E1FF000000        <1> 	and	ecx, 255
    42 00000C7A 294E50              <1> 	sub	dword ptr [rsi+RDATAC], ecx
    43 00000C7D 895E54              <1> 	mov	dword ptr [rsi+RDATA], ebx
    44                              <1> _rsr_x:
    45 00000C80 894510              <1> 	mov	dword ptr [rbp+A], eax
    46 00000C83 C3                  <1> 	ret
    47                              <1> 
    48                              <1> 
    49                              <1> ;	write staging register
    50                              <1> ;	write bits to a stream of bits
    51                              <1> 
    52 00000C84 8B4E58              <1> _wsr:	mov	ecx, dword ptr [rsi+WDATAC]
    53 00000C87 88CD                <1> 	mov	ch, cl					; accumulated count
    54 00000C89 88C1                <1> 	mov	cl, al					; new request
    55                              <1> 
    56 00000C8B 8B465C              <1> 	mov	eax, dword ptr [rsi+WDATA]	; accumulated data
    57 00000C8E 8B5D10              <1> 	mov	ebx, dword ptr [rbp+A]		; source new data
    58                              <1> 
    59 00000C91 80C5E8              <1> 	add	ch, -24				; space for new data expressed negative
    60 00000C94 F786B0040000100000- <1> 	test	dword ptr [rsi+PSR], B_STREAM16W	; 16 bits / word flag
    60 00000C9D 00                  <1>
    61 00000C9E 7403                <1> 	jz	_wsr24
    62 00000CA0 80C508              <1> 	add	ch, 8
    63                              <1> 
    64 00000CA3 00CD                <1> _wsr24:	add	ch, cl			; increment towards zero
    65 00000CA5 7404                <1> 	jz	_wsr_write		; accumulated word exactly full
    66 00000CA7 731E                <1> 	jnc	_wsr_add		; not yet full
    67                              <1> 
    68 00000CA9 28E9                <1> 	sub	cl, ch			; full + some more
    69                              <1> 
    70                              <1> _wsr_write:
    71 00000CAB E8EE0E0000          <1> 	call	dsl			; fill output word
    72 00000CB0 88E9                <1> 	mov	cl, ch			; position outstanding count
    73 00000CB2 E83E000000          <1> 	call	stream_write
    74                              <1> 
    75 00000CB7 480F7EFE            <1> 	movq	rsi, mm7
    76                              <1> ;	mov	esi, dword ptr [rbp+CORE_INDEX1]	; after call to operand_write
    77 00000CBB B800000000          <1> 	mov	eax, 0
    78 00000CC0 C7465800000000      <1> 	mov	dword ptr [rsi+REGISTER+WDATAC], 0
    79                              <1> 
    80                              <1> _wsr_add:
    81 00000CC7 6651                <1> 	push	cx
    82 00000CC9 E8D00E0000          <1> 	call	dsl			; add to output word
    83 00000CCE 6659                <1> 	pop	cx
    84 00000CD0 81E1FF000000        <1> 	and	ecx, 255		; format ecx for add to accumulated count 
    85 00000CD6 014E58              <1> 	add	dword ptr [rsi+REGISTER+WDATAC], ecx
    86 00000CD9 89465C              <1> 	mov	dword ptr [rsi+REGISTER+WDATA], eax
    87 00000CDC 895D10              <1> 	mov	dword ptr [rbp+A], ebx
    88 00000CDF C3                  <1> 	ret
    89                              <1> 
    90                              <1> stream_read:
    91 00000CE0 51                  <1> 	push	rcx
    92 00000CE1 50                  <1> 	push	rax
    93 00000CE2 8B4534              <1> 	mov	eax, dword ptr [rbp+Q]
    94 00000CE5 83453401            <1> 	add	dword ptr [rbp+Q], 1
    95 00000CE9 30C9                <1> 	xor	cl, cl
    96 00000CEB E80AF8FFFF          <1> 	call	_operand_read
    97 00000CF0 89C3                <1> 	mov	ebx, eax
    98 00000CF2 58                  <1> 	pop	rax
    99 00000CF3 59                  <1> 	pop	rcx
   100 00000CF4 C3                  <1> 	ret
   101                              <1> 
   102                              <1> stream_write:
   103 00000CF5 51                  <1> 	push	rcx
   104 00000CF6 53                  <1> 	push	rbx
   105 00000CF7 89C3                <1> 	mov	ebx, eax
   106 00000CF9 8B4530              <1> 	mov	eax, dword ptr [rbp+P]
   107 00000CFC 83453001            <1> 	add	dword ptr [rbp+P], 1
   108 00000D00 30C9                <1> 	xor	cl, cl
   109 00000D02 E8B6F9FFFF          <1> 	call	_operand_write
   110 00000D07 5B                  <1> 	pop	rbx
   111 00000D08 59                  <1> 	pop	rcx
   112 00000D09 C3                  <1> 	ret
   113                              <1> 
    34                                  	%include	"io.msm"
     1 00000D0A 8B9C86E0040000      <1> _inA:	mov	ebx, dword ptr [rsi+IO_PORT+rax*4]	; a <- port[ea]
     2 00000D11 895D10              <1> 	mov	dword ptr [rbp+A], ebx
     3 00000D14 C3                  <1> _inA_:	ret
     4                              <1> 
     5 00000D15 8B9C86E0040000      <1> _inB:	mov	ebx, dword ptr [rsi+IO_PORT+rax*4]	; b <- port[ea]
     6 00000D1C 895D14              <1> 	mov	dword ptr [rbp+B], ebx
     7 00000D1F C3                  <1> _inB_:	ret
     8                              <1> 
     9 00000D20 8B5D10              <1> _outA:	mov	ebx, dword ptr [rbp+A]			; a -> port[ea]
    10 00000D23 E9C3010000          <1> 	jmp	oport
    11                              <1> 
    12 00000D28 8B5D14              <1> _outB:	mov	ebx, dword ptr [rbp+B]			; b -> port[ea]
    13 00000D2B E9BB010000          <1> 	jmp	oport
    14                              <1> 
    15                              <1> 
    16                              <1> ISR_ONLY equ	8
    17                              <1> MEMTYPE	equ	1
    18                              <1> MEMZERONLY equ	2
    19                              <1> EXTERNAL_IO equ	4
    20                              <1> BROADCAST equ	16
    21                              <1> 
    22                              <1> B_1	equ	MEMTYPE
    23                              <1> B_TCB	equ	MEMTYPE+ISR_ONLY
    24                              <1> B_KERN	equ	MEMTYPE+ISR_ONLY
    25                              <1> A_THREP	equ	MEMZERONLY+ISR_ONLY
    26                              <1> I_PORT	equ	EXTERNAL_IO
    27                              <1> O_PORT	equ	EXTERNAL_IO
    28                              <1> O_INDICA equ	EXTERNAL_IO
    29                              <1> O_CHILL	equ	EXTERNAL_IO
    30                              <1> I_TZONE	equ	EXTERNAL_IO
    31                              <1> RAM_THRESH equ	ISR_ONLY+MEMZERONLY
    32                              <1> XI_ACK	equ	ISR_ONLY+EXTERNAL_IO
    33                              <1> O_LEDS	equ	EXTERNAL_IO
    34                              <1> O_SYSSWCH equ	EXTERNAL_IO
    35                              <1> O_INC	equ	ISR_ONLY+EXTERNAL_IO
    36                              <1> O_MCAST	equ	ISR_ONLY+BROADCAST
    37                              <1> 
    38                              <1> 
    39                              <1> mask_port_outAB:
    40 00000D30 000100000000000000- <1> 	db    0,B_1,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    40 00000D39 00000000000000      <1>
    41 00000D40 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    41 00000D49 00000000000000      <1>
    42                              <1> 
    43 00000D50 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    43 00000D59 00000000000000      <1>
    44 00000D60 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    44 00000D69 00000000000000      <1>
    45                              <1> 
    46 00000D70 0009090909090909    <1> 	db	0,B_TCB,B_KERN,B_KERN,  B_KERN,B_KERN,B_KERN,B_KERN
    47 00000D78 0A00000C0C000018    <1> 	db	A_THREP,0,0,XI_ACK,     O_INC,0,0,O_MCAST
    48                              <1> 
    49 00000D80 0404040404040404    <1> 	db	I_PORT,I_PORT,I_PORT,I_PORT,  I_PORT,I_PORT,I_PORT,I_PORT
    50 00000D88 0404040404040404    <1> 	db	O_PORT,O_PORT,O_PORT,O_PORT,  O_PORT,O_PORT,O_PORT,O_PORT
    51                              <1> 
    52 00000D90 0000000000040404    <1> 	db	0,0,0,0,  0,I_TZONE,O_INDICA,O_CHILL
    53 00000D98 0000000000000000    <1> 	db	0,0,0,0,  0,0,0,0
    54 00000DA0 0000000000000000    <1> 	db	0,0,0,0,  0,0,0,0
    55 00000DA8 0000000000000404    <1> 	db	0,0,0,0,  0,0,O_SYSSWCH,O_LEDS
    56                              <1> 
    57 00000DB0 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    57 00000DB9 00000000000000      <1>
    58 00000DC0 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    58 00000DC9 00000000000000      <1>
    59 00000DD0 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    59 00000DD9 00000000000000      <1>
    60 00000DE0 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
    60 00000DE9 00000000000000      <1>
    61                              <1> 
    62                              <1> 					; outA|B rules flags per I/O port
    63                              <1> 
    64                              <1> _reload:
    65 00000DF0 50                  <1> 	push	rax
    66 00000DF1 8B4510              <1> 	mov	eax, dword ptr [rbp+A]
    67 00000DF4 83451002            <1> 	add	dword ptr [rbp+A], 2
    68 00000DF8 E8BBF6FFFF          <1> 	call	_burst_read2
    69 00000DFD 5F                  <1> 	pop	rdi
    70                              <1> 
    71 00000DFE 480F7EFE            <1> 	movq	rsi, mm7
    72                              <1> ;	mov	rsi, qword ptr [rbp+CORE_INDEX1]
    73                              <1> 
    74 00000E02 8984BEE0040000      <1> 	mov	dword ptr [rsi+IO_PORT+rdi*4], eax
    75 00000E09 899CBEE4040000      <1> 	mov	dword ptr [rsi+IO_PORT+rdi*4+4], ebx
    76 00000E10 C3                  <1> 	ret
    35                                  	%include	"sabr.msm"
     1                              <1> ;	check and write to I/O port <- storage base index in range [ 2..63 ]
     2                              <1> ;	write a copy to reload base table in thread control block
     3                              <1> ;	values out of memory range are replaced with trap device C00001
     4                              <1> ;	which causes GUARD$ exception if the sindow is accessed
     5                              <1> 
     6                              <1> ;	anauthorised actions
     7                              <1> ;
     8                              <1> ;		attempt to write window base < 2 or > 63
     9                              <1> ;		application selecting ISR space
    10                              <1> ;		application selecting NVRAM
    11                              <1> ;
    12                              <1> ;	are not carried out and a GUARD$ exception is raised
    13                              <1> ;	ISRs write the trap device C00001 to close memory windows
    14                              <1> 
    15                              <1> _sabr_guard:
    16 00000E11 E918030000          <1> 	jmp	guard_ii_authority
    17                              <1> 
    18 00000E16 A93E000000          <1> _sabr:	test	eax, 03Eh		; ea not < 2
    19 00000E1B 74F4                <1> 	jz	_sabr_guard
    20 00000E1D A9C0FFFF00          <1> 	test	eax, 0FFFFC0h		; ea not > 63
    21 00000E22 75ED                <1> 	jnz	_sabr_guard
    22                              <1> 
    23 00000E24 8B4D10              <1> 	mov	ecx, dword ptr [rbp+A]
    24                              <1> 
    25 00000E27 F7C100004000        <1> 	test	ecx, 00400000h
    26 00000E2D 746C                <1> 	jz	memory_page
    27 00000E2F F7C13F000000        <1> 	test	ecx, 63
    28 00000E35 745E                <1> 	jz	large_memory_page
    29                              <1> 
    30 00000E37 F7C100008000        <1> 	test	ecx, 00800000h
    31 00000E3D 740E                <1> 	jz	array_attribute
    32                              <1> 
    33 00000E3F F786B0040000000080- <1> 	test	dword ptr [rsi+PSR], 0800000h
    33 00000E48 00                  <1>
    34 00000E49 74C6                <1> 	jz	_sabr_guard
    35 00000E4B EB76                <1> 	jmp	unthru			; ISR write illegal device thru
    36                              <1> 					; closes the address space window
    37                              <1> 
    38                              <1> 					; application may not write device
    39                              <1> 					; but may zero -> sabr  with same effect
    40                              <1> array_attribute:
    41                              <1> 
    42 00000E4D 48C1E102            <1> 	shl	rcx, 2
    43 00000E51 480FB6D9            <1> 	movzx	rbx, cl			; cl = device * 4
    44                              <1> 
    45 00000E55 8B9C33E0060000      <1> 	mov	ebx, dword ptr [rsi+rbx+IO_PORT+_DEVICE]
    46                              <1> 					; platform address + device descriptor
    47                              <1> 
    48                              <1> 
    49                              <1> 	%if	0
    50                              <1> 	mov	dword ptr [rsi+eax*8+DATAFRAME], rbx	; rapid recall
    51                              <1> 	mov	dword ptr [rsi+eax*8+DATAFRAME+4], rdi	; device information
    52                              <1> 	%endif						; via window tag
    53                              <1> 
    54 00000E5C 48C1E908            <1> 	shr	rcx, 6+2		; lose previous shift + device code
    55 00000E60 F7C300004000        <1> 	test	ebx, 00400000h
    56 00000E66 750A                <1> 	jnz	peripheral_array
    57 00000E68 F7C300008000        <1> 	test	ebx, 00800000h
    58 00000E6E 7520                <1> 	jnz	memory_array
    59                              <1> 
    60 00000E70 EB9F                <1> 	jmp	_sabr_guard		; no device code
    61                              <1> 
    62                              <1> peripheral_array:			; device types 00C00000 00400000
    63 00000E72 F786B0040000000080- <1> 	test	dword ptr [rsi+PSR], 00800000h
    63 00000E7B 00                  <1>
    64 00000E7C 7493                <1> 	jz	_sabr_guard
    65                              <1> 
    66 00000E7E 81E1FFFF0000        <1> 	and	ecx, 0000FFFFh		; have # large blocks in low 16 bits
    67 00000E84 81E3FFFF0000        <1> 	and	ebx, 0000FFFFh
    68 00000E8A 29CB                <1> 	sub	ebx, ecx
    69 00000E8C 7932                <1> 	jns	thru
    70 00000E8E EB29                <1> 	jmp	_sabr_safeguard
    71                              <1> 
    72                              <1> memory_array:
    73 00000E90 C1E106              <1> 	shl	ecx, 6			; block * 64
    74 00000E93 EB14                <1> 	jmp	memory_array_bound?
    75                              <1> 
    76                              <1> large_memory_page:
    77 00000E95 81E1FFFFBF00        <1> 	and	ecx, 00BFFFFFh		; remove 00400000 bit for lower bound check
    78                              <1> 
    79                              <1> memory_page:
    80 00000E9B 8B9EE0060000        <1> 	mov	ebx, dword ptr [rsi+IO_PORT+_DEVICE]	; device zero memory attribute
    81 00000EA1 3B8E00060000        <1> 	cmp	ecx, dword ptr [rsi+IO_PORT+_APP_THRESHOLD]	; ISR / application boundary
    82 00000EA7 7210                <1> 	jb	_sabr_safeguard
    83                              <1> 
    84                              <1> memory_array_bound?:
    85 00000EA9 81E1FFFFBF00        <1> 	and	ecx, 00BFFFFFh		; bit 00800000 is a bad accident
    86 00000EAF 81E3FFFF3F00        <1> 	and	ebx, 003FFFFFh		; stop it here
    87 00000EB5 29CB                <1> 	sub	ebx, ecx
    88 00000EB7 7907                <1> 	jns	thru
    89                              <1> 
    90                              <1> _sabr_safeguard:
    91 00000EB9 B90100C000          <1> 	mov	ecx, 00C00001h
    92 00000EBE EB03                <1> 	jmp	unthru
    93                              <1> 
    94 00000EC0 8B4D10              <1> thru:	mov	ecx, dword ptr [rbp+A]		; i.e. correct as supplied
    95 00000EC3 898C86E0040000      <1> unthru:	mov	dword ptr [rsi+rax*4+IO_PORT], ecx
    96                              <1> 
    97 00000ECA 48BF-               <1> 	mov	rdi, _memory
    97 00000ECC [0000000000000000]  <1>
    98 00000ED4 8B9EE4050000        <1> 	mov	ebx, dword ptr [rsi+IO_PORT+65*4] ; thread control block
    99                              <1> 
   100 00000EDA 48C1E30C            <1> 	shl	rbx, 12			; multiply to TCB size
   101 00000EDE 4801C3              <1> 	add	rbx, rax		; ea is target base index
   102 00000EE1 0FC9                <1> 	bswap	ecx			; for this is a big endian memory write
   103 00000EE3 898C9F00010000      <1> 	mov	dword ptr [rdi+rbx*4+64*4], ecx
   104 00000EEA C3                  <1> 	ret				; save TCB reload copy of loaded pointer
    36                                  	%include	"oport.msm"
     1                              <1> 
     2                              <1> OOO_TRACE	equ	0
     3                              <1> 
     4                              <1> 							; static void oport(int ea, int value, smp *xcore)
     5                              <1> 							; {
     6                              <1> oport:		; write I / O port			;    int		 rule,
     7                              <1> 		; RTA instructions outA outB		;			 device;
     8                              <1> 							; 
     9                              <1> 		; ports which are memory pointers	;    int		 mask,
    10                              <1> 		; must have a block that exists		;			 from,
    11                              <1> 		; ISRs can write trap value C00001 	;                 	 index;
    12                              <1> 		; = device 400001 | illegal 800000	; 
    13                              <1> 		; port # = effective address = eax	;    int		 device_index = 0;
    14                              <1> 		; write value in ebx			; 
    15                              <1> 		; multicast bits in RTA register k	;    smp		*ascor;
    16                              <1> 		 					;    unsigned	*register_set = xcore->register_set;
    17                              <1> 
    18 00000EEB 3DC0000000          <1> 	cmp	eax, IO_PORTS				; 
    19 00000EF0 0F839A000000        <1> 	jnb	near no_port				;    if (ea < IO_PORTS)
    20                              <1> 							;    {
    21 00000EF6 8A88[300D0000]      <1> 	mov	cl, byte ptr [rax+mask_port_outAB]	;       rule = mask_port_outAB[ea];
    22 00000EFC 20C9                <1> 	and	cl, cl					; 
    23 00000EFE 0F848C000000        <1> 	jz	near no_rule				;       if (rule)
    24 00000F04 F6C108              <1> 	test	cl, ISR_ONLY				;       {
    25 00000F07 7410                <1> 	jz	application_plus_isr_rule		;          if (((rule & ISR_ONLY) == 0) || (psr & 0x00800000))
    26 00000F09 F786B0040000000080- <1> 	test	dword ptr [rsi+PSR], 0800000h		;          {
    26 00000F12 00                  <1>
    27 00000F13 0F8477000000        <1> 	jz	near no_authority			;
    28                              <1> 							;
    29                              <1> application_plus_isr_rule:				;
    30 00000F19 F6C104              <1> 	test	cl, EXTERNAL_IO				;             if (rule & EXTERNAL_IO)
    31 00000F1C 7423                <1> 	jz	broadcast_rule?				;             {
    32 00000F1E 899C86E0040000      <1> 	mov	dword ptr [rsi+IO_PORT+rax*4], ebx	;                base[ea] = value;
    33 00000F25 83F866              <1> 	cmp	eax, 102	; INDICATION$		;                if (ea == 102) indication |= value;
    34 00000F28 7506                <1> 	jne	xi_ack?		 			;
    35 00000F2A 099EA4040000        <1> 	or	dword ptr [rsi+INDICATION], ebx		;
    36                              <1>  							;
    37                              <1> xi_ack?:							;
    38 00000F30 83F84B              <1> 	cmp	eax, 75					;                if (ea == 75)
    39 00000F33 750B                <1> 	jne	xi_no_ack				;                {
    40 00000F35 F6D3                <1> 	not	bl					;                    base[74] &= (value & 255) ^ 255;
    41 00000F37 0FB6DB              <1> 	movzx	ebx, bl					;                    // indication |= (value & 255) << 8;
    42                              <1> 							;                }
    43 00000F3A 219E08060000        <1> 	and	dword ptr [rsi+IO_PORT+_XI_PENDING], ebx	; 
    44                              <1> xi_no_ack:						; //               if ((ea == 79) && (value & 1)) indication |= ATTENTION;
    45 00000F40 C3                  <1> 	ret						;                return;
    46                              <1> 							;             }
    47                              <1> 							; 
    48                              <1> broadcast_rule?:					;             if (rule & BROADCAST)
    49 00000F41 F6C110              <1> 	test	cl, BROADCAST				;             {
    50 00000F44 744F                <1> 	jz	memory_rule?				;                mask = k;
    51                              <1> 							;
    52 00000F46 8B9604060000        <1> 	mov	edx, dword ptr [rsi+IO_PORT+_CORE_PIN]	;
    53                              <1> 							;
    54 00000F4C 48BF-               <1> 	mov	rdi, _core				;
    54 00000F4E [0000000000000000]  <1>
    55 00000F56 8B4D04              <1> 	mov	ecx, dword ptr [rbp+REGISTER+K]		;
    56 00000F59 238ED4060000        <1> 	and	ecx, dword ptr [rsi+IO_PORT+_CORES_MASK] ;
    57                              <1> 							;
    58                              <1> multicast_select:					;
    59 00000F5F D1E9                <1> 	shr	ecx, 1					;                from = base[77];
    60 00000F61 7321                <1> 	jnc	multicast_next				; 
    61 00000F63 21DB                <1> 	and	ebx, ebx	; operand value?	;                for (index = 0; index < RTA_SMP; index++)
    62 00000F65 7416                <1> 	jz	multicast_time
    63                              <1> 
    64 00000F67 899C86E0040000      <1> 	mov	dword ptr [rsi+IO_PORT+rax*4], ebx	;
    65 00000F6E 099718060000        <1> 	or	dword ptr [rdi+IO_PORT+_MCAST_PENDING], edx ;             {
    66 00000F74 808FA404000080      <1> 	or	byte ptr [rdi+INDICATION], ATTENTION	;                   if (mask & 1)
    67 00000F7B EB07                <1> 	jmp	multicast_next				;                   {
    68                              <1> 
    69                              <1> multicast_time:
    70 00000F7D 808FA404000020      <1> 	or	byte ptr [rdi+INDICATION], TPULSE
    71                              <1> 
    72                              <1> multicast_next:						;                      ascor = core + index;
    73 00000F84 4881C7E0070000      <1> 	add	rdi, CORE_SIZE				;                      ascor->BASE[78] |= 1 << from;
    74                              <1> 							;                      ascor->INDICATION |= ATTENTION;
    75 00000F8B 21C9                <1> 	and	ecx, ecx				;                   }
    76 00000F8D 75D0                <1> 	jnz	multicast_select			; 
    77 00000F8F C3                  <1> 	ret						;                   mask >>= 1;
    78                              <1> 							;                }
    79                              <1> no_port:						; 
    80                              <1> no_rule:						;                /**************************************************
    81                              <1> no_authority:						; 			keep these on the sending side
    82                              <1> 							; 			until constructing interrupt frame
    83 00000F90 E999010000          <1> 	jmp	guard_ii_authority			; 			between instructions at target core
    84                              <1> 							;                         to avoid overwrites from other cores
    85                              <1> 							;                **************************************************/
    86                              <1> 							; 
    87                              <1> 							;                base[ea] = value;	/* latent parameter	*/
    88                              <1> 							;                return;
    89                              <1> 							;             }
    90                              <1> 							; 
    91                              <1> memory_rule?:	; system memory type only		;             else if (rule & MEMTYPE)
    92                              <1> 
    93 00000F95 F6C101              <1> 	test	cl, MEMTYPE				;             {
    94 00000F98 745C                <1> 	jz	page_pointer?				;                if (value & 0x00400000) device_index = value & 63;
    95 00000F9A F7C300004000        <1> 	test	ebx, 0400000h	; bank sized?		; 
    96 00000FA0 7461                <1> 	jz	memory_page_pointer			;                if (device_index)
    97                              <1> 							;                {
    98 00000FA2 F7C33F000000        <1> 	test	ebx, 63					;                   if (value & 0x00800000)
    99 00000FA8 741C                <1> 	jz	device_is_pointed			;                   {
   100 00000FAA F7C300008000        <1> 	test	ebx, 0800000h	; the trap device?	;                      if (psr & 0x00800000)
   101 00000FB0 7414                <1> 	jz	device_is_pointed			;                      {
   102 00000FB2 F786B004000000350C- <1> 	test	dword ptr [rsi+PSR], 00800000	; ISR?	;                         base[ea] = value;
   102 00000FBB 00                  <1>
   103 00000FBC 74D2                <1> 	jz	no_authority				;                         return;
   104 00000FBE 899C86E0040000      <1> 	mov	[rsi+IO_PORT+rax*4], ebx		;                      }
   105 00000FC5 C3                  <1> 	ret						; 
   106                              <1> 							;                      GUARD_AUTHORITY
   107                              <1> device_is_pointed:					;                      return;
   108 00000FC6 8B8EE0060000        <1> 	mov	ecx, dword ptr [rsi+IO_PORT+_DEVICE]	;                   }
   109 00000FCC F7C100008000        <1> 	test	ecx, 00800000h				;                }
   110 00000FD2 74BC                <1> 	jz	no_authority				; 
   111 00000FD4 F7C100004000        <1> 	test	ecx, 00400000h				;                device = base[128+device_index];
   112 00000FDA 75B4                <1> 	jnz	no_authority				;            
   113 00000FDC 81E1FFFF3F00        <1> 	and	ecx, 003FFFFFh				;                if ((device & 0x00C00000) == 0x00800000)
   114 00000FE2 89DF                <1> 	mov	edi, ebx				;                {
   115 00000FE4 81E7FFFF3F00        <1> 	and	edi, 003FFFFFh	; catch any 00800000	;                   if ((value & 0x003FFFC0) > (device & 0x003FFFFF))
   116 00000FEA 39F9                <1> 	cmp	ecx, edi				;                   {
   117 00000FEC 7233                <1> 	jb	outwith		; beyond memory		;                   }
   118 00000FEE 899C86E0040000      <1> 	mov	[rsi+IO_PORT+rax*4], ebx		;                   else
   119 00000FF5 C3                  <1> 	ret						;                   {
   120                              <1> 							;                      base[ea] = value;
   121                              <1> 							;                      return;
   122                              <1> 							;                   }
   123                              <1> 							;                }
   124                              <1> 							;             }
   125                              <1> 							;             else
   126                              <1> 							;             {
   127                              <1> 							;                /*******************************************
   128                              <1> ;	only a device zero page index will do		; 			page pointer to system memory
   129                              <1> 							;                *******************************************/
   130                              <1> page_pointer?:						; 
   131 00000FF6 F6C102              <1> 	test	cl, MEMZERONLY				;                if ((value & 0x00400000) == 0)
   132 00000FF9 7495                <1> 	jz	no_rule					;                {
   133 00000FFB F7C30000C000        <1> 	test	ebx, 00C00000h				;                   if (value > (base[128] & 0x003FFFFF))
   134 00001001 758D                <1> 	jnz	no_authority				;                   {
   135                              <1> 							;                   }
   136                              <1> memory_page_pointer:					;                   else
   137 00001003 8B8EE0060000        <1> 	mov	ecx, dword ptr [rsi+IO_PORT+_DEVICE]	;                   {
   138 00001009 81E1FFFF3F00        <1> 	and	ecx, 003FFFFFh				;                      base[ea] = value;
   139 0000100F 81E3FFFFFF00        <1> 	and	ebx, 00FFFFFFh				;                      return;
   140 00001015 39D9                <1> 	cmp	ecx, ebx				;                   }
   141 00001017 7208                <1> 	jb	outwith					;                }
   142 00001019 899C86E0040000      <1> 	mov	dword ptr [rsi+IO_PORT+rax*4], ebx	;             }
   143 00001020 C3                  <1> 	ret						;          }
   144                              <1> 							;       }
   145                              <1> 							;    }
   146                              <1> outwith:						; 
   147 00001021 B90E000000          <1> 	mov	ecx, LP_ADDRESS				;    GUARD_AUTHORITY;
   148 00001026 E908010000          <1> 	jmp	guard_ii_escape				; }							; 
    37                                  	%include	"ii.msm"
     1 0000102B 660986B0040000      <1> _on:	or	word ptr [rsi+PSR], ax	; only touch low-order 16 bits
     2 00001032 C3                  <1> 	ret
     3                              <1> 
     4 00001033 6683F0FF            <1> _off:	xor	ax, 0000FFFFh
     5 00001037 662186B0040000      <1> 	and	word ptr [rsi+PSR], ax	; only touch low-order 16 bits
     6 0000103E C3                  <1> 	ret
     7                              <1> 
     8                              <1> RELOAD_SMPP	equ	1
     9                              <1> III_TRACE	equ	0
    10                              <1> 
    11                              <1> _xi:
    12                              <1> 	%if	RELOAD_SMPP
    13 0000103F 480F7EFE            <1> 	movq	rsi, mm7
    14                              <1> ;	mov	rsi, qword ptr [rbp+CORE_INDEX1]
    15                              <1> 	%endif
    16                              <1> 
    17 00001043 20E4                <1> 	and	ah, ah				; 8 external interrupts?
    18 00001045 741B                <1> 	jz	_xix_beat?			; nane
    19                              <1> 
    20 00001047 30C9                <1> 	xor	cl, cl
    21                              <1> 
    22                              <1> _xi_next:					; external interrupt pending signals[8]
    23 00001049 88A608060000        <1> 	mov	byte ptr [rsi+IO_PORT+_XI_PENDING], ah	; position for inA|B from port XI_PENDING$	LL.mm.hh.zz
    24 0000104F C686A504000000      <1> 	mov	byte ptr [rsi+INDICATION+1], 0	; clear from platform indications fabric	ll.MM.hh.zz
    25 00001056 31C9                <1> 	xor	ecx, ecx			; clear latent param
    26 00001058 B802000000          <1> 	mov	eax, II_XINT			; select external interrupt
    27                              <1> 
    28 0000105D E9FF000000          <1> 	jmp	_ii_
    29                              <1> 	
    30                              <1> _xix_beat?:
    31 00001062 A820                <1> 	test	al, TPULSE
    32 00001064 742B                <1> 	jz	_xix
    33                              <1> 
    34 00001066 48BF-               <1> 	mov	rdi, _core			; i.e. &core[0]
    34 00001068 [0000000000000000]  <1>
    35 00001070 488B9F58020000      <1> 	mov	rbx, qword ptr [rdi+REGISTER+DAYCLOCK_U]
    36 00001077 48899E58020000      <1> 	mov	qword ptr [rsi+REGISTER+DAYCLOCK_U], rbx
    37 0000107E 8B9F74060000        <1> 	mov	ebx, dword ptr [rdi+IO_PORT+_TZONE]
    38 00001084 899E74060000        <1> 	mov	dword ptr [rsi+IO_PORT+_TZONE], ebx
    39 0000108A 80A6A4040000DF      <1> 	and	byte ptr [rsi+INDICATION], TPULSE^255
    40                              <1> 
    41 00001091 A880                <1> _xix:	test	al, ATTENTION			; core2core interrupt
    42 00001093 0F8455000000        <1> 	jz	near _xiy
    43                              <1> 
    44 00001099 8B9E18060000        <1> 	mov	ebx, dword ptr [rsi+IO_PORT+_MCAST_PENDING]
    45 0000109F 239ED4060000        <1> 	and	ebx, dword ptr [rsi+IO_PORT+_CORES_MASK]
    46 000010A5 BAFEFFFFFF          <1> 	mov	edx, -2
    47 000010AA 48BF-               <1> 	mov	rdi, _core
    47 000010AC [0000000000000000]  <1>
    48                              <1> 
    49                              <1> _xi_atn_sources:
    50 000010B4 D1EB                <1> 	shr	ebx, 1						; source pending
    51 000010B6 7316                <1> 	jnc	_xi_atn_source_next				; no
    52                              <1> 								; yes
    53 000010B8 219618060000        <1> 	and	[rsi+IO_PORT+_MCAST_PENDING], edx		; unpend
    54 000010BE 8B8F1C060000        <1> 	mov	ecx, dword ptr [rdi+IO_PORT+_MCAST_TO]		; latent parameter from other core
    55                              <1> 
    56 000010C4 B805000000          <1> 	mov	eax, II_ATTENTION				; no
    57 000010C9 E993000000          <1> 	jmp	_ii_						; _ii_ takes ecx for
    58                              <1> 								; latent parameter
    59                              <1> _xi_atn_source_next:
    60 000010CE 4881C7E0070000      <1> 	add	rdi, CORE_SIZE					; next core
    61 000010D5 D1C2                <1> 	rol	edx, 1						; next flag reset position
    62 000010D7 21DB                <1> 	and	ebx, ebx					; any next attention flags left?
    63 000010D9 75D9                <1> 	jnz	_xi_atn_sources
    64                              <1> 								; any attention flags set anew?
    65 000010DB F78618060000FFFFFF- <1> 	test	dword ptr [rsi+IO_PORT+_MCAST_PENDING], 00FFFFFFh
    65 000010E4 00                  <1>
    66 000010E5 7507                <1> 	jnz	_xi_atn_new_sources				; if so keep ATTENTION request
    67                              <1> 								; for next pass
    68 000010E7 80A6A40400007F      <1> 	and	byte ptr [rsi+INDICATION], ATTENTION^255	; otherwise quiet request
    69                              <1> 
    70                              <1> _xi_atn_new_sources:
    71                              <1> 	
    72                              <1> 
    73 000010EE 8B86A4040000        <1> _xiy:	mov	eax, dword ptr [rsi+INDICATION]			; case we did _xix in the same sweep
    74 000010F4 F686A404000040      <1> 	test	byte ptr [rsi+INDICATION], INCREMENTER_CARRY	; nanosecond or other counter 
    75 000010FB 7410                <1> 	jz	_xiz						; from minus to carrry on zero
    76                              <1> 								; to feed millisecond dayclock
    77 000010FD 80A6A4040000BF      <1> 	and	byte ptr [rsi+INDICATION], INCREMENTER_CARRY^255
    78 00001104 B804000000          <1> 	mov	eax, II_MSECOND
    79 00001109 31C9                <1> 	xor	ecx, ecx
    80 0000110B EB54                <1> 	jmp	_ii_
    81                              <1> 
    82 0000110D C3                  <1> _xiz:	ret
    83                              <1> 
    84                              <1> _ii_instruction:
    85 0000110E 89C3                <1> 	mov	ebx, eax
    86 00001110 C1EB06              <1> 	shr	ebx, 6
    87 00001113 2B9E00060000        <1> 	sub	ebx, dword ptr [rsi+IO_PORT+_APP_THRESHOLD]	; application threshold
    88 00001119 7913                <1> 	jns	guard_ii_authority	; must have executed a character string
    89                              <1> 					; like 757575
    90 0000111B A9C0FFFFFF          <1> 	test	eax, -64
    91 00001120 7521                <1> 	jnz	_ii			; not in restart page OK
    92 00001122 F786B004000000350C- <1> 	test	dword ptr [rsi+PSR], 00800000
    92 0000112B 00                  <1>
    93 0000112C 7515                <1> 	jnz	_ii			; ISR may interrupt to restart page
    94                              <1> 
    95                              <1> 					; service call application to restart page not allowed
    96                              <1> 					; most likely to be an accident
    97                              <1> 					; drop thru and be quelled
    98                              <1> 
    99                              <1> guard_ii_authority:
   100 0000112E B901000000          <1> 	mov	ecx, LP_AUTHORITY
   101                              <1> guard_ii_escape:
   102 00001133 B85F000000          <1> 	mov	eax, II_GUARD
   103                              <1> _ii_escape:
   104                              <1> 	%if	RELOAD_SMPP
   105 00001138 480F7EFE            <1> 	movq	rsi, mm7
   106                              <1> ;	mov	rsi, qword ptr [rbp+CORE_INDEX1]	; read register 152 or 280
   107                              <1> 	%endif						; depending ebp -> application / ISR registers
   108                              <1> 
   109 0000113C 488BA678040000      <1> 	mov	rsp, qword ptr [rsi+REGISTER+286*4]	; read esp at start of _execute
   110                              <1> 
   111 00001143 83F85F              <1> _ii:	cmp	eax, II_GUARD
   112 00001146 7519                <1> 	jnz	_ii_
   113 00001148 F60425[19000000]01  <1> 	test	byte ptr [_uflag+'Z'-'A'], 1	; break to debug console?
   114 00001150 740F                <1> 	jz	_ii_					; not if not opted
   115 00001152 808EA404000002      <1> 	or	byte ptr [rsi+INDICATION], LOCKSTEP
   116 00001159 800C25[00000000]02  <1> 	or	byte ptr [_general_indication], LOCKSTEP
   117                              <1> 	
   118 00001161 488DAE00020000      <1> _ii_:	lea	rbp, [rsi+128*4] 
   119                              <1> 
   120 00001168 4889AE98040000      <1> 	mov	qword ptr [rsi+REGISTER_SET], rbp
   121 0000116F C786AC040000800000- <1> 	mov	dword ptr [rsi+ISELECT], 128
   121 00001178 00                  <1>
   122                              <1> 
   123 00001179 8B5D3C              <1> 	mov	ebx, dword ptr [rbp+S_P]
   124 0000117C 81FB00010000        <1> 	cmp	ebx, 256
   125 00001182 0F87D4010000        <1> 	ja	near guard_stack
   126 00001188 83C3FC              <1> 	add	ebx, -4
   127                              <1> 
   128 0000118B 81FB9A000000        <1> 	cmp	ebx, 128+24+2
   129 00001191 0F82C5010000        <1> 	jb	near guard_stack
   130 00001197 895D3C              <1> 	mov	dword ptr [rbp+S_P], ebx
   131                              <1> 
   132 0000119A 4C2BA690040000      <1> 	sub	r12, qword ptr [rsi+B0P]		; platform-relative absolute program counter
   133 000011A1 49C1EC02            <1> 	shr	r12, 2
   134 000011A5 4489649E0C          <1> 	mov	dword ptr [rsi+rbx*4+REGISTER+3*4], r12d	; save PC offset
   135 000011AA 8B96B4040000        <1> 	mov	edx, dword ptr [rsi+B0_NAME]
   136 000011B0 89549E08            <1> 	mov	dword ptr [rsi+rbx*4+REGISTER+2*4], edx	; save bank ID
   137 000011B4 8B96B0040000        <1> 	mov	edx, dword ptr [rsi+PSR]
   138 000011BA 89549E04            <1> 	mov	dword ptr [rsi+rbx*4+REGISTER+4], edx	; saved PSR
   139 000011BE 890C9E              <1> 	mov	dword ptr [rsi+rbx*4+REGISTER], ecx	; latent parameter
   140 000011C1 F7C200008000        <1> 	test	edx, 00800000h				; nested interrupt ?
   141 000011C7 7503                <1> 	jnz	_ii_ii
   142 000011C9 895D38              <1> 	mov	dword ptr [rbp+FP], ebx			; if not, mark interrupted
   143                              <1> 							; application stack frame
   144                              <1> _ii_ii:
   145 000011CC 81CA00008000        <1> 	or	edx, 00800000h				; ISR active
   146 000011D2 8996B0040000        <1> 	mov	dword ptr [rsi+PSR], edx
   147                              <1> 
   148 000011D8 89C2                <1> 	mov	edx, eax				; get to the operand
   149 000011DA 83E23F              <1> 	and	edx, 63					; vector offset
   150 000011DD C1E806              <1> 	shr	eax, 6					; vector start page index
   151 000011E0 25FF030000          <1> 	and	eax, 000003FFh				; eax -> page containing ISR ; edx  -> vector
   152 000011E5 31DB                <1> 	xor	ebx, ebx				; single page ISR
   153 000011E7 E97B060000          <1> 	jmp	_go2_frame
   154                              <1> 
   155                              <1> ;	_ir	sign extended ea is in eax
   156                              <1> 
   157 000011EC F786B0040000000080- <1> _ir:	test	dword ptr [rsi+PSR], 00800000h		; eax = EA = variation on return offset
   157 000011F5 00                  <1>
   158 000011F6 0F8432FFFFFF        <1> 	jz	guard_ii_authority			; not good to do Interrupt Return from application space
   159                              <1> 
   160                              <1> 							; r12 stays the same until return is finalised
   161                              <1> 							; in case the operation interrupts itself
   162 000011FC 89C2                <1> 	mov	edx, eax				; +- displacement operand, offset in stack added later
   163                              <1> 
   164 000011FE E891010000          <1> 	call	stack_read4				; [rbp+rbx*4] -> interrupt stack frame
   165                              <1> 							; interrupt stack pointer is already updated ebx+4
   166                              <1> 
   167 00001203 8B449E08            <1> 	mov	eax, dword ptr [rsi+rbx*4+2*4]		; interrupted b0_name
   168                              <1> 
   169 00001207 8B4C9E04            <1> 	mov	ecx, dword ptr [rsi+rbx*4+1*4]		; interrupted psr
   170                              <1> 
   171 0000120B 03549E0C            <1> 	add	edx, dword ptr [rsi+rbx*4+3*4]		; add interrupted iframe offset to EA
   172 0000120F 81E2FFFF3F00        <1> 	and	edx, 03FFFFFh				;
   173                              <1> 
   174 00001215 31DB                <1> 	xor	ebx, ebx				; iframe default page high index  
   175 00001217 A900008000          <1> 	test	eax, 00800000h				; +page[s] flag on b0_name ?
   176 0000121C 741A                <1> 	jz	ir_4k_iframe				; 1-page iframe return target
   177                              <1> 
   178 0000121E 89C3                <1> 	mov	ebx, eax
   179 00001220 C1E30A              <1> 	shl	ebx, 2+8				; drop the flag bit from iframe name
   180 00001223 48C1E302            <1> 	shl	rbx, 12-10				; complete the multiplication * page 
   181                              <1> 
   182                              <1> 	%if	__MOVBE
   183                              <1> 	movbe	rbx, dword ptr [rbx*4+64*4+_memory]
   184                              <1> 	%else
   185 00001227 488B1C9D[00010000]  <1> 	mov	rbx, qword ptr [rbx*4+64*4+_memory]	; read the embedded gate table
   186 0000122F 30DB                <1> 	xor	bl, bl
   187 00001231 480FCB              <1> 	bswap	rbx
   188                              <1> 	%endif
   189                              <1> 
   190 00001234 48C1EB32            <1> 	shr	rbx, 18+32					; <- iframe page high index
   191                              <1> 
   192                              <1> 	%if	0
   193                              <1> 	mov	qword ptr [_ultra], rax
   194                              <1> 	mov	qword ptr [_ultra1], rbx
   195                              <1> 	mov	qword ptr [_ultra2], rcx
   196                              <1> 	mov	qword ptr [_ultra3], rdx
   197                              <1> 	%endif
   198                              <1> 
   199                              <1> ir_4k_iframe:
   200 00001238 898EB0040000        <1> 	mov	dword ptr [rsi+PSR], ecx
   201 0000123E F7C100008000        <1> 	test	ecx, 00800000h				; returning ISR -> ISR ?
   202 00001244 741D                <1> 	jz	ir_application				; no
   203                              <1> 
   204 00001246 488DAE00020000      <1> 	lea	rbp, [rsi+REGISTER+128*4]		; for nested interrupts
   205 0000124D 4889AE98040000      <1> 	mov	qword ptr [rsi+REGISTER_SET], rbp	; interrupt register set. presumably already so
   206 00001254 C786AC040000800000- <1> 	mov	dword ptr [rsi+ISELECT], 128		; interrupt register set
   206 0000125D 00                  <1>
   207 0000125E E904060000          <1> 	jmp	_go2_frame				; yes
   208                              <1> 
   209                              <1> ir_application:
   210 00001263 4889F5              <1> 	mov	rbp, rsi				; application register set
   211 00001266 4889AE98040000      <1> 	mov	qword ptr [rsi+REGISTER_SET], rbp
   212 0000126D C786AC040000000000- <1> 	mov	dword ptr [rsi+ISELECT], 0
   212 00001276 00                  <1>
   213                              <1> 
   214                              <1> 	%if	0
   215                              <1>         mov	qword ptr [_ultra4], rsi
   216                              <1> 	mov	qword ptr [_ultra5], rbp
   217                              <1> 	%endif
   218                              <1> 
   219 00001277 E9EB050000          <1> 	jmp	_go2_frame				; eax <- reload iframe name
   220                              <1> 							; ebx <- reload iframe page high index
   221                              <1> 							; edx <- return word offset
    38                                  	%include	"stack.msm"
     1                              <1> ;	stack operations call these to add or subract stack
     2                              <1> ;	limits are checked here
     3                              <1> ;	these routines always leave epb -> all registers 0..255
     4                              <1> ;	because both  interrupt internal stack pointer register 128 + 15
     5                              <1> ;		and application internal stack pointer register 15
     6                              <1> 
     7                              <1> ;	are absolute pointers to the entire register stack
     8                              <1> 
     9                              <1> ;	therefore instructions calling here must afterwards
    10                              <1> 
    11                              <1> ;		mov	ebp, dword ptr [_register_set]
    12                              <1> 
    13                              <1> ;	to get ebp back to application registers 0..127
    14                              <1> ;			or interrupt registers 128..255
    15                              <1> 
    16                              <1> ;	ebp governs which r k x y a b mantissa2 mantissa3 fp sp is implied in the instruction opcode
    17                              <1> ;	registers addressed as operand are always absolute in the range 0..255
    18                              <1> 
    19                              <1> ;	these don't move any data but leave [ebp+ebx*4] pointing to the required stack frame
    20                              <1> ;	and update the stack pointer
    21                              <1> 
    22                              <1> ;	although applications can and must read interrupt registers with load instructions
    23                              <1> ;	they can't read interrupt registers with runaway pop instructions
    24                              <1> ;	because the problem is easier to find with an interrupt as soon as 128+ gets popped
    25                              <1> 
    26                              <1> 
    27                              <1> 
    28                              <1> stack1:
    29                              <1> 	%if	0
    30                              <1> 	mov	ebx, dword ptr [ebp+S_P]
    31                              <1> 	dec	ebx
    32                              <1> 	mov	dword ptr [ebp+S_P], ebx
    33                              <1> 	ret
    34                              <1> 	%endif
    35                              <1> 
    36 0000127C 8B5D3C              <1> 	mov	ebx, dword ptr [rbp+S_P]	; read whichever internal sp
    37 0000127F F686B204000080      <1> 	test	byte ptr [rsi+PSR+2], 128	; ISR ?
    38 00001286 742C                <1> 	jz	stack1_a			; no ?
    39 00001288 81FB00010000        <1> 	cmp	ebx, 256			; in upper range ?
    40 0000128E 0F87C8000000        <1> 	ja	near guard_stack		; no ?
    41 00001294 FFCB                <1> 	dec	ebx				; decrement
    42 00001296 0F88C0000000        <1> 	js	near guard_stack		; < 0 ?
    43 0000129C 81FB98000000        <1> 	cmp	ebx, 128+24	; +2		; in clock registers?
    44 000012A2 730C                <1> 	jnb	stack1_j			;
    45 000012A4 81FB80000000        <1> 	cmp	ebx, 128			; in app stack? Allowed for thread switch
    46 000012AA 0F83AC000000        <1> 	jnb	near guard_stack		; in working registers page
    47                              <1> stack1_j:
    48 000012B0 895D3C              <1> 	mov	dword ptr [rbp+S_P], ebx	; new frame
    49 000012B3 C3                  <1> 	ret
    50                              <1> 
    51                              <1> stack1_a:					; this is application
    52 000012B4 81FB80000000        <1> 	cmp	ebx, 128			; > interrupt register range start
    53 000012BA 0F879C000000        <1> 	ja	near guard_stack		; not allowed
    54 000012C0 FFCB                <1> 	dec	ebx				; decrement
    55 000012C2 0F8894000000        <1> 	js	near guard_stack		; < 0 ?
    56 000012C8 83FB18              <1> 	cmp	ebx, 24				; in control registers ?
    57 000012CB 0F828B000000        <1> 	jb	near guard_stack		; not allowed
    58 000012D1 895D3C              <1> 	mov	dword ptr [rbp+S_P], ebx	; new frame
    59 000012D4 C3                  <1> 	ret
    60                              <1> 
    61                              <1> stack2:
    62                              <1> 	%if	0
    63                              <1> 	mov	ebx, dword ptr [ebp+S_P]
    64                              <1> 	add	ebx, -2
    65                              <1> 	mov	dword ptr [ebp+S_P], ebx
    66                              <1> 	ret
    67                              <1> 	%endif
    68                              <1> 
    69 000012D5 8B5D3C              <1> 	mov	ebx, dword ptr [rbp+S_P]
    70 000012D8 F686B204000080      <1> 	test	byte ptr [rsi+PSR+2], 128
    71 000012DF 742A                <1> 	jz	stack2_a
    72 000012E1 81FB00010000        <1> 	cmp	ebx, 256
    73 000012E7 0F876F000000        <1> 	ja	near guard_stack
    74 000012ED 83C3FE              <1> 	add	ebx, -2
    75 000012F0 0F8866000000        <1> 	js	near guard_stack
    76 000012F6 81FB98000000        <1> 	cmp	ebx, 128+24
    77 000012FC 7309                <1> 	jnb	stack2_j
    78 000012FE 83FB7E              <1> 	cmp	ebx, 128-2
    79 00001301 0F8755000000        <1> 	ja	near guard_stack
    80                              <1> 
    81                              <1> stack2_j:
    82 00001307 895D3C              <1> 	mov	dword ptr [rbp+S_P], ebx
    83 0000130A C3                  <1> 	ret
    84                              <1> 
    85                              <1> stack2_a:
    86 0000130B 81FB80000000        <1> 	cmp	ebx, 128			; application push high limit 128,  ISR 256
    87 00001311 7749                <1> 	ja	guard_stack
    88 00001313 83C3FE              <1> 	add	ebx, -2
    89 00001316 7844                <1> 	js	guard_stack
    90 00001318 83FB18              <1> 	cmp	ebx, 24
    91 0000131B 723F                <1> 	jb	guard_stack			; stack top limit zero ISR and application
    92 0000131D 895D3C              <1> 	mov	dword ptr [rbp+S_P], ebx
    93 00001320 C3                  <1> 	ret
    94                              <1> 
    95                              <1> stack4:
    96                              <1> 	%if	0
    97                              <1> 	mov	ebx, dword ptr [ebp+S_P]
    98                              <1> 	add	ebx, -4
    99                              <1> 	mov	dword ptr [ebp+S_P], ebx
   100                              <1> 	ret
   101                              <1> 	%endif
   102                              <1> 
   103 00001321 8B5D3C              <1> 	mov	ebx, dword ptr [rbp+S_P]
   104 00001324 F686B204000080      <1> 	test	byte ptr [rsi+PSR+2], 128	; read psr interrupt bit
   105 0000132B 741C                <1> 	jz	stack4_a			; stack is registers 24..127
   106 0000132D 81FB00010000        <1> 	cmp	ebx, 256			; stack is registers  0..255
   107 00001333 7727                <1> 	ja	guard_stack
   108 00001335 83C3FC              <1> 	add	ebx, -4				; proposed frame
   109 00001338 7822                <1> 	js	guard_stack			; not lower than register zero
   110 0000133A 81FB98000000        <1> 	cmp	ebx, 128+24
   111 00001340 7303                <1> 	jnb	stack4_j
   112 00001342 83FB7C              <1> 	cmp	ebx, 128-4			; in working registers page
   113                              <1> ;	ja	guard_stack			; caller does that
   114                              <1> 
   115                              <1> stack4_j:
   116 00001345 895D3C              <1> 	mov	dword ptr [rbp+S_P], ebx
   117 00001348 C3                  <1> 	ret					; both sp are absolute pointers
   118                              <1> 
   119                              <1> stack4_a:
   120 00001349 81FB80000000        <1> 	cmp	ebx, 128			; don't push into a higher register than 127
   121 0000134F 770B                <1> 	ja	guard_stack
   122 00001351 83C3FC              <1> 	add	ebx, -4
   123 00001354 7806                <1> 	js	guard_stack
   124 00001356 83FB18              <1> 	cmp	ebx, 24				; dont push lower than 24
   125 00001359 7201                <1> 	jb	guard_stack
   126                              <1> ;	mov	dword ptr [rbp+S_P], ebx	; caller does that
   127 0000135B C3                  <1> 	ret					; return new frame
   128                              <1> 
   129                              <1> guard_stack:
   130                              <1> stack_underflow:
   131 0000135C 8BAE98040000        <1> 	mov	ebp, dword ptr [rsi+REGISTER_SET] ; esi -> core.REGISTER
   132 00001362 F786B0040000000080- <1> 	test	dword ptr [rsi+PSR], 00800000h	; interrupt mode?
   132 0000136B 00                  <1>
   133 0000136C 0F84BCFDFFFF        <1> 	jz	guard_ii_authority		; sideline the application
   134 00001372 C7453C00010000      <1> 	mov	dword ptr [rbp+S_P], 256	; restart the interrupt stack
   135 00001379 B801000000          <1> 	mov	eax, 1				; so the interrupt can be interrupted
   136 0000137E F60425[19000000]01  <1> 	test	byte ptr [_uflag+'Z'-'A'], 1
   137 00001386 7407                <1> 	jz	gsago
   138 00001388 808EA404000002      <1> 	or	byte ptr [rsi+INDICATION], LOCKSTEP
   139 0000138F E9A4FDFFFF          <1> gsago:	jmp	_ii_escape
   140                              <1> 
   141                              <1> stack_read4:
   142 00001394 BB04000000          <1> 	mov	ebx, 4
   143 00001399 035D3C              <1> 	add	ebx, dword ptr [rbp+S_P]
   144 0000139C 81FB80000000        <1> 	cmp	ebx, 128			; you can have stack locations up to here
   145 000013A2 7611                <1> 	jna	stack_r4			; whoever you are
   146 000013A4 F686B204000080      <1> 	test	byte ptr [rsi+PSR+2], 128	; any higher you have to be an ISR
   147 000013AB 74AF                <1> 	jz	stack_underflow
   148 000013AD 81FB00010000        <1> 	cmp	ebx, 256			; and then not any higher than this
   149 000013B3 77A7                <1> 	ja	stack_underflow
   150                              <1> 
   151                              <1> stack_r4:
   152 000013B5 875D3C              <1> 	xchg	ebx, dword ptr [rbp+S_P]	; write new stack top
   153 000013B8 C3                  <1> 	ret					; return old stack top
   154                              <1> 
   155                              <1> stack_read2:
   156 000013B9 BB02000000          <1> 	mov	ebx, 2
   157 000013BE 035D3C              <1> 	add	ebx, dword ptr [rbp+S_P]
   158 000013C1 81FB80000000        <1> 	cmp	ebx, 128			; you can have stack locations up to here
   159 000013C7 7611                <1> 	jna	stack_r2			; whoever you are
   160 000013C9 F686B204000080      <1> 	test	byte ptr [rsi+PSR+2], 128	; any higher you have to be an ISR
   161 000013D0 748A                <1> 	jz	stack_underflow
   162 000013D2 81FB00010000        <1> 	cmp	ebx, 256			; and then not any higher than this
   163 000013D8 7782                <1> 	ja	stack_underflow
   164                              <1> 
   165                              <1> stack_r2:
   166 000013DA 875D3C              <1> 	xchg	ebx, dword ptr [rbp+S_P]	; write new stack top
   167 000013DD C3                  <1> 	ret					; return old stack top
   168                              <1> 
   169                              <1> stack_read1:
   170 000013DE BB01000000          <1> 	mov	ebx, 1				; calculate
   171 000013E3 035D3C              <1> 	add	ebx, dword ptr [rbp+S_P]	; new stack top
   172 000013E6 81FB80000000        <1> 	cmp	ebx, 128			; you can have stack locations up to here
   173 000013EC 7619                <1> 	jna	stack_r1			; whoever you are
   174 000013EE F686B204000080      <1> 	test	byte ptr [rsi+PSR+2], 128	; any higher you have to be an ISR
   175 000013F5 0F8461FFFFFF        <1> 	jz	stack_underflow
   176 000013FB 81FB00010000        <1> 	cmp	ebx, 256			; and then not any higher than this
   177 00001401 0F8755FFFFFF        <1> 	ja	stack_underflow
   178                              <1> 
   179                              <1> stack_r1:
   180 00001407 875D3C              <1> 	xchg	ebx, dword ptr [rbp+S_P]	; write new stack top
   181 0000140A C3                  <1> 	ret					; return old stack top
   182                              <1> 
    39                                  	%include	"return.msm"
     1                              <1> _autoexit:
     2 0000140B B846000000          <1> 	mov	eax, II_EXIT
     3 00001410 B90B000000          <1> 	mov	ecx, LP_AUTOEXIT
     4 00001415 E91EFDFFFF          <1> 	jmp	_ii_escape
     5                              <1> 
     6 0000141A F786B0040000000080- <1> _lret:	test	dword ptr [rsi+PSR], 00800000h
     6 00001423 00                  <1>
     7 00001424 7509                <1> 	jnz	_lret_
     8                              <1> 
     9 00001426 817D3C80000000      <1> 	cmp	dword ptr [rbp+S_P], 128
    10 0000142D 74DC                <1> 	jz	_autoexit
    11                              <1> 
    12 0000142F E8AAFFFFFF          <1> _lret_:	call	stack_read1
    13 00001434 03049E              <1> 	add	eax, dword ptr [rsi+rbx*4]
    14 00001437 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
    15 0000143C E92C020000          <1> 	jmp	_j
    16                              <1> 
    17 00001441 F786B0040000000080- <1> _fret:	test	dword ptr [rsi+PSR], 00800000h
    17 0000144A 00                  <1>
    18 0000144B 7509                <1> 	jnz	_fret_
    19                              <1> 
    20 0000144D 817D3C80000000      <1> 	cmp	dword ptr [rbp+S_P], 128
    21 00001454 74B5                <1> 	jz	_autoexit
    22                              <1> 
    23 00001456 E85EFFFFFF          <1> _fret_:	call	stack_read2
    24 0000145B 4C89A680040000      <1> 	mov	qword ptr [rsi+APC],r12
    25 00001462 4889C2              <1> 	mov	rdx, rax			; effective address
    26 00001465 03549E04            <1> 	add	edx, dword ptr [rsi+rbx*4+1*4]	; add EA as displacement to offset on stack
    27 00001469 8B049E              <1> 	mov	eax, dword ptr [rsi+rbx*4]	; return b0_name
    28 0000146C 31DB                <1> 	xor	ebx, ebx			; 1-page frame?
    29 0000146E A900008000          <1> 	test	eax, 00800000h			; multipages frame?
    30 00001473 7418                <1> 	jz	_fret_1page
    31                              <1> 
    32 00001475 89C3                <1> 	mov	ebx, eax
    33 00001477 C1E30A              <1> 	shl	ebx, 2+8			; drop flag bit from b0_name
    34 0000147A 48C1E302            <1> 	shl	rbx, 12-10			; complete multiplication * page
    35                              <1> 
    36                              <1> 	%if	__MOVBE				; read the embedded gate table
    37                              <1> 	movbe	ebx, dword ptr [_memory+rbx*4+64*4]
    38                              <1> 	%else
    39 0000147E 8B1C9D[00010000]    <1> 	mov	ebx, dword ptr [_memory+rbx*4+64*4]
    40 00001485 30DB                <1> 	xor	bl, bl
    41 00001487 0FCB                <1> 	bswap	ebx
    42                              <1> 	%endif
    43                              <1> 
    44 00001489 48C1EB12            <1> 	shr	rbx, 18				; ebx <- iframe page high index
    45                              <1> 
    46                              <1> _fret_1page:					; eax <- iframe name
    47 0000148D E9D5030000          <1> 	jmp	_go2_frame			; edx <- word offset
    48                              <1> 
    49                              <1> _fpxpo_low_order:
    50 00001492 8B5C240C            <1> 	mov	ebx, dword ptr [rsp+3*4]	; tell ISR which accumulator
    51                              <1> 
    52 00001496 B803000000          <1> _fpxpo:	mov	eax, II_FPXPO
    53 0000149B 89D9                <1> 	mov	ecx, ebx			; tell ISR which accumulator
    54 0000149D E996FCFFFF          <1> 	jmp	_ii_escape
    55                              <1> 
    40                                  	%include	"rta.msm"
     1                              <1> 
     2 000014A2 80F904              <1> _sr:	cmp	cl, I
     3 000014A5 0F845FF8FFFF        <1> 	jz	_inA
     4 000014AB 80F905              <1> 	cmp	cl, XI
     5 000014AE 0F8477FBFFFF        <1> 	jz	_on
     6                              <1> 
     7 000014B4 8B5D00              <1> 	mov	ebx, dword ptr [rbp+R]
     8 000014B7 E901F2FFFF          <1> 	jmp	_operand_write
     9                              <1> 
    10 000014BC 80F904              <1> _sk:	cmp	cl, I
    11 000014BF 0F8450F8FFFF        <1> 	jz	_inB
    12 000014C5 80F905              <1> 	cmp	cl, XI
    13 000014C8 0F8465FBFFFF        <1> 	jz	_off
    14                              <1> 
    15 000014CE 8B5D04              <1> 	mov	ebx, dword ptr [rbp+K]
    16 000014D1 E9E7F1FFFF          <1> 	jmp	_operand_write
    17                              <1> 
    18 000014D6 80F904              <1> _sx:	cmp	cl, I
    19 000014D9 0F8441F8FFFF        <1> 	jz	_outA
    20 000014DF 80F905              <1> 	cmp	cl, XI
    21 000014E2 0F842BF7FFFF        <1> 	jz	_rsr
    22                              <1> 
    23 000014E8 8B5D08              <1> 	mov	ebx, dword ptr [rbp+X]
    24 000014EB E9CDF1FFFF          <1> 	jmp	_operand_write
    25                              <1> 
    26 000014F0 80F904              <1> _sy:	cmp	cl, I
    27 000014F3 0F842FF8FFFF        <1> 	jz	_outB
    28 000014F9 80F905              <1> 	cmp	cl, XI
    29 000014FC 0F8482F7FFFF        <1> 	jz	_wsr
    30                              <1> 
    31 00001502 8B5D0C              <1> 	mov	ebx, dword ptr [rbp+Y]
    32 00001505 E9B3F1FFFF          <1> 	jmp	_operand_write;
    33                              <1> 
    34 0000150A 80F904              <1> _sa:	cmp	cl, I
    35 0000150D 0F84DDF8FFFF        <1> 	jz	_reload
    36 00001513 80F905              <1> 	cmp	cl, XI
    37 00001516 744E                <1> 	jz	escape
    38                              <1> 
    39 00001518 8B5D10              <1> 	mov	ebx, dword ptr [rbp+A]
    40 0000151B E99DF1FFFF          <1> 	jmp	_operand_write
    41                              <1> 
    42 00001520 80F904              <1> _sb:	cmp	cl, I
    43 00001523 7441                <1> 	jz	escape
    44 00001525 80F905              <1> 	cmp	cl, XI
    45 00001528 743C                <1> 	jz	escape
    46                              <1> 
    47 0000152A 8B5D14              <1> 	mov	ebx, dword ptr [rbp+B]
    48 0000152D E98BF1FFFF          <1> 	jmp	_operand_write
    49                              <1> 
    50 00001532 80F904              <1> _z:	cmp	cl, I
    51 00001535 0F84DBF8FFFF        <1> 	jz	_sabr
    52 0000153B 80F905              <1> 	cmp	cl, XI
    53 0000153E 0F84D6FEFFFF        <1> 	jz	_lret
    54 00001544 31DB                <1> 	xor	ebx, ebx
    55 00001546 E972F1FFFF          <1> 	jmp	_operand_write
    56                              <1> 
    57 0000154B 80F904              <1> _pop:	cmp	cl, I
    58 0000154E 7416                <1> 	jz	escape
    59 00001550 80F905              <1> 	cmp	cl, XI
    60 00001553 0F84E8FEFFFF        <1> 	jz	_fret
    61                              <1> 
    62 00001559 E880FEFFFF          <1> 	call	stack_read1
    63 0000155E 8B1C9E              <1> 	mov	ebx, dword ptr [rsi+rbx*4]
    64 00001561 E957F1FFFF          <1> 	jmp	_operand_write
    65                              <1> 
    66 00001566 C3                  <1> escape	ret
    67                              <1> 
    68 00001567 E88EEFFFFF          <1> _lr:	call	_operand_read
    69 0000156C 894500              <1> 	mov	dword ptr [rbp+R], eax
    70 0000156F C3                  <1> 	ret
    71                              <1> 
    72 00001570 E885EFFFFF          <1> _lk:	call	_operand_read
    73 00001575 894504              <1> 	mov	dword ptr [rbp+K], eax
    74 00001578 C3                  <1> 	ret
    75 00001579 E87CEFFFFF          <1> _lx:	call	_operand_read
    76 0000157E 894508              <1> 	mov	dword ptr [rbp+X], eax
    77 00001581 C3                  <1> 	ret
    78                              <1> 
    79 00001582 E873EFFFFF          <1> _ly:	call	_operand_read
    80 00001587 89450C              <1> 	mov	dword ptr [rbp+Y], eax
    81 0000158A C3                  <1> 	ret
    82                              <1> 
    83 0000158B E86AEFFFFF          <1> _la:	call	_operand_read
    84 00001590 894510              <1> 	mov	dword ptr [rbp+A], eax
    85 00001593 C3                  <1> 	ret
    86                              <1> 
    87 00001594 E861EFFFFF          <1> _lb:	call	_operand_read
    88 00001599 894514              <1> 	mov	dword ptr [rbp+B], eax
    89 0000159C C3                  <1> 	ret
    90                              <1> 
    91 0000159D 80F904              <1> _tz:	cmp	cl, I
    92 000015A0 0F842A140000        <1> 	jz	near _rex
    93 000015A6 80F905              <1> 	cmp	cl, XI
    94 000015A9 B900000000          <1> 	mov	ecx, 0
    95 000015AE 0F845AFBFFFF        <1> 	jz	_ii_instruction
    96                              <1> 
    97 000015B4 E841EFFFFF          <1> 	call	_operand_read
    98 000015B9 A9FFFFFF00          <1> 	test	eax, 00FFFFFFh
    99 000015BE 7504                <1> 	jnz	_tz_
   100 000015C0 4983C404            <1> 	add	r12, 4
   101 000015C4 C3                  <1> _tz_:	ret
   102                              <1> 
   103 000015C5 80F904              <1> _tp:	cmp	cl, I
   104 000015C8 742C                <1> 	jz	_jdz
   105 000015CA 80F905              <1> 	cmp	cl, XI
   106 000015CD 0F8419FCFFFF        <1> 	jz	_ir
   107                              <1> 
   108 000015D3 E822EFFFFF          <1> 	call	_operand_read
   109 000015D8 A900008000          <1> 	test	eax, 00800000h
   110 000015DD 7504                <1> 	jnz	_tp_
   111 000015DF 4983C404            <1> 	add	r12, 4
   112 000015E3 C3                  <1> _tp_:	ret
   113                              <1> 
   114 000015E4 E811EFFFFF          <1> _push:	call	_operand_read
   115                              <1> 
   116 000015E9 480F7EFE            <1> 	movq	rsi, mm7
   117                              <1> ;	mov	rsi, qword ptr [rbp+CORE_INDEX1]
   118                              <1> 
   119 000015ED E88AFCFFFF          <1> 	call	stack1
   120 000015F2 89049E              <1> 	mov	dword ptr [rsi+rbx*4], eax
   121 000015F5 C3                  <1> 	ret
   122                              <1> 
   123 000015F6 8B5D14              <1> _jdz:	mov	ebx, dword ptr [rbp+B]
   124 000015F9 0B5D10              <1> 	or	ebx, dword ptr [rbp+A]
   125 000015FC 0F846B000000        <1> 	jz	near _j
   126 00001602 C3                  <1> 	ret
   127                              <1> 
   128 00001603 8B5D00              <1> _jdr:	mov	ebx, dword ptr [rbp+R]		; dec r and jump if it passed from zero to -1
   129 00001606 81C3FFFFFF00        <1> 	add	ebx, 00FFFFFFh
   130 0000160C C1C308              <1> 	rol	ebx, 8
   131 0000160F 88D9                <1> 	mov	cl, bl
   132 00001611 C1EB08              <1> 	shr	ebx, 8				; write back to registers only 00000000 thru 00FFFFFF
   133 00001614 895D00              <1> 	mov	dword ptr [rbp+R], ebx
   134 00001617 F6C101              <1> 	test	cl, 1
   135 0000161A 7551                <1> 	jnz	_j
   136 0000161C C3                  <1> 	ret
   137                              <1> 
   138 0000161D E85AFCFFFF          <1> _lcal:	call	stack1
   139 00001622 4C89E2              <1> 	mov	rdx, r12
   140 00001625 482B9690040000      <1> 	sub	rdx, qword ptr [rsi+B0P]
   141 0000162C 48C1EA02            <1> 	shr	rdx, 2
   142 00001630 89149E              <1> 	mov	dword ptr [rsi+rbx*4], edx
   143                              <1> 
   144                              <1> 	%if	0
   145                              <1> 	shl	rax, 2
   146                              <1> 	add	rax, qword ptr [rsi+B0P]
   147                              <1> 	mov	r12, rax
   148                              <1> 	ret
   149                              <1> 	%endif
   150                              <1> 
   151 00001633 EB38                <1> 	jmp	_j				; EA is in eax
   152                              <1> 
   153 00001635 F786B0040000010000- <1> _jnc:	test	dword ptr [rsi+PSR], 1
   153 0000163E 00                  <1>
   154 0000163F 742C                <1> 	jz	_j
   155 00001641 C3                  <1> 	ret
   156                              <1> 
   157 00001642 F786B0040000010000- <1> _jc:	test	dword ptr [rsi+PSR], 1
   157 0000164B 00                  <1>
   158 0000164C 751F                <1> 	jnz	_j
   159 0000164E C3                  <1> 	ret
   160                              <1> 
   161 0000164F F7451001000000      <1> _jao:	test	dword ptr [rbp+A], 1
   162 00001656 7515                <1> 	jnz	_j
   163 00001658 C3                  <1> 	ret
   164                              <1> 
   165 00001659 F7451000008000      <1> _jpa:	test	dword ptr [rbp+A], 00800000h
   166 00001660 740B                <1> 	jz	_j
   167 00001662 C3                  <1> 	ret
   168                              <1> 
   169 00001663 F7451400008000      <1> _jpb:	test	dword ptr [rbp+B], 00800000h
   170 0000166A 7401                <1> 	jz	_j
   171 0000166C C3                  <1> 	ret
   172                              <1> 
   173 0000166D 48C1E002            <1> _j:	shl	rax, 2
   174 00001671 48038690040000      <1> 	add	rax, qword ptr [rsi+B0P]
   175                              <1> 
   176                              <1> ;	cmp	rax, r13			; there is a range check on instr fetch but 
   177                              <1> ;	ja	_j_check			; if a jump goes wrong the come-from address
   178                              <1> 						; is more use in the interrupt frame
   179 00001678 4989C4              <1> 	mov	r12, rax			; than a wild go-to address
   180 0000167B C3                  <1> 	ret
   181                              <1> 
   182                              <1> _j_check:					; apc before is in rdx
   183                              <1> 						; restore updated apc
   184 0000167C B90E000000          <1> 	mov	ecx, LP_ADDRESS
   185 00001681 E9ADFAFFFF          <1> 	jmp	guard_ii_escape			; for interrupt come-from
   186                              <1> 
   187 00001686 E8D4100000          <1> _jpo:	call	NEAR _get_parity
   188 0000168B 7BE0                <1> 	jpo	_j
   189 0000168D C3                  <1> 	ret
   190                              <1> 
   191 0000168E 816510FFFFFF00      <1> _jza:	and	dword ptr [rbp+A], 00FFFFFFh
   192 00001695 74D6                <1> 	jz	_j
   193 00001697 C3                  <1> 	ret
   194                              <1> 
   195 00001698 816514FFFFFF00      <1> _jzb:	and	dword ptr [rbp+B], 00FFFFFFh
   196 0000169F 74CC                <1> 	jz	_j
   197 000016A1 C3                  <1> 	ret
   198                              <1> 
   199 000016A2 816510FFFFFF00      <1> _jnza:	and	dword ptr [rbp+A], 00FFFFFFh
   200 000016A9 75C2                <1> 	jnz	_j
   201 000016AB C3                  <1> 	ret
   202                              <1> 
   203 000016AC 816514FFFFFF00      <1> _jnzb:	and	dword ptr [rbp+B], 00FFFFFFh
   204 000016B3 75B8                <1> 	jnz	_j
   205 000016B5 C3                  <1> 	ret
   206                              <1> 
   207 000016B6 F7451000008000      <1> _jna:	test	dword ptr [rbp+A], 00800000h
   208 000016BD 75AE                <1> 	jnz	_j
   209 000016BF C3                  <1> 	ret
   210                              <1> 
   211 000016C0 F7451400008000      <1> _jnb:	test	dword ptr [rbp+B], 00800000h
   212 000016C7 75A4                <1> 	jnz	_j
   213 000016C9 C3                  <1> 	ret
   214                              <1> 
   215 000016CA 8B5D08              <1> _jxge:	mov	ebx, dword ptr [rbp+X]
   216 000016CD 2B5D00              <1> 	sub	ebx, dword ptr [rbp+R]
   217 000016D0 F7C300000001        <1> 	test	ebx, 01000000h		; microcarry?
   218 000016D6 7495                <1> 	jz	_j			; no:  x <  r,    jump
   219 000016D8 C3                  <1> 	ret				; yes: x >= r, no jump
   220                              <1> 
   221 000016D9 8B5D0C              <1> _jyge:	mov	ebx, dword ptr [rbp+Y]
   222 000016DC 2B5D00              <1> 	sub	ebx, dword ptr [rbp+R]
   223 000016DF F7C300000001        <1> 	test	ebx, 01000000h		; microcarry?
   224 000016E5 7486                <1> 	jz	_j			; no:  y <  r,    jump
   225 000016E7 C3                  <1> 	ret				; yes: y >= r, no jump
   226                              <1> 
   227 000016E8 BB04000000          <1> _qs:	mov	ebx, a
   228 000016ED E955EFFFFF          <1> 	jmp	_burst_write4
   229                              <1> 
   230 000016F2 BB04000000          <1> _ql:	mov	ebx, a
   231 000016F7 E9D1EDFFFF          <1> 	jmp	_burst_read4
   232                              <1> 
   233 000016FC E893FCFFFF          <1> _qpop:	call	stack_read4			; places 4 stack registers in the scope of burst write
   234 00001701 55                  <1> 	push	rbp
   235                              <1> 
   236 00001702 480F7EFD            <1> 	movq	rbp, mm7
   237                              <1> ;	mov	rbp, qword ptr [ebp+CORE_INDEX1] 
   238                              <1> 
   239 00001706 E83CEFFFFF          <1> 	call	_burst_write4
   240 0000170B 5D                  <1> 	pop	rbp
   241 0000170C C3                  <1> 	ret					; stack pointers are absolute
   242                              <1> 
   243 0000170D E80FFCFFFF          <1> _qpush:	call	stack4
   244 00001712 55                  <1> 	push	rbp
   245                              <1> 
   246 00001713 480F7EFD            <1> 	movq	rbp, mm7
   247                              <1> ;	mov	rbp, qword ptr [ebp+CORE_INDEX1]
   248 00001717 E8B1EDFFFF          <1> 	call	_burst_read4
   249 0000171C 5D                  <1> 	pop	rbp
   250 0000171D 67895D3C            <1> 	mov	dword ptr [ebp+S_P], ebx	; not done in stack4 in case
   251 00001721 C3                  <1> 	ret					; RTA1 sp is in the pushed frame
   252                              <1> 						; then it would pop wrong
   253 00001722 E892FCFFFF          <1> _dpop:	call	stack_read2
   254 00001727 55                  <1> 	push	rbp
   255                              <1> 
   256 00001728 480F7EFD            <1> 	movq	rbp, mm7
   257                              <1> ;	mov	rbp, qword ptr [ebp+CORE_INDEX1]
   258 0000172C E85BEFFFFF          <1> 	call	_burst_write2
   259 00001731 5D                  <1> 	pop	rbp
   260 00001732 C3                  <1> 	ret
   261                              <1> 
   262 00001733 E880EDFFFF          <1> _dpush:	call	_burst_read2			; do this before changing RTA1 sp
   263 00001738 89DA                <1> 	mov	edx, ebx			; in case that is in pushed pair
   264                              <1> 
   265 0000173A 480F7EFE            <1> 	movq	rsi, mm7
   266                              <1> ;	mov	rsi, qword ptr [rbp+CORE_INDEX1]
   267                              <1> 
   268 0000173E E892FBFFFF          <1> 	call	stack2				
   269 00001743 89549E04            <1> 	mov	dword ptr [rsi+rbx*4+4], edx	; stack the data
   270 00001747 89049E              <1> 	mov	dword ptr [rsi+rbx*4], eax
   271 0000174A C3                  <1> 	ret
   272                              <1> 
   273 0000174B E8AAEDFFFF          <1> _mta:	call	_operand_read
   274 00001750 334510              <1> 	xor	eax, dword ptr [rbp+A]
   275 00001753 234504              <1> 	and	eax, dword ptr [rbp+K]
   276 00001756 7504                <1> 	jnz	_mta_
   277 00001758 4983C404            <1> 	add	r12, 4		; k AND (a XOR operand) = 0, skip 1 instruction
   278 0000175C C3                  <1> _mta_:	ret
   279                              <1> 
   280 0000175D E856EDFFFF          <1> _dte:	call	_burst_read2
   281 00001762 334510              <1> 	xor	eax, dword ptr [rbp+A]
   282 00001765 7509                <1> 	jnz	_dte_
   283 00001767 335D14              <1> 	xor	ebx, dword ptr [rbp+B]
   284 0000176A 7504                <1> 	jnz	_dte_
   285 0000176C 4983C404            <1> 	add	r12, 4
   286 00001770 C3                  <1> _dte_:	ret	
   287                              <1> 
   288 00001771 8B9EB0040000        <1> _sc:	mov	ebx, dword ptr [rsi+PSR]
   289 00001777 83E301              <1> 	and	ebx, 1		; store carry 
   290 0000177A E93EEFFFFF          <1> 	jmp	_operand_write
   291                              <1> 
   292 0000177F E876EDFFFF          <1> _mlb:	call	_operand_read
   293 00001784 8B5D04              <1> 	mov	ebx, dword ptr [rbp+K]
   294 00001787 21D8                <1> 	and	eax, ebx
   295 00001789 81F3FFFFFF00        <1> 	xor	ebx, 00FFFFFFh
   296 0000178F 235D14              <1> 	and	ebx, dword ptr [rbp+B]
   297 00001792 09C3                <1> 	or	ebx, eax
   298 00001794 895D14              <1> 	mov	dword ptr [rbp+B], ebx	; b = (b AND (NOT k)) OR (operand AND k)
   299 00001797 C3                  <1> 	ret
   300                              <1> 
   301 00001798 BB04000000          <1> _ds:	mov	ebx, a
   302 0000179D E9EAEEFFFF          <1> 	jmp	_burst_write2
   303                              <1> 
   304 000017A2 E811EDFFFF          <1> _dl:	call	_burst_read2
   305 000017A7 895D14              <1> 	mov	dword ptr [rbp+B], ebx
   306 000017AA 894510              <1> 	mov	dword ptr [rbp+A], eax
   307 000017AD C3                  <1> 	ret
   308                              <1> 
   309 000017AE C3                  <1> _spare:	ret
   310                              <1> 
   311 000017AF E8ABF0FFFF          <1> _ex:	call	memory_read
   312                              <1> 
   313 000017B4 480F7EFE            <1> 	movq	rsi, mm7
   314                              <1> ;	mov	rsi, qword ptr [rbp+CORE_INDEX1]
   315                              <1> 
   316 000017B8 E9BDE9FFFF          <1> 	jmp	_execute
   317                              <1> 
   318 000017BD E8D9F0FFFF          <1> _ts:	call	memory_lock			; edi + rsi -> memory word
   319 000017C2 66B80080            <1> 	mov	ax, 08000h
   320 000017C6 668704B7            <1> 	xchg	ax, word ptr [rdi+rsi*4]	; swap -> t1 for 080 under lock
   321 000017CA 6621C0              <1> 	and	ax, ax
   322 000017CD 7804                <1> 	js	_ts___				; no action if already locked
   323                              <1> 
   324 000017CF 4983C404            <1> 	add	r12, 4				; skip if ms bit was clear before
   325                              <1> 
   326 000017D3 C3                  <1> _ts___:	ret
   327                              <1> 
   328                              <1> 
   329 000017D4 E893F0FFFF          <1> _sim:	call	memoreg				; edi -> device		edi <- NULL
   330                              <1> 						; rsi -> word	OR	ebx -> register
   331 000017D9 480F7EF9            <1> 	movq	rcx, mm7			; eax <- data
   332                              <1> ;	mov	ecx, dword ptr [rbp+CORE_INDEX1]
   333                              <1> 
   334 000017DD 66C1E008            <1> 	shl	ax, 8
   335 000017E1 8A81B2040000        <1> 	mov	al, byte ptr [rcx+PSR+2]
   336 000017E7 C1C803              <1> 	ror	eax, 3
   337 000017EA C0C003              <1> 	rol	al, 3
   338 000017ED 8881B2040000        <1> 	mov	byte ptr [rcx+PSR+2], al
   339 000017F3 C1E81D              <1> 	shr	eax, 32-3
   340                              <1> 
   341 000017F6 E94EF0FFFF          <1> 	jmp	memoreg_writeback
   342                              <1> 
   343 000017FB 4C89E2              <1> _call:	mov	rdx, r12				; copy [ pc -> ] in case the jump interrupts
   344 000017FE E8D2FAFFFF          <1> 	call	stack2					; frame
   345 00001803 482B9690040000      <1> 	sub	rdx, qword ptr [rsi+B0P]		; pc - page address on platform
   346 0000180A 48C1EA02            <1> 	shr	rdx, 2					; / 4 = RTA1 word offset
   347 0000180E 89549E04            <1> 	mov	dword ptr [rsi+rbx*4+1*4], edx		; -> stack frame + 1
   348 00001812 8B96B4040000        <1> 	mov	edx, dword ptr [rsi+B0_NAME]		; iframe name
   349 00001818 89149E              <1> 	mov	dword ptr [rsi+rbx*4], edx		; -> stack frame + 0
   350                              <1> 
   351 0000181B 4C89A680040000      <1> _go:	mov	qword ptr [rsi+APC], r12		; write back actual platform value up2 here
   352                              <1> 							; of emulated [ program counter -> ]
   353 00001822 E8D3ECFFFF          <1> 	call	_operand_read
   354                              <1> 
   355 00001827 480F7EFE            <1> 	movq	rsi, mm7
   356                              <1> ;	mov	rsi, qword ptr [rbp+CORE_INDEX1]	; regain core pointer
   357                              <1> 
   358 0000182B 89C2                <1> 	mov	edx, eax				; lookaside to calculate the vector
   359 0000182D A900008000          <1> 	test	eax, 00800000h				; gate?			
   360 00001832 7426                <1> 	jz	_go2_4k_frame				; one page fixed target iframe 
   361                              <1> 
   362 00001834 25FFFF7F00          <1> 	and	eax, 007FFFFFh				; read the gate constant / variable
   363 00001839 E87AECFFFF          <1> 	call	_burst_read2				; into eax : ebx
   364                              <1> 
   365 0000183E 480F7EFE            <1> 	movq	rsi, mm7
   366                              <1> ;	mov	rsi, qword ptr [rbp+CORE_INDEX1]	; retrieve core pointer
   367                              <1> 
   368 00001842 89C2                <1> 	mov	edx, eax				; page high index ++ word offset 6.18
   369 00001844 89D8                <1> 	mov	eax, ebx				; iframe name
   370 00001846 C1C20E              <1> 	rol	edx, 6+8				; roll down page high index + 2 flag bits
   371 00001849 89D3                <1> 	mov	ebx, edx				; instruction frame page high index
   372 0000184B 83E33F              <1> 	and	ebx, 63					; remove flag bits 
   373 0000184E 7405                <1> 	jz	_go_gate				; page high index zero -> one page iframe
   374 00001850 0D00008000          <1> 	or	eax, 00800000h				; two+ page iframe
   375                              <1> 
   376                              <1> _go_gate:
   377 00001855 C1EA0E              <1> 	shr	edx, 6+8				; net word offset
   378                              <1> 
   379 00001858 EB0D                <1> 	jmp	_go2_frame
   380                              <1> 	
   381                              <1> _go2_4k_frame:
   382 0000185A 83E23F              <1> 	and	edx, 63					; target is in 4k block, 64 vectors
   383 0000185D C1E806              <1> 	shr	eax, 6					; new b0_name
   384 00001860 25FFFF0000          <1> 	and	eax, 0000FFFFh				; bit 22 of GO / CALL word reserved
   385 00001865 31DB                <1> 	xor	ebx, ebx				; frame high page index
   386                              <1> 
   387                              <1> _go2_frame:
   388 00001867 F686B204000080      <1> 	test	byte ptr [rsi+PSR+2], 128		; already in interrupt code?
   389 0000186E 751C                <1> 	jnz	_go2_base_frame			 	; may branch into interrupt code
   390                              <1> 							; because already interrupt code
   391 00001870 89C1                <1> 	mov	ecx, eax				; iframe name
   392 00001872 81E1FFFF3F00        <1> 	and	ecx, 03FFFFFh				; minus flag bits
   393 00001878 2B8E00060000        <1> 	sub	ecx, dword ptr [rsi+IO_PORT+_APP_THRESHOLD]	; applications lower limit
   394 0000187E 7D0C                <1> 	jnl	_go2_base_frame				; you can
   395                              <1> 
   396 00001880 4C8BA680040000      <1> 	mov	r12, qword ptr [rsi+APC]		; you can't
   397 00001887 E9A2F8FFFF          <1> 	jmp	guard_ii_authority
   398                              <1> 
   399                              <1> _go2_base_frame:
   400                              <1> 
   401 0000188C 8986B4040000        <1> 	mov	dword ptr [rsi+B0_NAME], eax		; iframe name with flags
   402 00001892 25FFFF3F00          <1> 	and	eax, 003FFFFFh				; start page index without flags
   403 00001897 01C3                <1> 	add	ebx, eax				; iframe highest page
   404 00001899 899EE0050000        <1> 	mov	dword ptr [rsi+IO_PORT+_IFRAME_U], ebx	; port 64 <- iframe highest page
   405                              <1> 
   406 0000189F 8B8EE0060000        <1> 	mov	ecx, dword ptr [rsi+IO_PORT+_DEVICE]	; memory page high index
   407 000018A5 81E1FFFF3F00        <1> 	and	ecx, 003FFFFFh				; strip memory type bits
   408 000018AB 29D9                <1> 	sub	ecx, ebx				; iframe high page may be = not >
   409 000018AD 7911                <1> 	jns	_go2_frame_in_range			; you can
   410                              <1> 
   411 000018AF B90E000000          <1> 	mov	ecx, LP_ADDRESS
   412 000018B4 4C8BA680040000      <1> 	mov	r12, qword ptr [rsi+APC]		; you can't
   413 000018BB E973F8FFFF          <1> 	jmp	guard_ii_escape
   414                              <1> 
   415                              <1> _go2_frame_in_range:
   416                              <1> 
   417 000018C0 48C1E30C            <1> 	shl	rbx, 12					; multiply highest page by page size
   418 000018C4 4C8D2C9D[FC3F0000]  <1> 	lea	r13, [_memory+rbx*4+4095*4]		; last instruction word in iframe
   419                              <1> 							; higher = wrong
   420 000018CC 4C89AE88040000      <1> 	mov	qword ptr [rsi+APCZ], r13		; set execution limit pointer
   421                              <1> 
   422 000018D3 8986E0040000        <1> 	mov	dword ptr [rsi+IO_PORT], eax		; write B0 <- iframe start page index
   423 000018D9 48C1E00E            <1> 	shl	rax, 12+2				; 4kword block multiplied by 4 for word
   424 000018DD 4805[00000000]      <1> 	add	rax, _memory				; add the platform location of executable space
   425 000018E3 48898690040000      <1> 	mov	qword ptr [rsi+B0P], rax		; store address in platform of B0 page start
   426 000018EA C1E202              <1> 	shl	edx, 2					; add the vector offset * 4 for word
   427 000018ED 4801C2              <1> 	add	rdx, rax				; absolute apc + _memory
   428 000018F0 4989D4              <1> 	mov	r12, rdx
   429 000018F3 C3                  <1> _go_:	ret
   430                              <1> 
    41                                  	%include	"alu.msm"
     1                              <1> 
     2                              <1> 
     3 000018F4 E801ECFFFF          <1> _ax:	call	_operand_read
     4 000018F9 034508              <1> 	add	eax, dword ptr [rbp+X]
     5 000018FC 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
     6 00001901 894508              <1> 	mov	dword ptr [rbp+X], eax
     7 00001904 C3                  <1> 	ret
     8                              <1> 
     9 00001905 E8F0EBFFFF          <1> _ay:	call	_operand_read
    10 0000190A 03450C              <1> 	add	eax, dword ptr [rbp+Y]
    11 0000190D 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
    12 00001912 89450C              <1> 	mov	dword ptr [rbp+Y], eax
    13 00001915 C3                  <1> 	ret
    14                              <1> 
    15 00001916 E8DFEBFFFF          <1> _or:	call	_operand_read
    16 0000191B 094510              <1> 	or	dword ptr [rbp+A], eax
    17 0000191E C3                  <1> 	ret
    18                              <1> 
    19 0000191F E8D6EBFFFF          <1> _orB:	call	_operand_read
    20 00001924 094514              <1> 	or	dword ptr [rbp+B], eax
    21 00001927 C3                  <1> 	ret
    22                              <1> 
    23 00001928 E8CDEBFFFF          <1> _and:	call	_operand_read
    24 0000192D 214510              <1> 	and	dword ptr [rbp+A], eax
    25 00001930 C3                  <1> 	ret
    26                              <1> 
    27 00001931 E8C4EBFFFF          <1> _andB:	call	_operand_read
    28 00001936 214514              <1> 	and	dword ptr [rbp+B], eax
    29 00001939 C3                  <1> 	ret
    30                              <1> 
    31 0000193A E8BBEBFFFF          <1> _xor:	call	_operand_read
    32 0000193F 314510              <1> 	xor	dword ptr [rbp+A], eax
    33 00001942 C3                  <1> 	ret
    34                              <1> 
    35 00001943 E8B2EBFFFF          <1> _xorB:	call	_operand_read
    36 00001948 314514              <1> 	xor	dword ptr [rbp+B], eax
    37 0000194B C3                  <1> 	ret
    38                              <1> 
    39 0000194C E8A9EBFFFF          <1> _aa:	call	_operand_read
    40 00001951 EB0D                <1> 	jmp	_aa_
    41                              <1> 
    42 00001953 E8A2EBFFFF          <1> _ana:	call	_operand_read
    43 00001958 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
    44 0000195D 83C001              <1> 	add	eax, 1
    45                              <1> 
    46 00001960 034510              <1> _aa_:	add	eax, dword ptr [rbp+A]
    47 00001963 E8B9040000          <1> 	call	_alu_carry
    48                              <1> 
    49 00001968 894510              <1> 	mov	dword ptr [rbp+A], eax
    50 0000196B C3                  <1> 	ret
    51                              <1> 
    52 0000196C E889EBFFFF          <1> _ab:	call	_operand_read
    53 00001971 EB0D                <1> 	jmp	_ab_
    54                              <1> 
    55 00001973 E882EBFFFF          <1> _anb:	call	_operand_read
    56 00001978 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
    57 0000197D 83C001              <1> 	add	eax, 1
    58                              <1> 
    59 00001980 034514              <1> _ab_:	add	eax, dword ptr [rbp+B]
    60 00001983 E899040000          <1> 	call	_alu_carry
    61                              <1> 
    62 00001988 894514              <1> 	mov	dword ptr [rbp+B], eax
    63 0000198B C3                  <1> 	ret
    64                              <1> 
    65                              <1> _m:
    66                              <1> ;	push	rdx			; 80386 platform has it ready made, so
    67 0000198C E869EBFFFF          <1> 	call	_operand_read
    68 00001991 C1E008              <1> 	shl	eax, 8			; prepare multiplier to be multiplicand 
    69 00001994 C1F808              <1> 	sar	eax, 8			; sign it in eax
    70 00001997 8B5D14              <1> 	mov	ebx, dword ptr [rbp+B]	; this is register side multiplicand but
    71                              <1> 					; it makes no difference which is which
    72 0000199A C1E308              <1> 	shl	ebx, 8			; so use it as multiplier if that is OK
    73 0000199D C1FB08              <1> 	sar	ebx, 8			; sign it first
    74                              <1> 
    75 000019A0 F7EB                <1> 	imul	ebx
    76                              <1> 
    77 000019A2 C1C008              <1> 	rol	eax, 8			; move 8 bits up from eax to edx
    78 000019A5 C1E208              <1> 	shl	edx, 8
    79 000019A8 88C2                <1> 	mov	dl, al
    80 000019AA C1E808              <1> 	shr	eax, 8
    81 000019AD 894514              <1> 	mov	dword ptr [rbp+B], eax	; product bits 23..0
    82 000019B0 C1E208              <1> 	shl	edx, 8
    83 000019B3 C1EA08              <1> 	shr	edx, 8
    84 000019B6 895510              <1> 	mov	dword ptr [rbp+A], edx	; product high order bits
    85                              <1> ;	pop	rdx
    86 000019B9 C3                  <1> 	ret
    87                              <1> 
    88                              <1> _mf:
    89                              <1> ;	push	rdx		; the multiplier is signed the multiplicand unsigned
    90 000019BA E83BEBFFFF          <1> 	call	_operand_read
    91 000019BF 89C1                <1> 	mov	ecx, eax	; just to remember the multiplier sign
    92 000019C1 A900008000          <1> 	test	eax, 00800000h
    93 000019C6 7408                <1> 	jz	_mfplusplus
    94 000019C8 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
    95 000019CD 83C001              <1> 	add	eax, 1
    96                              <1> _mfplusplus:
    97 000019D0 8B5D14              <1> 	mov	ebx, dword ptr [rbp+B]	; this is the multiplicand, unsigned
    98 000019D3 F7E3                <1> 	mul	ebx		; two 24-bit unsigned values should be OK here
    99 000019D5 C1C008              <1> 	rol	eax, 8
   100 000019D8 C1E208              <1> 	shl	edx, 8
   101 000019DB 88C2                <1> 	mov	dl, al
   102 000019DD C1E808              <1> 	shr	eax, 8
   103 000019E0 C1E208              <1> 	shl	edx, 8
   104 000019E3 C1EA08              <1> 	shr	edx, 8
   105 000019E6 F7C100008000        <1> 	test	ecx, 00800000h	; was the multiplier signed?
   106 000019EC 741F                <1> 	jz	_mfstore
   107 000019EE 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   108 000019F3 81F2FFFFFF00        <1> 	xor	edx, 00FFFFFFh
   109 000019F9 83C001              <1> 	add	eax, 1
   110 000019FC C1C008              <1> 	rol	eax, 8
   111 000019FF 0FB6C8              <1> 	movzx	ecx, al
   112 00001A02 C1E808              <1> 	shr	eax, 8
   113 00001A05 01CA                <1> 	add	edx, ecx
   114 00001A07 81E2FFFFFF00        <1> 	and	edx, 00FFFFFFh
   115                              <1> _mfstore:
   116 00001A0D 894514              <1> 	mov	dword ptr [rbp+B], eax
   117 00001A10 895510              <1> 	mov	dword ptr [rbp+A], edx
   118                              <1> ;	pop	rdx
   119 00001A13 C3                  <1> 	ret
   120                              <1> 
   121 00001A14 BF04000000          <1> _d:	mov	rdi, a
   122 00001A19 E80A000000          <1> 	call	_divide
   123 00001A1E 895D10              <1> 	mov	dword ptr [rbp+A], ebx
   124 00001A21 894518              <1> 	mov	dword ptr [rbp+MANTISSA2], eax
   125 00001A24 894D14              <1> 	mov	dword ptr [rbp+B], ecx
   126 00001A27 C3                  <1> 	ret
   127                              <1> 
   128                              <1> 	%if	1
   129                              <1> 
   130                              <1> ;	this divide made from 2 Intel divides should be a better method
   131                              <1> ;	than the procession of 1-bit shifts and test subtracts
   132                              <1> ;	which is the %else which it replaces. That also works
   133                              <1> 
   134                              <1> ;	this converts to and from positive magnitude
   135                              <1> ;	because zoning the 2nd divide with a zero 1st remainder
   136                              <1> ;	can't tell +0 from -0 in platform 2s complement
   137                              <1> 
   138                              <1> ;	polarity conversions before and after need no explanation
   139                              <1> 
   140                              <1> ;	1st dividend is 48 zero bits and high order 16 data bits
   141                              <1> ;	of the the 48-bit RTA1 dividend
   142                              <1> 
   143                              <1> ;	2nd dividend is 1st remainder and the remaining 32 bits
   144                              <1> ;	the the RTA1 dividend
   145                              <1> 
   146                              <1> ;	input is compressed from 24-bit words and output unpacked
   147                              <1> ;	to 24-bit words
   148                              <1> 
   149                              <1> ;	64-bit dividend in 386 mode is high order bits in edx, low in eax
   150                              <1> ;	platform faults if quotient carries from eax. Remainder in edx
   151                              <1> 
   152                              <1> ;	RTA1 quotient is 48 bits so it takes 2 divides in 32-bit mode
   153                              <1> 
   154                              <1> _divide:
   155                              <1> ;	push	edx
   156 00001A28 57                  <1> 	push	rdi
   157 00001A29 E8CCEAFFFF          <1> 	call	_operand_read	; read divisor
   158 00001A2E 5F                  <1> 	pop	rdi
   159 00001A2F 31C9                <1> 	xor	ecx, ecx	; final sign
   160 00001A31 A900008000          <1> 	test	eax, 00800000h
   161 00001A36 7409                <1> 	jz	_dsig?
   162 00001A38 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   163 00001A3D F7D1                <1> 	not	ecx		; reverse final sign
   164 00001A3F FFC0                <1> 	inc	eax
   165 00001A41 25FFFFFF00          <1> _dsig?:	and	eax, 00FFFFFFh	; check zerodiv here mebbes
   166 00001A46 89C3                <1> 	mov	ebx, eax	; eax will be used twice as divisor LS word
   167 00001A48 746E                <1> 	jz	_d_ont		; zero results in eax ebx already
   168                              <1> 
   169 00001A4A 8B44BD04            <1> 	mov	eax, dword ptr [rbp+rdi*4+4]
   170 00001A4E 8B54BD00            <1> 	mov	edx, dword ptr [rbp+rdi*4]
   171 00001A52 C1E008              <1> 	shl	eax, 8		; pack two 24-bit words to 64 bits 
   172 00001A55 88D0                <1> 	mov	al, dl
   173 00001A57 C1C808              <1> 	ror	eax, 8
   174 00001A5A C1E208              <1> 	shl	edx, 8
   175 00001A5D C1EA10              <1> 	shr	edx, 16
   176 00001A60 6689D1              <1> 	mov	cx, dx		; save dividend sign
   177 00001A63 6621D2              <1> 	and	dx, dx		; bit 47 on?
   178 00001A66 7912                <1> 	jns	_dive_in
   179                              <1> 
   180 00001A68 81F10000FFFF        <1> 	xor	ecx, 0FFFF0000h	; reverse final sign
   181 00001A6E F7D0                <1> 	not	eax
   182 00001A70 66F7D2              <1> 	not	dx
   183 00001A73 83C001              <1> 	add	eax, 1
   184 00001A76 6683D200            <1> 	adc	dx, 0
   185                              <1> 
   186                              <1> _dive_in:
   187 00001A7A 89C6                <1> 	mov	esi, eax	; reserve 2nd dividend
   188 00001A7C 89D0                <1> 	mov	eax, edx	; position 1st dividend
   189 00001A7E 31D2                <1> 	xor	edx, edx	; with leading zero
   190 00001A80 F7F3                <1> 	div	ebx
   191 00001A82 96                  <1> 	xchg	eax, esi	; save 1st quotient
   192 00001A83 F7F3                <1> 	div	ebx		; generate 2nd quotient
   193                              <1> 
   194 00001A85 6621C9              <1> 	and	cx, cx		; dividend negative?
   195 00001A88 7904                <1> 	jns	_d_remainder_plus
   196 00001A8A F7D2                <1> 	not	edx
   197 00001A8C FFC2                <1> 	inc	edx
   198                              <1> 
   199                              <1> _d_remainder_plus:
   200 00001A8E 81E2FFFFFF00        <1> 	and	edx, 00FFFFFFh
   201 00001A94 87D1                <1> 	xchg	edx, ecx	; remainder -> ecx / final sign -> edx
   202                              <1> 
   203 00001A96 89C3                <1> 	mov	ebx, eax	; low order quotient
   204 00001A98 89F0                <1> 	mov	eax, esi	; high order quotient
   205                              <1> 
   206 00001A9A 21D2                <1> 	and	edx, edx	; final sign?
   207 00001A9C 790C                <1> 	jns	_d_quotient_plus
   208                              <1> 
   209 00001A9E F7D3                <1> 	not	ebx		; invert + increment quotient
   210 00001AA0 66F7D0              <1> 	not	ax		; RTA1 integer is also 2s complement
   211 00001AA3 83C301              <1> 	add	ebx, 1
   212 00001AA6 6683D000            <1> 	adc	ax, 0
   213                              <1> 
   214                              <1> _d_quotient_plus:
   215 00001AAA 0FB7C0              <1> 	movzx	eax, ax		; unpack from 32-bit words to 24-bit words
   216 00001AAD C1E008              <1> 	shl	eax, 8		; move 8 bits up
   217 00001AB0 C1C308              <1> 	rol	ebx, 8
   218 00001AB3 88D8                <1> 	mov	al, bl
   219 00001AB5 C1EB08              <1> 	shr	ebx, 8		; quotient in eax:ebx
   220                              <1> 
   221                              <1> _d_ont:
   222                              <1> ;	pop	edx		; give back the emulated program counter
   223 00001AB8 C3                  <1> 	ret
   224                              <1> 
   225                              <1> 	%else
   226                              <1> 
   227                              <1> _divide:
   228                              <1> 	xor	ebx, ebx
   229                              <1> 	push	ebx		;
   230                              <1> 	push	ebx		; quotient
   231                              <1> 	push	ebx		; dividend[b]
   232                              <1> 	push	ebx		; dividend[a]
   233                              <1> 	push	ebx		; trailing divisor
   234                              <1> 	push	ebx		; divisor
   235                              <1> 	push	ebx		; signs2 
   236                              <1> 	push	ebx		; signs1
   237                              <1> 	mov	ebx, 24
   238                              <1> 	push	ebx		; beats
   239                              <1> 
   240                              <1> 
   241                              <1> _D_BEATS	equ	0
   242                              <1> _D_SIGNS1	equ	1*4
   243                              <1> _D_SIGNS2	equ	2*4
   244                              <1> _D_DIVISORU	equ	3*4
   245                              <1> _D_DIVISORL	equ	4*4
   246                              <1> _D_DIVIDENDU	equ	5*4
   247                              <1> _D_DIVIDENDL	equ	6*4
   248                              <1> _D_QUOTIENTU	equ	7*4
   249                              <1> _D_QUOTIENTL	equ	8*4
   250                              <1> 
   251                              <1> 	push	edi
   252                              <1> 	call	_operand_read
   253                              <1> 	pop	edi
   254                              <1> 
   255                              <1> 	test	eax, 00800000h
   256                              <1> 	jnz	_d_nmagnitude1			; must be stored negative
   257                              <1> 	xor	eax, 00FFFFFFh
   258                              <1> 	jmp	_d_nmagnitude2
   259                              <1> _d_nmagnitude1:
   260                              <1> 	add	eax, -1				; if it's already negative
   261                              <1> 	mov	dword ptr [rsp+_D_SIGNS2], 0FFFFFFFFh
   262                              <1> _d_nmagnitude2:
   263                              <1> 	call	qscale
   264                              <1> 	cmp	bl, 24
   265                              <1> 	jz	_d_allsigns
   266                              <1> 	add	dword ptr [rsp+_D_BEATS], ebx
   267                              <1> _d_allsigns:
   268                              <1> 	mov	ebx, 00FFFFFF00h ; make the divisor 48 bits contiguous	
   269                              <1> 	mov	bl, al
   270                              <1> 	ror	ebx, 8
   271                              <1> 	shl	eax, 8
   272                              <1> 	mov	ax, 65535
   273                              <1> 	ror	eax, 16
   274                              <1> 
   275                              <1> 	mov	dword ptr [rsp+_D_DIVISORL], ebx
   276                              <1> 	mov	dword ptr [rsp+_D_DIVISORU], eax
   277                              <1> 
   278                              <1> 	mov	ecx, 1				; precarry
   279                              <1> 
   280                              <1> ;	mov	ebx, dword ptr [rbp+B]	; dividend
   281                              <1> ;	mov	eax, dword ptr [rbp+A]
   282                              <1> 
   283                              <1> 	mov	ebx, dword ptr [rbp+edi*4+4]
   284                              <1> 	mov	eax, dword ptr [rbp+edi*4] 
   285                              <1> 
   286                              <1> 	test	eax, 00800000h
   287                              <1> 	jz	_d_pmagnitude			; must be stored positive
   288                              <1> 	mov	dword ptr [rsp+_D_SIGNS1], 00FFFFFFFFh
   289                              <1> 	xor	ebx, 00FFFFFFh
   290                              <1> 	xor	eax, 00FFFFFFh
   291                              <1> 	add	ecx, ebx
   292                              <1> 	mov	ebx, ecx
   293                              <1> 	and	ebx, 00FFFFFFh
   294                              <1> 	shr	ecx, 24
   295                              <1> 	add	eax, ecx
   296                              <1> 	and	eax, 00FFFFFFh
   297                              <1> 
   298                              <1> _d_pmagnitude:
   299                              <1> 	shl	ebx, 8
   300                              <1> 	mov	bl, al
   301                              <1> 	ror	ebx, 8
   302                              <1> 	shl	eax, 8
   303                              <1> 	shr	eax, 16
   304                              <1> 	mov	dword ptr [rsp+_D_DIVIDENDL], ebx
   305                              <1> 	mov	dword ptr [rsp+_D_DIVIDENDU], eax
   306                              <1> 
   307                              <1> 	mov	ecx, dword ptr [rsp+_D_BEATS]
   308                              <1> 
   309                              <1> 	add	ecx, -1
   310                              <1> _d_beat:			; iterative part as quick as possible
   311                              <1> 				; could study doing a pair of Intel divides here
   312                              <1> 	stc
   313                              <1> 	rcr	dword ptr [rsp+_D_DIVISORU], 1
   314                              <1> 	rcr	dword ptr [rsp+_D_DIVISORL], 1
   315                              <1> 
   316                              <1> 	stc
   317                              <1> 	adc	ebx, dword ptr [rsp+_D_DIVISORL]
   318                              <1> 	adc	eax, dword ptr [rsp+_D_DIVISORU]
   319                              <1> 
   320                              <1> 	jc	_d_carried
   321                              <1> 	mov	ebx, dword ptr [rsp+_D_DIVIDENDL]
   322                              <1> 	mov	eax, dword ptr [rsp+_D_DIVIDENDU]
   323                              <1> 	jmp	_d_carried_or_not
   324                              <1> 
   325                              <1> _d_carried:
   326                              <1> 	mov	dword ptr [rsp+_D_DIVIDENDL], ebx
   327                              <1> 	mov	dword ptr [rsp+_D_DIVIDENDU], eax
   328                              <1> 
   329                              <1> _d_carried_or_not:
   330                              <1> 	rcl	dword ptr [rsp+_D_QUOTIENTL], 1
   331                              <1> 	rcl	dword ptr [rsp+_D_QUOTIENTU], 1
   332                              <1> 	
   333                              <1> 	add	ecx, -1
   334                              <1> 	jc	_d_beat
   335                              <1> 
   336                              <1> 	pop	ecx		; BEATS
   337                              <1> 	pop	ecx		; SIGNS1
   338                              <1> 	pop	eax		; SIGNS2
   339                              <1> 	pop	ebx		; DIVISORU
   340                              <1> 	pop	ebx		; DIVISORL
   341                              <1> 	pop	ebx		; DIVIDENDU
   342                              <1> 	pop	ebx		; DIVIDENDL
   343                              <1> 
   344                              <1> 	xor	ebx, ecx	; set remainder to sign of dividend
   345                              <1> 	jns	_d_remplus
   346                              <1> 	inc	ebx		; set -remainder 2s complement
   347                              <1> 
   348                              <1> _d_remplus:
   349                              <1> 	and	ebx, 00FFFFFFh	; store remainder
   350                              <1> ;	mov	dword ptr [rbp+B], ebx
   351                              <1> 
   352                              <1> 	xor	ecx, eax	; set sign of quotient to difference of signs
   353                              <1> 	mov	ecx, ebx	; remainder for return
   354                              <1> 	pop	eax		; QUOTIENTU
   355                              <1> 	pop	ebx		; QUOTIENTL
   356                              <1> 
   357                              <1> 	jns	_d_quotient_plus		; cc set from xor of signy
   358                              <1> 
   359                              <1> 	not	eax
   360                              <1> 	not	ebx
   361                              <1> 	add	ebx, 1
   362                              <1> 	adc	eax, 0
   363                              <1> 
   364                              <1> _d_quotient_plus:
   365                              <1> 	shl	eax, 8
   366                              <1> 	rol	ebx, 8
   367                              <1> 	mov	al, bl
   368                              <1> 	shr	ebx, 8
   369                              <1> 	shl	eax, 8
   370                              <1> 	shr	eax, 8
   371                              <1> 
   372                              <1> ;	mov	dword ptr [rbp+A], ebx
   373                              <1> ;	mov	dword ptr [rbp+MANTISSA2], eax
   374                              <1> 	ret
   375                              <1> 
   376                              <1> 	%endif
   377                              <1> 
   378                              <1> 
   379 00001AB9 88C1                <1> _sar:	mov	cl, al			; eax shift radix is 31
   380 00001ABB 8B4510              <1> 	mov	eax, dword ptr [rbp+A]
   381 00001ABE F6C1E0              <1> 	test	cl, -32
   382 00001AC1 7402                <1> 	jz	_sardo
   383 00001AC3 31C0                <1> 	xor	eax, eax		; shift 32+ clears same as 24+
   384 00001AC5 D3E8                <1> _sardo:	shr	eax, cl
   385 00001AC7 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   386 00001ACC 894510              <1> 	mov	dword ptr [rbp+A], eax
   387 00001ACF C3                  <1> 	ret
   388                              <1> 
   389 00001AD0 88C1                <1> _sbr:	mov	cl, al
   390 00001AD2 8B4514              <1> 	mov	eax, dword ptr [rbp+B]
   391 00001AD5 F6C1E0              <1> 	test	cl, -32
   392 00001AD8 7402                <1> 	jz	_sbrdo
   393 00001ADA 31C0                <1> 	xor	eax, eax		; shift 32+ clears same as 24+
   394 00001ADC D3E8                <1> _sbrdo:	shr	eax, cl
   395 00001ADE 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   396 00001AE3 894514              <1> 	mov	dword ptr [rbp+B], eax
   397 00001AE6 C3                  <1> 	ret
   398                              <1> 
   399                              <1> 
   400 00001AE7 88C1                <1> _dsr:	mov	cl, al
   401 00001AE9 8B5D14              <1> 	mov	ebx, dword ptr [rbp+B]
   402 00001AEC 8B4510              <1> 	mov	eax, dword ptr [rbp+A]
   403 00001AEF E875000000          <1> 	call	dsr
   404 00001AF4 895D14              <1> 	mov	dword ptr [rbp+B], ebx
   405 00001AF7 894510              <1> 	mov	dword ptr [rbp+A], eax
   406 00001AFA C3                  <1> 	ret
   407                              <1> 
   408 00001AFB 88C1                <1> _sal:	mov	cl, al			; shift radix eax is 31
   409 00001AFD 8B4510              <1> 	mov	eax, dword ptr [rbp+A]
   410 00001B00 F6C1E0              <1> 	test	cl, -32
   411 00001B03 7402                <1> 	jz	_saldo
   412 00001B05 31C0                <1> 	xor	eax, eax		; shift 32+ clears same as 24+
   413 00001B07 D3E0                <1> _saldo:	shl	eax, cl
   414 00001B09 25FFFFFF00          <1> 	and	eax, 00FFFFFFh		; write back to registers only 00000000 thru 00FFFFFF
   415 00001B0E 894510              <1> 	mov	dword ptr [rbp+A], eax
   416 00001B11 C3                  <1> 	ret
   417                              <1> 
   418 00001B12 88C1                <1> _sbl:	mov	cl, al
   419 00001B14 8B4514              <1> 	mov	eax, dword ptr [rbp+B]
   420 00001B17 F6C1E0              <1> 	test	cl,-32
   421 00001B1A 7402                <1> 	jz	_sbldo
   422 00001B1C 31C0                <1> 	xor	eax, eax		; shift 32+ clears same as 24+
   423 00001B1E D3E0                <1> _sbldo:	shl	eax, cl
   424 00001B20 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   425 00001B25 894514              <1> 	mov	dword ptr [rbp+B], eax
   426 00001B28 C3                  <1> 	ret
   427                              <1> 
   428 00001B29 88C1                <1> _dsl	mov	cl, al
   429 00001B2B 8B5D14              <1> 	mov	ebx, dword ptr [rbp+B]
   430 00001B2E 8B4510              <1> 	mov	eax, dword ptr [rbp+A]
   431 00001B31 E868000000          <1> 	call	dsl
   432 00001B36 895D14              <1> 	mov	dword ptr [rbp+B], ebx
   433 00001B39 894510              <1> 	mov	dword ptr [rbp+A], eax
   434 00001B3C C3                  <1> 	ret
   435                              <1> 
   436 00001B3D 8B5D10              <1> _rar:	mov	ebx, dword ptr [rbp+A]
   437 00001B40 E8C6000000          <1> 	call	rr
   438 00001B45 895D10              <1> 	mov	dword ptr [rbp+A], ebx
   439 00001B48 C3                  <1> 	ret
   440                              <1> 
   441 00001B49 8B5D14              <1> _rbr:	mov	ebx, dword ptr [rbp+B]
   442 00001B4C E8BA000000          <1> 	call	rr
   443 00001B51 895D14              <1> 	mov	dword ptr [rbp+B], ebx
   444 00001B54 C3                  <1> 	ret
   445                              <1> 
   446 00001B55 88C1                <1> _drr:	mov	cl, al
   447 00001B57 8B5D14              <1> 	mov	ebx, dword ptr [rbp+B]
   448 00001B5A 8B4510              <1> 	mov	eax, dword ptr [rbp+A]
   449 00001B5D E8F7000000          <1> 	call	drr
   450 00001B62 895D14              <1> 	mov	dword ptr [rbp+B], ebx
   451 00001B65 894510              <1> 	mov	dword ptr [rbp+A], eax
   452 00001B68 C3                  <1> 	ret
   453                              <1> 
   454                              <1> 
   455 00001B69 C1E008              <1> dsr:	shl	eax, 8
   456 00001B6C C1E308              <1> 	shl	ebx, 8
   457 00001B6F 80C1E8              <1> dsru:	add	cl, -24
   458 00001B72 7306                <1> 	jnc	dsrl
   459 00001B74 89C3                <1> 	mov	ebx, eax
   460 00001B76 31C0                <1> 	xor	eax, eax
   461 00001B78 EBF5                <1> 	jmp	dsru
   462 00001B7A 80C110              <1> dsrl:	add	cl, 16
   463 00001B7D 730D                <1> 	jnc	dsr7
   464 00001B7F C1E808              <1> dsr8:	shr	eax, 8
   465 00001B82 88C3                <1> 	mov	bl, al
   466 00001B84 C1CB08              <1> 	ror	ebx, 8
   467 00001B87 80C1F8              <1> 	add	cl,-8
   468 00001B8A 72F3                <1> 	jc	dsr8
   469 00001B8C 80E107              <1> dsr7:	and	cl, 7
   470 00001B8F D3E8                <1> 	shr	eax, cl
   471 00001B91 88C3                <1> 	mov	bl, al		; bits from al in high-order positions bl
   472 00001B93 D2C3                <1> 	rol	bl, cl		; roll them to low-order positions
   473 00001B95 D3CB                <1> 	ror	ebx, cl
   474 00001B97 C1EB08              <1> 	shr	ebx, 8
   475 00001B9A C1E808              <1> 	shr	eax, 8
   476 00001B9D C3                  <1> 	ret
   477                              <1> 
   478 00001B9E C1E008              <1> dsl:	shl	eax, 8
   479 00001BA1 C1E308              <1> 	shl	ebx, 8
   480 00001BA4 80C1E8              <1> dslu:	add	cl, -24
   481 00001BA7 7306                <1> 	jnc	dsll
   482 00001BA9 89D8                <1> 	mov	eax, ebx
   483 00001BAB 31DB                <1> 	xor	ebx, ebx
   484 00001BAD EBF5                <1> 	jmp	dslu
   485 00001BAF 80C110              <1> dsll:	add	cl, 16
   486 00001BB2 730F                <1> 	jnc	dsl7
   487 00001BB4 C1C308              <1> dsl8:	rol	ebx, 8
   488 00001BB7 88D8                <1> 	mov	al, bl
   489 00001BB9 30DB                <1> 	xor	bl, bl
   490 00001BBB C1E008              <1> 	shl	eax, 8
   491 00001BBE 80C1F8              <1> 	add	cl, -8
   492 00001BC1 72F1                <1> 	jc	dsl8
   493 00001BC3 80E107              <1> dsl7:	and	cl, 7
   494 00001BC6 D3C3                <1> 	rol	ebx, cl
   495 00001BC8 88D8                <1> 	mov	al, bl		; bits from bl in low-order positions al
   496 00001BCA D2C8                <1> 	ror	al, cl		; roll them to high-order positions
   497 00001BCC D3E0                <1> 	shl	eax, cl
   498 00001BCE C1EB08              <1> 	shr	ebx, 8
   499 00001BD1 C1E808              <1> 	shr	eax, 8
   500 00001BD4 C3                  <1> 	ret
   501                              <1> 
   502 00001BD5 C1E008              <1> dsa:	shl	eax, 8
   503 00001BD8 C1E308              <1> 	shl	ebx, 8
   504 00001BDB 80C1E8              <1> dsa24:	add	cl, -24
   505 00001BDE 7307                <1> 	jnc	dsa16
   506 00001BE0 89C3                <1> 	mov	ebx, eax
   507 00001BE2 C1F818              <1> 	sar	eax, 24
   508 00001BE5 EBF4                <1> 	jmp	dsa24
   509 00001BE7 80C110              <1> dsa16:	add	cl, 16
   510 00001BEA 730D                <1> 	jnc	dsa7
   511 00001BEC C1F808              <1> dsa8:	sar	eax, 8
   512 00001BEF 88C3                <1> 	mov	bl, al
   513 00001BF1 C1CB08              <1> 	ror	ebx, 8
   514 00001BF4 80C1F8              <1> 	add	cl, -8
   515 00001BF7 72F3                <1> 	jc	dsa8
   516 00001BF9 80E107              <1> dsa7:	and	cl, 7
   517 00001BFC D3F8                <1> 	sar	eax, cl
   518 00001BFE 88C3                <1> 	mov	bl, al		; bits from al in high-order positions bl
   519 00001C00 D2C3                <1> 	rol	bl, cl		; roll them to low-order positions
   520 00001C02 D3CB                <1> 	ror	ebx, cl
   521 00001C04 C1E808              <1> 	shr	eax, 8
   522 00001C07 C1EB08              <1> 	shr	ebx, 8
   523 00001C0A C3                  <1> 	ret	
   524                              <1> 
   525                              <1> 
   526 00001C0B 88C1                <1> rr:	mov	cl, al
   527 00001C0D C1E308              <1> 	shl	ebx, 8
   528 00001C10 F6C118              <1> 	test	cl, 24		; bits 16:8 are self-cancelling
   529 00001C13 7A11                <1> 	jpe	rr7
   530 00001C15 F6C110              <1> 	test	cl, 16
   531 00001C18 7407                <1> 	jz	rr8		; 16 is off so 8 is on
   532 00001C1A C1C308              <1> 	rol	ebx, 8		; 8 left in 24-bit ring = 16 right
   533 00001C1D 88DF                <1> 	mov	bh, bl		; compress 32-bit ring to 24-bit
   534 00001C1F EB05                <1> 	jmp	short rr7
   535 00001C21 88FB                <1> rr8:	mov	bl, bh		; extend 24-bit ring to 32-bit
   536 00001C23 C1CB08              <1> 	ror	ebx, 8
   537 00001C26 80E107              <1> rr7:	and	cl, 7		; isolate remaining count bits
   538 00001C29 88FB                <1> 	mov	bl, bh		; don't ask, just do it
   539 00001C2B D3CB                <1> 	ror	ebx, cl
   540 00001C2D C1EB08              <1> 	shr	ebx, 8
   541 00001C30 C3                  <1> 	ret
   542                              <1> 
   543 00001C31 88C1                <1> rl:	mov	cl, al
   544 00001C33 C1E308              <1> 	shl	ebx, 8
   545 00001C36 F6C118              <1> 	test	cl, 24		; bits 16:8 are self-cancelling
   546 00001C39 7A11                <1> 	jpe	rl7
   547 00001C3B F6C110              <1> 	test	cl, 16
   548 00001C3E 7407                <1> 	jz	rl8		; 16 is off so 8 is on
   549 00001C40 88FB                <1> 	mov	bl, bh		; extend 24-bit ring to 32-bit
   550 00001C42 C1CB08              <1> 	ror	ebx, 8		; 8 right in 24-bit ring = 16 left
   551 00001C45 EB05                <1> 	jmp	short rl7
   552 00001C47 C1C308              <1> rl8:	rol	ebx, 8
   553 00001C4A 88DF                <1> 	mov	bh, bl		; compress 32-bit ring to 24-bit	
   554 00001C4C 80E107              <1> rl7:	and	cl, 7
   555 00001C4F 30DB                <1> 	xor	bl, bl
   556 00001C51 D3C3                <1> 	rol	ebx, cl
   557 00001C53 08DF                <1> 	or	bh, bl
   558 00001C55 C1EB08              <1> 	shr	ebx, 8
   559 00001C58 C3                  <1> 	ret
   560                              <1> 
   561 00001C59 C1E008              <1> drr:	shl	eax, 8
   562 00001C5C C1E308              <1> 	shl	ebx, 8
   563                              <1> 
   564 00001C5F F6C130              <1> 	test	cl, 48		; bits 32:16 are self-cancelling
   565 00001C62 7B07                <1> 	jpo	drr24		; rotate 48 = zero or 56 = 8 positions
   566 00001C64 F6C108              <1> 	test	cl, 8		; parity = pe dans le pays d'Intel
   567 00001C67 741C                <1> 	jz	drr7
   568 00001C69 EB15                <1> 	jmp	drr_cdrr8
   569                              <1> 
   570 00001C6B 93                  <1> drr24:	xchg	eax, ebx	; rotate 24 right or left as you wish
   571 00001C6C F6C118              <1> 	test	cl, 24
   572 00001C6F 7A0D                <1> 	jpe	drr24_32	; pattern is 100xxx or 011xxx
   573 00001C71 F6C108              <1> 	test	cl, 8		; pattern is 010xxx or 101xxx
   574 00001C74 7401                <1> 	jz	drrl8		; pattern is 010
   575 00001C76 93                  <1> 	xchg	eax, ebx	; swap back, pattern 101 = 40 right = 8 left 
   576 00001C77 E828000000          <1> drrl8:	call	near drl8	; pattern is 010
   577 00001C7C EB07                <1> 	jmp	short drr7 	; already rotated 24 right, now 8 left
   578                              <1> 
   579                              <1> drr24_32:
   580 00001C7E 7505                <1> 	jnz	drr7		; pattern is 011 = rotate 24. We did
   581                              <1> drr_cdrr8:
   582 00001C80 E814000000          <1> 	call	near drr8	; pattern is 100 = rotate 32
   583 00001C85 80E107              <1> drr7:	and	cl, 7
   584 00001C88 7408                <1> 	jz	drrx
   585 00001C8A 88E3                <1> 	mov	bl, ah		; rotate low bits ebx 31:8 to eax high positions
   586 00001C8C 88F8                <1> 	mov	al, bh		; rotate low bits eax 31:8 to ebx high positions
   587 00001C8E D3C8                <1> 	ror	eax, cl		; bits from bh in low order positions al
   588 00001C90 D3CB                <1> 	ror	ebx, cl		; bits from ah in low order positions bl
   589 00001C92 C1E808              <1> drrx:	shr	eax, 8
   590 00001C95 C1EB08              <1> 	shr	ebx, 8
   591 00001C98 C3                  <1> 	ret
   592                              <1> 
   593 00001C99 88E3                <1> drr8:   mov     bl, ah          ; cross 8 bits from one 32-bit ring to another
   594 00001C9B 88F8                <1>         mov     al, bh		
   595 00001C9D C1C808              <1>         ror     eax, 8
   596 00001CA0 C1CB08              <1>         ror     ebx, 8
   597 00001CA3 C3                  <1>         ret
   598                              <1> 
   599 00001CA4 C1C008              <1> drl8:   rol     eax, 8
   600 00001CA7 C1C308              <1>         rol     ebx, 8
   601 00001CAA 88DC                <1>         mov     ah, bl          ; cross 8 bits from one 32-bit ring to another
   602 00001CAC 88C7                <1>         mov     bh, al
   603 00001CAE C3                  <1>         ret
   604                              <1> 
   605 00001CAF C1E008              <1> drl:	shl	eax, 8
   606 00001CB2 C1E308              <1> 	shl	ebx, 8
   607 00001CB5 F6C130              <1> 	test	cl, 48		; values 32:16 cancel each other
   608 00001CB8 7B07                <1> 	jpo	drl24
   609 00001CBA F6C108              <1> 	test	cl, 8
   610 00001CBD 741C                <1> 	jz	drl7
   611 00001CBF EB15                <1> 	jmp	short drl_cdrl8
   612                              <1> 
   613 00001CC1 93                  <1> drl24:	xchg	eax, ebx
   614 00001CC2 F6C118              <1> 	test	cl, 24
   615 00001CC5 7A0D                <1> 	jpe	drl24_32	; pattern is 011xxx or 100xxx
   616 00001CC7 F6C108              <1> 	test	cl, 8		; pattern is 010xxx or 101xxx
   617 00001CCA 7401                <1> 	jz	drlr8		; pattern is 010 = 16 left = 8 right
   618 00001CCC 93                  <1> 	xchg	eax, ebx	; swap back, pattern = 101 = 40 left = 8 right
   619 00001CCD E8C7FFFFFF          <1> drlr8:	call	drr8
   620 00001CD2 EB07                <1> 	jmp	short drl7
   621                              <1> 
   622                              <1> drl24_32:
   623 00001CD4 7505                <1> 	jnz	drl7		; pattern is 011 = rotate24. We did
   624                              <1> drl_cdrl8:			; pattern = 100xxx or 001xxx, rotate 8 more
   625 00001CD6 E8C9FFFFFF          <1> 	call	drl8
   626 00001CDB 80E107              <1> drl7:	and	cl, 7		; rotate positions 0..7
   627 00001CDE 30C0                <1> 	xor	al, al
   628 00001CE0 30DB                <1> 	xor	bl, bl
   629 00001CE2 D3C0                <1> 	rol	eax, cl
   630 00001CE4 D3C3                <1> 	rol	ebx, cl
   631 00001CE6 08DC                <1> 	or	ah, bl
   632 00001CE8 08C7                <1> 	or	bh, al
   633 00001CEA C1E808              <1> 	shr	eax, 8
   634 00001CED C1EB08              <1> 	shr	ebx, 8
   635 00001CF0 C3                  <1> 	ret
   636                              <1> 
   637 00001CF1 8B5D10              <1> _ral:	mov	ebx, dword ptr [rbp+A]
   638 00001CF4 E838FFFFFF          <1> 	call	rl
   639 00001CF9 895D10              <1> 	mov	dword ptr [rbp+A], ebx
   640 00001CFC C3                  <1> 	ret
   641                              <1> 
   642 00001CFD 8B5D14              <1> _rbl:	mov	ebx, dword ptr [rbp+B]
   643 00001D00 E82CFFFFFF          <1> 	call	rl
   644 00001D05 895D14              <1> 	mov	dword ptr [rbp+B], ebx
   645 00001D08 C3                  <1> 	ret	
   646                              <1> 
   647 00001D09 88C1                <1> _drl:	mov	cl, al
   648 00001D0B 8B4510              <1> 	mov	eax, dword ptr [rbp+A]
   649 00001D0E 8B5D14              <1> 	mov	ebx, dword ptr [rbp+B]
   650 00001D11 E899FFFFFF          <1> 	call	drl
   651 00001D16 895D14              <1> 	mov	dword ptr [rbp+B], ebx
   652 00001D19 894510              <1> 	mov	dword ptr [rbp+A], eax
   653 00001D1C C3                  <1> 	ret
   654                              <1> 
   655 00001D1D 88C1                <1> _saa:	mov	cl, al
   656 00001D1F 8B4510              <1> 	mov	eax, dword ptr [rbp+A]
   657 00001D22 C1E008              <1> 	shl	eax, 8
   658 00001D25 D3F8                <1> 	sar	eax, cl
   659 00001D27 C1E808              <1> 	shr	eax, 8
   660 00001D2A 894510              <1> 	mov	dword ptr [rbp+A], eax
   661 00001D2D C3                  <1> 	ret
   662                              <1> 
   663 00001D2E 88C1                <1> _sba:	mov	cl, al
   664 00001D30 8B5D14              <1> 	mov	ebx, dword ptr [rbp+B]
   665 00001D33 C1E308              <1> 	shl	ebx, 8
   666 00001D36 D3FB                <1> 	sar	ebx, cl
   667 00001D38 C1EB08              <1> 	shr	ebx, 8
   668 00001D3B 895D14              <1> 	mov	dword ptr [rbp+B], ebx
   669 00001D3E C3                  <1> 	ret
   670                              <1> 
   671 00001D3F 88C1                <1> _dsa:	mov	cl, al
   672 00001D41 8B5D14              <1> 	mov	ebx, dword ptr [rbp+B]
   673 00001D44 8B4510              <1> 	mov	eax, dword ptr [rbp+A]
   674 00001D47 E889FEFFFF          <1> 	call	dsa
   675 00001D4C 895D14              <1> 	mov	dword ptr [rbp+B], ebx
   676 00001D4F 894510              <1> 	mov	dword ptr [rbp+A], eax
   677 00001D52 C3                  <1> 	ret
   678                              <1> 
   679 00001D53 E814EBFFFF          <1> _n:	call	memoreg
   680 00001D58 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   681 00001D5D E9E7EAFFFF          <1> 	jmp	memoreg_writeback
   682                              <1> 
   683 00001D62 E805EBFFFF          <1> _inc:	call	memoreg
   684 00001D67 FFC0                <1> 	inc	eax
   685 00001D69 E9DBEAFFFF          <1> 	jmp	memoreg_writeback
   686                              <1> 
   687 00001D6E E8F9EAFFFF          <1> _dec:	call	memoreg
   688 00001D73 FFC8                <1> 	dec	eax
   689 00001D75 E9CFEAFFFF          <1> 	jmp	memoreg_writeback
   690                              <1> 
   691 00001D7A E8EDEAFFFF          <1> _src:	call	memoreg
   692 00001D7F C1E008              <1> 	shl	eax, 8
   693 00001D82 8A86B0040000        <1> 	mov	al, byte ptr [rsi+PSR]
   694 00001D88 D1C8                <1> 	ror	eax, 1
   695 00001D8A D0C0                <1> 	rol	al, 1
   696 00001D8C 8886B0040000        <1> 	mov	byte ptr [rsi+PSR], al
   697 00001D92 C1E808              <1> 	shr	eax, 8
   698 00001D95 E9AFEAFFFF          <1> 	jmp	memoreg_writeback
   699                              <1> 
   700 00001D9A E8CDEAFFFF          <1> _slc:	call	memoreg
   701 00001D9F C1E008              <1> 	shl	eax, 8
   702 00001DA2 8A86B0040000        <1> 	mov	al, byte ptr [rsi+PSR]
   703 00001DA8 D0C8                <1> 	ror	al, 1
   704 00001DAA D1C0                <1> 	rol	eax, 1
   705 00001DAC 8886B0040000        <1> 	mov	byte ptr [rsi+PSR], al
   706 00001DB2 C1E808              <1> 	shr	eax, 8
   707 00001DB5 E98FEAFFFF          <1> 	jmp	memoreg_writeback
   708                              <1> 
   709                              <1> 	%if	0
   710                              <1> _popA:	call	stack_read1				; ebx <- stack pointer
   711                              <1> 	mov	ebx, dword ptr [rsi+ebx*4+REGISTER]	; stack word
   712                              <1> 
   713                              <1> 	mov	ecx, rsi				; keep core.REGISTER *
   714                              <1> 	push	ebx
   715                              <1> 	call	memoreg					; reply is memory edi + rsi ->
   716                              <1> 							;     or register rsi + ebx ->
   717                              <1> 	add	eax, dword ptr [rsp]
   718                              <1> 	add	rsp, 4
   719                              <1> 
   720                              <1> 	rol	eax, 8					; carry -> LS bit
   721                              <1> 	and	al, 1
   722                              <1> 
   723                              <1> 	and	byte ptr [ecx+PSR], 254
   724                              <1> 	or	byte ptr [ecx+PSR], al
   725                              <1> 	shr	eax, 8					; resulting value without carry
   726                              <1> 	jmp	memoreg_writeback			; eax -> target
   727                              <1> 							; [ edi ] + rsi -> memory / register
   728                              <1> 	%else
   729                              <1> 
   730 00001DBA E8ADEAFFFF          <1> _popA:	call	memoreg					; eax <- addend for update
   731 00001DBF 53                  <1> 	push	rbx					; ebx -> writeback register
   732 00001DC0 56                  <1> 	push	rsi					; or [ edi esi ] -> writeback memory word
   733                              <1> 
   734 00001DC1 480F7EFE            <1> 	movq	rsi, mm7
   735                              <1> ;	mov	rsi, qword ptr [rbp+CORE_INDEX1]	; get back the smp core for PSR and...
   736                              <1> 							; total register array and...
   737                              <1> 							; whichever of [ 2 * RTA1 sp ] is in ebx *
   738                              <1> 							; that is simple position in register list
   739                              <1> 							; not application / ISR relative as in rbp
   740                              <1> 							; although each (RTA1 sp) MOSTLY operates
   741                              <1> 							; its own portions of the register array
   742                              <1> 							; CORE_INDEX is in both scopes of rbp :-)
   743                              <1> 
   744 00001DC5 E814F6FFFF          <1> 	call	stack_read1				; ebx -> old (RTA1 internal stack) sp
   745 00001DCA 03049E              <1> 	add	eax, dword ptr [rsi+rbx*4+REGISTER]	; add word from internal stack
   746                              <1> 
   747 00001DCD C1C008              <1> 	rol	eax, 8					; isolate carry out of bit 23
   748 00001DD0 2401                <1> 	and	al, 1
   749 00001DD2 8B9EB0040000        <1> 	mov	ebx, dword ptr [rsi+PSR]		; platform memory read then write MIGHT
   750 00001DD8 80E3FE              <1> 	and	bl, 254					; be better than 2 * read : write cycle
   751 00001DDB 08C3                <1> 	or	bl, al
   752 00001DDD 899EB0040000        <1> 	mov	dword ptr [rsi+PSR], ebx		; write PSR back
   753                              <1> 
   754 00001DE3 C1E808              <1> 	shr	eax, 8					; reposition and clean result
   755                              <1> 
   756 00001DE6 5E                  <1> 	pop	rsi					; retrieve possible storage offset
   757 00001DE7 5B                  <1> 	pop	rbx					; retrieve possible register writeback
   758 00001DE8 E95CEAFFFF          <1> 	jmp	memoreg_writeback
   759                              <1> 
   760                              <1> 	%endif
   761                              <1> 	
   762 00001DED E8C6E6FFFF          <1> _da:	call	_burst_read2
   763 00001DF2 EB12                <1> 	jmp	_da_
   764                              <1> 
   765 00001DF4 E8BFE6FFFF          <1> _dan:	call	_burst_read2
   766 00001DF9 81F3FFFFFF00        <1> 	xor	ebx, 00FFFFFFh
   767 00001DFF 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   768 00001E04 FFC3                <1> 	inc	ebx			; carry from bit 23 
   769                              <1> 					; remains in bit 24 for now
   770                              <1> 
   771 00001E06 035D14              <1> _da_:	add	ebx, [rbp+B]
   772 00001E09 C1E308              <1> 	shl	ebx, 8
   773 00001E0C 83D000              <1> 	adc	eax, 0
   774 00001E0F C1EB08              <1> 	shr	ebx, 8
   775 00001E12 895D14              <1> 	mov	[rbp+B], ebx
   776 00001E15 034510              <1> 	add	eax, [rbp+A]
   777 00001E18 E804000000          <1> 	call	_alu_carry
   778 00001E1D 894510              <1> 	mov	[rbp+A], eax
   779 00001E20 C3                  <1> 	ret
   780                              <1> 
   781                              <1> _alu_carry:
   782 00001E21 480F7EFE            <1> 	movq	rsi, mm7
   783                              <1> ;	mov	rsi, qword ptr [rbp+CORE_INDEX1]
   784 00001E25 C1C008              <1> 	rol	eax, 8
   785 00001E28 2401                <1> 	and	al, 1
   786 00001E2A 80A6B0040000FE      <1> 	and	byte ptr [rsi+PSR], 254
   787 00001E31 0886B0040000        <1> 	or	byte ptr [rsi+PSR], al
   788 00001E37 C1E808              <1> 	shr	eax, 8
   789 00001E3A C3                  <1> 	ret
   790                              <1> 
   791 00001E3B 040302020101010100- <1> scalex	db	4,3,2,2, 1,1,1,1, 0,0,0,0, 0,0,0,0
   791 00001E44 00000000000000      <1>
   792                              <1> 
   793                              <1> field_scale:			; examine 24-bit integer in 8-position steps
   794 00001E4B C1C008              <1> 	rol	eax, 8		; until high-order 8 bits are not all signs
   795 00001E4E 88C4                <1> 	mov	ah, al
   796 00001E50 30E8                <1> 	xor	al, ch
   797 00001E52 7509                <1> 	jnz	not8signs
   798 00001E54 80C108              <1> 	add	cl, 8
   799 00001E57 80F918              <1> 	cmp	cl, 24
   800 00001E5A 72EF                <1> 	jb	field_scale
   801 00001E5C C3                  <1> 	ret			; 24 signs = the RTA1 computer word
   802                              <1> not8signs:			; al = 0 indicates it
   803 00001E5D A8F0                <1> 	test	al, 240		; move back some positions but keep counting up
   804 00001E5F 7506                <1> 	jnz	scale_u
   805 00001E61 80C104              <1> 	add	cl, 4
   806 00001E64 C0C004              <1> 	rol	al, 4
   807                              <1> scale_u:
   808 00001E67 C0E804              <1> 	shr	al, 4
   809 00001E6A 480FB6F0            <1> 	movzx	rsi, al		; add to count-up 1..7
   810 00001E6E 028E[3B1E0000]      <1> 	add	cl, [rsi+scalex]
   811 00001E74 51                  <1> 	push	rcx		; roll back 7..1 positions
   812 00001E75 80E107              <1> 	and	cl, 7
   813 00001E78 80F107              <1> 	xor	cl, 7
   814 00001E7B 80C101              <1> 	add	cl, 1
   815 00001E7E 88E0                <1> 	mov	al, ah
   816 00001E80 D3C8                <1> 	ror	eax, cl
   817 00001E82 59                  <1> 	pop	rcx
   818 00001E83 C3                  <1> 	ret
   819                              <1> 
   820 00001E84 C1E008              <1> qscale:	shl	eax, 8		; 1.2.3
   821 00001E87 C1F808              <1> 	sar	eax, 8		; s.1.2.3
   822 00001E8A C1C008              <1> 	rol	eax, 8		; 1.2.3.s
   823 00001E8D 6631C9              <1> 	xor	cx, cx
   824 00001E90 88C5                <1> 	mov	ch, al		; keep 8 sign bits
   825 00001E92 E8B4FFFFFF          <1> 	call	field_scale
   826                              <1> 
   827 00001E97 0FB6D9              <1> 	movzx	ebx, cl
   828                              <1> 
   829 00001E9A C1E808              <1> 	shr	eax, 8
   830 00001E9D C3                  <1> 	ret
   831                              <1> 
   832 00001E9E E857E6FFFF          <1> _lsc:	call	_operand_read
   833 00001EA3 E8DCFFFFFF          <1> 	call	qscale
   834 00001EA8 895D14              <1> 	mov	dword ptr [rbp+B], ebx	; store the scale
   835 00001EAB 894510              <1> 	mov	dword ptr [rbp+A], eax	; store the rotated value
   836 00001EAE C3                  <1> 	ret
   837                              <1> 
   838 00001EAF E804E6FFFF          <1> _dlsc:	call	_burst_read2
   839 00001EB4 894510              <1> 	mov	dword ptr [rbp+A], eax		; keep original 1st word
   840 00001EB7 C1E008              <1> 	shl	eax, 8
   841 00001EBA C1F808              <1> 	sar	eax, 8
   842 00001EBD C1C008              <1> 	rol	eax, 8
   843 00001EC0 6631C9              <1> 	xor	cx, cx
   844 00001EC3 88C5                <1> 	mov	ch, al				; keep 8 sign bits
   845 00001EC5 E881FFFFFF          <1> 	call	field_scale
   846 00001ECA 20C0                <1> 	and	al, al
   847 00001ECC 7415                <1> 	jz	_dlsc24				; if the first word is all signs
   848                              <1> 
   849 00001ECE 0FB6C1              <1> 	movzx	eax, cl
   850 00001ED1 894518              <1> 	mov	dword ptr [rbp+MANTISSA2], eax	; store the scale
   851 00001ED4 8B4510              <1> 	mov	eax, dword ptr [rbp+A]		; retrieve the input high order word
   852 00001ED7 E8D3FDFFFF          <1> 	call	drl				; scale the two input words per cl
   853 00001EDC 895D14              <1> 	mov	dword ptr [rbp+B], ebx
   854 00001EDF 894510              <1> 	mov	dword ptr [rbp+A], eax  	; store the rotated value
   855 00001EE2 C3                  <1> 	ret
   856                              <1> 
   857                              <1> _dlsc24:				; different when high order word is all signs
   858 00001EE3 C1E808              <1> 	shr	eax, 8			; one result word of signs
   859 00001EE6 894514              <1> 	mov	dword ptr [rbp+B], eax	; into the low-order result word
   860 00001EE9 89D8                <1> 	mov	eax, ebx		; scale the low-order input
   861 00001EEB C1E008              <1> 	shl	eax, 8
   862 00001EEE 30C9                <1> 	xor	cl, cl			; restart the scale count-up
   863 00001EF0 E856FFFFFF          <1> 	call	field_scale
   864 00001EF5 80C118              <1> 	add	cl, 24			; restore the early part of the count-up
   865                              <1> 
   866 00001EF8 0FB6D9              <1> 	movzx	ebx, cl
   867 00001EFB 895D18              <1> 	mov	dword ptr [rbp+MANTISSA2], ebx	; store the scale
   868                              <1> 
   869 00001EFE C1E808              <1> 	shr	eax, 8
   870 00001F01 894510              <1> 	mov	dword ptr [rbp+A], eax	; store the rotated value
   871 00001F04 C3                  <1> 	ret
   872                              <1> 
   873                              <1> 	%if	0
   874                              <1> 
   875                              <1> _fpx:	call	_burst_read2		; data read in eax ebx
   876                              <1> 
   877                              <1> 	movq	rsi, mm7
   878                              <1> ;	mov	rsi, dword ptr [rbp+CORE_INDEX1]
   879                              <1> 
   880                              <1> 	push	ebx			; ebx is used in RTA1 stack frame
   881                              <1> 	call	stack4			; construct RTA1 stack frame
   882                              <1> 
   883                              <1> 	shl	eax, 4			; move 12 mantissa bits out of eax
   884                              <1> 	movsx	ecx, ax			; and extend the normalising bit
   885                              <1> 
   886                              <1> 	rol	eax, 4+1		; shelter sign in eax bit 0
   887                              <1> 	shl	ax, 12			; better still in eax bit 12
   888                              <1> 	sar	eax, 12			; propagate the value at midpoint position
   889                              <1> 	ror	eax, 1			; have the sign back
   890                              <1> 	shr	eax, 8			; clear eax 31..24
   891                              <1> 	xor	eax, 003ffc00h		; reverse the 12 copies of midpoint bit
   892                              <1> 					; yon's ra complicated bit done
   893                              <1> 	mov	dword ptr [rbp+ebx*4], eax
   894                              <1> 
   895                              <1> 	xor	eax, ecx		; is the normalising bit opposite to signs ?
   896                              <1> 	test	eax, 00800000h
   897                              <1> 	jz	_fpx_allsigns		; no so unnormalised = zero
   898                              <1> 
   899                              <1> 	pop	eax			; the 2nd operand word, ya remember?
   900                              <1> 	shl	eax, 4			; get them 2 halves over the centre
   901                              <1> 
   902                              <1> 	shr	cx, 4			; zero quartets at high order of 16 bits
   903                              <1> 	shr	ax, 4
   904                              <1> 
   905                              <1> 	xchg	ax, cx			; low-order mantissa bits with unsigns in ecx
   906                              <1> 					; high-order mantissa bits with middle part in eax
   907                              <1> 
   908                              <1> 	shl	eax, 4			; LLLz | HHHz
   909                              <1> 	shr	ax, 4			; LLLz | zHHH
   910                              <1> 	rol	eax, 12			; zzHH | HLLL
   911                              <1> 
   912                              <1> 	mov	dword ptr [rbp+ebx*4+1*4], eax
   913                              <1> 	rol	ecx, 12
   914                              <1> 	xor	ecx, 0FFFh		; 12 normalising bits = 12 inverted signs
   915                              <1> 	mov	dword ptr [rbp+ebx*4+2*4], ecx
   916                              <1> 	not	ecx			; convert high order quartet to signs
   917                              <1> 	sar	ecx, 20			; 24 of them
   918                              <1> 	shr	ecx, 8
   919                              <1> 	mov	dword ptr [rbp+ebx*4+3*4], ecx
   920                              <1> ;	mov	rbp, dword ptr [rsi+REGISTER_SET]
   921                              <1> 	mov	dword ptr [rbp+S_P], ebx	; update whichever sp that is
   922                              <1> 	ret
   923                              <1> 
   924                              <1> _fpx_allsigns:
   925                              <1> 	add	rsp, 4			; take saved operand word back from stack
   926                              <1> 	sar	ecx, 8			; 16 unnormalised normalising bits
   927                              <1> 	shr	ecx, 8			; = 24 sign bits
   928                              <1> 
   929                              <1> 	mov	dword ptr [rbp+ebx*4], ecx
   930                              <1> 	mov	dword ptr [rbp+ebx*4+1*4], ecx
   931                              <1> 	mov	dword ptr [rbp+ebx*4+2*4], ecx
   932                              <1> 	mov	dword ptr [rbp+ebx*4+3*4], ecx
   933                              <1> 
   934                              <1> ;	mov	rbp, dword ptr [_register_set]
   935                              <1> 	mov	dword ptr [rbp+S_P], ebx	; update whichever sp that is
   936                              <1> 	ret
   937                              <1> 
   938                              <1> _fpp:	call	stack_read4
   939                              <1> 	push	eax				; thats EA
   940                              <1> 
   941                              <1> 	mov	eax, dword ptr [rbp+ebx*4]	; s + 23 exponent bits
   942                              <1> 	rol	eax, 8+2			; save sign and midpoint
   943                              <1> 	shl	eax, 12				; squeeze out 12 exponent bits
   944                              <1> 	shr	ax, 12				; bring sign + midpoint back
   945                              <1> 	ror	eax, 2				; and roll them back in
   946                              <1> 	shr	eax, 4				; position 12 bits low in 16 bits
   947                              <1> 	mov	ecx, dword ptr [rbp+ebx*4+1*4]	; take 1st mantissa word from the stack
   948                              <1> 	ror	ecx, 12				; rotate 12 bits down
   949                              <1> 	shl	cx, 4				; position 12 bits high in 16 bits
   950                              <1> 	mov	ax, cx				; merge
   951                              <1> 	shr	eax, 4				; position 24 bits low in 32 bits
   952                              <1> 	mov	dword ptr [rbp+ebx*4], eax	; place back in RTA1 stack frame
   953                              <1> 						; next 12 mantissa bits in ecx 31..20
   954                              <1> 
   955                              <1> 	mov	eax, dword ptr [rbp+ebx*4+2*4]	; read 24 more
   956                              <1> 	shr	eax, 12-4			; position 12 bits at ax 15..4
   957                              <1> 	shr	ecx, 4				;				
   958                              <1> 	mov	cx, ax				; juxtapose with mantissa 23..12
   959                              <1> 	shr	ecx, 4				; wirraff
   960                              <1> 
   961                              <1> 	mov	dword ptr [rbp+ebx*4+1*4], ecx	; making 2nd and final output word
   962                              <1> 
   963                              <1> 	pop	eax				; recover EA
   964                              <1> 	jmp	_burst_write2
   965                              <1> 
   966                              <1> 	%endif
    42                                  	%include	"fpu.msm"
     1                              <1> compress4to8:			; readout floating operand
     2                              <1> 				; and pack to 32-bit words
     3                              <1> 				; for 1 bit-distance shifting
     4                              <1> 				; acquired operand is in 1st half of 
     5                              <1> 				; 8-register block [rdi]
     6                              <1> 
     7 00001F05 8B07                <1> 	mov	eax, dword ptr [rdi]	; 1s-complement scale field
     8 00001F07 C1E008              <1> 	shl	eax, 8			; 1st data bit reveals sign
     9 00001F0A C1F808              <1> 	sar	eax, 8			; propagate that sign some
    10 00001F0D 89C3                <1> 	mov	ebx, eax
    11 00001F0F C1F818              <1> 	sar	eax, 24			; propagate signs to 32 bits
    12 00001F12 31C3                <1> 	xor	ebx, eax		; change scale to unsigned magnitude
    13 00001F14 891F                <1> 	mov	dword ptr [rdi], ebx	; position scale magnitude in 1st register
    14 00001F16 89471C              <1> 	mov	dword ptr [rdi+7*4], eax	; 96 trailing signs
    15 00001F19 894718              <1> 	mov	dword ptr [rdi+6*4], eax
    16 00001F1C 894714              <1> 	mov	dword ptr [rdi+5*4], eax
    17 00001F1F 8B5F0C              <1> 	mov	ebx, dword ptr [rdi+3*4]	; read low-order mantissa word
    18 00001F22 88D8                <1> 	mov	al, bl				; low-order octet
    19 00001F24 C1C808              <1> 	ror	eax, 8				; is followed by 24 signs
    20 00001F27 894710              <1> 	mov	dword ptr [rdi+4*4], eax	; ebx also contains mantissa 23..8
    21                              <1> 						; in positions 23..8
    22                              <1> 
    23 00001F2A 8B4708              <1> 	mov	eax, dword ptr [rdi+2*4]	; eax now contains mantissa 47..24
    24 00001F2D C1E308              <1> 	shl	ebx, 8
    25 00001F30 6689C3              <1> 	mov	bx, ax				; mantissa 39..24 -> ebx
    26 00001F33 C1C310              <1> 	rol	ebx, 16				; ebx now contains mantissa 40..8
    27 00001F36 895F0C              <1> 	mov	dword ptr [rdi+3*4], ebx
    28 00001F39 8B5F04              <1> 	mov	ebx, dword ptr [rdi+1*4]	; mantissa 71..48
    29 00001F3C C1E308              <1> 	shl	ebx, 8
    30 00001F3F C1E810              <1> 	shr	eax, 16				; mantissa 47..40
    31 00001F42 88C3                <1> 	mov	bl, al
    32 00001F44 895F08              <1> 	mov	dword ptr [rdi+2*4], ebx	; mantissa 71..40
    33 00001F47 8B4714              <1> 	mov	eax, dword ptr [rdi+5*4]	; copy 32 signs
    34 00001F4A 894704              <1> 	mov	dword ptr [rdi+1*4], eax	; to 2nd word of register block
    35 00001F4D C3                  <1> 	ret
    36                              <1> 
    37                              <1> 
    38                              <1> ;	___________________________________
    39                              <1> ;	| magnitude scale|     32 signs   |
    40                              <1> ;	|________________|________________|
    41                              <1> ;	| platform word 7| platform word 6|
    42                              <1> 
    43                              <1> 
    44                              <1> ;	<------------ 168-bit mantissa 167..72-------------|
    45                              <1> ;	<------------  72-bit mantissa ------>
    46                              <1> ;	_____________|___________|____________|____________________________
    47                              <1> ;	|      24    | 8 |   16  |   16   | 8 |    24 signs|96 more signs for
    48                              <1> ;	|____________|___|______ |________|___|____________|rrsidue calculation
    49                              <1> ;	| platform word 5| platform word 4|   +rounding <--- @  96-bit operation
    50                              <1> 
    51                              <1> ;	                 <---------------------------------[ platform words 2..0
    52                              <1> ;	                 :
    53                              <1> ;	                 [                                                  ]
    54                              <1> 
    55                              <1> ;	                 |--- 168-bit mantissa 71:0   -------->
    56                              <1> ;	                      rounding @ 192-bit operation --->+
    57                              <1> ;      	                 _________________________|____________|_____________
    58                              <1> ;	                 |      24    | 8 |   16  |   16   | 8 |    24 signs|
    59                              <1> ;	                 |____________|___|_______|________|___|____________|
    60                              <1> ;	                 | platform word 2| platform word 1| platform word 0|
    61                              <1> 
    62                              <1> ;	                 |    rrsidue rounding -->+
    63                              <1> ;	                 |--- 144-bit mantissa -->	                                    
    64                              <1> 
    65                              <1> _deliver_:
    66 00001F4E 480F7EFE            <1> 	movq	rsi, mm7
    67                              <1> ;	mov	rsi, qword ptr [rbp+CORE_INDEX1]
    68                              <1> 
    69 00001F52 F786B0040000080000- <1> 	test	dword ptr [rsi+PSR], FP_R
    69 00001F5B 00                  <1>
    70 00001F5C 0F847E000000        <1> 	jz	near _deliver
    71 00001F62 53                  <1> 	push	rbx		; save result register index
    72 00001F63 8B1F                <1> 	mov	ebx, dword ptr [rdi]		; read scale unsigned magnitude
    73                              <1> 						; not yet signed
    74                              <1> 
    75                              <1> 				; all results except scale have been polarised
    76                              <1> 				; ebx = positive magnitude of major exponent
    77                              <1> 				; deliver floating rrsidue
    78 00001F65 83C3B8              <1> 	add	ebx, -72	; calculate exponent of rrsidue
    79 00001F68 B148                <1> 	mov	cl, 72
    80                              <1> 
    81 00001F6A 8B4710              <1> 	mov	eax, dword ptr [rdi+4*4]	; mantissa */ 64 bits
    82 00001F6D C1E008              <1> 	shl	eax, 8		; separate rrsidual mantissa
    83 00001F70 C1E808              <1> 	shr	eax, 8
    84 00001F73 50                  <1> 	push	rax
    85 00001F74 8B4714              <1> 	mov	eax, dword ptr [rdi+5*4]	; mantissa */ 96 bits
    86 00001F77 50                  <1> 	push	rax
    87 00001F78 8B4718              <1> 	mov	eax, dword ptr [rdi+6*4]	; mantissa */ 128 bits
    88 00001F7B 668B4704            <1> 	mov	ax, word ptr [rdi+1*4]		; change low-order half trailing word to signs
    89 00001F7F 50                  <1> 	push	rax				; before normalising
    90                              <1> 
    91                              <1> _normalise_residue:
    92 00001F80 8B442410            <1> 	mov	eax, dword ptr [rsp+2*8]	; residual mantissa high-order word
    93 00001F84 334704              <1> 	xor	eax, dword ptr [rdi+1*4]	; signs
    94 00001F87 2500008000          <1> 	and	eax, 00800000h			; normalising position
    95 00001F8C 751A                <1> 	jnz	_residue_normalised
    96 00001F8E 8B4704              <1> 	mov	eax, dword ptr [rdi+1*4]	; signs again
    97 00001F91 D1D0                <1> 	rcl	eax, 1				; place a sign in carry				
    98 00001F93 D11424              <1> 	rcl	dword ptr [rsp], 1		; rotate 96 bits rrsidual mantissa
    99 00001F96 D1542408            <1> 	rcl	dword ptr [rsp+1*8], 1
   100 00001F9A D1542410            <1> 	rcl	dword ptr [rsp+2*8], 1		; thirdly the high-order word
   101 00001F9E 83C3FF              <1> 	add	ebx, -1
   102 00001FA1 80C1FF              <1> 	add	cl, -1
   103 00001FA4 72DA                <1> 	jc	_normalise_residue
   104 00001FA6 31DB                <1> 	xor	ebx, ebx			; rrsidue all signs zero -> scale
   105                              <1> _residue_normalised:
   106 00001FA8 F7C3000080FF        <1> 	test	ebx, 0FF800000h
   107 00001FAE 0F85DEF4FFFF        <1> 	jnz	_fpxpo_low_order		; nonzero mantissa
   108                              <1> 						; and exponent underflow / overflow
   109                              <1> 						
   110                              <1> ;			rrsidual mantissa on the stack now is
   111                              <1> ;			______________________________________________
   112                              <1> ;	sp------------->| mantissa bits 15..0 | 16 sign bits discard |
   113                              <1> ;			|_____________________|______________________|
   114                              <1> ;			|            mantissa bits 47..16            |
   115                              <1> ;			|____________________________________________| 
   116                              <1> ;			| 0000 0000  mantissa bits 71..48            |
   117                              <1> ;			|____________________________________________|
   118                              <1> ;			|	     result register indication      |
   119                              <1> ;			|____________________________________________|
   120                              <1> 
   121 00001FB4 8B4704              <1> 	mov	eax, dword ptr [rdi+1*4]	; signs
   122 00001FB7 31D8                <1> 	xor	eax, ebx			; sign rrsidue exponent now
   123 00001FB9 C1E008              <1> 	shl	eax, 8				; trim characteristic to RTA1 24-bit word
   124 00001FBC C1E808              <1> 	shr	eax, 8
   125 00001FBF 894520              <1> 	mov	dword ptr [rbp+8*4], eax	; scale XOR signs -> rrsidue characteristic
   126                              <1> 
   127 00001FC2 5B                  <1> 	pop	rbx				; low order mantissa part
   128 00001FC3 58                  <1> 	pop	rax				; middle order mantissa part
   129 00001FC4 88C3                <1> 	mov	bl, al				; donate 8 bits
   130 00001FC6 C1CB08              <1> 	ror	ebx, 8				; distribute as RTA1 24-bit words
   131 00001FC9 C1EB08              <1> 	shr	ebx, 8				; mantissa 23..0
   132 00001FCC C1E808              <1> 	shr	eax, 8				; mantissa 47..24
   133 00001FCF 895D2C              <1> 	mov	dword ptr [rbp+11*4], ebx
   134 00001FD2 894528              <1> 	mov	dword ptr [rbp+10*4], eax
   135 00001FD5 58                  <1> 	pop	rax				; high order rrsidual mantissa part
   136 00001FD6 5B                  <1> 	pop	rbx				; saved result register index
   137 00001FD7 C1E008              <1> 	shl	eax, 8
   138 00001FDA C1E808              <1> 	shr	eax, 8				; normalising position is bit 23
   139 00001FDD 894524              <1> 	mov	dword ptr [rbp+9*4], eax	; mantissa 71..48
   140                              <1> 
   141                              <1> _deliver:					; deliver floating result
   142                              <1> 						; ebx = target register index
   143                              <1> 						; result register index [rbp+]ebx*4
   144 00001FE0 8B07                <1> 	mov	eax, dword ptr [rdi]		; unsigned scale magnitude
   145 00001FE2 A9000080FF          <1> 	test	eax, 0FF800000h
   146 00001FE7 0F85A9F4FFFF        <1> 	jnz	_fpxpo				; exponent underflow / overflow
   147 00001FED 334704              <1> 	xor	eax, dword ptr [rdi+1*4]	; sign it
   148 00001FF0 C1E008              <1> 	shl	eax, 8
   149 00001FF3 C1E808              <1> 	shr	eax, 8
   150                              <1> 
   151                              <1> _store_float:
   152 00001FF6 89449D00            <1>         mov     dword ptr [rbp+rbx*4], eax      ; store characteristic = scale XOR signs
   153 00001FFA 8B4708              <1>         mov     eax, dword ptr [rdi+2*4]	; read bits 71..40 major mantissa
   154 00001FFD 0FB6C8              <1>         movzx   ecx, al
   155 00002000 C1E808              <1>         shr     eax, 8
   156 00002003 89449D04            <1>         mov     dword ptr [rbp+rbx*4+4], eax	; store mantissa bits 71..48
   157 00002007 8B470C              <1>         mov     eax, dword ptr [rdi+3*4]	; read mantissa bits 39..8
   158 0000200A C1E110              <1>         shl     ecx, 16				; position mantissa bits 47..40
   159 0000200D C1C810              <1>         ror     eax, 16
   160 00002010 6689C1              <1>         mov     cx, ax				; position mantissa bits 39..24
   161 00002013 894C9D08            <1>         mov     dword ptr [rbp+rbx*4+8], ecx	; store mantissa bits 47..24
   162 00002017 8B4F10              <1>         mov     ecx, dword ptr [rdi+4*4]	; read mantissa bits 7..0 plus 24 trailing bits
   163 0000201A C1E910              <1>         shr     ecx, 16				; position after mantissa 23..8
   164 0000201D 6689C8              <1>         mov     ax, cx
   165 00002020 C1E808              <1>         shr     eax, 8				; store mantissa bits 23..0
   166 00002023 89449D0C            <1>         mov     dword ptr [rbp+rbx*4+12], eax
   167 00002027 C3                  <1> 	ret
   168                              <1> 
   169                              <1> ;	_output equ	272
   170                              <1> ;	_inputr equ	264
   171                              <1> ;	_input2 equ	256
   172                              <1> 
   173                              <1> ;	_OUTPUT	equ	__register+_output*4
   174                              <1> ;	_INPUTR equ	__register+_inputr*4
   175                              <1> ;	_INPUT2 equ	__register+_input2*4
   176                              <1> ;	_BIAS	equ	_OUTPUT
   177                              <1> 
   178                              <1> zoutput:
   179 00002028 31C0                <1> 	xor	eax, eax
   180 0000202A 8907                <1> 	mov	dword ptr [rdi], eax
   181 0000202C 894704              <1> 	mov	dword ptr [rdi+1*4], eax
   182 0000202F 894708              <1> 	mov	dword ptr [rdi+2*4], eax
   183 00002032 89470C              <1> 	mov	dword ptr [rdi+3*4], eax
   184 00002035 894710              <1> 	mov	dword ptr [rdi+4*4], eax
   185 00002038 894714              <1> 	mov	dword ptr [rdi+5*4], eax
   186 0000203B 894718              <1> 	mov	dword ptr [rdi+6*4], eax
   187 0000203E 89471C              <1> 	mov	dword ptr [rdi+7*4], eax
   188 00002041 C3                  <1> 	ret
   189                              <1> 
   190                              <1> 
   191                              <1> ;	round before add or divide
   192                              <1> ;	XOR rounding pattern to guard field
   193                              <1> 
   194 00002042 480F7EFB            <1> round1:	movq	rbx, mm7
   195 00002046 8B834C020000        <1> 	mov	eax, dword ptr [rbx+REGISTER+FP_GUARD]
   196 0000204C D3E8                <1> 	shr	eax, cl
   197 0000204E C1E008              <1> 	shl	eax, 8
   198 00002051 0FB6DD              <1> 	movzx	ebx, ch
   199 00002054 31449F08            <1> 	xor	dword ptr [rdi+rbx*4+2*4], eax
   200 00002058 C3                  <1> 	ret
   201                              <1> 
   202 00002059 0FB6DD              <1> round2:	movzx	ebx, ch
   203                              <1> 
   204 0000205C 480F7EFE            <1> 	movq	rsi, mm7
   205                              <1> ;	mov	eax, dword ptr [rbp+CORE_INDEX1]	; ? can't have mattered much	
   206                              <1> 
   207 00002060 8B864C020000        <1> 	mov	eax, dword ptr [rsi+REGISTER+FP_GUARD]
   208 00002066 D3E8                <1> 	shr	eax, cl
   209 00002068 C1E008              <1> 	shl	eax, 8
   210 0000206B 01449F08            <1> 	add	dword ptr [rdi+rbx*4+2*4], eax
   211                              <1> round2more:
   212 0000206F 83549F0400          <1> 	adc	dword ptr [rdi+rbx*4+1*4], 0
   213 00002074 FFCB                <1> 	dec	ebx
   214 00002076 75F7                <1> 	jnz	round2more
   215 00002078 C3                  <1> 	ret
   216                              <1> 
   217                              <1> __FLAT_STAC	equ	1
   218                              <1> 
   219                              <1> end_around_carry:
   220                              <1> 
   221                              <1> 	%if	__FLAT_STAC
   222 00002079 F7D2                <1> 	not	edx				; signs B4
   223 0000207B 0FB6C3              <1> 	movzx	eax, bl				; carry saved from add
   224 0000207E 21D2                <1> 	and	edx, edx			; test new polarity
   225                              <1> 	%else
   226                              <1> 
   227                              <1> 	not	dword ptr [rsi+2*4]		; seems to vary or be vaguely documented
   228                              <1> 	movzx	eax, byte ptr [rsi+1*4]		; what size the call return stack frame is
   229                              <1> 						; so we push ei and copy rsp to it
   230                              <1> 						; to see stuff near the stack top
   231                              <1> 
   232                              <1> 	test	byte ptr dword ptr [rsi+2*4], 128
   233                              <1> 	%endif
   234                              <1> 
   235 00002080 790B                <1> 	jns	end_around_carry_plus		; updated signs +
   236                              <1> 
   237 00002082 B8FFFFFFFF          <1> 	mov	eax, -1				; 1 -> -1 in 1s complement
   238 00002087 D3E8                <1> 	shr	eax, cl
   239 00002089 F7D0                <1> 	not	eax
   240 0000208B EB06                <1> 	jmp	eoc1
   241                              <1> 
   242                              <1> end_around_carry_plus:
   243 0000208D 21C0                <1> 	and	eax, eax
   244 0000208F 7417                <1> 	jz	eox1				; ? don't call this if there is no carry
   245 00002091 D3C8                <1> 	ror	eax, cl
   246                              <1> 
   247 00002093 0FB6DD              <1> eoc1:	movzx	ebx, ch
   248 00002096 01449F08            <1> 	add	dword ptr [rdi+rbx*4+2*4], eax
   249                              <1> 
   250 0000209A 9C                  <1> 	pushfq
   251 0000209B C1F81F              <1> 	sar	eax, 31				; shift leave carry alone
   252 0000209E 9D                  <1> 	popfq
   253                              <1> 
   254 0000209F FFC3                <1> 	inc	ebx				; but reference displacements - 2
   255                              <1> 
   256 000020A1 11049F              <1> eoc:	adc	dword ptr [rdi+rbx*4], eax	; referencing displacements - 2
   257 000020A4 FFCB                <1> 	dec	ebx
   258 000020A6 75F9                <1> 	jnz	eoc
   259 000020A8 C3                  <1> eox1:	ret
   260                              <1> 
   261                              <1> restore_trailing_signs:
   262 000020A9 0FB6DD              <1> 	movzx	ebx, ch
   263 000020AC 8B4704              <1> 	mov	eax, dword ptr [rdi+1*4]
   264                              <1> 
   265 000020AF 89471C              <1> 	mov	dword ptr [rdi+7*4], eax
   266                              <1> 
   267 000020B2 21C0                <1> 	and	eax, eax
   268 000020B4 780B                <1> 	js	restore_trailing_ones
   269 000020B6 F7D0                <1> 	not	eax
   270 000020B8 D3E8                <1> 	shr	eax, cl
   271 000020BA F7D0                <1> 	not	eax
   272 000020BC 21449F08            <1> 	and	dword ptr [rdi+rbx*4+2*4], eax
   273 000020C0 C3                  <1> 	ret
   274                              <1> 
   275                              <1> restore_trailing_ones:
   276 000020C1 D3E8                <1> 	shr	eax, cl
   277 000020C3 09449F08            <1> 	or	dword ptr [rdi+rbx*4+2*4], eax
   278                              <1> 
   279 000020C7 C3                  <1> 	ret
   280                              <1> 
   281                              <1> BIAS_FIELD	equ	8
   282                              <1> 
   283                              <1> bias_addend:					; input mantissa [rsi] is biased into location _BIAS
   284 000020C8 57                  <1> 	push	rdi
   285 000020C9 4889F7              <1> 	mov	rdi, rsi
   286                              <1> 
   287 000020CC 480F7EFE            <1> 	movq	rsi, mm7
   288                              <1> ;	mov	rsi, qword ptr[rbp+CORE_INDEX1]
   289                              <1> 
   290 000020D0 488DB640040000      <1> 	lea	rsi, [rsi+_BIAS]
   291                              <1> 
   292 000020D7 56                  <1> 	push	rsi
   293 000020D8 E803000000          <1> 	call	biasfp
   294                              <1> 
   295 000020DD 5E                  <1> 	pop	rsi
   296 000020DE 5F                  <1> 	pop	rdi
   297 000020DF C3                  <1> 	ret
   298                              <1> 
   299 000020E0 52                  <1> biasfp:	push	rdx
   300 000020E1 51                  <1> 	push	rcx
   301                              <1> 
   302 000020E2 BB01000000          <1> 	mov	ebx, 1				; output index
   303 000020E7 66C1E003            <1> 	shl	ax, 3				; words sign fill
   304 000020EB C0E803              <1> 	shr	al, 3				; bits sign fill
   305 000020EE 6689C1              <1> 	mov	cx, ax
   306 000020F1 4883C704            <1> 	add	rdi, 4				; input pointer
   307 000020F5 8B07                <1> 	mov	eax, dword ptr [rdi]		; there shall be this word of signs at least
   308                              <1> 
   309 000020F7 89049E              <1> bias32:	mov	dword ptr [rsi+rbx*4], eax	; write 1 word of signs
   310 000020FA FFC3                <1> 	inc	ebx				; consider the next output word
   311 000020FC FECD                <1> 	dec	ch				; any more words of signs?
   312 000020FE 79F7                <1> 	jns	bias32
   313                              <1> 
   314 00002100 20C9                <1> 	and	cl, cl
   315 00002102 7423                <1> 	jz	bias_fast			; there is no 32-bit shift
   316                              <1> 
   317 00002104 B520                <1> 	mov	ch, 32				; demonstrate the missing advantage
   318 00002106 28CD                <1> 	sub	ch, cl				; of instruction architectures
   319                              <1> 						; with 2-register shifts
   320                              <1> biasup2:
   321 00002108 83FB08              <1> 	cmp	ebx, BIAS_FIELD
   322 0000210B 742D                <1> 	jz	bias_addx
   323 0000210D 4883C704            <1> 	add	rdi, 4				; read new mantissa word
   324 00002111 8B17                <1> 	mov	edx, dword ptr [rdi]		; it becomes word # new in edx
   325 00002113 86E9                <1> 	xchg	ch, cl
   326 00002115 D3E0                <1> 	shl	eax, cl				; shift buffered word left 32 - bit offset
   327 00002117 86E9                <1> 	xchg	ch, cl
   328 00002119 D3EA                <1> 	shr	edx, cl				; shift new mantissa word right bit offset
   329 0000211B 09D0                <1> 	or	eax, edx
   330 0000211D 89049E              <1> 	mov	dword ptr [rsi+rbx*4], eax	; write 1 merged word
   331 00002120 8B07                <1> 	mov	eax, dword ptr [rdi]		; read the same mantissa word again
   332 00002122 83C301              <1> 	add	ebx, 1				; it becomes word # previous in eax
   333 00002125 EBE1                <1> 	jmp	biasup2
   334                              <1> 
   335                              <1> bias_fast:
   336 00002127 83FB08              <1> 	cmp	ebx, BIAS_FIELD
   337 0000212A 740E                <1> 	jz	bias_addx
   338 0000212C 4883C704            <1> 	add	rdi, 4
   339 00002130 8B07                <1> 	mov	eax, dword ptr [rdi]
   340 00002132 89049E              <1> 	mov	dword ptr [rsi+rbx*4], eax
   341 00002135 83C301              <1> 	add	ebx, 1
   342 00002138 EBED                <1> 	jmp	bias_fast
   343                              <1> 
   344                              <1> bias_addx:
   345 0000213A 59                  <1> 	pop	rcx
   346 0000213B 5A                  <1> 	pop	rdx				; restore the program counter
   347 0000213C C3                  <1> 	ret
   348                              <1> 
   349                              <1> frame_mantissa:
   350                              <1> ;	ror	ecx, 16				; words count is up, beats index down
   351 0000213D 80C501              <1> 	add	ch, 1				; up the beats index to beats count
   352 00002140 66C1E905            <1> 	shr	cx, 5				; positions / 32 in ch
   353 00002144 C0E903              <1> 	shr	cl, 3				; positions /// 32 in cl
   354 00002147 0FB6DD              <1> 	movzx	ebx, ch				; derive platform words rounded down
   355 0000214A C3                  <1> 	ret
   356                              <1> 
   357                              <1> renormalise:					; rule 1: restore sign fill in
   358                              <1> 						; low-order containing platform word
   359                              <1> ; done before end-around-carry, and saved
   360                              <1> ;;	call	frame_mantissa			; it was mashed by rounding and adding
   361 0000214B E859FFFFFF          <1> 	call	restore_trailing_signs
   362 00002150 C1C910              <1> 	ror	ecx, 16				; the governing parameter is now
   363                              <1> 						; the containing words count in cx
   364                              <1> renormalise32:
   365 00002153 8B4708              <1> 	mov	eax, dword ptr [rdi+2*4]	; sample 32 mantissa bits
   366 00002156 3B4704              <1> 	cmp	eax, dword ptr [rdi+1*4]	; compare it with 32 signs
   367 00002159 750C                <1> 	jnz	renormalise8
   368 0000215B E83E000000          <1> 	call	rotate32left			; this also discovers if it's ALL signs = 0
   369 00002160 21C0                <1> 	and	eax, eax			; and is the only place that needs examined
   370 00002162 75EF                <1> 	jnz	renormalise32
   371                              <1> 
   372 00002164 8907                <1> 	mov	dword ptr [rdi], eax		; mantissa is signed zero, +0 -> scale
   373                              <1> renormalised:
   374 00002166 C3                  <1> 	ret
   375                              <1> 
   376                              <1> renormalise8:					; from this point on the value is nonzero
   377 00002167 C1C008              <1> 	rol	eax, 8				; are there 8 signs at head of mantissa?
   378 0000216A 3A4707              <1> 	cmp	al, byte ptr [rdi+1*4+3]	; this is Intel and the 4th byte is high-order
   379 0000216D 750A                <1> 	jnz	renormalise1			; you have found the 8 bits containing the
   380                              <1> 						; normalising bit
   381 0000216F E84A000000          <1> 	call	rotate8left			; or else you haven't
   382 00002174 8B4708              <1> 	mov     eax, dword ptr [rdi+2*4]	; sample the moved mantissa
   383 00002177 EBEE                <1> 	jmp	renormalise8
   384                              <1> 
   385                              <1> renormalise1:
   386                              <1> ;	movzx	ebx, cx	
   387 00002179 8B4704              <1> 	mov	eax, dword ptr [rdi+1*4]		
   388                              <1> ;	mov	dword ptr [rdi+rbx*4+1*4], eax	; in case polarity has changed
   389 0000217C 334708              <1> 	xor	eax, dword ptr [rdi+2*4]	; normalising bit opposite polarity to sign?
   390 0000217F 78E5                <1> 	js	renormalised			; arrived
   391 00002181 E802000000          <1> 	call	bitwise_scale			; almost arrived
   392 00002186 EBF1                <1> 	jmp	renormalise1
   393                              <1> 
   394                              <1> 
   395                              <1> bitwise_scale:
   396 00002188 D1571C              <1> 	rcl	dword ptr [rdi+7*4], 1	; so it doesn't matter whether 0 or 1
   397 0000218B D15718              <1> 	rcl	dword ptr [rdi+6*4], 1	; gets shifted into the 192nd bit
   398 0000218E D15714              <1> 	rcl	dword ptr [rdi+5*4], 1
   399 00002191 D15710              <1> 	rcl	dword ptr [rdi+4*4], 1	; it's quicker to shift 6 words
   400 00002194 D1570C              <1> 	rcl	dword ptr [rdi+3*4], 1	; than a counted loop of 4 or 5 or 6 words
   401 00002197 D15708              <1> 	rcl	dword ptr [rdi+2*4], 1
   402                              <1> 
   403 0000219A 8307FF              <1> 	add	dword ptr [rdi], -1	; scale down
   404 0000219D C3                  <1> 	ret
   405                              <1> 
   406                              <1> rotate32left:				; rotate all containing platform words of mantissa
   407 0000219E 52                  <1> 	push	rdx			; 32 bit positions left and report if all signs
   408 0000219F 51                  <1> 	push	rcx
   409 000021A0 0FB7D9              <1> 	movzx	ebx, cx
   410 000021A3 31D2                <1> 	xor	edx, edx		; initialise equality = all signs
   411                              <1> 
   412                              <1> rotate32next:				; the word initially loaded in eax is all signs
   413 000021A5 FFCB                <1> 	dec	ebx
   414 000021A7 87449F08            <1> 	xchg	eax, dword ptr [rdi+rbx*4+2*4]
   415 000021AB 89C1                <1> 	mov	ecx, eax
   416 000021AD 334F04              <1> 	xor	ecx, dword ptr [rdi+1*4] ; difference between this word and signs
   417 000021B0 09CA                <1> 	or	edx, ecx		; sum of differences
   418 000021B2 21DB                <1> 	and	ebx, ebx
   419 000021B4 75EF                <1> 	jnz	rotate32next
   420 000021B6 8307E0              <1> 	add	dword ptr [rdi], -32	; scale down
   421 000021B9 89D0                <1> 	mov	eax, edx
   422 000021BB 59                  <1> 	pop	rcx
   423 000021BC 5A                  <1> 	pop	rdx
   424 000021BD C3                  <1> 	ret
   425                              <1> 
   426                              <1> rotate8left:				; rotate all containing platform words of mantissa
   427 000021BE 51                  <1> 	push	rcx			; 8 bit positions left. 1st word is rotated already
   428 000021BF 0FB7D9              <1> 	movzx	ebx, cx			; and contains signs in 8 low-order bit positions
   429                              <1> rotate8next:
   430 000021C2 8B4C9F08            <1> 	mov	ecx, dword ptr [rdi+rbx*4+2*4]
   431 000021C6 C1C108              <1> 	rol	ecx, 8
   432 000021C9 86C1                <1> 	xchg	al, cl
   433 000021CB 894C9F08            <1> 	mov	dword ptr [rdi+rbx*4+2*4], ecx
   434 000021CF 83C3FF              <1> 	add	ebx, -1
   435 000021D2 72EE                <1> 	jc	rotate8next
   436 000021D4 8307F8              <1> 	add	dword ptr [rdi], -8	; scale down
   437 000021D7 59                  <1> 	pop	rcx
   438 000021D8 C3                  <1> 	ret
   439                              <1> 
   440 000021D9 F75708              <1> zover:	not	dword ptr [rdi+2*4]
   441 000021DC F7570C              <1> 	not	dword ptr [rdi+3*4]
   442 000021DF F75710              <1> 	not	dword ptr [rdi+4*4]
   443 000021E2 F75714              <1> 	not	dword ptr [rdi+5*4]
   444 000021E5 F75718              <1> 	not	dword ptr [rdi+6*4]
   445 000021E8 F7571C              <1> 	not	dword ptr [rdi+7*4]
   446 000021EB C3                  <1> 	ret
   447                              <1> 
   448                              <1> _add_low:
   449 000021EC 8B961C040000        <1>         mov     edx, dword ptr [rsi+_INPUT2+7*4]
   450 000021F2 13963C040000        <1>         adc     edx, dword ptr [rsi+_INPUTR+7*4]
   451 000021F8 8B9E18040000        <1>         mov     ebx, dword ptr [rsi+_INPUT2+6*4]
   452 000021FE 139E38040000        <1>         adc     ebx, dword ptr [rsi+_INPUTR+6*4]
   453 00002204 8B8614040000        <1>         mov     eax, dword ptr [rsi+_INPUT2+5*4]
   454 0000220A 138634040000        <1>         adc     eax, dword ptr [rsi+_INPUTR+5*4]
   455 00002210 C3                  <1>         ret
   456                              <1> 
   457                              <1> _add_high:
   458 00002211 8B9610040000        <1>         mov     edx, dword ptr [rsi+_INPUT2+4*4]
   459 00002217 139630040000        <1>         adc     edx, dword ptr [rsi+_INPUTR+4*4]
   460 0000221D 8B9E0C040000        <1>         mov     ebx, dword ptr [rsi+_INPUT2+3*4]
   461 00002223 139E2C040000        <1>         adc     ebx, dword ptr [rsi+_INPUTR+3*4]
   462 00002229 8B8608040000        <1>         mov     eax, dword ptr [rsi+_INPUT2+2*4]
   463 0000222F 138628040000        <1>         adc     eax, dword ptr [rsi+_INPUTR+2*4]
   464 00002235 C3                  <1>         ret
   465                              <1> 
   466 00002236 488DBE00040000      <1> fan:	lea	rdi, [rsi+_INPUT2]
   467 0000223D E897FFFFFF          <1> 	call	zover				; mantissa
   468 00002242 F79604040000        <1> 	not	dword ptr [rsi+_INPUT2+1*4]	; 32 signs
   469                              <1> 
   470 00002248 488DBE20040000      <1> fa:	lea	rdi, [rsi+_INPUTR]
   471 0000224F 488DB600040000      <1> 	lea	rsi, [rsi+_INPUT2]
   472                              <1> 
   473 00002256 8B4604              <1> 	mov	eax, dword ptr [rsi+1*4]	; normalised?
   474 00002259 334608              <1> 	xor	eax, dword ptr [rsi+2*4]	; normalising bit must ^ signs
   475 0000225C 7801                <1> 	js	fa_addend_normalised		; yes
   476 0000225E C3                  <1> fa_nop:	ret					; accumulator block unchanged
   477                              <1> 
   478                              <1> fa_addend_normalised:
   479 0000225F 8B4704              <1> 	mov	eax, dword ptr [rdi+1*4]	; register side operand normalised?
   480 00002262 334708              <1> 	xor	eax, dword ptr [rdi+2*4]	; normalising bit must ^ signs
   481 00002265 7804                <1> 	js	fa_promote_magnitude		; normalised, get on with it
   482 00002267 4889F7              <1> 	mov	rdi, rsi			; accumulator block is not normalised
   483 0000226A C3                  <1> 	ret					; storage addend zero-added
   484                              <1> 
   485                              <1> fa_promote_magnitude:
   486 0000226B 8B07                <1> 	mov	eax, dword ptr [rdi]
   487 0000226D 2B06                <1> 	sub	eax, dword ptr [rsi]
   488                              <1> 
   489 0000226F 7905                <1> 	jns	fa_add				; register-side operand is not lower
   490                              <1> 
   491 00002271 4887F7              <1> 	xchg	rsi, rdi			;
   492 00002274 F7D8                <1> 	neg	eax
   493                              <1> 
   494                              <1> fa_add:	;	call	frame_mantissa
   495 00002276 50                  <1> 	push	rax				; exponent difference
   496 00002277 E8C6FDFFFF          <1> 	call	round1
   497                              <1> 
   498 0000227C 58                  <1> 	pop	rax				; exponent difference
   499 0000227D 21C0                <1> 	and	eax, eax			; is + and either zero or not
   500 0000227F 740C                <1> 	jz	fa_addfast
   501                              <1> 
   502 00002281 3DBF000000          <1> 	cmp	eax, 191			; do they touch?
   503 00002286 77D6                <1> 	ja	fa_nop
   504                              <1> 
   505 00002288 E83BFEFFFF          <1> 	call	bias_addend
   506                              <1> ;	mov	rsi, dword ptr [rbp+CORE_INDEX1] ; done inside bias_addend
   507                              <1> ;	from mm7 anyway
   508                              <1> ;	lea	rsi, [rsi+_BIAS]		; shifted added
   509                              <1> 
   510                              <1> fa_addfast:
   511 0000228D 8B4704              <1> 	mov	eax, dword ptr [rdi+1*4]	; before look signs
   512                              <1> 
   513                              <1> 	%if	__FLAT_STAC
   514 00002290 89C2                <1> 	mov	edx, eax
   515                              <1> 	%else
   516                              <1> 	push	rax				; near stack top until fa_normalised
   517                              <1> 	%endif
   518                              <1> 
   519 00002292 C1C910              <1> 	ror	ecx, 16				; get containing compute words
   520 00002295 0FB7D9              <1> 	movzx	ebx, cx				; index / count
   521 00002298 C1C910              <1> 	ror	ecx, 16
   522                              <1> 
   523                              <1> 	%if	BIAS_FIELD=8
   524 0000229B 81671C000000FF      <1> 	and	dword ptr [rdi+7*4], 0FF000000h
   525 000022A2 81661C000000FF      <1> 	and	dword ptr [rsi+7*4], 0FF000000h
   526                              <1> 	%endif
   527                              <1> 
   528 000022A9 F8                  <1> 	clc
   529                              <1> 
   530                              <1> fa_action:
   531 000022AA 8B049E              <1> 	mov	eax, dword ptr [rsi+rbx*4]
   532 000022AD 11049F              <1> 	adc	dword ptr [rdi+rbx*4], eax
   533 000022B0 FFCB                <1> 	dec	ebx				; process word 1
   534 000022B2 75F6                <1> 	jnz	fa_action			; leave word 0 alone
   535                              <1> 
   536 000022B4 0F92C3              <1> 	setc	bl				; boolean instructions following
   537                              <1> 
   538                              <1> 	%if	__FLAT_STAC
   539                              <1> 	%else
   540                              <1> 	push	rbx				; should not change carry but
   541                              <1> 	%endif
   542                              <1> 
   543 000022B7 480F7EFE            <1> 	movq	rsi, mm7
   544                              <1> 	
   545 000022BB 8B4704              <1> 	mov	eax, dword ptr [rdi+1*4]	; has sign switched ?
   546                              <1> 
   547                              <1> 	%if	__FLAT_STAC
   548 000022BE 31D0                <1> 	xor	eax, edx
   549                              <1> 	%else
   550                              <1> 	xor	eax, dword ptr [rsp+1*4]
   551                              <1> 	%endif
   552                              <1> 	
   553 000022C0 7917                <1> 	jns	fa_testcarry
   554                              <1> 
   555                              <1> ;	not	dword ptr [rsi+7*4]
   556                              <1> 
   557 000022C2 F686B004000008      <1> 	test	byte ptr [rsi+PSR], FP_R	; flag 8 = store residue
   558 000022C9 7509                <1> 	jnz	switch_long
   559                              <1> 
   560 000022CB F7561C              <1> 	not	dword ptr [rsi+7*4]
   561 000022CE F75718              <1> 	not	dword ptr [rdi+6*4]		; if double size (+ residue)
   562 000022D1 F75714              <1> 	not	dword ptr [rdi+5*4]		; these are written in the add loop
   563                              <1> switch_long:
   564                              <1> 
   565                              <1> ;	not	dword ptr [rdi+7*4]		; thru zero
   566                              <1> 
   567                              <1> 	%if	__FLAT_STAC
   568                              <1> 	%else
   569                              <1> 	push	rsi				; have a clear expectation
   570                              <1> 	mov	rsi, rsp			; where the first stack words are
   571                              <1> 	%endif
   572                              <1> 
   573 000022D4 E8A0FDFFFF          <1> 	call	end_around_carry
   574                              <1> 
   575                              <1> 	%if	__FLAT_STAC
   576                              <1> 	%else
   577                              <1> 	pop	rsi
   578                              <1> 	%endif
   579                              <1> 
   580                              <1> fa_testcarry:
   581                              <1> 
   582                              <1> 	%if	__FLAT_STAC
   583 000022D9 89D0                <1> 	mov	eax, edx
   584                              <1> 	%else
   585                              <1> 	mov	eax, dword ptr [rsp+1*4]		; [ rsp + 1L ] -> updated signs
   586                              <1> 	%endif
   587                              <1> 
   588 000022DB 334704              <1> 	xor	eax, dword ptr [rdi+1*4]		; carry from normalising position?
   589                              <1> 
   590 000022DE 2401                <1> 	and	al, 1
   591 000022E0 7420                <1> 	jz	fa_normalise
   592                              <1> 
   593 000022E2 FF07                <1> 	inc	dword ptr [rdi]				; exponent magnitude++
   594                              <1> 
   595                              <1> 	%if	 __FLAT_STAC
   596 000022E4 89D0                <1> 	mov	eax, edx
   597                              <1> 	%else
   598                              <1> 	mov	eax, dword ptr [rsp+1*4]	 	; read 32 signs
   599                              <1> 	%endif
   600                              <1> 
   601 000022E6 D1C8                <1> 	ror	eax, 1					; move a sign to carry	
   602                              <1> 
   603 000022E8 D15F04              <1> 	rcr	dword ptr [rdi+1*4], 1			; shift from signs word
   604 000022EB D15F08              <1> 	rcr	dword ptr [rdi+2*4], 1			; to normalising position
   605 000022EE D15F0C              <1> 	rcr	dword ptr [rdi+3*4], 1			; keep going
   606 000022F1 D15F10              <1> 	rcr	dword ptr [rdi+4*4], 1
   607 000022F4 D15F14              <1> 	rcr	dword ptr [rdi+5*4], 1
   608 000022F7 D15F18              <1> 	rcr	dword ptr [rdi+6*4], 1
   609 000022FA D15F1C              <1> 	rcr	dword ptr [rdi+7*4], 1
   610                              <1> 
   611 000022FD 894704              <1> 	mov	dword ptr [rdi+1*4], eax		; write all signs back to signs word
   612                              <1> 
   613 00002300 EB0A                <1> 	jmp	fa_normalised
   614                              <1> 
   615                              <1> fa_normalise:
   616                              <1> 	%if	BIAS_FIELD=8
   617 00002302 E821040000          <1> 	call	fp_registers_m
   618                              <1> 	%endif
   619                              <1> 
   620 00002307 E83FFEFFFF          <1> 	call	renormalise				; in case the sum is plenty positions
   621                              <1> 
   622                              <1> fa_normalised:
   623                              <1> 	%if	__FLAT_STAC
   624                              <1> 	%else
   625                              <1> 	pop	rbx
   626                              <1> 	pop	rax					; below the fractional point
   627                              <1> 	%endif
   628 0000230C C3                  <1> 	ret
   629                              <1> 	
   630 0000230D 488DBE40040000      <1> fm:	lea	rdi, [rsi+_OUTPUT]			; initialise final accumulation
   631 00002314 E80FFDFFFF          <1> 	call	zoutput
   632                              <1> 
   633 00002319 8B9E24040000        <1> 	mov	ebx, dword ptr [rsi+_INPUTR+1*4]	; read register-side signs
   634 0000231F 8B8628040000        <1> 	mov	eax, dword ptr [rsi+_INPUTR+2*4]	; and high-end mantissa
   635 00002325 31D8                <1> 	xor	eax, ebx	 			; cache if-normalised in eax
   636 00002327 339E04040000        <1> 	xor	ebx, dword ptr [rsi+_INPUT2+1*4]	; multiply signs
   637 0000232D 899E44040000        <1> 	mov	dword ptr [rsi+_OUTPUT+1*4], ebx	; save the output sign
   638 00002333 21C0                <1> 	and	eax, eax				; test the cached if-normalised
   639 00002335 790E                <1> 	jns	fmdont
   640                              <1> 
   641 00002337 8B8604040000        <1> 	mov	eax, dword ptr [rsi+_INPUT2+1*4]	; is the multiplier normalised?
   642 0000233D 338608040000        <1> 	xor	eax, dword ptr [rsi+_INPUT2+2*4]	; sign XOR normalising bit?
   643 00002343 782F                <1> 	js	fmgo					; yes, proceed
   644                              <1> 
   645 00002345 899E48040000        <1> fmdont:	mov	dword ptr [rsi+_OUTPUT+2*4], ebx
   646 0000234B 899E4C040000        <1> 	mov	dword ptr [rsi+_OUTPUT+3*4], ebx
   647 00002351 899E50040000        <1> 	mov	dword ptr [rsi+_OUTPUT+4*4], ebx
   648 00002357 899E54040000        <1> 	mov	dword ptr [rsi+_OUTPUT+5*4], ebx
   649 0000235D 899E58040000        <1> 	mov	dword ptr [rsi+_OUTPUT+6*4], ebx
   650 00002363 899E5C040000        <1> 	mov	dword ptr [rsi+_OUTPUT+7*4], ebx
   651 00002369 C78640040000000000- <1> 	mov	dword ptr [rsi+_OUTPUT], 0		; mantissa to go
   651 00002372 00                  <1>
   652                              <1> 
   653 00002373 C3                  <1> 	ret					; no, effective zero multiplier
   654                              <1> 
   655 00002374 51                  <1> fmgo:	push	rcx
   656 00002375 8B8624040000        <1> 	mov	eax, dword ptr [rsi+_INPUTR+1*4]
   657 0000237B B148                <1> 	mov	cl, 72				; beats count exactly 72
   658 0000237D 21C0                <1> 	and	eax, eax
   659                              <1> 
   660 0000237F 790C                <1> 	jns	fmp1
   661 00002381 488DBE20040000      <1> 	lea	rdi, [rsi+_INPUTR]
   662 00002388 E84CFEFFFF          <1> 	call	zover
   663                              <1> 
   664 0000238D 8B8604040000        <1> fmp1:	mov	eax, dword ptr [rsi+_INPUT2+1*4]
   665 00002393 21C0                <1> 	and	eax, eax
   666 00002395 790C                <1> 	jns	fmadd
   667 00002397 488DBE00040000      <1> 	lea	rdi, [rsi+_INPUT2]
   668 0000239E E836FEFFFF          <1> 	call	zover
   669                              <1> 
   670 000023A3 F8                  <1> fmadd:	clc
   671                              <1> 
   672 000023A4 488DBE20040000      <1> 	lea	rdi, [rsi+_INPUTR]
   673 000023AB D15F08              <1> 	rcr	dword ptr [rdi+2*4], 1		; addend shift right
   674 000023AE D15F0C              <1> 	rcr	dword ptr [rdi+3*4], 1
   675 000023B1 D15F10              <1> 	rcr	dword ptr [rdi+4*4], 1
   676 000023B4 D15F14              <1> 	rcr	dword ptr [rdi+5*4], 1
   677 000023B7 D15F18              <1> 	rcr	dword ptr [rdi+6*4], 1
   678 000023BA D15F1C              <1> 	rcr	dword ptr [rdi+7*4], 1
   679                              <1> 
   680 000023BD 488DBE00040000      <1> 	lea	rdi, [rsi+_INPUT2]
   681                              <1> 
   682                              <1> 	%if	0
   683                              <1> 	rcl	dword ptr [rdi+7*4], 1		; multiplier shift left
   684                              <1> 	rcl	dword ptr [rdi+6*4], 1
   685                              <1> 	rcl	dword ptr [rdi+5*4], 1		; multiplier mantissa is only 72 bits
   686                              <1> 	%endif
   687                              <1> 
   688 000023C4 D15710              <1> 	rcl	dword ptr [rdi+4*4], 1
   689 000023C7 D1570C              <1> 	rcl	dword ptr [rdi+3*4], 1
   690 000023CA D15708              <1> 	rcl	dword ptr [rdi+2*4], 1
   691                              <1> 
   692 000023CD 488DBE40040000      <1> 	lea	rdi, [rsi+_OUTPUT]
   693 000023D4 7336                <1> 	jnc	fmadx
   694                              <1> 						; 1 shifted from multiplier
   695 000023D6 8B863C040000        <1> fmadc:	mov	eax, dword ptr [rsi+_INPUTR+7*4]	
   696 000023DC 01471C              <1> 	add	dword ptr [rdi+7*4], eax	; do not use carry
   697 000023DF 8B8638040000        <1> 	mov	eax, dword ptr [rsi+_INPUTR+6*4]
   698 000023E5 114718              <1> 	adc	dword ptr [rdi+6*4], eax	; start using carry
   699 000023E8 8B8634040000        <1> 	mov	eax, dword ptr [rsi+_INPUTR+5*4]
   700 000023EE 114714              <1> 	adc	dword ptr [rdi+5*4], eax
   701 000023F1 8B8630040000        <1> 	mov	eax, dword ptr [rsi+_INPUTR+4*4]
   702 000023F7 114710              <1> 	adc	dword ptr [rdi+4*4], eax
   703 000023FA 8B862C040000        <1> 	mov	eax, dword ptr [rsi+_INPUTR+3*4]
   704 00002400 11470C              <1> 	adc	dword ptr [rdi+3*4], eax
   705 00002403 8B8628040000        <1> 	mov	eax, dword ptr [rsi+_INPUTR+2*4]
   706 00002409 114708              <1> 	adc	dword ptr [rdi+2*4], eax
   707                              <1> 
   708 0000240C FEC9                <1> fmadx:	dec	cl
   709 0000240E 7593                <1> 	jnz	fmadd
   710                              <1> 
   711 00002410 59                  <1> fmadz:	pop	rcx
   712                              <1> 
   713 00002411 8B4708              <1> 	mov	eax, dword ptr [rdi+2*4] 	; normalised?
   714 00002414 D1D0                <1> 	rcl	eax, 1
   715 00002416 721B                <1> 	jc	fm_normalised
   716                              <1> 
   717 00002418 838620040000FF      <1> 	add	dword ptr [rsi+_INPUTR], -1		; take 1 from scale
   718 0000241F D1571C              <1> 	rcl	dword ptr [rdi+7*4], 1
   719 00002422 D15718              <1> 	rcl	dword ptr [rdi+6*4], 1
   720 00002425 D15714              <1> 	rcl	dword ptr [rdi+5*4], 1
   721 00002428 D15710              <1> 	rcl	dword ptr [rdi+4*4], 1
   722 0000242B D1570C              <1> 	rcl	dword ptr [rdi+3*4], 1
   723 0000242E D15708              <1> 	rcl	dword ptr [rdi+2*4], 1
   724                              <1> 
   725 00002431 EB27                <1> 	jmp	fm_inrange
   726                              <1> 
   727                              <1> fm_normalised:
   728 00002433 488DBE40040000      <1> 	lea	rdi, [rsi+_OUTPUT]
   729 0000243A E81AFCFFFF          <1> 	call	round2
   730 0000243F 7319                <1> 	jnc	fm_inrange
   731                              <1> 
   732 00002441 D15F08              <1> 	rcr	dword ptr [rdi+2*4], 1
   733 00002444 D15F0C              <1> 	rcr	dword ptr [rdi+3*4], 1
   734 00002447 D15F10              <1> 	rcr	dword ptr [rdi+4*4], 1
   735 0000244A D15F14              <1> 	rcr	dword ptr [rdi+5*4], 1
   736 0000244D D15F18              <1> 	rcr	dword ptr [rdi+6*4], 1
   737 00002450 D15F1C              <1> 	rcr	dword ptr [rdi+7*4], 1
   738 00002453 83862004000001      <1> 	add	dword ptr [rsi+_INPUTR], 1
   739                              <1> 
   740                              <1> fm_inrange:
   741 0000245A 8B8620040000        <1> 	mov	eax, dword ptr [rsi+_INPUTR]
   742 00002460 038600040000        <1> 	add	eax, dword ptr [rsi+_INPUT2]
   743 00002466 050000C0FF          <1> 	add	eax, -00400000h
   744 0000246B 8907                <1> 	mov	dword ptr [rdi], eax		; insert unsigned magnitude product scale
   745 0000246D 8B4704              <1> 	mov	eax, dword ptr [rdi+1*4]
   746 00002470 314708              <1> 	xor	dword ptr [rdi+2*4], eax	; the mantissa gets polarised here
   747 00002473 31470C              <1> 	xor	dword ptr [rdi+3*4], eax
   748 00002476 314710              <1> 	xor	dword ptr [rdi+4*4], eax
   749 00002479 314714              <1> 	xor	dword ptr [rdi+5*4], eax
   750 0000247C 314718              <1> 	xor	dword ptr [rdi+6*4], eax
   751 0000247F 31471C              <1> 	xor	dword ptr [rdi+7*4], eax
   752 00002482 C3                  <1> 	ret
   753                              <1> 
   754 00002483 488DBE40040000      <1> fd:	lea	rdi, [rsi+_OUTPUT]
   755 0000248A E899FBFFFF          <1> 	call	zoutput				; result which may stay zero
   756 0000248F 8B8604040000        <1> 	mov	eax, dword ptr [rsi+_INPUT2+1*4]	; signs
   757 00002495 89C3                <1> 	mov	ebx, eax
   758 00002497 338608040000        <1> 	xor	eax, dword ptr [rsi+_INPUT2+2*4]	; normalising bit 31
   759 0000249D 780C                <1> 	js	fdgo
   760 0000249F F79644040000        <1> 	not	dword ptr [rsi+_OUTPUT+1*4]		; divisor 0 or otherwise unnormalised
   761 000024A5 E82FFDFFFF          <1> 	call	zover				; return -0.0
   762 000024AA C3                  <1> fdnop:	ret					; not normalised = zero divisor
   763                              <1> 
   764 000024AB 8B8624040000        <1> fdgo:	mov     eax, dword ptr [rsi+_INPUTR+1*4]	; make sure the dividend is present
   765 000024B1 338628040000        <1> 	xor	eax, dword ptr [rsi+_INPUTR+2*4]	; normalising bit must be not sign
   766 000024B7 783B                <1> 	js	fdop				; go after all
   767                              <1> 						; unnormalised = 0 = unnormalised
   768 000024B9 8B8624040000        <1> 	mov	eax, dword ptr [rsi+_INPUTR+1*4]	; read the signs I tell you
   769 000024BF C78640040000000000- <1> 	mov	dword ptr [rsi+_OUTPUT], 0		; exponent magnitude of nowhere
   769 000024C8 00                  <1>
   770 000024C9 898644040000        <1> 	mov	dword ptr [rsi+_OUTPUT+1*4], eax	; signs
   771 000024CF 898648040000        <1> 	mov	dword ptr [rsi+_OUTPUT+2*4], eax	; and as much mantissa as you like
   772 000024D5 89864C040000        <1> 	mov	dword ptr [rsi+_OUTPUT+3*4], eax
   773 000024DB 898650040000        <1> 	mov	dword ptr [rsi+_OUTPUT+4*4], eax
   774 000024E1 898654040000        <1> 	mov	dword ptr [rsi+_OUTPUT+5*4], eax
   775 000024E7 898658040000        <1> 	mov	dword ptr [rsi+_OUTPUT+6*4], eax
   776 000024ED 89865C040000        <1> 	mov	dword ptr [rsi+_OUTPUT+7*4], eax
   777 000024F3 C3                  <1> 	ret
   778                              <1> 
   779 000024F4 21DB                <1> fdop:	and	ebx, ebx				; divisor either is negative magnitude
   780 000024F6 780C                <1> 	js	fd_comp1	
   781 000024F8 488DBE00040000      <1> 	lea	rdi, [rsi+_INPUT2]			; or shall be
   782 000024FF E8D5FCFFFF          <1> 	call	zover
   783                              <1> fd_comp1:
   784 00002504 F78624040000000000- <1> 	test	dword ptr [rsi+_INPUTR+1*4], 080000000h
   784 0000250D 80                  <1>
   785 0000250E 740C                <1> 	jz	fd_upright			; dividend must be positive magnitude
   786 00002510 488DBE20040000      <1> 	lea	rdi, [rsi+_INPUTR]
   787 00002517 E8BDFCFFFF          <1> 	call	zover
   788                              <1> fd_upright:
   789 0000251C 488DBE20040000      <1> 	lea	rdi, [rsi+_INPUTR]
   790                              <1> 
   791 00002523 E81AFBFFFF          <1> 	call	round1				; this also sets counters
   792                              <1> 
   793 00002528 52                  <1> 	push	rdx
   794 00002529 51                  <1> 	push	rcx
   795                              <1> 
   796                              <1> ;	add	cx, 01818h		; a divide needs 24 more beats
   797                              <1> 					; than a multiply
   798                              <1> 
   799 0000252A 89C8                <1> 	mov	eax, ecx		; save words count in add range
   800 0000252C B15F                <1> 	mov	cl, 95
   801                              <1> 
   802 0000252E C1E810              <1> 	shr	eax, 16			; isolate words count in add range
   803 00002531 6683C0FA            <1> 	add	ax, -6			; is it big?
   804 00002535 0F8393000000        <1> 	jnc	near fd_72
   805                              <1> 
   806                              <1> ;	test	ch, 128
   807                              <1> ;	jz	near fd_72
   808                              <1> 
   809 0000253B 4889E7              <1> 	mov	rdi, rsp
   810                              <1> 
   811 0000253E B1BF                <1> 	mov	cl, 191			; 
   812                              <1> 
   813 00002540 F9                  <1> fd_144:	stc				; add negative mantissa
   814 00002541 E8A6FCFFFF          <1> 	call	_add_low		; to positive dividend
   815 00002546 52                  <1> 	push	rdx			; save the low half in the stack
   816 00002547 53                  <1> 	push	rbx
   817 00002548 50                  <1> 	push	rax
   818 00002549 E8C3FCFFFF          <1> 	call	_add_high			; add the high half in eax edx ebx
   819                              <1> 
   820 0000254E 7327                <1> 	jnc	fd_144level			; no carry = drop the result
   821                              <1> 
   822 00002550 898628040000        <1> 	mov	dword ptr [rsi+_INPUTR+2*4], eax	; carry = update the dividend
   823 00002556 899E2C040000        <1> 	mov	dword ptr [rsi+_INPUTR+3*4], ebx
   824 0000255C 899630040000        <1> 	mov	dword ptr [rsi+_INPUTR+4*4], edx
   825                              <1> 
   826 00002562 58                  <1> 	pop	rax
   827 00002563 898634040000        <1> 	mov	dword ptr [rsi+_INPUTR+5*4], eax
   828 00002569 58                  <1> 	pop	rax
   829 0000256A 898638040000        <1> 	mov	dword ptr [rsi+_INPUTR+6*4], eax
   830 00002570 58                  <1> 	pop	rax
   831 00002571 89863C040000        <1> 	mov	dword ptr [rsi+_INPUTR+7*4], eax
   832                              <1> fd_144level:
   833 00002577 4889FC              <1> 	mov	rsp, rdi	; clear stack whether popped or not
   834 0000257A D1965C040000        <1> 	rcl	dword ptr [rsi+_OUTPUT+7*4], 1	; shift value of carry into quotient
   835 00002580 D19658040000        <1> 	rcl	dword ptr [rsi+_OUTPUT+6*4], 1
   836 00002586 D19654040000        <1> 	rcl	dword ptr [rsi+_OUTPUT+5*4], 1
   837 0000258C D19650040000        <1> 	rcl	dword ptr [rsi+_OUTPUT+4*4], 1
   838 00002592 D1964C040000        <1> 	rcl	dword ptr [rsi+_OUTPUT+3*4], 1
   839 00002598 D19648040000        <1> 	rcl	dword ptr [rsi+_OUTPUT+2*4], 1
   840                              <1> 
   841 0000259E F9                  <1> 	stc
   842 0000259F D19E08040000        <1> 	rcr	dword ptr [rsi+_INPUT2+2*4], 1	; shift negative addend
   843 000025A5 D19E0C040000        <1> 	rcr	dword ptr [rsi+_INPUT2+3*4], 1	; 1 position starboard
   844 000025AB D19E10040000        <1> 	rcr	dword ptr [rsi+_INPUT2+4*4], 1
   845 000025B1 D19E14040000        <1> 	rcr	dword ptr [rsi+_INPUT2+5*4], 1
   846 000025B7 D19E18040000        <1> 	rcr	dword ptr [rsi+_INPUT2+6*4], 1
   847 000025BD D19E1C040000        <1> 	rcr	dword ptr [rsi+_INPUT2+7*4], 1
   848                              <1> 
   849 000025C3 80C1FF              <1> 	add	cl, -1
   850 000025C6 0F8274FFFFFF        <1> 	jc	fd_144
   851 000025CC EB44                <1> 	jmp	fd_restore	
   852                              <1> 
   853 000025CE F9                  <1> fd_72:	stc					; add negative mantissa
   854 000025CF E83DFCFFFF          <1> 	call	_add_high			; to positive dividend
   855 000025D4 7312                <1> 	jnc	fd_72level			; no carry = drop the result
   856                              <1> 
   857 000025D6 898628040000        <1> 	mov	dword ptr [rsi+_INPUTR+2*4], eax	; carry = update the dividend
   858 000025DC 899E2C040000        <1> 	mov	dword ptr [rsi+_INPUTR+3*4], ebx
   859 000025E2 899630040000        <1> 	mov	dword ptr [rsi+_INPUTR+4*4], edx
   860                              <1> fd_72level:
   861 000025E8 D19650040000        <1> 	rcl	dword ptr [rsi+_OUTPUT+4*4], 1	; shift value of carry into quotient
   862 000025EE D1964C040000        <1> 	rcl	dword ptr [rsi+_OUTPUT+3*4], 1
   863 000025F4 D19648040000        <1> 	rcl	dword ptr [rsi+_OUTPUT+2*4], 1
   864                              <1> 
   865 000025FA F9                  <1> 	stc
   866 000025FB D19E08040000        <1> 	rcr	dword ptr [rsi+_INPUT2+2*4], 1	; shift negative addend
   867 00002601 D19E0C040000        <1> 	rcr	dword ptr [rsi+_INPUT2+3*4], 1	; 1 position starboard
   868 00002607 D19E10040000        <1> 	rcr	dword ptr [rsi+_INPUT2+4*4], 1	;
   869                              <1> 
   870 0000260D 80C1FF              <1> 	add	cl, -1
   871 00002610 72BC                <1> 	jc	fd_72
   872                              <1> 
   873 00002612 59                  <1> fd_restore:	pop	rcx
   874 00002613 5A                  <1> 		pop	rdx				; hand the program counter back
   875                              <1> 
   876                              <1> 
   877                              <1> ;		mov	rsi, dword ptr [rbp+CORE_INDEX1] ; fd kept esi -> core state
   878                              <1> ;	from mm7 anyway
   879                              <1> 
   880 00002614 8B8620040000        <1> 		mov	eax, dword ptr [rsi+_INPUTR]	; + magnitude dividend exponent
   881 0000261A 2B8600040000        <1> 		sub	eax, dword ptr [rsi+_INPUT2]	; + magnitude divisor exponent
   882 00002620 0501004000          <1> 		add	eax, 00400001h			; midpoint + 1
   883 00002625 898640040000        <1> 		mov	dword ptr [rsi+_OUTPUT], eax	; magnitude of quotient scale
   884                              <1> 							; -> front of delivery string
   885 0000262B 488DBE40040000      <1> 		lea	rdi, [rsi+_OUTPUT]
   886                              <1> 
   887 00002632 E814FBFFFF          <1> 		call	renormalise
   888                              <1> 
   889 00002637 488DBE40040000      <1> 		lea	rdi, [rsi+_OUTPUT]			; tell rewrite where it is
   890 0000263E 8B8624040000        <1> 		mov	eax, dword ptr [rsi+_INPUTR+1*4]	; determine sign of quotient
   891 00002644 338604040000        <1> 		xor	eax, dword ptr [rsi+_INPUT2+1*4]
   892 0000264A 894704              <1> 		mov	[rdi+1*4], eax			; output 32 signs
   893                              <1> 							; _deliver_ polarises the quotient scale
   894 0000264D 314708              <1> 		xor	dword ptr [rdi+2*4], eax	; switch quotient mantissa
   895 00002650 31470C              <1> 		xor	dword ptr [rdi+3*4], eax
   896 00002653 314710              <1> 		xor	dword ptr [rdi+4*4], eax
   897 00002656 314714              <1> 		xor	dword ptr [rdi+5*4], eax	; switch the long mantissa
   898 00002659 314718              <1> 		xor	dword ptr [rdi+6*4], eax
   899 0000265C 31471C              <1> 		xor	dword ptr [rdi+7*4], eax
   900                              <1> 
   901 0000265F C3                  <1> fd_z:		ret
   902                              <1> 
   903                              <1> 	;	these instructions take the left-side + target as
   904                              <1> 	;	[register_set]->a:b:mantissa2:mantissa3
   905                              <1> 	;	and the right side as [ea]
   906                              <1> 
   907                              <1> 	;	after acquisition and before delivery they call modules
   908                              <1> ;	fa fan fm fd
   909                              <1> ;	which may be used in extended instruction sets
   910                              <1> ;	using source and target registers in the internal stack
   911                              <1> ;	with maximum mantissa size 168 bits
   912                              <1> 
   913                              <1> 
   914                              <1> ;	rsi -> core state but must also be used dynamically a lot
   915                              <1> ;	rbp -> always points at either one of two locations
   916                              <1> 
   917                              <1> ;		RTA1 application registers [ 0..127 ] modeled in 128 integers
   918                              <1> ;		RTA1 interrupt registers [ 128..255 ] modeled in 128 integers
   919                              <1> ;
   920                              <1> ;	there is always a copy of rsi for retrieval at [ rbp + 152 integers ] ->
   921                              <1> 
   922                              <1> ;	_________________________.------ rsi and rbp in application mode
   923                              <1> ;	|  RTA1 register 0	|					|
   924                              <1> ;	|_______________________|					|
   925                              <1> ;									|
   926                              <1> ;	________________________.------- rbp in ISR mode		|
   927                              <1> ;	|  RTA1 register 128	|			|		|
   928                              <1> ;	|_______________________|			|		|
   929                              <1> ;							|		|
   930                              <1> ;							|		|
   931                              <1> ;							|		|
   932                              <1> ;	_________________________.______________________|_______________|
   933                              <1> ;	| 64-bit mm7 = rsi save + refresh 
   934                              <1> ;	|_______________________|
   935                              <1> 
   936                              <1> 	%if	BIAS_FIELD=8
   937                              <1> BIAS_POINTERS	equ	fp_registers_a
   938                              <1> 	%else
   939                              <1> BIAS_POINTERS	equ	fp_registers_m
   940                              <1> 	%endif
   941                              <1> 
   942 00002660 BB04000000          <1> _fa:	mov 	ebx, a
   943 00002665 53                  <1> _far:	push	rbx
   944 00002666 E86F000000          <1> 	call	fp_operands
   945 0000266B E89D000000          <1> 	call	BIAS_POINTERS
   946 00002670 E8D3FBFFFF          <1> 	call	fa
   947 00002675 5B                  <1> 	pop	rbx
   948 00002676 E9D3F8FFFF          <1> 	jmp	_deliver_
   949                              <1> 
   950 0000267B BB04000000          <1> _fan:	mov	ebx, a
   951 00002680 53                  <1> _fanr:	push	rbx
   952 00002681 E854000000          <1> 	call	fp_operands
   953 00002686 E882000000          <1> 	call	BIAS_POINTERS
   954 0000268B E8A6FBFFFF          <1> 	call	fan
   955 00002690 5B                  <1> 	pop	rbx
   956 00002691 E9B8F8FFFF          <1> 	jmp	_deliver_
   957                              <1> 
   958 00002696 BB04000000          <1> _fm:	mov	ebx, a
   959 0000269B 53                  <1> _fmr:	push	rbx
   960 0000269C E839000000          <1> 	call	fp_operands
   961 000026A1 E882000000          <1> 	call	fp_registers_m
   962 000026A6 E862FCFFFF          <1> 	call	fm
   963 000026AB 5B                  <1> 	pop	rbx
   964 000026AC 488DBE40040000      <1> 	lea	rdi, [rsi+_OUTPUT]
   965 000026B3 E996F8FFFF          <1> 	jmp	 _deliver_
   966                              <1> 
   967 000026B8 BB04000000          <1> _fd:	mov	ebx, a				; default target register
   968 000026BD 53                  <1> _fdr:	push	rbx
   969 000026BE E817000000          <1> 	call	fp_operands
   970 000026C3 E860000000          <1> 	call	fp_registers_m
   971 000026C8 E8B6FDFFFF          <1> 	call	fd
   972 000026CD 5B                  <1> 	pop	rbx
   973 000026CE 488DBE40040000      <1> 	lea	rdi, [rsi+_OUTPUT]
   974 000026D5 E974F8FFFF          <1> 	jmp	_deliver_
   975                              <1> 
   976                              <1> fp_operands:
   977 000026DA 488DBE20040000      <1> 	lea	rdi, [rsi+_INPUTR]
   978 000026E1 50                  <1> 	push	rax				; save effective address
   979 000026E2 E85C000000          <1> 	call	_load_quad
   980 000026E7 E819F8FFFF          <1> 	call	compress4to8
   981 000026EC 58                  <1> 	pop	rax				; restore effective address
   982                              <1> 
   983 000026ED 55                  <1> 	push	rbp				; ebp must momentarily
   984 000026EE 4889F5              <1> 	mov	rbp, rsi			; -> start of all register list
   985 000026F1 BB00010000          <1> 	mov	ebx, _input2			; into starboard buffer
   986 000026F6 E8D2DDFFFF          <1> 	call	_burst_read4			; memory or registers @ ea
   987 000026FB 5D                  <1> 	pop	rbp				; App / Int register context
   988                              <1> 
   989 000026FC 480F7EFE            <1> 	movq	rsi, mm7
   990                              <1> ;	mov	rsi, qword ptr [rbp+CORE_INDEX1]
   991                              <1> 
   992 00002700 488DBE00040000      <1> 	lea	rdi, [rsi+_INPUT2]		; but still in rbp
   993 00002707 E8F9F7FFFF          <1> 	call	compress4to8
   994 0000270C C3                  <1> 	ret
   995                              <1> 
   996                              <1> fp_registers_a:
   997 0000270D 480F7EFE            <1> 	movq	rsi, mm7
   998                              <1> ;	mov	rsi, qword ptr [rbp+CORE_INDEX1]
   999 00002711 B908020400          <1> 	mov	ecx, 00040208h
  1000 00002716 F786B0040000080000- <1> 	test	dword ptr [rsi+PSR], FP_R
  1000 0000271F 00                  <1>
  1001 00002720 7405                <1> 	jz	fp_registers_x
  1002 00002722 B910040700          <1> 	mov	ecx, 00070410h
  1003                              <1> fp_registers_x:
  1004 00002727 C3                  <1> 	ret
  1005                              <1> 
  1006                              <1> fp_registers_m:
  1007 00002728 480F7EFE            <1> 	movq	rsi, mm7
  1008                              <1> ;	mov	rsi, qword ptr [rbp+CORE_INDEX1]
  1009 0000272C B908020400          <1> 	mov	ecx, 00040208h
  1010 00002731 F786B0040000080000- <1> 	test	dword ptr [rsi+PSR], FP_R
  1010 0000273A 00                  <1>
  1011 0000273B 7405                <1> 	jz	fp_registers_z
  1012 0000273D B910040600          <1> 	mov	ecx, 00060410h
  1013                              <1> fp_registers_z:
  1014 00002742 C3                  <1> 	ret
  1015                              <1> 
  1016                              <1> _load_quad:
  1017 00002743 8B449D0C            <1> 	mov	eax, dword ptr[rbp+rbx*4+3*4]
  1018 00002747 89470C              <1> 	mov	dword ptr [rdi+3*4], eax
  1019 0000274A 8B449D08            <1> 	mov	eax, dword ptr  [rbp+rbx*4+2*4]
  1020 0000274E 894708              <1> 	mov	dword ptr [rdi+2*4], eax
  1021 00002751 8B449D04            <1> 	mov	eax, dword ptr [rbp+rbx*4+1*4]
  1022 00002755 894704              <1> 	mov	dword ptr [rdi+1*4], eax
  1023 00002758 8B449D00            <1> 	mov	eax, dword ptr [rbp+rbx*4]
  1024 0000275C 8907                <1> 	mov	dword ptr [rdi], eax
  1025 0000275E C3                  <1> 	ret
  1026                              <1> 
  1027                              <1> 
  1028                              <1> 	%if	0
  1029                              <1> ultrate:
  1030                              <1> 	mov	eax, dword ptr [rdi]
  1031                              <1> 	mov	dword ptr [_ultra], eax
  1032                              <1>  
  1033                              <1> 	mov     eax, dword ptr [rdi+1*4]
  1034                              <1> 	mov     dword ptr [_ultra1], eax
  1035                              <1> 
  1036                              <1>         mov     eax, dword ptr [rdi+2*4]
  1037                              <1>         mov     dword ptr [_ultra2], eax
  1038                              <1> 
  1039                              <1>         mov     eax, dword ptr [rdi+3*4]
  1040                              <1>         mov     dword ptr [_ultra3], eax
  1041                              <1> 
  1042                              <1>         mov     eax, dword ptr [rdi+4*4]
  1043                              <1>         mov     dword ptr [_ultra4], eax
  1044                              <1> 
  1045                              <1>         mov     eax, dword ptr [rdi+5*4]
  1046                              <1>         mov     dword ptr [_ultra5], eax
  1047                              <1> 
  1048                              <1>         mov     eax, dword ptr [rdi+6*4]
  1049                              <1>         mov     dword ptr [_ultra6], eax
  1050                              <1> 
  1051                              <1>         mov     eax, dword ptr [rdi+7*4]
  1052                              <1>         mov     dword ptr [_ultra7], eax
  1053                              <1> 
  1054                              <1> 	ret
  1055                              <1> 
  1056                              <1> zultrate:
  1057                              <1> 	push	rdi
  1058                              <1> 	mov	rdi, __ZERO
  1059                              <1> 	call	ultrate
  1060                              <1> 	pop	rdi
  1061                              <1> 	ret
  1062                              <1> 
  1063                              <1> __ZERO	dd	0, 0, 0, 0, 0, 0, 0, 0
  1064                              <1> 	%endif
    43                                  	%include	"parity.msm"
     1                              <1> _get_parity:
     2 0000275F 8B5D10              <1>         mov     ebx, dword ptr [rbp+A]
     3 00002762 235D04              <1>         and     ebx, dword ptr [rbp+K]
     4                              <1> _fold_parity:
     5 00002765 30DF                <1>         xor     bh, bl
     6 00002767 C1EB08              <1>         shr     ebx, 8
     7 0000276A 30FB                <1>         xor     bl, bh
     8 0000276C C3                  <1>         ret
     9                              <1> 
    44                                  	%include	"margin.msm"
     1                              <1> read_straddle_12b?:
     2                              <1> 
     3 0000276D F6C101              <1> 	test	cl, 1				; 4 words? You are here because
     4 00002770 753A                <1> 	jnz	split_read4w			; offset is within last 3 of page
     5                              <1> 						; 2 words then
     6 00002772 81FEFF0F0000        <1> 	cmp	esi, 0FFFh			; starting @ last word of page?
     7 00002778 7231                <1> 	jb	readout				; not so, go ahead with burst read
     8                              <1> 
     9                              <1> split_read2w:
    10 0000277A 480F7EFE            <1> 	movq	rsi, mm7
    11                              <1> ;	mov	rsi, qword ptr [rbp+CORE_INDEX1]
    12                              <1> 
    13 0000277E 48893C24            <1> 	mov	qword ptr [rsp], rdi		; delete 1st return address + save EA
    14 00002782 4889F8              <1> 	mov	rax, rdi			; recover EA
    15 00002785 30C9                <1> 	xor	cl, cl				; request 1 word
    16 00002787 E886DDFFFF          <1> 	call	_bus_read			;
    17 0000278C 48870424            <1> 	xchg	rax, qword ptr [rsp]		; save 1st word read + load updated EA
    18 00002790 FFC0                <1> 	inc	eax				; advance EA onto next page
    19 00002792 30C9                <1> 	xor	cl, cl				; request 1 word
    20 00002794 E879DDFFFF          <1> 	call	_bus_read			; read new page or block
    21 00002799 89C3                <1> 	mov	ebx, eax
    22 0000279B 58                  <1> 	pop	rax				; recover 1st read word
    23 0000279C C3                  <1> 	ret					; return to caller of operand_read
    24                              <1> 
    25                              <1> read_straddle_18b?:
    26 0000279D F6C101              <1> 	test	cl, 1				; 4 words? You are here because 
    27 000027A0 750A                <1> 	jnz	split_read4w			; offset is within last 3 of of bank
    28                              <1> 						; 2 words then
    29 000027A2 4881FEFFFF0300      <1> 	cmp	rsi, 0003FFFFh			; starting @ last word of bank?
    30 000027A9 73CF                <1> 	jnb	split_read2w			; otherwise fall thru to burst read
    31                              <1> 
    32                              <1> readout:
    33 000027AB C3                  <1> 	ret					; burst read in order
    34                              <1> 
    35                              <1> split_read4w:					; write EA over stack top return address
    36 000027AC 480F7EFE            <1> 	movq	rsi, mm7
    37                              <1> ;	mov	rsi, qword ptr [rbp+CORE_INDEX1]
    38                              <1> 
    39 000027B0 48893C24            <1> 	mov	qword ptr [rsp], rdi		; one or other of these 2-word reads
    40 000027B4 89F8                <1> 	mov	eax, edi			; splits down to 1-word reads
    41 000027B6 E807000000          <1> 	call	read2				; when offset is [3F]FFD
    42 000027BB E802000000          <1> 	call	read2				;             or [3F]FFF
    43 000027C0 58                  <1> 	pop	rax				;   but not when [3F]FFE
    44 000027C1 C3                  <1> 	ret					; return to caller of caller
    45                              <1> 	
    46 000027C2 50                  <1> read2:	push	rax				; EA
    47 000027C3 53                  <1> 	push	rbx				; destination index on stack top
    48 000027C4 B106                <1> 	mov	cl, 6				; ask bus for 2 words
    49 000027C6 E847DDFFFF          <1> 	call	_bus_read			; replaces eax and ebx
    50 000027CB 48871C24            <1> 	xchg	rbx, qword ptr [rsp]		; get destination index up again
    51 000027CF 89449D00            <1> 	mov	dword ptr [rbp+rbx*4], eax	; write 1st result word
    52 000027D3 58                  <1> 	pop	rax				; recover 2nd result word
    53 000027D4 89449D04            <1> 	mov	dword ptr [rbp+rbx*4+1*4], eax	; write 2nd result word
    54 000027D8 58                  <1> 	pop	rax				; EA
    55 000027D9 4883C002            <1> 	add	rax, 2
    56 000027DD 4883C302            <1> 	add	rbx, 2
    57 000027E1 C3                  <1> 	ret	
    58                              <1> 
    45                                  	%include	"margin_w.msm"
     1                              <1> write_straddle_12b?:				; multiword write request
     2                              <1> write_straddle12b?:				; in last 3 words of block
     3 000027E2 F6C101              <1> 	test	cl, 1				; 4-word write request?
     4 000027E5 753E                <1> 	jnz	split_write4w			;
     5 000027E7 81FEFF0F0000        <1> 	cmp	esi, 0FFFH			; 2 words then. In last word?
     6 000027ED 7235                <1> 	jb	writeout			; no
     7                              <1> 						; yes
     8                              <1> split_write2w:
     9 000027EF 480F7EFE            <1> 	movq	rsi, mm7
    10                              <1> ;	mov	rsi, qword ptr [rbp+CORE_INDEX1]
    11                              <1> 
    12 000027F3 48891C24            <1> 	mov	qword ptr [rsp], rbx		; not returning to there
    13 000027F7 57                  <1> 	push	rdi				; esp -> saved eax [ea], saved ebx
    14 000027F8 4889F8              <1> 	mov	rax, rdi			; place ea in eax
    15 000027FB 30C9                <1> 	xor	cl, cl				; request 1-word write
    16 000027FD 8B5C9D00            <1> 	mov	ebx, dword ptr [rbp+rbx*4]	; data from register array
    17 00002801 E8DADEFFFF          <1> 	call	bus_write
    18 00002806 58                  <1> 	pop	rax				; retrieve ea from stack
    19 00002807 5B                  <1> 	pop	rbx				; retrieve register index
    20 00002808 48FFC0              <1> 	inc	rax				; advance ea to next block
    21 0000280B 8B5C9D04            <1> 	mov	ebx, dword ptr [rbp+rbx*4+4]	; data from register array
    22 0000280F 30C9                <1> 	xor	cl, cl				; request 1-word write
    23 00002811 E8CADEFFFF          <1> 	call	bus_write
    24 00002816 C3                  <1> 	ret					; return caller of caller
    25                              <1> 
    26                              <1> write_straddle_18b?:				; multiword write request
    27                              <1> write_straddle18b?:				; in last 3 words of block
    28 00002817 F6C101              <1> 	test	cl, 1				; 4 words?
    29 0000281A 7509                <1> 	jnz	split_write4w
    30 0000281C 81FEFFFF0300        <1> 	cmp	esi, 0003FFFFh			; 2 words then. In last word?
    31 00002822 73CB                <1> 	jnb	split_write2w			; yes
    32                              <1> 						; no
    33                              <1> writeout:
    34 00002824 C3                  <1> 	ret					; return to burst write
    35                              <1> 
    36                              <1> split_write4w:
    37 00002825 480F7EFE            <1> 	movq	rsi, mm7
    38                              <1> ;	mov	rsi, qword ptr [rbp+CORE_INDEX1]
    39                              <1> 
    40 00002829 48893C24            <1> 	mov	qword ptr [rsp], rdi		; return address at stack top not used
    41 0000282D 4889F8              <1> 	mov	rax, rdi			; copy ea
    42 00002830 E807000000          <1> 	call	write2				; request 2 writes word pairs
    43 00002835 E802000000          <1> 	call	write2				; if 1 of them straddles it splits again
    44 0000283A 58                  <1> 	pop	rax				; this is ea
    45 0000283B C3                  <1> 	ret					; return to caller of caller
    46                              <1> 
    47                              <1> 
    48 0000283C B106                <1> write2:	mov	cl, 6				; request 2-word bus write
    49 0000283E 50                  <1> 	push	rax				; save ea
    50 0000283F 53                  <1> 	push	rbx				; save register array index
    51 00002840 E89BDEFFFF          <1> 	call	bus_write			; send write pair request
    52 00002845 5B                  <1> 	pop	rbx				; retrieve register index
    53 00002846 58                  <1> 	pop	rax				; and ea
    54 00002847 4883C302            <1> 	add	rbx, 2				; update register index
    55 0000284B 4883C002            <1> 	add	rax, 2				; and ea
    56 0000284F C3                  <1> 	ret
    46                                  	%include	"rex.msm"
     1                              <1> SIMD_192	equ	1
     2                              <1> 
     3                              <1> _rextable_1
     3          ******************  <1>  warning: label alone on a line without a colon might be in error [-w+orphan-labels]
     4 00002850 000000000000000000- <1> 	dd	0, 0, 0, 0,		r_sa, r_sb, r_z, 0
     4 00002859 00000000000000-     <1>
     4 00002860 [D92B0000]-         <1>
     4 00002864 [D02B0000]-         <1>
     4 00002868 [F22B0000]00000000  <1>
     5 00002870 000000000000000000- <1> 	dd	0, 0, 0, 0,		r_la, r_lb, r_tz, r_tp
     5 00002879 00000000000000-     <1>
     5 00002880 [0D2C0000]-         <1>
     5 00002884 [042C0000]-         <1>
     5 00002888 [992B0000]-         <1>
     5 0000288C [B42B0000]          <1>
     6 00002890 0000000000000000-   <1> 	dd	0, 0, r_or, r_orB,	r_and, r_andB, r_xor, r_xorB
     6 00002898 [2B2C0000]-         <1>
     6 0000289C [222C0000]-         <1>
     6 000028A0 [4D2C0000]-         <1>
     6 000028A4 [442C0000]-         <1>
     6 000028A8 [6F2C0000]-         <1>
     6 000028AC [662C0000]          <1>
     7 000028B0 [912C0000]-         <1> 	dd	r_aa, r_ab, r_ana, r_anb, r_m, r_mf, r_d, 0
     7 000028B4 [882C0000]-         <1>
     7 000028B8 [AF2C0000]-         <1>
     7 000028BC [A62C0000]-         <1>
     7 000028C0 [EC2C0000]-         <1>
     7 000028C4 [CB2C0000]-         <1>
     7 000028C8 [982D0000]00000000  <1>
     8                              <1> 
     9                              <1> _rextable_6
     9          ******************  <1>  warning: label alone on a line without a colon might be in error [-w+orphan-labels]
    10 000028D0 [D82D0000]-         <1> 	dd	r_sar, r_sbr, r_dsr, 0, r_sal, r_sbl, r_dsl, 0
    10 000028D4 [CF2D0000]-         <1>
    10 000028D8 [F32D0000]00000000- <1>
    10 000028E0 [1F2E0000]-         <1>
    10 000028E4 [162E0000]-         <1>
    10 000028E8 [3A2E0000]00000000  <1>
    11 000028F0 [662E0000]-         <1> 	dd	r_rar, r_rbr, r_drr, 0, r_ral, r_rbl, r_drl, 0
    11 000028F4 [5D2E0000]-         <1>
    11 000028F8 [7F2E0000]00000000- <1>
    11 00002900 [AB2E0000]-         <1>
    11 00002904 [A22E0000]-         <1>
    11 00002908 [C42E0000]00000000  <1>
    12 00002910 [F02E0000]-         <1> 	dd	r_saa, r_sba, r_dsa, 0, 0, 0, 0, 0
    12 00002914 [E72E0000]-         <1>
    12 00002918 [0C2F0000]00000000- <1>
    12 00002920 000000000000000000- <1>
    12 00002929 00000000000000      <1>
    13 00002930 000000000000000000- <1> 	dd	0, 0, 0, 0, 		0, 0, 0, 0
    13 00002939 000000000000000000- <1>
    13 00002942 000000000000000000- <1>
    13 0000294B 0000000000          <1>
    14                              <1> 
    15                              <1> _rextable_7
    15          ******************  <1>  warning: label alone on a line without a colon might be in error [-w+orphan-labels]
    16 00002950 000000000000000000- <1> 	dd	0, 0, 0, 0,		0, 0, 0, 0
    16 00002959 000000000000000000- <1>
    16 00002962 000000000000000000- <1>
    16 0000296B 0000000000          <1>
    17 00002970 [2F2F0000]-         <1> 	dd	r_qs, r_ql, r_dte, 0,	r_fa, r_fan, r_fm, r_fd
    17 00002974 [3E2F0000]-         <1>
    17 00002978 [4D2F0000]00000000- <1>
    17 00002980 [2F2B0000]-         <1>
    17 00002984 [482B0000]-         <1>
    17 00002988 [612B0000]-         <1>
    17 0000298C [7D2B0000]          <1>
    18 00002990 000000000000000000- <1> 	dd	0, 0, 0, 0, 		0, r_mta, 0, 0
    18 00002999 000000000000000000- <1>
    18 000029A2 0000[632F0000]0000- <1>
    18 000029AA 000000000000        <1>
    19 000029B0 [822F0000]-         <1> 	dd	r_ds, r_dl, r_da, r_dan, 0, 0, 0, 0
    19 000029B4 [912F0000]-         <1>
    19 000029B8 [C52F0000]-         <1>
    19 000029BC [AA2F0000]00000000- <1>
    19 000029C4 000000000000000000- <1>
    19 000029CD 000000              <1>
    20                              <1> 
    21                              <1> 
    22 000029D0 F686B204000080      <1> _rex:	test	byte ptr [rsi+PSR+2], 128
    23 000029D7 0F88D8000000        <1> 	js	near _rex_z				; ISRs can't do this
    24                              <1> 
    25 000029DD E87DDEFFFF          <1> 	call	memory_read				; ea -> instruction for repeat	
    26                              <1> 
    27 000029E2 480F7EFE            <1> 	movq	rsi, mm7
    28                              <1> ;	mov	rsi, qword ptr [rbp+CORE_INDEX1]	; retrieve smp core ->
    29                              <1> 
    30 000029E6 898668040000        <1> 	mov	dword ptr [rsi+REGISTER+282*4], eax	; save instruction word
    31 000029EC E830D7FFFF          <1> 	call	__ea					; get initial ea of repeated  instruction
    32 000029F1 0FB6DD              <1> 	movzx	ebx, ch					; spin-off is opcode index in ch
    33                              <1> 							; and operand type in cl
    34 000029F4 80F906              <1> 	cmp	cl, 6
    35 000029F7 7214                <1> 	jb	_rex_itable1
    36 000029F9 7709                <1> 	ja	_rex_itable7
    37                              <1> 							; instruction list 6
    38 000029FB 8B1C9D[D0280000]    <1> 	mov	ebx, dword ptr [_rextable_6+rbx*4]	; shifts and jumps
    39 00002A02 EB10                <1> 	jmp	_rex_evaluate
    40                              <1> 
    41                              <1> _rex_itable7:						; instruction list 7
    42 00002A04 8B1C9D[50290000]    <1> 	mov	ebx, dword ptr [_rextable_7+rbx*4]	; large arithmetic
    43 00002A0B EB07                <1> 	jmp	_rex_evaluate
    44                              <1> 
    45                              <1> _rex_itable1:						; instruction list 1
    46 00002A0D 8B1C9D[50280000]    <1> 	mov	ebx, dword ptr [_rextable_1+rbx*4]	; single integer arithmetic
    47                              <1> 
    48                              <1> _rex_evaluate:
    49 00002A14 21DB                <1> 	and	ebx, ebx				; instruction for repeat execute?
    50 00002A16 0F8499000000        <1> 	jz	near _rex_z				; no
    51 00002A1C 899E74040000        <1> 	mov	dword ptr [rsi+REGISTER+285*4], ebx	; yes: save execution logic pointer
    52                              <1> 
    53                              <1> 							; if repeat instruction is indexed:
    54                              <1> 							; quick lookup tag for index increment
    55 00002A22 C78670040000000000- <1> 	mov	dword ptr [rsi+REGISTER+284*4], 0		; default no index register referenced
    55 00002A2B 00                  <1>
    56 00002A2C 8B9E68040000        <1> 	mov	ebx, dword ptr [rsi+REGISTER+282*4]	; identify any index register tag
    57 00002A32 6621DB              <1> 	and	bx, bx					; in the instruction word
    58 00002A35 791A                <1> 	jns	_rex_ready				; by testing bit 15
    59 00002A37 66C1EB0C            <1> 	shr	bx, 12
    60                              <1> 							; must be > indirection tags *B0+ *B1+
    61 00002A3B 80FB0A              <1> 	cmp	bl, 10					; pointers in storage not incremented
    62 00002A3E 7211                <1> 	jb	_rex_ready				; index registers may increment
    63 00002A40 80FB0E              <1> 	cmp	bl, 14
    64 00002A43 7303                <1> 	jnb	_rex_indexed				; [   fp sp ]  registers   [ 14 15 ]
    65 00002A45 80E307              <1> 	and	bl, 7					; [ x y a b ]  registers [ 2 3 4 5 ]
    66                              <1> 
    67                              <1> _rex_indexed:
    68 00002A48 83E30F              <1> 	and	ebx, 15					; make 32-bit index value
    69 00002A4B 899E70040000        <1> 	mov	dword ptr [rsi+REGISTER+284*4], ebx	; write quick lookup
    70                              <1> 
    71                              <1> _rex_ready:
    72 00002A51 8B5E34              <1> 	mov	ebx, dword ptr [rsi+REGISTER+Q]		; default target register [ q ] ->	
    73 00002A54 8B9674040000        <1> 	mov	edx, dword ptr [rsi+REGISTER+285*4]	; execute logic ->
    74 00002A5A FFD2                <1> 	call	rdx
    75                              <1> 
    76 00002A5C 8B8670040000        <1> 	mov	eax, dword ptr [rsi+REGISTER+284*4]	; index register tag?
    77 00002A62 6621C0              <1> 	and	ax, ax
    78 00002A65 7417                <1> 	jz	_rex_count				; no
    79                              <1> 
    80 00002A67 8B4E5C              <1> 	mov	ecx, dword ptr [rsi+REGISTER+WDATA]
    81 00002A6A 81E1FFFFFF00        <1> 	and	ecx, 00FFFFFFh				; index register increment configured?
    82 00002A70 740C                <1> 	jz	_rex_count				; no
    83                              <1> 
    84 00002A72 030C86              <1> 	add	ecx, dword ptr [rsi+REGISTER+rax*4]	; calculate index + increment
    85 00002A75 81E1FFFFFF00        <1> 	and	ecx, 00FFFFFFh				; 
    86 00002A7B 890C86              <1> 	mov	dword ptr [rsi+REGISTER+rax*4], ecx	; write back to tagged index register
    87                              <1> 
    88                              <1> _rex_count:
    89 00002A7E 8B4650              <1> 	mov	eax, dword ptr [rsi+REGISTER+RDATAC]
    90 00002A81 FFC8                <1> 	dec	eax
    91 00002A83 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
    92                              <1> 
    93 00002A88 894650              <1> 	mov	dword ptr [rsi+REGISTER+RDATAC], eax
    94 00002A8B A900008000          <1> 	test	eax, 00800000h
    95 00002A90 7523                <1> 	jnz	_rex_z					; reached -1 end
    96                              <1> 
    97 00002A92 66F786A4040000E0FF  <1> 	test	word ptr [rsi+INDICATION], EXTERNAL_INDICATIONS
    98 00002A9B 7405                <1> 	jz	_rex_along
    99                              <1> 
   100 00002A9D 83C2FC              <1> 	add	edx, -4					; restart after
   101 00002AA0 EB13                <1> 	jmp	_rex_z					; yielding to interrupt
   102                              <1> 
   103                              <1> _rex_along:
   104 00002AA2 8B8668040000        <1> 	mov	eax, [rsi+REGISTER+282*4]			; instruction encoding
   105 00002AA8 E874D6FFFF          <1> 	call	__ea
   106 00002AAD 8B9E74040000        <1> 	mov	ebx, [rsi+REGISTER+285*4]			; command pointer
   107 00002AB3 EB9C                <1> 	jmp	_rex_ready
   108 00002AB5 C3                  <1> _rex_z:	ret
   109                              <1> 
   110                              <1> _rex_prime_final_count:
   111 00002AB6 F7455000008000      <1> 	test	dword ptr [rbp+RDATAC], 00800000h
   112 00002ABD 7422                <1> 	jz	_rex_primed
   113 00002ABF 8B5D58              <1> 	mov	ebx, dword ptr [rbp+WDATAC]
   114 00002AC2 895D50              <1> 	mov	dword ptr [rbp+RDATAC], ebx
   115 00002AC5 C3                  <1> 	ret
   116                              <1> 
   117                              <1> _rex_prime:
   118 00002AC6 F7455000008000      <1> 	test	dword ptr [rbp+RDATAC], 00800000h
   119 00002ACD 7412                <1> 	jz	_rex_primed
   120 00002ACF 8B5D58              <1> 	mov	ebx, dword ptr [rbp+WDATAC]
   121 00002AD2 895D50              <1> 	mov	dword ptr [rbp+RDATAC], ebx
   122 00002AD5 8B5D3C              <1> 	mov	ebx, dword ptr [rbp+S_P]
   123 00002AD8 81E3FFFFFF00        <1> 	and	ebx, 00FFFFFFh
   124 00002ADE 895D34              <1> 	mov	dword ptr [rbp+Q], ebx
   125                              <1> _rex_primed:
   126 00002AE1 C3                  <1> 	ret
   127                              <1> 
   128                              <1> _rex_accumulate:
   129 00002AE2 480F7EFE            <1> 	movq	rsi, mm7
   130                              <1> ;	mov	rsi, qword ptr [rbp+CORE_INDEX1]
   131                              <1> 
   132 00002AE6 8B5E54              <1> 	mov	ebx, dword ptr [rsi+RDATA]
   133 00002AE9 035D34              <1> 	add	ebx, dword ptr [rbp+Q]
   134 00002AEC 81E3FFFFFF00        <1> 	and	ebx, 00FFFFFFh
   135 00002AF2 895D34              <1> 	mov	dword ptr [rbp+Q], ebx
   136 00002AF5 C3                  <1> 	ret
   137                              <1> 
   138                              <1> _rex_chex_127:
   139 00002AF6 E8CBFFFFFF          <1> 	call	_rex_prime
   140 00002AFB 83FB7F              <1> 	cmp	ebx, 127
   141 00002AFE 7624                <1> 	jna	_rex_chex_low
   142 00002B00 EB28                <1> 	jmp	_rex_chexit
   143                              <1> 
   144                              <1> _rex_chex_126:
   145 00002B02 E8BFFFFFFF          <1> 	call	_rex_prime
   146 00002B07 83FB7E              <1> 	cmp	ebx, 126
   147 00002B0A 7618                <1> 	jna	_rex_chex_low
   148 00002B0C EB1C                <1> 	jmp	_rex_chexit
   149                              <1> 
   150                              <1> _rex_chex_120:
   151 00002B0E E8B3FFFFFF          <1> 	call	_rex_prime
   152 00002B13 83FB78              <1> 	cmp	ebx, 120
   153 00002B16 760C                <1> 	jna	_rex_chex_low
   154 00002B18 EB10                <1> 	jmp	_rex_chexit
   155                              <1> 
   156                              <1> _rex_chex_124:
   157 00002B1A E8A7FFFFFF          <1> 	call	_rex_prime
   158 00002B1F 83FB7C              <1> 	cmp	ebx, 124
   159 00002B22 7706                <1> 	ja	_rex_chexit
   160                              <1> _rex_chex_low:
   161 00002B24 83FB18              <1> 	cmp	ebx, 24
   162 00002B27 7201                <1> 	jb	_rex_chexit
   163 00002B29 C3                  <1> 	ret
   164                              <1> 
   165                              <1> _rex_chexit:
   166 00002B2A E9FFE5FFFF          <1> 	jmp	guard_ii_authority
   167                              <1> 
   168                              <1> ;	eax = EA
   169                              <1> ;	q -> target register selected
   170                              <1> 
   171 00002B2F F686B004000008      <1> r_fa:	test	byte ptr [rsi+PSR], FP_R
   172 00002B36 0F85B8040000        <1> 	jnz	r_fa_192
   173                              <1> 
   174 00002B3C E8D9FFFFFF          <1> 	call	_rex_chex_124
   175 00002B41 E81FFBFFFF          <1> 	call	_far
   176 00002B46 EB9A                <1> 	jmp	_rex_accumulate
   177                              <1> 
   178 00002B48 F686B004000008      <1> r_fan:	test	byte ptr [rsi+PSR], FP_R
   179 00002B4F 0F85BC040000        <1> 	jnz	r_fan_192
   180                              <1> 
   181 00002B55 E8C0FFFFFF          <1> 	call	_rex_chex_124
   182 00002B5A E821FBFFFF          <1> 	call	_fanr
   183 00002B5F EB81                <1> 	jmp	_rex_accumulate
   184                              <1> 
   185 00002B61 F686B004000008      <1> r_fm:	test	byte ptr [rsi+PSR], FP_R
   186 00002B68 0F85C0040000        <1> 	jnz	r_fm_192
   187                              <1> 
   188 00002B6E E8A7FFFFFF          <1> 	call	_rex_chex_124
   189 00002B73 E823FBFFFF          <1> 	call	_fmr
   190 00002B78 E965FFFFFF          <1> 	jmp	_rex_accumulate
   191                              <1> 
   192 00002B7D F686B004000008      <1> r_fd:	test	byte ptr [rsi+PSR], FP_R
   193 00002B84 0F85BD040000        <1> 	jnz	r_fd_192
   194                              <1> 
   195 00002B8A E88BFFFFFF          <1> 	call	_rex_chex_124
   196 00002B8F E829FBFFFF          <1> 	call	_fdr
   197 00002B94 E949FFFFFF          <1> 	jmp	_rex_accumulate
   198                              <1> 
   199 00002B99 E818FFFFFF          <1> r_tz:	call	_rex_prime_final_count
   200 00002B9E 80F904              <1> 	cmp	cl, 4			; may not be [ i xi ]
   201 00002BA1 732C                <1> 	jnb	r_noskip		; but pointers are updated on no_op
   202 00002BA3 E852D9FFFF          <1> 	call	_operand_read
   203 00002BA8 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   204 00002BAD 7520                <1> 	jnz	r_noskip
   205                              <1> 
   206 00002BAF E9C3030000          <1> 	jmp	r_skipout		; stop search repeat
   207                              <1> 
   208 00002BB4 E8FDFEFFFF          <1> r_tp:	call	_rex_prime_final_count
   209 00002BB9 80F904              <1> 	cmp	cl, 4			; may not be [ i xi ]
   210 00002BBC 7311                <1> 	jnb	r_noskip		; but pointers are updated on no_op
   211 00002BBE E837D9FFFF          <1> 	call	_operand_read
   212 00002BC3 A900008000          <1> 	test	eax, 00800000h
   213 00002BC8 7505                <1> 	jnz	r_noskip
   214                              <1> 
   215 00002BCA E9A8030000          <1> 	jmp	r_skipout		; stop search repeat
   216                              <1> 
   217 00002BCF C3                  <1> r_noskip:	ret
   218                              <1> 
   219 00002BD0 E82DFFFFFF          <1> r_sb:	call	_rex_chex_126
   220 00002BD5 FFC3                <1> 	inc	ebx			; starboard lane
   221 00002BD7 EB05                <1> 	jmp	r_s
   222 00002BD9 E818FFFFFF          <1> r_sa:	call	_rex_chex_127
   223 00002BDE 80F904              <1> r_s:	cmp	cl, 4			; may not be [ i xi ]
   224 00002BE1 7309                <1> 	jnb	r_no_op_s		; but pointers are updated 
   225 00002BE3 8B5C9D00            <1> 	mov	ebx, dword ptr [rbp+rbx*4]
   226 00002BE7 E8D1DAFFFF          <1> 	call	_operand_write
   227                              <1> r_no_op_s:
   228 00002BEC E9F1FEFFFF          <1> 	jmp	_rex_accumulate
   229 00002BF1 C3                  <1> 	ret
   230                              <1> 
   231 00002BF2 E8BFFEFFFF          <1> r_z:	call	_rex_prime_final_count
   232 00002BF7 80F904              <1> 	cmp	cl, 4			; may not be [ i xi ]
   233 00002BFA 7307                <1> 	jnb	r_no_op_z		; but pointers are updated
   234 00002BFC 31DB                <1> 	xor	ebx, ebx
   235 00002BFE E9BADAFFFF          <1> 	jmp	_operand_write
   236                              <1> r_no_op_z:
   237 00002C03 C3                  <1> 	ret
   238                              <1> 
   239 00002C04 E8F9FEFFFF          <1> r_lb:	call	_rex_chex_126
   240 00002C09 FFC3                <1> 	inc	ebx			; starboard lane
   241 00002C0B EB05                <1> 	jmp	r_l
   242 00002C0D E8E4FEFFFF          <1> r_la:	call	_rex_chex_127
   243 00002C12 53                  <1> r_l:	push	rbx
   244 00002C13 E8E2D8FFFF          <1> 	call	_operand_read
   245 00002C18 5B                  <1> 	pop	rbx
   246 00002C19 89449D00            <1> 	mov	dword ptr [rbp+rbx*4], eax
   247 00002C1D E9C0FEFFFF          <1> 	jmp	_rex_accumulate
   248                              <1> 
   249 00002C22 E8DBFEFFFF          <1> r_orB:	call	_rex_chex_126
   250 00002C27 FFC3                <1> 	inc	ebx			; starboard lane
   251 00002C29 EB05                <1> 	jmp	r_OR
   252 00002C2B E8C6FEFFFF          <1> r_or:	call	_rex_chex_127
   253 00002C30 53                  <1> r_OR:	push	rbx
   254 00002C31 E8C4D8FFFF          <1> 	call	_operand_read
   255 00002C36 5B                  <1> 	pop	rbx
   256 00002C37 0B449D00            <1> 	or	eax, dword ptr [rbp+rbx*4]
   257 00002C3B 89449D00            <1> 	mov	dword ptr [rbp+rbx*4], eax
   258 00002C3F E99EFEFFFF          <1> 	jmp	_rex_accumulate
   259                              <1> 
   260 00002C44 E8B9FEFFFF          <1> r_andB:	call	_rex_chex_126
   261 00002C49 FFC3                <1> 	inc	ebx		; starboard lane
   262 00002C4B EB05                <1> 	jmp	r_AND
   263 00002C4D E8A4FEFFFF          <1> r_and:	call	_rex_chex_127
   264 00002C52 53                  <1> r_AND:	push	rbx
   265 00002C53 E8A2D8FFFF          <1> 	call	_operand_read
   266 00002C58 5B                  <1> 	pop	rbx
   267 00002C59 23449D00            <1> 	and	eax, dword ptr [rbp+rbx*4]
   268 00002C5D 89449D00            <1> 	mov	dword ptr [rbp+rbx*4], eax
   269 00002C61 E97CFEFFFF          <1> 	jmp	_rex_accumulate
   270                              <1> 
   271 00002C66 E897FEFFFF          <1> r_xorB:	call	_rex_chex_126
   272 00002C6B FFC3                <1> 	inc	ebx		; starboard lane
   273 00002C6D EB05                <1> 	jmp	r_XOR
   274 00002C6F E882FEFFFF          <1> r_xor:	call	_rex_chex_127
   275 00002C74 53                  <1> r_XOR:	push	rbx
   276 00002C75 E880D8FFFF          <1> 	call	_operand_read
   277 00002C7A 5B                  <1> 	pop	rbx
   278 00002C7B 33449D00            <1> 	xor	eax, dword ptr [rbp+rbx*4]
   279 00002C7F 89449D00            <1> 	mov	dword ptr [rbp+rbx*4], eax
   280 00002C83 E95AFEFFFF          <1> 	jmp	_rex_accumulate
   281                              <1> 
   282 00002C88 E875FEFFFF          <1> r_ab:	call	_rex_chex_126
   283 00002C8D FFC3                <1> 	inc	ebx		; starboard lane
   284 00002C8F EB05                <1> 	jmp	r_a
   285 00002C91 E860FEFFFF          <1> r_aa:	call	_rex_chex_127
   286 00002C96 53                  <1> r_a:	push	rbx
   287 00002C97 E85ED8FFFF          <1> 	call	_operand_read
   288 00002C9C 5F                  <1> 	pop	rdi
   289 00002C9D 0344BD00            <1> 	add	eax, dword ptr [rbp+rdi*4]
   290 00002CA1 E940030000          <1> 	jmp	r_store_carry
   291                              <1> 
   292 00002CA6 E857FEFFFF          <1> r_anb:	call	_rex_chex_126
   293 00002CAB FFC3                <1> 	inc	ebx		; starboard lane
   294 00002CAD EB05                <1> 	jmp	r_an
   295 00002CAF E842FEFFFF          <1> r_ana:	call	_rex_chex_127
   296 00002CB4 53                  <1> r_an:	push	rbx
   297 00002CB5 E840D8FFFF          <1> 	call	_operand_read
   298 00002CBA 5F                  <1> 	pop	rdi
   299 00002CBB 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   300 00002CC0 FFC0                <1> 	inc	eax
   301 00002CC2 0344BD00            <1> 	add	eax, dword ptr [rbp+rdi*4]
   302 00002CC6 E91B030000          <1> 	jmp	r_store_carry
   303                              <1> 
   304 00002CCB E826FEFFFF          <1> r_mf:	call    _rex_chex_127
   305 00002CD0 52                  <1> 	push	rdx
   306 00002CD1 53                  <1> 	push	rbx
   307 00002CD2 E823D8FFFF          <1> 	call	_operand_read
   308 00002CD7 5F                  <1> 	pop	rdi
   309 00002CD8 0FAF44BD00          <1> 	imul	eax, dword ptr [rbp+rdi*4]
   310 00002CDD 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   311 00002CE2 8944BD00            <1> 	mov	dword ptr [rbp+rdi*4], eax
   312 00002CE6 5A                  <1> 	pop	rdx
   313 00002CE7 E9F6FDFFFF          <1> 	jmp	_rex_accumulate
   314                              <1> 
   315                              <1> ; use the platform unsigned multiply
   316                              <1> ; work in positive magnitude
   317                              <1> ; adjust the final sign after offset-adding products
   318                              <1> 
   319 00002CEC E811FEFFFF          <1> r_m:	call	_rex_chex_126
   320 00002CF1 52                  <1> 	push	rdx
   321 00002CF2 53                  <1> 	push	rbx			; register stack cursor
   322 00002CF3 E802D8FFFF          <1> 	call	_operand_read
   323 00002CF8 5F                  <1> 	pop	rdi			; recover register stack cursor
   324                              <1> 
   325 00002CF9 31C9                <1> 	xor	ecx, ecx		; final sign
   326 00002CFB A900008000          <1> 	test	eax, 00800000h		;
   327 00002D00 740E                <1> 	jz	r_msigu?		; negative multiplier?
   328 00002D02 F7D1                <1> 	not	ecx			; final sign reverse
   329 00002D04 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   330 00002D09 FFC0                <1> 	inc	eax			; 2s complement
   331 00002D0B 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   332                              <1> 
   333                              <1> r_msigu?:
   334 00002D10 89C3                <1> 	mov	ebx, eax		; multiplier 2b used twice
   335 00002D12 8B44BD00            <1> 	mov	eax, dword ptr [rbp+rdi*4]
   336 00002D16 A900008000          <1> 	test	eax, 00800000h		; multiply high order part 1st
   337 00002D1B 7429                <1> 	jz	r_mgoferit_yall
   338                              <1> 
   339 00002D1D F7D1                <1> 	not	ecx			; final sign reverse
   340 00002D1F 8B54BD04            <1> 	mov	edx, dword ptr [rbp+rdi*4+4]
   341 00002D23 81F2FFFFFF00        <1> 	xor	edx, 00FFFFFFh
   342 00002D29 FFC2                <1> 	inc	edx			; 2s complement
   343 00002D2B C1C208              <1> 	rol	edx, 8
   344 00002D2E 480FB6F2            <1> 	movzx	rsi, dl
   345 00002D32 C1EA08              <1> 	shr	edx, 8
   346 00002D35 8954BD04            <1> 	mov	dword ptr [rbp+rdi*4+4], edx
   347 00002D39 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh		; ms register long multiplicand
   348 00002D3E 4801F0              <1> 	add	rax, rsi
   349 00002D41 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   350                              <1> 
   351                              <1> r_mgoferit_yall:
   352 00002D46 F7E3                <1> 	mul	ebx			; multiply high order part
   353 00002D48 8944BD00            <1> 	mov	dword ptr [rbp+rdi*4], eax	; save lower half of product
   354 00002D4C 8B44BD04            <1> 	mov	eax, dword ptr [rbp+rdi*4+4]	; multiply low order part
   355 00002D50 F7E3                <1> 	mul	ebx
   356 00002D52 C1E208              <1> 	shl	edx, 8			; 8 bits of eax must shift up to edx
   357 00002D55 C1C008              <1> 	rol	eax, 8
   358 00002D58 88C2                <1> 	mov	dl, al
   359 00002D5A C1E808              <1> 	shr	eax, 8			; leaving 8 zeros in eax high end
   360 00002D5D 0354BD00            <1> 	add	edx, dword ptr [rbp+rdi*4]	; add2 lower half of 1st product
   361 00002D61 21C9                <1> 	and	ecx, ecx		; final sign?
   362 00002D63 791A                <1> 	jns	r_m_writeback
   363                              <1> 
   364 00002D65 81F2FFFFFF00        <1> 	xor	edx, 00FFFFFFh
   365 00002D6B 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   366 00002D70 FFC0                <1> 	inc	eax			; 2s complement
   367 00002D72 C1C008              <1> 	rol	eax, 8			; carried out single bit?
   368 00002D75 480FB6F0            <1> 	movzx	rsi, al			; must add to edx
   369 00002D79 C1E808              <1> 	shr	eax, 8
   370 00002D7C 4801F2              <1> 	add	rdx, rsi
   371                              <1> 
   372                              <1> r_m_writeback:
   373 00002D7F 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   374 00002D84 81E2FFFFFF00        <1> 	and	edx, 00FFFFFFh
   375 00002D8A 8944BD04            <1> 	mov	dword ptr [rbp+rdi*4+4], eax	
   376 00002D8E 8954BD00            <1> 	mov	dword ptr [rbp+rdi*4], edx
   377 00002D92 5A                  <1> 	pop	rdx
   378 00002D93 E94AFDFFFF          <1> 	jmp	_rex_accumulate
   379                              <1> 
   380 00002D98 E865FDFFFF          <1> r_d:	call	_rex_chex_126
   381 00002D9D 89DF                <1> 	mov	edi, ebx		; register cursor
   382 00002D9F E884ECFFFF          <1> 	call	_divide
   383 00002DA4 895CBD04            <1> 	mov	dword ptr [rbp+rdi*4+4], ebx
   384 00002DA8 8944BD00            <1> 	mov	dword ptr [rbp+rdi*4], eax
   385                              <1> 
   386 00002DAC 480F7EFE            <1> 	movq	rsi, mm7
   387                              <1> ;	mov	rsi, qword ptr [rbp+CORE_INDEX1]
   388                              <1> 
   389 00002DB0 F686B004000008      <1> 	test	byte ptr [rsi+PSR], FP_R
   390 00002DB7 0F8425FDFFFF        <1> 	jz	_rex_accumulate
   391 00002DBD 83FF7D              <1> 	cmp	edi, 125
   392 00002DC0 0F871CFDFFFF        <1> 	ja	_rex_accumulate
   393 00002DC6 894CBD08            <1> 	mov	dword ptr [rbp+rdi*4+8], ecx
   394 00002DCA E913FDFFFF          <1> r_dnor:	jmp	_rex_accumulate
   395                              <1> 
   396 00002DCF E82EFDFFFF          <1> r_sbr:	call	_rex_chex_126
   397 00002DD4 FFC3                <1> 	inc	ebx		; starboard lane
   398 00002DD6 EB05                <1> 	jmp	r_lsr
   399 00002DD8 E819FDFFFF          <1> r_sar:	call	_rex_chex_127
   400 00002DDD 88C1                <1> r_lsr	mov	cl, al
   401 00002DDF 8B449D00            <1> 	mov	eax, dword ptr [rbp+rbx*4]
   402 00002DE3 D3E8                <1> 	shr	eax, cl
   403 00002DE5 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   404 00002DEA 89449D00            <1> 	mov	dword ptr [rbp+rbx*4], eax
   405 00002DEE E9EFFCFFFF          <1> 	jmp	_rex_accumulate
   406                              <1> 
   407 00002DF3 E80AFDFFFF          <1> r_dsr:	call	_rex_chex_126
   408 00002DF8 88C1                <1> 	mov	cl, al
   409 00002DFA 89DF                <1> 	mov	edi, ebx
   410 00002DFC 8B44BD00            <1> 	mov	eax, dword ptr [rbp+rdi*4]
   411 00002E00 8B5CBD04            <1> 	mov	ebx, dword ptr [rbp+rdi*4+4]
   412 00002E04 E860EDFFFF          <1> 	call	dsr
   413 00002E09 8944BD00            <1> 	mov	dword ptr [rbp+rdi*4], eax
   414 00002E0D 895CBD04            <1> 	mov	dword ptr [rbp+rdi*4+4], ebx
   415 00002E11 E9CCFCFFFF          <1> 	jmp	_rex_accumulate
   416                              <1> 
   417 00002E16 E8E7FCFFFF          <1> r_sbl:	call	_rex_chex_126
   418 00002E1B FFC3                <1> 	inc	ebx		; starboard lane
   419 00002E1D EB05                <1> 	jmp	r_lsl
   420 00002E1F E8D2FCFFFF          <1> r_sal:	call	_rex_chex_127
   421 00002E24 88C1                <1> r_lsl:	mov	cl, al
   422 00002E26 8B449D00            <1> 	mov	eax, dword ptr [rbp+rbx*4]
   423 00002E2A D3E0                <1> 	shl	eax, cl
   424 00002E2C 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
   425 00002E31 89449D00            <1> 	mov	dword ptr [rbp+rbx*4], eax
   426 00002E35 E9A8FCFFFF          <1> 	jmp	_rex_accumulate
   427                              <1> 
   428 00002E3A E8C3FCFFFF          <1> r_dsl:	call	_rex_chex_126
   429 00002E3F 88C1                <1> 	mov	cl, al
   430 00002E41 89DF                <1> 	mov	edi, ebx
   431 00002E43 8B44BD00            <1> 	mov	eax, dword ptr [rbp+rdi*4]
   432 00002E47 8B5CBD04            <1> 	mov	ebx, dword ptr [rbp+rdi*4+4]
   433 00002E4B E84EEDFFFF          <1> 	call	dsl
   434 00002E50 8944BD00            <1> 	mov	dword ptr [rbp+rdi*4], eax
   435 00002E54 895CBD04            <1> 	mov	dword ptr [rbp+rdi*4+4], ebx
   436 00002E58 E985FCFFFF          <1> 	jmp	_rex_accumulate
   437                              <1> 
   438 00002E5D E8A0FCFFFF          <1> r_rbr:	call	_rex_chex_126
   439 00002E62 FFC3                <1> 	inc	ebx		; starboard lane
   440 00002E64 EB05                <1> 	jmp	r_rr
   441 00002E66 E88BFCFFFF          <1> r_rar:	call	_rex_chex_127
   442 00002E6B 89DF                <1> r_rr:	mov	edi, ebx
   443 00002E6D 8B5CBD00            <1> 	mov	ebx, dword ptr [rbp+rdi*4]
   444 00002E71 E895EDFFFF          <1> 	call	rr
   445 00002E76 895CBD00            <1> 	mov	dword ptr [rbp+rdi*4], ebx
   446 00002E7A E963FCFFFF          <1> 	jmp	_rex_accumulate
   447                              <1> 
   448 00002E7F E87EFCFFFF          <1> r_drr:	call	_rex_chex_126
   449 00002E84 88C1                <1> 	mov	cl, al
   450 00002E86 89DF                <1> 	mov	edi, ebx
   451 00002E88 8B44BD00            <1> 	mov	eax, dword ptr [rbp+rdi*4]
   452 00002E8C 8B5CBD04            <1> 	mov	ebx, dword ptr [rbp+rdi*4+4]
   453 00002E90 E8C4EDFFFF          <1> 	call	drr
   454 00002E95 8944BD00            <1> 	mov	dword ptr [rbp+rdi*4], eax
   455 00002E99 895CBD04            <1> 	mov	dword ptr [rbp+rdi*4+4], ebx
   456 00002E9D E940FCFFFF          <1> 	jmp	_rex_accumulate
   457                              <1> 
   458 00002EA2 E85BFCFFFF          <1> r_rbl:	call	_rex_chex_126
   459 00002EA7 FFC3                <1> 	inc	ebx		; starboard lane
   460 00002EA9 EB05                <1> 	jmp	r_rl
   461 00002EAB E846FCFFFF          <1> r_ral:	call	_rex_chex_127
   462 00002EB0 89DF                <1> r_rl:	mov	edi, ebx
   463 00002EB2 8B5CBD00            <1> 	mov	ebx, dword ptr [rbp+rdi*4]
   464 00002EB6 E876EDFFFF          <1> 	call	rl
   465 00002EBB 895CBD00            <1> 	mov	dword ptr [rbp+rdi*4], ebx
   466 00002EBF E91EFCFFFF          <1> 	jmp	_rex_accumulate
   467                              <1> 
   468 00002EC4 E839FCFFFF          <1> r_drl:	call	_rex_chex_126
   469 00002EC9 88C1                <1> 	mov	cl, al
   470 00002ECB 89DF                <1> 	mov	edi, ebx
   471 00002ECD 8B44BD00            <1> 	mov	eax, dword ptr [rbp+rdi*4]
   472 00002ED1 8B5CBD04            <1> 	mov	ebx, dword ptr [rbp+rdi*4+4]
   473 00002ED5 E8D5EDFFFF          <1> 	call	drl
   474 00002EDA 8944BD00            <1> 	mov	dword ptr [rbp+rdi*4], eax
   475 00002EDE 895CBD04            <1> 	mov	dword ptr [rbp+rdi*4+4], ebx
   476 00002EE2 E9FBFBFFFF          <1> 	jmp	_rex_accumulate
   477                              <1> 
   478 00002EE7 E816FCFFFF          <1> r_sba:	call	_rex_chex_126
   479 00002EEC FFC3                <1> 	inc	ebx		; starboard lane
   480 00002EEE EB05                <1> 	jmp	r_asr
   481 00002EF0 E801FCFFFF          <1> r_saa:	call	_rex_chex_127
   482 00002EF5 88C1                <1> r_asr:	mov	cl, al
   483 00002EF7 8B449D00            <1> 	mov	eax, dword ptr [rbp+rbx*4]
   484 00002EFB C1E008              <1> 	shl	eax, 8
   485 00002EFE D3F8                <1> 	sar	eax, cl
   486 00002F00 C1E808              <1> 	shr	eax, 8
   487 00002F03 89449D00            <1> 	mov	dword ptr [rbp+rbx*4], eax
   488 00002F07 E9D6FBFFFF          <1> 	jmp	_rex_accumulate
   489                              <1> 
   490 00002F0C E8F1FBFFFF          <1> r_dsa:	call	_rex_chex_126
   491 00002F11 88C1                <1> 	mov	cl, al
   492 00002F13 89DF                <1> 	mov	edi, ebx
   493 00002F15 8B44BD00            <1> 	mov	eax, dword ptr [rbp+rdi*4]
   494 00002F19 8B5CBD04            <1> 	mov	ebx, dword ptr [rbp+rdi*4+4]
   495 00002F1D E8B3ECFFFF          <1> 	call	dsa
   496 00002F22 8944BD00            <1> 	mov	dword ptr [rbp+rdi*4], eax
   497 00002F26 895CBD04            <1> 	mov	dword ptr [rbp+rdi*4+4], ebx
   498 00002F2A E9B3FBFFFF          <1> 	jmp	_rex_accumulate
   499                              <1> 
   500 00002F2F E8E6FBFFFF          <1> r_qs:	call	_rex_chex_124
   501 00002F34 E80ED7FFFF          <1> 	call	_burst_write4	; eax -> ea / ebx -> register cursor
   502 00002F39 E9A4FBFFFF          <1> 	jmp	_rex_accumulate
   503                              <1> 
   504 00002F3E E8D7FBFFFF          <1> r_ql:	call	_rex_chex_124
   505 00002F43 E885D5FFFF          <1> 	call	_burst_read4	; eax -> ea / ebx -> register cursor
   506 00002F48 E995FBFFFF          <1> 	jmp	_rex_accumulate
   507                              <1> 
   508 00002F4D E864FBFFFF          <1> r_dte:	call	_rex_prime_final_count
   509 00002F52 E861D5FFFF          <1> 	call	_burst_read2
   510 00002F57 334510              <1> 	xor	eax, dword ptr [rbp+A]
   511 00002F5A 7525                <1> 	jnz	r_mtax
   512 00002F5C 335D14              <1> 	xor	ebx, dword ptr [rbp+B]
   513 00002F5F 7520                <1> 	jnz	r_mtax
   514 00002F61 EB14                <1> 	jmp	r_skipout		; stop search repeat
   515                              <1> 
   516 00002F63 E84EFBFFFF          <1> r_mta:	call	_rex_prime_final_count
   517 00002F68 B100                <1> 	mov	cl, 0		; operand size 1 word
   518 00002F6A E88BD5FFFF          <1> 	call	_operand_read
   519 00002F6F 334510              <1> 	xor	eax, dword ptr [rbp+A]
   520 00002F72 234504              <1> 	and	eax, dword ptr [rbp+K]
   521 00002F75 750A                <1> 	jnz	r_mtax
   522                              <1> 
   523                              <1> r_skipout:				; stop search repeat
   524 00002F77 83C204              <1> 	add	edx, 4
   525 00002F7A 488BA568040000      <1> 	mov	rsp, qword ptr [rbp+282*4]
   526 00002F81 C3                  <1> r_mtax:	ret
   527                              <1> 
   528 00002F82 E87BFBFFFF          <1> r_ds:	call	_rex_chex_126
   529 00002F87 E800D7FFFF          <1> 	call	_burst_write2	; eax -> ea / ebx -> register cursor
   530 00002F8C E951FBFFFF          <1> 	jmp	_rex_accumulate
   531                              <1> 
   532 00002F91 E86CFBFFFF          <1> r_dl:	call	 _rex_chex_126
   533 00002F96 53                  <1> 	push	rbx
   534 00002F97 E81CD5FFFF          <1> 	call	_burst_read2
   535 00002F9C 5F                  <1> 	pop	rdi
   536 00002F9D 895CBD04            <1> 	mov	dword ptr [rbp+rdi*4+4], ebx
   537 00002FA1 8944BD00            <1> 	mov	dword ptr [rbp+rdi*4], eax
   538 00002FA5 E938FBFFFF          <1> 	jmp	_rex_accumulate
   539                              <1> 
   540 00002FAA E853FBFFFF          <1> r_dan:	call	 _rex_chex_126
   541 00002FAF 53                  <1> 	push	rbx
   542 00002FB0 E803D5FFFF          <1> 	call	_burst_read2
   543 00002FB5 5F                  <1> 	pop	rdi
   544 00002FB6 81F3FFFFFF00        <1> 	xor	ebx, 00FFFFFFh
   545 00002FBC 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
   546 00002FC1 FFC3                <1> 	inc	ebx
   547 00002FC3 EB0C                <1> 	jmp	r_danad
   548                              <1> 
   549 00002FC5 E838FBFFFF          <1> r_da:	call	 _rex_chex_126
   550 00002FCA 53                  <1> 	push	rbx
   551 00002FCB E8E8D4FFFF          <1> 	call	_burst_read2
   552 00002FD0 5F                  <1> 	pop	rdi
   553                              <1> 
   554                              <1> r_danad:
   555 00002FD1 035CBD04            <1> 	add	ebx, dword ptr [rbp+rdi*4+4]
   556 00002FD5 C1E308              <1> 	shl	ebx, 8
   557 00002FD8 83D000              <1> 	adc	eax, 0
   558 00002FDB C1EB08              <1> 	shr	ebx, 8
   559 00002FDE 895CBD04            <1> 	mov	dword ptr [rbp+rdi*4+4], ebx
   560 00002FE2 0344BD00            <1> 	add	eax, dword ptr [rbp+rdi*4]
   561                              <1> 
   562                              <1> r_store_carry:
   563 00002FE6 E836EEFFFF          <1> 	call	_alu_carry
   564 00002FEB 8944BD00            <1> 	mov	dword ptr [rbp+rdi*4], eax
   565 00002FEF E9EEFAFFFF          <1> 	jmp	_rex_accumulate
   566                              <1> 
    47                                  	%include	"144.msm"
     1                              <1> 	%if	SIMD_192
     2                              <1> 
     3                              <1> r_fa_192:
     4 00002FF4 E867000000          <1> 	call	fp_192_concentrate
     5 00002FF9 E80FF7FFFF          <1> 	call	BIAS_POINTERS			; needs 1 octet of 8th platform word 
     6 00002FFE E845F2FFFF          <1> 	call	fa
     7 00003003 480F7EFE            <1> 	movq	rsi, mm7
     8 00003007 E8B3000000          <1> 	call	fp_192_store_left_right
     9 0000300C E9D1FAFFFF          <1> 	jmp	_rex_accumulate
    10                              <1> 
    11                              <1> r_fan_192:
    12 00003011 E84A000000          <1> 	call	fp_192_concentrate
    13 00003016 E8F2F6FFFF          <1> 	call	BIAS_POINTERS			; needs 1 octet of 8th platform word
    14 0000301B E816F2FFFF          <1> 	call	fan
    15 00003020 480F7EFE            <1> 	movq	rsi, mm7
    16 00003024 E896000000          <1> 	call	fp_192_store_left_right
    17 00003029 E9B4FAFFFF          <1> 	jmp	_rex_accumulate
    18                              <1> 
    19                              <1> r_fm_192:
    20 0000302E E82D000000          <1> 	call	fp_192_concentrate
    21 00003033 E8F0F6FFFF          <1> 	call	fp_registers_m
    22 00003038 E81D010000          <1> 	call	_144_fm
    23 0000303D E872000000          <1> 	call	fp_192_store
    24 00003042 E99BFAFFFF          <1> 	jmp	_rex_accumulate
    25                              <1> 
    26                              <1> r_fd_192:
    27 00003047 E814000000          <1> 	call	fp_192_concentrate
    28 0000304C E8D7F6FFFF          <1> 	call	fp_registers_m
    29 00003051 E82DF4FFFF          <1> 	call	fd
    30 00003056 E859000000          <1> 	call	fp_192_store
    31 0000305B E982FAFFFF          <1> 	jmp	_rex_accumulate
    32                              <1> 
    33                              <1> fp_192_concentrate:
    34 00003060 50                  <1> 	push	rax
    35 00003061 E8A8FAFFFF          <1> 	call	_rex_chex_120
    36 00003066 488B0424            <1> 	mov	rax, qword ptr [rsp]
    37 0000306A E86BF6FFFF          <1> 	call	fp_operands
    38 0000306F 480F7EFE            <1> 	movq	rsi, mm7
    39 00003073 488D7D20            <1> 	lea	rdi, [rbp+8*4]
    40 00003077 8B5D34              <1> 	mov	ebx, dword ptr [rbp+Q]
    41 0000307A 83C304              <1> 	add	ebx, 4				; starboard sum
    42 0000307D E8C1F6FFFF          <1> 	call	_load_quad
    43 00003082 488DBE20040000      <1> 	lea	rdi, [rsi+_INPUTR]
    44                              <1> 
    45 00003089 E84F000000          <1> 	call	pack_144
    46                              <1> ; call ultrate
    47 0000308E BB08000000          <1> 	mov	ebx, 8
    48 00003093 58                  <1> 	pop	rax				; ea
    49 00003094 83C004              <1> 	add	eax, 4				; +
    50 00003097 E831D4FFFF          <1> 	call	_burst_read4
    51 0000309C 480F7EFE            <1> 	movq	rsi, mm7
    52 000030A0 488DBE00040000      <1> 	lea	rdi, [rsi+_INPUT2]
    53 000030A7 E831000000          <1> 	call	pack_144
    54                              <1> 
    55 000030AC 808EB004000008      <1> 	or	byte ptr [rsi+PSR], FP_R
    56                              <1> ;	call	fp_registers_m			; moved to operations r_fa...
    57 000030B3 C3                  <1> 	ret
    58                              <1> 	
    59                              <1> fp_192_store:
    60 000030B4 480F7EFE            <1> 	movq	rsi, mm7
    61 000030B8 488DBE40040000      <1> 	lea	rdi, [rsi+_OUTPUT]
    62                              <1> fp_192_store_left_right:			; fa / fan decide out-string ->
    63 000030BF 8B5D34              <1> 	mov	ebx, dword ptr [rbp+Q]
    64 000030C2 E887EEFFFF          <1> 	call	_deliver_
    65                              <1> 
    66 000030C7 8B5D34              <1> 	mov	ebx, dword ptr [rbp+Q]
    67 000030CA 0F6F7520            <1> 	movq	mm6, qword ptr [rbp+8*4]
    68 000030CE 0F7F749D10          <1> 	movq	qword ptr [rbp+rbx*4+4*4], mm6
    69 000030D3 0F6F7528            <1> 	movq	mm6, qword ptr [rbp+10*4]
    70 000030D7 0F7F749D18          <1> 	movq	qword ptr [rbp+rbx*4+6*4], mm6
    71 000030DC C3                  <1> 	ret
    72                              <1> 
    73                              <1> pack_144:
    74 000030DD 52                  <1> 	push	rdx
    75 000030DE 51                  <1> 	push	rcx
    76 000030DF 53                  <1> 	push	rbx
    77 000030E0 50                  <1> 	push	rax
    78                              <1> 
    79 000030E1 8B4520              <1> 	mov	eax, [rbp+8*4]
    80 000030E4 334524              <1> 	xor	eax, [rbp+9*4]
    81 000030E7 A900008000          <1> 	test	eax, 00800000h			; is 2nd sum normalised?
    82 000030EC 7467                <1> 	jz	end_pack_144			; no? words 4..7 are alraady signs
    83                              <1> 
    84 000030EE 8B552C              <1> 	mov	edx, dword ptr [rbp+11*4]	; read starboard end 2nd value
    85 000030F1 C1C210              <1> 	rol	edx, 16				; move 8 bits up
    86 000030F4 8B5D28              <1> 	mov	ebx, dword ptr [rbp+10*4]	; to higher order word
    87 000030F7 C1E308              <1> 	shl	ebx, 8
    88 000030FA 88D3                <1> 	mov	bl, dl
    89 000030FC 8B4704              <1> 	mov	eax, dword ptr [rdi+1*4]	; do partial longs register:register
    90                              <1> 						; to avoid contemplating endianism
    91 000030FF 6689C2              <1> 	mov	dx, ax				; add 16 signs to low-order word
    92                              <1> 
    93 00003102 8B4524              <1> 	mov	eax, dword ptr [rbp+9*4]	; starboard mantissa high-order word
    94                              <1> 
    95 00003105 8B4D20              <1> 	mov	ecx, dword ptr [rbp+8*4]	; starboard exponent in register 8
    96                              <1> 						; loaded exponent is positive magnitude
    97 00003108 81E1FFFFFF00        <1> 	and	ecx, 00FFFFFFh			; should be impossible to need that...
    98 0000310E F7C100008000        <1> 	test	ecx, 00800000h			; this one may be 1s-complement
    99 00003114 7406                <1> 	jz	exponent_magnitude_difference
   100 00003116 81F1FFFFFF00        <1> 	xor	ecx, 00FFFFFFh			; 1s-complement RTA1 data word
   101                              <1> 						; still won't compute
   102                              <1> exponent_magnitude_difference:			; if component numbers are out of order
   103 0000311C F7D9                <1> 	neg	ecx				; 2s-complement platform integer
   104 0000311E 030F                <1> 	add	ecx, dword ptr [rdi]		; subtract it from
   105                              <1> 						; the exponent you first thought of
   106 00003120 83C1B8              <1> 	add	ecx, -72
   107 00003123 7419                <1> 	jz	_144_normalised			; net normalising count zero
   108 00003125 782E                <1> 	js	end_pack_144			; bad one, values in wrong order
   109                              <1> 						; just leave signs in bits 71..0
   110 00003127 83F947              <1> 	cmp	ecx, 71				; no use replacing 72+ signs
   111 0000312A 7729                <1> 	ja	end_pack_144			; with signs
   112                              <1> 						; rspecially not millions of them
   113 0000312C C1E008              <1> 	shl	eax, 8
   114 0000312F 88D0                <1> 	mov	al, dl				; 8 sign bits
   115 00003131 C1C808              <1> 	ror	eax, 8
   116                              <1> 
   117                              <1> insert_sign:
   118 00003134 D1F8                <1> 	sar	eax, 1				; normalising shift field <- signs
   119 00003136 D1DB                <1> 	rcr	ebx, 1
   120 00003138 D1DA                <1> 	rcr	edx, 1
   121                              <1> 
   122 0000313A FFC9                <1> 	dec	ecx
   123 0000313C 75F6                <1> 	jnz	insert_sign
   124                              <1> 
   125                              <1> _144_normalised:
   126 0000313E 895718              <1> 	mov	dword ptr [rdi+6*4], edx	; mantissa 15..0 : 16 signs
   127 00003141 895F14              <1> 	mov	dword ptr [rdi+5*4], ebx	; mantissa 47..16
   128 00003144 8B5F10              <1> 	mov	ebx, dword ptr [rdi+4*4]	; mantissa bits 79..72 : unknown
   129 00003147 C1E008              <1> 	shl	eax, 8				; mantissa bits 71..48
   130 0000314A C1C308              <1> 	rol	ebx, 8
   131 0000314D 88D8                <1> 	mov	al, bl				; mantissa bits 79..72
   132 0000314F C1C808              <1> 	ror	eax, 8				; mantissa bits 79..48
   133 00003152 894710              <1> 	mov	dword ptr [rdi+4*4], eax
   134                              <1> 
   135                              <1> end_pack_144:
   136 00003155 58                  <1> 	pop	rax
   137 00003156 5B                  <1> 	pop	rbx
   138 00003157 59                  <1> 	pop	rcx
   139 00003158 5A                  <1> 	pop	rdx
   140 00003159 C3                  <1> 	ret
   141                              <1> 
   142                              <1> 	%endif
    48                                  	%include	"_144_fm.msm"
     1                              <1> ;	this is like fm: routine in fpu.msm
     2                              <1> ;	except it has uconditionally different radix and repeat count
     3                              <1> ;	and so exists separately to avoid condition jumps
     4                              <1> ;	and to avoid messing with the original for new parameters
     5                              <1> 
     6                              <1> _144_fm:
     7 0000315A 488DBE40040000      <1> 	lea	rdi, [rsi+_OUTPUT]			; initialise final accumulation
     8 00003161 E8C2EEFFFF          <1> 	call	zoutput
     9                              <1> 
    10 00003166 8B9E24040000        <1> 	mov	ebx, dword ptr [rsi+_INPUTR+1*4]	; read register-side signs
    11 0000316C 8B8628040000        <1> 	mov	eax, dword ptr [rsi+_INPUTR+2*4]	; and high-end mantissa
    12 00003172 31D8                <1> 	xor	eax, ebx	 			; cache if-normalised in eax
    13 00003174 339E04040000        <1> 	xor	ebx, dword ptr [rsi+_INPUT2+1*4]	; multiply signs
    14 0000317A 899E44040000        <1> 	mov	dword ptr [rsi+_OUTPUT+1*4], ebx	; save the output sign
    15 00003180 21C0                <1> 	and	eax, eax				; test the cached if-normalised
    16 00003182 790E                <1> 	jns	_144_fmdont
    17                              <1> 
    18 00003184 8B8604040000        <1> 	mov	eax, dword ptr [rsi+_INPUT2+1*4]	; is the multiplier normalised?
    19 0000318A 338608040000        <1> 	xor	eax, dword ptr [rsi+_INPUT2+2*4]	; sign XOR normalising bit?
    20 00003190 782F                <1> 	js	_144_fmgo				; yes, proceed
    21                              <1> 
    22                              <1> _144_fmdont:
    23 00003192 899E48040000        <1> 	mov	dword ptr [rsi+_OUTPUT+2*4], ebx
    24 00003198 899E4C040000        <1> 	mov	dword ptr [rsi+_OUTPUT+3*4], ebx
    25 0000319E 899E50040000        <1> 	mov	dword ptr [rsi+_OUTPUT+4*4], ebx
    26 000031A4 899E54040000        <1> 	mov	dword ptr [rsi+_OUTPUT+5*4], ebx
    27 000031AA 899E58040000        <1> 	mov	dword ptr [rsi+_OUTPUT+6*4], ebx
    28 000031B0 899E5C040000        <1> 	mov	dword ptr [rsi+_OUTPUT+7*4], ebx
    29 000031B6 C78640040000000000- <1> 	mov	dword ptr [rsi+_OUTPUT], 0		; mantissa to go
    29 000031BF 00                  <1>
    30                              <1> 
    31 000031C0 C3                  <1> 	ret					; no, effective zero multiplier
    32                              <1> 
    33                              <1> _144_fmgo:
    34 000031C1 51                  <1> 	push	rcx
    35 000031C2 8B8624040000        <1> 	mov	eax, dword ptr [rsi+_INPUTR+1*4]
    36                              <1> 
    37 000031C8 B190                <1> 	mov	cl, 144				; beats count exactly mantissa size
    38                              <1> 
    39 000031CA 21C0                <1> 	and	eax, eax
    40                              <1> 
    41 000031CC 790C                <1> 	jns	_144_fmp1
    42 000031CE 488DBE20040000      <1> 	lea	rdi, [rsi+_INPUTR]
    43 000031D5 E8FFEFFFFF          <1> 	call	zover
    44                              <1> 
    45                              <1> _144_fmp1:
    46 000031DA 8B8604040000        <1> 	mov	eax, dword ptr [rsi+_INPUT2+1*4]
    47 000031E0 21C0                <1> 	and	eax, eax
    48 000031E2 790C                <1> 	jns	_144_fmadd
    49 000031E4 488DBE00040000      <1> 	lea	rdi, [rsi+_INPUT2]
    50 000031EB E8E9EFFFFF          <1> 	call	zover
    51                              <1> 
    52                              <1> _144_fmadd:
    53 000031F0 F8                  <1> 	clc
    54                              <1> 
    55 000031F1 488DBE20040000      <1> 	lea	rdi, [rsi+_INPUTR]
    56 000031F8 D15F08              <1> 	rcr	dword ptr [rdi+2*4], 1		; addend shift right
    57 000031FB D15F0C              <1> 	rcr	dword ptr [rdi+3*4], 1
    58 000031FE D15F10              <1> 	rcr	dword ptr [rdi+4*4], 1
    59 00003201 D15F14              <1> 	rcr	dword ptr [rdi+5*4], 1
    60 00003204 D15F18              <1> 	rcr	dword ptr [rdi+6*4], 1
    61 00003207 D15F1C              <1> 	rcr	dword ptr [rdi+7*4], 1
    62                              <1> 
    63 0000320A 488DBE00040000      <1> 	lea	rdi, [rsi+_INPUT2]
    64                              <1> 
    65                              <1> 	%if	1
    66 00003211 D1571C              <1> 	rcl	dword ptr [rdi+7*4], 1		; multiplier shift left
    67 00003214 D15718              <1> 	rcl	dword ptr [rdi+6*4], 1
    68 00003217 D15714              <1> 	rcl	dword ptr [rdi+5*4], 1		; multiplier mantissa is only 72 bits
    69                              <1> 	%endif
    70                              <1> 
    71 0000321A D15710              <1> 	rcl	dword ptr [rdi+4*4], 1
    72 0000321D D1570C              <1> 	rcl	dword ptr [rdi+3*4], 1
    73 00003220 D15708              <1> 	rcl	dword ptr [rdi+2*4], 1
    74                              <1> 
    75 00003223 488DBE40040000      <1> 	lea	rdi, [rsi+_OUTPUT]
    76 0000322A 7336                <1> 	jnc	_144_fmadx
    77                              <1> 						; 1 shifted from multiplier
    78                              <1> _144_fmadc:
    79 0000322C 8B863C040000        <1> 	mov	eax, dword ptr [rsi+_INPUTR+7*4]	
    80 00003232 01471C              <1> 	add	dword ptr [rdi+7*4], eax	; do not use carry
    81 00003235 8B8638040000        <1> 	mov	eax, dword ptr [rsi+_INPUTR+6*4]
    82 0000323B 114718              <1> 	adc	dword ptr [rdi+6*4], eax	; start using carry
    83 0000323E 8B8634040000        <1> 	mov	eax, dword ptr [rsi+_INPUTR+5*4]
    84 00003244 114714              <1> 	adc	dword ptr [rdi+5*4], eax
    85 00003247 8B8630040000        <1> 	mov	eax, dword ptr [rsi+_INPUTR+4*4]
    86 0000324D 114710              <1> 	adc	dword ptr [rdi+4*4], eax
    87 00003250 8B862C040000        <1> 	mov	eax, dword ptr [rsi+_INPUTR+3*4]
    88 00003256 11470C              <1> 	adc	dword ptr [rdi+3*4], eax
    89 00003259 8B8628040000        <1> 	mov	eax, dword ptr [rsi+_INPUTR+2*4]
    90 0000325F 114708              <1> 	adc	dword ptr [rdi+2*4], eax
    91                              <1> 
    92                              <1> _144_fmadx:
    93 00003262 FEC9                <1> 	dec	cl
    94 00003264 758A                <1> 	jnz	_144_fmadd
    95                              <1> 
    96                              <1> _144_fmadz:
    97 00003266 59                  <1> 	pop	rcx
    98                              <1> 
    99 00003267 8B4708              <1> 	mov	eax, dword ptr [rdi+2*4] 	; normalised?
   100 0000326A D1D0                <1> 	rcl	eax, 1
   101 0000326C 721B                <1> 	jc	_144_fm_normalised
   102                              <1> 
   103 0000326E 838620040000FF      <1> 	add	dword ptr [rsi+_INPUTR], -1		; take 1 from scale
   104 00003275 D1571C              <1> 	rcl	dword ptr [rdi+7*4], 1
   105 00003278 D15718              <1> 	rcl	dword ptr [rdi+6*4], 1
   106 0000327B D15714              <1> 	rcl	dword ptr [rdi+5*4], 1
   107 0000327E D15710              <1> 	rcl	dword ptr [rdi+4*4], 1
   108 00003281 D1570C              <1> 	rcl	dword ptr [rdi+3*4], 1
   109 00003284 D15708              <1> 	rcl	dword ptr [rdi+2*4], 1
   110                              <1> 
   111 00003287 EB27                <1> 	jmp	_144_fm_inrange
   112                              <1> 
   113                              <1> _144_fm_normalised:
   114 00003289 488DBE40040000      <1> 	lea	rdi, [rsi+_OUTPUT]
   115 00003290 E8C4EDFFFF          <1> 	call	round2
   116 00003295 7319                <1> 	jnc	_144_fm_inrange
   117                              <1> 
   118 00003297 D15F08              <1> 	rcr	dword ptr [rdi+2*4], 1
   119 0000329A D15F0C              <1> 	rcr	dword ptr [rdi+3*4], 1
   120 0000329D D15F10              <1> 	rcr	dword ptr [rdi+4*4], 1
   121 000032A0 D15F14              <1> 	rcr	dword ptr [rdi+5*4], 1
   122 000032A3 D15F18              <1> 	rcr	dword ptr [rdi+6*4], 1
   123 000032A6 D15F1C              <1> 	rcr	dword ptr [rdi+7*4], 1
   124 000032A9 83862004000001      <1> 	add	dword ptr [rsi+_INPUTR], 1
   125                              <1> 
   126                              <1> _144_fm_inrange:
   127 000032B0 8B8620040000        <1> 	mov	eax, dword ptr [rsi+_INPUTR]
   128 000032B6 038600040000        <1> 	add	eax, dword ptr [rsi+_INPUT2]
   129 000032BC 050000C0FF          <1> 	add	eax, -00400000h
   130 000032C1 8907                <1> 	mov	dword ptr [rdi], eax		; insert unsigned magnitude product scale
   131 000032C3 8B4704              <1> 	mov	eax, dword ptr [rdi+1*4]
   132 000032C6 314708              <1> 	xor	dword ptr [rdi+2*4], eax	; the mantissa gets polarised here
   133 000032C9 31470C              <1> 	xor	dword ptr [rdi+3*4], eax
   134 000032CC 314710              <1> 	xor	dword ptr [rdi+4*4], eax
   135 000032CF 314714              <1> 	xor	dword ptr [rdi+5*4], eax
   136 000032D2 314718              <1> 	xor	dword ptr [rdi+6*4], eax
   137 000032D5 31471C              <1> 	xor	dword ptr [rdi+7*4], eax
   138 000032D8 C3                  <1> 	ret
   139                              <1> 
    49                                  					; data follows here
    50                                  					; if it is in this assembly
    51                                  	%if	RTA_MBANKS
    52                                  
    53                                  	section		.data
    54                                  	%include	"rta_data.msm"
    55                                  
    56                                  	section		.bss
    57                                  _memory	resd	MEMORY
    58                                  
    59                                  	%endif
    60                                  
    61                                  	end
    61          ******************       warning: label alone on a line without a colon might be in error [-w+orphan-labels]
    62                                  
