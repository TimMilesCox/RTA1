     1                                  
     2                                  	%include	"rta_x86n.def"
     3                              <1> 
     4                              <1> __SMP		equ	8
     5                              <1> 
     6                              <1> TIME_UPDATE	equ     1
     7                              <1> LOCKSTEP	equ	2
     8                              <1> BREAKPOINT	equ	4
     9                              <1> CHILLDOWN	equ	8
    10                              <1> TOUCHPOINT	equ	16
    11                              <1> 
    12                              <1> EXTERNAL_INTERRUPT 	equ	00FF00h
    13                              <1> ATTENTION		equ	128
    14                              <1> INCREMENTER_CARRY	equ	64
    15                              <1> 
    16                              <1> 		%if	DRANG & 2
    17                              <1> INDICATIONS	equ	CHILLDOWN|TIME_UPDATE|LOCKSTEP
    18                              <1> 		%else
    19                              <1> INDICATIONS	equ	CHILLDOWN|TIME_UPDATE|LOCKSTEP|BREAKPOINT
    20                              <1> 		%endif
    21                              <1> 
    22                              <1> EXTERNAL_INDICATIONS equ EXTERNAL_INTERRUPT|ATTENTION|INCREMENTER_CARRY
    23                              <1> 
    24                              <1> IO_PORTS	equ	192
    25                              <1> 
    26                              <1> 	%if	RTA_MBANKS
    27                              <1> global	_metric
    28                              <1> global	_indication
    29                              <1> global	_iselect
    30                              <1> global	_iselectu
    31                              <1> global	_readout
    32                              <1> global	_readoutx
    33                              <1> global	_readoutp
    34                              <1> global	_psr
    35                              <1> global	_apc
    36                              <1> global	_apcz
    37                              <1> global	_breakpoint
    38                              <1> global	_b0_name
    39                              <1> global	_b0p
    40                              <1> global	_devices
    41                              <1> global	_base
    42                              <1> global	_register_set
    43                              <1> global	__register
    44                              <1> global	_memory
    45                              <1> 
    46                              <1> 	%if	RTA_MBANKS<1
    47                              <1> RTA_MPAGES	equ	32
    48                              <1> 	%else
    49                              <1> RTA_MPAGES	equ	RTA_MBANKS*64
    50                              <1> 	%endif
    51                              <1> 
    52                              <1> 	%else
    53                              <1> ;	extern	_metric
    54                              <1> extern	_general_indication
    55                              <1> ;	extern	_iselect
    56                              <1> ;	extern	_iselectu
    57                              <1> ;	extern	_psr
    58                              <1> ;	extern	_apc
    59                              <1> ;	extern	_apcu
    60                              <1> ;	extern	_apcz
    61                              <1> 
    62                              <1> extern	_breakpoint
    63                              <1> extern	_touchpoint
    64                              <1> extern	_touchpoint2
    65                              <1> 
    66                              <1> ;	extern	_b0_name
    67                              <1> ;	extern	_b0p
    68                              <1> extern	_devices
    69                              <1> ;	extern	_base
    70                              <1> ;	extern	_register_set
    71                              <1> ;	extern	__register
    72                              <1> extern	_memory
    73                              <1> 
    74                              <1> _output equ     272
    75                              <1> _inputr equ     264
    76                              <1> _input2 equ     256
    77                              <1> 
    78                              <1> _OUTPUT	equ	_output*4
    79                              <1> _INPUTR	equ	_inputr*4
    80                              <1> _INPUT2 equ	_input2*4
    81                              <1> _BIAS	equ	_OUTPUT
    82                              <1> 
    83                              <1> 	%endif
    84                              <1> 
    85                              <1> 	extern	_flag
    86                              <1> 	extern	_uflag
    87                              <1> 
    88                              <1> HALF_W	equ	128
    89                              <1> FP_R	equ	8
    90                              <1> B_STREAMZR  equ 64
    91                              <1> B_STREAM16R equ 32
    92                              <1> B_STREAM16W equ 16
    93                              <1> 
    94                              <1> r	equ	0
    95                              <1> k	equ	1
    96                              <1> x	equ	2
    97                              <1> y	equ	3
    98                              <1> a	equ	4
    99                              <1> b	equ	5
   100                              <1> mantissa2 equ	6
   101                              <1> mantissa3 equ	7
   102                              <1> residue	equ	8
   103                              <1> p	equ	12
   104                              <1> q	equ	13
   105                              <1> fp	equ	14
   106                              <1> s_p	equ	15
   107                              <1> 
   108                              <1> rdatac	equ	20
   109                              <1> rdata	equ	21
   110                              <1> wdatac	equ	22
   111                              <1> wdata	equ	23
   112                              <1> 
   113                              <1> 
   114                              <1> fp_guard equ	128+19
   115                              <1> 
   116                              <1> rt_clock equ	128+20
   117                              <1> priority equ	128+21
   118                              <1> dayclock_u equ	128+22
   119                              <1> dayclock equ	128+23
   120                              <1> 
   121                              <1> R	equ	r*4
   122                              <1> K	equ	k*4
   123                              <1> X	equ	x*4
   124                              <1> Y	equ	y*4
   125                              <1> A	equ	a*4
   126                              <1> B	equ	b*4
   127                              <1> MANTISSA2 equ	mantissa2*4
   128                              <1> MANTISSA3 equ	mantissa3*4
   129                              <1> RESIDUE	equ	residue*4
   130                              <1> 
   131                              <1> P	equ	p*4
   132                              <1> Q	equ	q*4
   133                              <1> FP	equ	fp*4
   134                              <1> S_P	equ	s_p*4
   135                              <1> 
   136                              <1> RDATAC	equ	rdatac*4
   137                              <1> RDATA	equ	rdata*4
   138                              <1> WDATAC	equ	wdatac*4
   139                              <1> WDATA	equ	wdata*4
   140                              <1> 
   141                              <1> FP_GUARD equ	fp_guard*4
   142                              <1> 
   143                              <1> RT_CLOCK equ	rt_clock*4
   144                              <1> PRIORITY equ	priority*4
   145                              <1> DAYCLOCK_U equ	dayclock_u*4
   146                              <1> DAYCLOCK equ	dayclock*4
   147                              <1> 
   148                              <1> I	equ	4
   149                              <1> XI	equ	5
   150                              <1> 
   151                              <1> DEVICE  equ	32768
   152                              <1> SYSMEM  equ	16384
   153                              <1> DATA16  equ	1
   154                              <1> FSYS24  equ	2
   155                              <1> 
   156                              <1> II_GUARD equ	64+31
   157                              <1> II_EXIT	equ	64+6
   158                              <1> II_YIELD equ	64+1
   159                              <1> II_SPAWN equ	64+2
   160                              <1> II_BANK equ	64+3
   161                              <1> II_ARRAY equ	64+4
   162                              <1> II_BANK_FREE equ 64+5
   163                              <1> II_TWAIT equ	64+27
   164                              <1> II_EVENT_WAIT equ 64+28
   165                              <1> II_FPXPO equ	0+3
   166                              <1> 
   167                              <1> II_XINT		equ	0+2
   168                              <1> II_MSECOND	equ	0+4
   169                              <1> II_ATTENTION	equ	0+5
   170                              <1> 
   171                              <1> LP_AUTHORITY	equ	1		; latent parameters GUARD$
   172                              <1> LP_ADDRESS	equ	14
   173                              <1> 
   174                              <1> LP_TIMESLICE	equ	10		; latent parameter timeslice -> yield
   175                              <1> LP_RANGE	equ	12		; latent parameter FP$XPO
   176                              <1> LP_AUTOEXIT	equ	11		; latent parameter return -> EXIT$
   177                                  	%include	"rta_smp.def"
   178                              <1> __POINTER	equ	8
   179                              <1> 
   180                              <1> REGISTER	equ	0			; /*	288	int	*/
   181                              <1> 
   182                              <1> APC		equ	REGISTER+288*4		; /*	1	->	*/
   183                              <1> APCZ		equ	APC+__POINTER		; /*	1	->	*/
   184                              <1> B0P		equ	APCZ+__POINTER		; /*	1	->	*/
   185                              <1> REGISTER_SET	equ	B0P+__POINTER 
   186                              <1> 
   187                              <1> RESTART_VECTOR	equ	REGISTER_SET+__POINTER	; /*	1	int	*/
   188                              <1> INDICATION	equ	RESTART_VECTOR+4	; /*	1	int	*/	
   189                              <1> LATENT_PARAMETER equ	INDICATION+4		; /*	1	int	*/
   190                              <1> ISELECT		equ	LATENT_PARAMETER+4	; /*	1	int	*/	
   191                              <1> 
   192                              <1> PSR		equ	ISELECT+4		; /*	1	int	*/
   193                              <1> B0_NAME		equ	PSR+4			; /*	1	int	*/
   194                              <1> B0_SCOPE	equ	B0_NAME+4		; /*	1	int	*/
   195                              <1> 
   196                              <1> spare		equ	B0_SCOPE+4		; align with C structure
   197                              <1> 						; and align metric block 
   198                              <1> 
   199                              <1> DELTA		equ	spare+4			; /*	1	int	*/
   200                              <1> __METRIC	equ	DELTA+4			; /*	1	int	*/
   201                              <1> 
   202                              <1> DELTA_BASE	equ	__METRIC+4		; /*	1	long	*/
   203                              <1> TOTAL_DELTA	equ	DELTA_BASE+8		; /*	1	long	*/
   204                              <1> TOTAL_METRIC	equ	TOTAL_DELTA+8		; /*	1	long	*/
   205                              <1> 
   206                              <1> IO_PORT		equ	TOTAL_METRIC+8		; /*	192	int	*/
   207                              <1> DATAFRAME	equ	IO_PORT+192*4		; /*	nothing		*/
   208                              <1> 
   209                              <1> CORE_SIZE	equ	DATAFRAME+0
   210                              <1> 
   211                              <1> CORE_INDEX2	equ	4*280
   212                              <1> CORE_INDEX1	equ	4*(280-128)
   213                                  	%include	"rw.def"
   214                              <1> __REGFOR	equ	0
   215                              <1> __MOVBE		equ	0
   216                              <1> 
   217                              <1> 		default	abs
   218                                  	%include	"io.def"
   219                              <1> 
   220                              <1> _MCAST_SUBVECTOR	equ	75*4	; writeable port to fan out multicast vector
   221                              <1> 					; not a read port
   222                              <1> _XI_PENDING		equ	74*4	; mask of external interrupt sources
   223                              <1> _XI_ACK			equ	75*4	; writeable ack to quench pending signals
   224                              <1> _INCREMENTER_RESTART	equ	76*4
   225                              <1> _CORE_SOCKET		equ	77*4	; socket index this core
   226                              <1> 
   227                              <1> _MCAST_PENDING		equ	78*4	; mask of cores which have multicast to here
   228                              <1> _MCAST_TO		equ	79*4	; -> latent parameter
   229                              <1> 					; destinations mask in register k
   230                              <1> _TZONE			equ	101*4
   231                                  
   232                                  ;	this is not PIC code
   233                                  ;	but does relative jumps for compactness
   234                                  
   235                                  %define ptr
   236                                  %define include
   237                                  %define .model
   238                                  %define .code
   239                                  
   240                                  SYSMEM_FLAG	equ	00800000h
   241                                  DATA16_FLAG	equ	00400000h
   242                                  FSYS24_FLAG	equ	00C00000h
   243                                  
   244                                  					; instruction code starts here
   245                                  	section		.text
   246                                  	global		_leloup
   247                                  	global		_execute
   248                                  	global		_device_readp
   249                                  	global		_bus_readp
   250                                  	global		_memory_read
   251                                  	global		_bus_read
   252                                  	global		_device_read
   253                                  
   254                                  	%include	"leloup.msm"
   255                              <1> 
   256                              <1> 	extern	_ultra
   257                              <1> 	extern	_ultra1
   258                              <1> 	extern	_ultra2
   259                              <1> 	extern	_ultra3
   260                              <1> 	extern	_ultra4
   261                              <1> 	extern	_ultra5
   262                              <1> 	extern	_ultra6
   263                              <1> 	extern	_ultra7
   264                              <1> 	extern	_core
   265                              <1> 
   266                              <1> _save_ebp	equ	0
   267                              <1> _save_return	equ	4
   268                              <1> _1st_param	equ	8
   269                              <1> 
   270                              <1> _leloup:
   271 00000000 55                  <1> 	push	rbp
   272                              <1> 
   273                              <1> 	%if	0
   274                              <1> 	push	rsi
   275                              <1> 	push	rdi
   276                              <1> 	push	rax
   277                              <1> 	push	rcx
   278                              <1> 	push	rdx
   279                              <1> 	%endif
   280                              <1> 
   281 00000001 53                  <1> 	push	rbx
   282                              <1> 
   283 00000002 4889FE              <1> 	mov	rsi, rdi			; structure smp ->
   284                              <1> 
   285 00000005 4157                <1> 	push	r15
   286 00000007 4156                <1> 	push	r14
   287 00000009 4155                <1> 	push	r13
   288 0000000B 4154                <1> 	push	r12
   289                              <1> 
   290 0000000D 4C8BA680040000      <1> 	mov	r12, qword ptr [rsi+APC]
   291 00000014 488BAE98040000      <1> 	mov	rbp, qword ptr [rsi+REGISTER_SET]
   292 0000001B 4C8BAE88040000      <1> 	mov	r13, qword ptr [rsi+APCZ]
   293 00000022 4C8B3425[00000000]  <1> 	mov	r14, qword ptr [_breakpoint]
   294          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
   295 0000002A 4C8B3C25[00000000]  <1> 	mov	r15, qword ptr [_touchpoint]
   296          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
   297                              <1> 						; balance core state pointer
   298 00000032 56                  <1> 	push	rsi				; on stack top
   299                              <1> 
   300 00000033 4D39EC              <1> loup:	cmp	r12, r13			; [rsi+APCZ]
   301 00000036 774A                <1> 	ja	off_limits
   302                              <1> 
   303                              <1> 	%if	__MOVBE
   304                              <1> 	movbe	eax, dword ptr [r12]
   305                              <1> 	%else
   306 00000038 418B0424            <1> 	mov	eax, dword ptr [r12]
   307 0000003C 0FC8                <1> 	bswap	eax
   308                              <1> 	%endif
   309                              <1> 
   310 0000003E 4981C404000000      <1> 	add	r12, 4
   311                              <1> 
   312 00000045 E842010000          <1> 	call	_execute
   313                              <1> 
   314 0000004A 488B3424            <1> 	mov	rsi, qword ptr [rsp] 		; core pointer needed all the way round
   315                              <1> 
   316                              <1> 	%if	TSLICE
   317 0000004E F786B0040000000087- <1> 	test	dword ptr [rsi+PSR], 00870000h	; not while ISR or interrupt mask
   318 00000057 00                  <1>
   319 00000058 7532                <1> 	jnz	louping
   320 0000005A F78650020000FFFFFF- <1> 	test	dword ptr [rsi+RT_CLOCK], 00FFFFFFh
   321 00000063 00                  <1>
   322 00000064 7426                <1> 	jz	louping
   323                              <1> 
   324 00000066 FF8E50020000        <1> 	dec	dword ptr [rsi+RT_CLOCK]
   325 0000006C 751E                <1> 	jnz	louping
   326                              <1> 
   327 0000006E B841000000          <1> 	mov	eax, II_YIELD
   328                              <1> 
   329 00000073 B90A000000          <1> 	mov	ecx, LP_TIMESLICE
   330 00000078 E844110000          <1> 	call	_ii
   331                              <1> 
   332                              <1> 	%endif
   333                              <1> 
   334 0000007D E90A000000          <1> 	jmp	louping
   335                              <1> 
   336                              <1> off_limits:
   337 00000082 B85F000000          <1> 	mov	eax, II_GUARD
   338 00000087 E835110000          <1> 	call	_ii
   339                              <1> 
   340                              <1> louping:
   341 0000008C 4D39F4              <1> 	cmp	r12, r14			; [ _breakpoint ]
   342 0000008F 751C                <1> 	jnz	loup_count
   343                              <1> 
   344 00000091 800C25[00000000]02  <1> 	or	byte ptr [_general_indication], LOCKSTEP
   345          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
   346 00000099 808EA404000002      <1> 	or	byte ptr [rsi+INDICATION], LOCKSTEP
   347 000000A0 800C25[12000000]01  <1> 	or	byte ptr [_flag+'s'-'a'], 1
   348          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
   349 000000A8 E955000000          <1> 	jmp	indicated
   350                              <1> 
   351                              <1> loup_count:
   352 000000AD FF8E6C040000        <1> 	dec	dword ptr [rsi+283*4]		; decrement from quantity RATIO
   353 000000B3 7909                <1> 	jns	loup_away
   354 000000B5 66818EA40400000100  <1> 	or	word ptr [rsi+INDICATION], TIME_UPDATE
   355                              <1> loup_away:
   356                              <1> 
   357 000000BE 668B86A4040000      <1> 	mov	ax, word ptr [rsi+INDICATION]
   358 000000C5 8A8EB2040000        <1> 	mov	cl, byte ptr [rsi+PSR+2]
   359 000000CB 80E107              <1> 	and	cl, 7				; highest interrupt mask?
   360 000000CE 80F107              <1> 	xor	cl, 7
   361                              <1> 
   362 000000D1 7425                <1> 	jz	internal_indications?		; maskable interrupts are masked
   363                              <1> 
   364 000000D3 66A9CBFF            <1>         test	ax, INDICATIONS|EXTERNAL_INDICATIONS	; 1 or both of internal++external
   365 000000D7 0F8456FFFFFF        <1> 	jz	loup					; indications? No?
   366 000000DD 66A9C0FF            <1> 	test	ax, EXTERNAL_INDICATIONS	; external indications among the yes?
   367                              <1> 
   368 000000E1 741F                <1> 	jz	indicated			; external indications there are not
   369                              <1> 						; therefore internal indications there are
   370                              <1> ;	push	rsi				; therefore raise their interrupts
   371 000000E3 E8DD0F0000          <1> 	call	_xi
   372 000000E8 488B3424            <1> 	mov	rsi, qword ptr [rsp]
   373                              <1> 
   374 000000EC 80A6A40400007F      <1> 	and	byte ptr [rsi+INDICATION], 127
   375 000000F3 E994FFFFFF          <1> 	jmp	louping				; keep going intil pending flags are off
   376                              <1> 
   377                              <1> internal_indications?:
   378 000000F8 66A90B00            <1> 	test	ax, INDICATIONS			; just read from esi->INDICATION
   379 000000FC 0F8431FFFFFF        <1> 	jz	loup
   380                              <1> 
   381                              <1> indicated:
   382 00000102 80A6A4040000FD      <1> 	and	byte ptr [rsi+INDICATION], LOCKSTEP^255
   383                              <1> 
   384 00000109 4889AE98040000      <1> 	mov	qword ptr [rsi+REGISTER_SET], rbp
   385 00000110 4C89A680040000      <1> 	mov	qword ptr [rsi+APC], r12
   386 00000117 4C89AE88040000      <1> 	mov	qword ptr [rsi+APCZ], r13
   387                              <1> 
   388 0000011E 5F                  <1> 	pop	rdi				; take core pointer off stack
   389                              <1> 						; was passed in rdi, should not matter
   390 0000011F 415C                <1> 	pop	r12
   391 00000121 415D                <1> 	pop	r13
   392 00000123 415E                <1> 	pop	r14
   393 00000125 415F                <1> 	pop	r15
   394                              <1> 
   395 00000127 5B                  <1> 	pop	rbx				; caller values
   396                              <1> 
   397                              <1> 	%if	0
   398                              <1> 	pop	rdx
   399                              <1> 	pop	rcx
   400                              <1> 	pop	rax
   401                              <1> 	pop	rdi
   402                              <1> 	pop	rsi
   403                              <1> 	%endif
   404                              <1> 
   405 00000128 5D                  <1> 	pop	rbp
   406 00000129 C3                  <1> 	ret
   407                              <1> 
   408                                  	%include	"execute.msm"
   409                              <1> ;	include	rta_x86.h
   410                              <1> .model	small
   411                              <1> .code
   412                              <1> 
   413 0000012A 89C1                <1> __ea:	mov	ecx, eax
   414 0000012C C1E108              <1> 	shl	ecx, 8
   415 0000012F C1E913              <1> 	shr	ecx, 24-5		; instruction index in ch
   416 00000132 C0E905              <1> 	shr	cl, 5			; operand designator in cl
   417                              <1> 
   418 00000135 C1E010              <1> 	shl	eax, 16
   419 00000138 80F905              <1> 	cmp	cl, XI			; sign extended immediate?
   420 0000013B 750B                <1> 	jnz	derive_ea
   421                              <1> 
   422 0000013D C1F808              <1> 	sar	eax, 8			; different from other EAs
   423 00000140 C1E808              <1> 	shr	eax, 8
   424 00000143 E943000000          <1> 	jmp	ea_derived
   425                              <1> 
   426                              <1> derive_ea:
   427 00000148 C1E810              <1> 	shr	eax, 16			; no sign of it
   428 0000014B 6621C0              <1> 	and	ax, ax			; indexing / indirection ?
   429 0000014E 793B                <1> 	jns	ea_derived		; no
   430                              <1> 
   431 00000150 89C3                <1> 	mov	ebx, eax
   432 00000152 80E47F              <1> 	and	ah, 127			; ie: and ax 32767
   433 00000155 66C1EB0C            <1> 	shr	bx, 12			; position index tag
   434 00000159 F6C306              <1> 	test	bl, 6			; indirect or indexed ?
   435 0000015C 7418                <1> 	jz	indirect
   436                              <1> 					; pe = PF set
   437                              <1> 					; can only be tested on b7..0
   438 0000015E 7A03                <1> 	jpe	indexed_4bit		; indexed fp / sp
   439                              <1> 					; indexed x / y / a / b
   440 00000160 80E307              <1> 	and	bl, 7			; zero bit 3
   441                              <1> 
   442                              <1> indexed_4bit:
   443 00000163 6625FF0F            <1> 	and	ax, 4095		; isolate adqress offset
   444 00000167 03449D00            <1> 	add	eax, dword ptr [rbp+rbx*4]
   445                              <1> 
   446 0000016B C1E008              <1> 	shl	eax, 8			; truncate any overflow
   447 0000016E C1E808              <1> 	shr	eax, 8
   448                              <1> 
   449 00000171 E915000000          <1> 	jmp	ea_derived
   450                              <1> 
   451                              <1> indirect:				; indirect via page B0 / B1
   452 00000176 6689CB              <1> 	mov	bx, cx
   453 00000179 6631C9              <1> 	xor	cx, cx			; cl <- zero to read 1-word indirection pointer
   454 0000017C E891030000          <1> 	call	_operand_read
   455 00000181 6689D9              <1> 	mov	cx, bx			; retrieve instruction:class into cx
   456 00000184 488BB560020000      <1> 	mov	rsi, qword ptr [rbp+CORE_INDEX1]	; retrieve smp core ->
   457                              <1> 
   458                              <1> ea_derived:
   459 0000018B C3                  <1> 	ret
   460                              <1> 
   461                              <1> _execute:
   462 0000018C 4889A678040000      <1> 	mov	qword ptr [rsi+REGISTER+286*4], rsp
   463 00000193 E892FFFFFF          <1> 	call	__ea
   464                              <1> 
   465 00000198 0FB6DD              <1> 	movzx	ebx, ch			; instruction index
   466 0000019B 80F906              <1> 	cmp	cl, 6
   467 0000019E 0F8410010000        <1> 	jz	near shifts_jumps
   468 000001A4 0F8714020000        <1> 	ja	near large_operations
   469                              <1> 
   470                              <1> integer_operations:
   471 000001AA 488B1CDD[B4010000]  <1> 	mov	rbx, qword ptr [operations1+rbx*8]
   472          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
   473 000001B2 FFE3                <1> 	jmp	rbx
   474                              <1> 
   475                              <1> operations1:
   476 000001B4 [4115000000000000]  <1>         dq	_sr
   477 000001BC [5B15000000000000]  <1>         dq	_sk
   478 000001C4 [7515000000000000]  <1>         dq	_sx
   479 000001CC [8F15000000000000]  <1>         dq	_sy
   480 000001D4 [A915000000000000]  <1>         dq	_sa
   481 000001DC [BF15000000000000]  <1>         dq	_sb
   482 000001E4 [D515000000000000]  <1>         dq	_z
   483 000001EC [EE15000000000000]  <1>         dq	_pop
   484                              <1> 
   485 000001F4 [0A16000000000000]  <1>         dq	_lr
   486 000001FC [1316000000000000]  <1>         dq	_lk
   487 00000204 [1C16000000000000]  <1>         dq	_lx
   488 0000020C [2516000000000000]  <1>         dq	_ly
   489 00000214 [2E16000000000000]  <1>         dq	_la
   490 0000021C [3716000000000000]  <1>         dq	_lb
   491 00000224 [4016000000000000]  <1>         dq	_tz
   492 0000022C [6B16000000000000]  <1>         dq	_tp
   493                              <1> 
   494 00000234 [D319000000000000]  <1>         dq	_ax
   495 0000023C [E419000000000000]  <1>         dq	_ay
   496 00000244 [F519000000000000]  <1>         dq	_or
   497 0000024C [FE19000000000000]  <1>         dq	_orB
   498 00000254 [071A000000000000]  <1>         dq	_and
   499 0000025C [101A000000000000]  <1>         dq	_andB
   500 00000264 [191A000000000000]  <1>         dq	_xor
   501 0000026C [221A000000000000]  <1>         dq	_xorB
   502                              <1> 
   503 00000274 [2B1A000000000000]  <1>         dq	_aa
   504 0000027C [501A000000000000]  <1>         dq	_ab
   505 00000284 [351A000000000000]  <1>         dq	_ana
   506 0000028C [5A1A000000000000]  <1>         dq	_anb
   507 00000294 [751A000000000000]  <1>         dq	_m
   508 0000029C [A31A000000000000]  <1>         dq	_mf
   509 000002A4 [011B000000000000]  <1>         dq	_d
   510 000002AC [8D16000000000000]  <1>         dq	_push
   511                              <1> 
   512                              <1> shifts_jumps:
   513 000002B4 488B1CDD[BE020000]  <1> 	mov	rbx, qword ptr [operations6+rbx*8]
   514          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
   515 000002BC FFE3                <1> 	jmp	rbx
   516                              <1> 
   517                              <1> operations6:
   518 000002BE [B11B000000000000]  <1>         dq	_sar
   519 000002C6 [C81B000000000000]  <1>         dq	_sbr
   520 000002CE [DF1B000000000000]  <1>         dq	_dsr
   521 000002D6 [AF16000000000000]  <1>         dq	_jdr
   522 000002DE [F31B000000000000]  <1>         dq	_sal
   523 000002E6 [0A1C000000000000]  <1>         dq	_sbl
   524 000002EE [211C000000000000]  <1>         dq	_dsl
   525 000002F6 [C916000000000000]  <1>         dq	_lcal
   526                              <1> 
   527 000002FE [351C000000000000]  <1>         dq	_rar
   528 00000306 [411C000000000000]  <1>         dq	_rbr
   529 0000030E [4D1C000000000000]  <1>         dq	_drr
   530 00000316 [E416000000000000]  <1>         dq	_jnc
   531 0000031E [F51D000000000000]  <1>         dq	_ral
   532 00000326 [011E000000000000]  <1>         dq	_rbl
   533 0000032E [0D1E000000000000]  <1>         dq	_drl
   534 00000336 [F116000000000000]  <1>         dq	_jc
   535                              <1> 
   536 0000033E [211E000000000000]  <1>         dq	_saa
   537 00000346 [321E000000000000]  <1>         dq	_sba
   538 0000034E [431E000000000000]  <1>         dq	_dsa
   539 00000356 [FE16000000000000]  <1>         dq	_jao
   540 0000035E [0817000000000000]  <1>         dq	_jpa
   541 00000366 [1217000000000000]  <1>         dq	_jpb
   542 0000036E [1C17000000000000]  <1>         dq	_j
   543 00000376 [3517000000000000]  <1>         dq	_jpo
   544                              <1> 
   545 0000037E [3D17000000000000]  <1>         dq	_jza
   546 00000386 [4717000000000000]  <1>         dq	_jzb
   547 0000038E [5117000000000000]  <1>         dq	_jnza
   548 00000396 [5B17000000000000]  <1>         dq	_jnzb
   549 0000039E [6517000000000000]  <1>         dq	_jna
   550 000003A6 [6F17000000000000]  <1>         dq	_jnb
   551 000003AE [7917000000000000]  <1>         dq	_jxge
   552 000003B6 [8817000000000000]  <1>         dq	_jyge
   553                              <1> 
   554                              <1> 
   555                              <1> large_operations:
   556 000003BE 488B1CDD[CA030000]  <1> 	mov	rbx, qword ptr [operations7+rbx*8]
   557          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
   558 000003C6 B100                <1> 	mov	cl, 0		; default size large operand
   559 000003C8 FFE3                <1> 	jmp	rbx		; 1 word
   560                              <1> 
   561                              <1> operations7:
   562 000003CA [8718000000000000]  <1>         dq	_ts
   563 000003D2 [571E000000000000]  <1>         dq	_n
   564 000003DA [661E000000000000]  <1>         dq	_inc
   565 000003E2 [721E000000000000]  <1>         dq	_dec
   566 000003EA [A118000000000000]  <1>         dq	_sim
   567 000003F2 [BE1E000000000000]  <1>         dq	_popA
   568 000003FA [7E1E000000000000]  <1>         dq	_src
   569 00000402 [9E1E000000000000]  <1>         dq	_slc
   570                              <1> 
   571 0000040A [9717000000000000]  <1>         dq	_qs
   572 00000412 [A117000000000000]  <1>         dq	_ql
   573 0000041A [1E18000000000000]  <1>         dq	_dte
   574 00000422 [D917000000000000]  <1>         dq	_dpop
   575 0000042A [B227000000000000]  <1>         dq	_fa
   576 00000432 [CD27000000000000]  <1>         dq	_fan
   577 0000043A [E827000000000000]  <1>         dq	_fm
   578 00000442 [0A28000000000000]  <1>         dq	_fd
   579                              <1> 
   580 0000044A [AB17000000000000]  <1>         dq	_qpop
   581 00000452 [C017000000000000]  <1>         dq	_qpush
   582 0000045A [7618000000000000]  <1>         dq	_ex
   583 00000462 [EE17000000000000]  <1>         dq	_dpush
   584 0000046A [AD1F000000000000]  <1>         dq	_lsc
   585 00000472 [0918000000000000]  <1>         dq	_mta
   586 0000047A [3518000000000000]  <1>         dq	_sc
   587 00000482 [4618000000000000]  <1>         dq	_mlb
   588                              <1> 
   589 0000048A [5F18000000000000]  <1>         dq	_ds
   590 00000492 [6918000000000000]  <1>         dq	_dl
   591 0000049A [F41E000000000000]  <1>         dq	_da
   592 000004A2 [FE1E000000000000]  <1>         dq	_dan
   593 000004AA [BE1F000000000000]  <1>         dq	_dlsc
   594 000004B2 [7518000000000000]  <1>         dq	_spare
   595 000004BA [EC18000000000000]  <1>         dq	_go
   596 000004C2 [CC18000000000000]  <1>         dq	_call
   597                              <1> 
   598                                  	%include	"rw.msm"
   599                              <1> 
   600                              <1> 
   601                              <1> ;	include	rta_x86.h
   602                              <1> ;	.model	large
   603                              <1> ;	.code
   604                              <1> 
   605                              <1> ;	this is the operand reader / writer
   606                              <1> ;	for emulated RTA1 on x86
   607                              <1> 
   608                              <1> ;	layout is
   609                              <1> 
   610                              <1> ;	RTA1 24-bit registers are modeled in an array of
   611                              <1> ;	platform-endian integers. In x86 these are 32-bit
   612                              <1> ;	little-endian integers
   613                              <1> 
   614                              <1> ;	platform-endian doesn't affect registers
   615                              <1> ;	because endianness is not at the CPU
   616                              <1> ;	side of the bus, but at the memory side
   617                              <1> 
   618                              <1> ;	when Intel circuitry in the x86 CPU staticises the value
   619                              <1> ;	of an emulated register, that value is big endian
   620                              <1> 
   621                              <1> ;	the stored integers where emulated registers are modeled
   622                              <1> ;	are platform-endian, with identical effect on big and
   623                              <1> ;	little endian emulator platforms
   624                              <1> 
   625                              <1> ;	RTA1 24-bit executable space storage words are modeled in
   626                              <1> ;	another array of platform-endian 32-bit integers. Emulation
   627                              <1> ;	on x86 swaps the byte order of storage words on read and
   628                              <1> ;	before write to conform with RTA1 canonical storage order
   629                              <1> 
   630                              <1> ;       RTA1 architecture has registers in the first 256 locations
   631                              <1> ;       of address space and access differentiates registers from
   632                              <1> ;       from memory according to effective address
   633                              <1> 
   634                              <1> ;	location of registers and storage are handed to read / write
   635                              <1> ;	routines as RTA1 word linear effective addresses
   636                              <1> 
   637                              <1> ;	These routines maintain the RTA1 linear addresses passed
   638                              <1> ;	in x86 registers and apply them with shifted scale plus
   639                              <1> ;	displacement, for example
   640                              <1> 
   641                              <1> ;		mov	eax, dword ptr [edi+esi*4+_memory]
   642                              <1> ;		bswap	eax
   643                              <1> ;		mov	dword_ptr [ebp+ebx*4], eax
   644                              <1> 
   645                              <1> ;	RTA1 register addresses are already absolute in terms of
   646                              <1> ;	the emulated RTA1 machine
   647                              <1> 
   648                              <1> ;	ebp points at the context register frame. There are two
   649                              <1> ;	register frames, application and interrupt. Registers
   650                              <1> ;	addressed as storage operand are in a single list
   651                              <1> 
   652                              <1> ;		mov	eax, dword ptr [esi*4+__register]
   653                              <1> 
   654                              <1> ;	RTA1 storage addresses are translated by RTA1 relocation
   655                              <1> ;	architecture before application. The updated linear addresses
   656                              <1> ;	of the emulated machine are in esi
   657                              <1> 
   658                              <1> ;	The operand routines in this file point edi to the x86 platform
   659                              <1> ;	storage array start of the storage device, most often emulated
   660                              <1> ;	RTA1 executable space
   661                              <1> 
   662                              <1> ;	instructions call these operand routines with RTA1 effective 
   663                              <1> ;	address in eax
   664                              <1> 
   665                              <1> ;	instructions receive load operand values in eax and ebx, or in
   666                              <1> ;	a list of RTA1 emulated register locations pointed by ebp+ebx
   667                              <1> 
   668                              <1> ;	store instructions submit a value in ebx, or values in list of
   669                              <1> ;	RTA1 emulated register locations pointed by ebp+ebx
   670                              <1> 
   671                              <1> ;	to preserve linear address consistency, application instruction
   672                              <1> ;	work areas, where needed in addition to x86 registers, are
   673                              <1> ;	implemented as sub-architectural extra RTA1 registers at the end
   674                              <1> ;	of the 256-longword register stack. x86 register ebp+ebx*4 identify
   675                              <1> ;	these locations by linear RTA1 word quantum as "registers"
   676                              <1> 
   677                              <1> ;	RTA1 registers and storage alike are in 24-bit word address quantum space
   678                              <1> 
   679                              <1> ;	emulated instructions loading or storing multiple hidden extra work
   680                              <1> ;	registers should unconditionally set ebp to the start or application
   681                              <1> ;	frame of the emulated register array, so that [ebp+ebx*4] accesses the
   682                              <1> ;	correct locations at register occurence 256+
   683                              <1> 
   684                              <1> ;               _floating_operand2 equ  256+12
   685                              <1> 
   686                              <1> ;		push	ebp
   687                              <1> ;		mov	ebp, __register	; point to application register frame[0]
   688                              <1> ;		mov	ebx, 256+_floating_operand2
   689                              <1> ;		call	_burst_read4
   690                              <1> 
   691                              <1> ;		pop	ebp		; return to previous register frame[0] application
   692                              <1> 					;                          or frame[1] interrupt
   693                              <1> 
   694                              <1> ;	Both internal stack pointers are also absolute, so for stack operations
   695                              <1> ;	ebp should be momentarily forced to the lower-addressed (application) stack
   696                              <1> ;	frame after being used to point the stack location of reference
   697                              <1> 
   698                              <1> ;		mov	ebx, dword ptr [ebp+S_P]	; read one of the two stack pointers
   699                              <1> ;		cmp	ebx, ebp+STACK_LOWER_LIMIT	; 24*4 within context of either stack
   700                              <1> ;		jl	II_GUARD
   701                              <1> ;		add	ebx, -1				; new stack top
   702                              <1> ;		mov	dword ptr [ebp+S_P], ebx
   703                              <1> ;		push	ebp				; which ever stack pointer it is, it points
   704                              <1> ;		mov	ebp,__register			; relative to all the register stack
   705                              <1> ;		call	_operand_read			; for I am the single-word push instruction
   706                              <1> ;		pop	ebp				;
   707                              <1> 
   708                              <1> ;	register identities supplied from emulated instructions to these routines
   709                              <1> ;	are their lowercase names equated to RTA1 word addresses
   710                              <1> 
   711                              <1> ;	There exist also uppercase spellings which instruction routines may
   712                              <1> ;	access internally. The uppercase names are four times in value the
   713                              <1> ;	equivalent lowercase ordinal names to give x86 platform offset values
   714                              <1> 
   715                              <1> ;       Assembly language equate is like parentheses! What's in a label
   716                              <1> ;       is not an expression but its value. Nothing like C preprocessor.
   717                              <1> ;       Just in case you're developing enhancements in assembly using
   718                              <1> ;       preprocessor and #define
   719                              <1> 
   720                              <1> ;		_floating_operand2 equ	256+12
   721                              <1> ;		FLOATING_OPERAND2 equ	_floating_operand2*4
   722                              <1> 
   723                              <1> 
   724                              <1> ;		a	equ	4
   725                              <1> ;		b	equ	5
   726                              <1> ;		mantissa2 equ	6
   727                              <1> 
   728                              <1> ;		A	equ	a*4
   729                              <1> ;		B	equ	b*4
   730                              <1> ;		MANTISSA2 equ	mantissa2*4
   731                              <1> 
   732                              <1> ;		mov	ebx, dword ptr [bp+MANTISSA2]	; the very same!
   733                              <1> ;		mov	ebx, dword ptr [bp+mantissa2*4]	; the very same
   734                              <1> 
   735                              <1> ;	but to identify an instruction-implied register to these operand routines
   736                              <1> 
   737                              <1> ;		mov	ebx, mantissa2		; bp already says which register set
   738                              <1> 
   739                              <1> ;	instruction evaluation supplies right-hand side operand EA in eax
   740                              <1> ;	Instruction implementation needs not examine EA. Call _operand_read
   741                              <1> ;	or _operand_write. eax must be as supplied to the instruction routine
   742                              <1> ;	on on operand retrieve and store
   743                              <1> 
   744                              <1> ;	simple instructions receive operand mode in cl from instruction
   745                              <1> ;	evaluation
   746                              <1> 
   747                              <1> ;	shifts and jumps use the ea which is already indexed or indirected
   748                              <1> ;	if necessary and make no operand call
   749                              <1> 
   750                              <1> ;	instructions call _burst_read2 or _burst_write2 for two-word operand cycles
   751                              <1> ;	instructions call _burst_read4 or _burst_write4 for four-word operand cycles
   752                              <1> 
   753                              <1> ;	operand reads of 1 or 2 words return values in eax:ebx
   754                              <1> 
   755                              <1> ;		call	_burst_read2
   756                              <1> ;		mov	dword ptr [ebp+A], eax
   757                              <1> ;		mov	dword ptr [ebp+B], ebx
   758                              <1> 
   759                              <1> ;	to store one operand word place it in ebx
   760                              <1> 
   761                              <1> ;	_sc	mov	ebx, dword ptr[_psr]	; I am the store carry instruction sc
   762                              <1> ;		and	ebx, 1			; CARRY
   763                              <1> ;		call	_operand_write
   764                              <1> 
   765                              <1> ;	to store two or four words or to load four words, point bx to register
   766                              <1> 
   767                              <1> ;	_qpop	mov	ebx, dword ptr [ebp+S_P] ; internal stack pointer
   768                              <1> ;						; either application sp or interrupt sp
   769                              <1> ;
   770                              <1> ;		add	dword ptr [ebp+S_P], 4	; internal stack+= 4
   771                              <1> ;		push	ebp			;
   772                              <1> ;		mov	ebp, __register		; in case context is interrupt registers
   773                              <1> ;		call	_burst_write4		; both internal stack pointers are absolute
   774                              <1> ;		pop	ebp			; point epb back to application registers
   775                              <1> ;						;                or interrupt registers
   776                              <1> 
   777                              <1> ;	more complex instructions do something to the registers after
   778                              <1> ;	acquiring operands
   779                              <1> 
   780                              <1> ;		call	_operand_read
   781                              <1> ;		add	eax, dword ptr [ebp+A]
   782                              <1> ;		rol	eax
   783                              <1> ;		and	al, CARRY		; 1
   784                              <1> ;		or	byte ptr [_psr], al	; low-order byte of longword _psr
   785                              <1> ;		shr	eax, 8
   786                              <1> ;		mov	dword ptr [ebp+A], eax
   787                              <1> 
   788                              <1> ;	emulated RTA1 instructions which both read and write (modify)
   789                              <1> ;	storage use the address in [edi+esi*4] to rewrite. edi is
   790                              <1> ;	NULL if it's not a suitable memory for a modify operation
   791                              <1> 
   792                              <1> ;	modify instructions which may have a register operand (not TS)
   793                              <1> ;	call _operand_write to rewrite a register. This guards aganst
   794                              <1> ;	applications writing interrupt registers.
   795                              <1>  
   796                              <1> ;	the effect of storage buses characteristically different
   797                              <1> ;	from RTA1 executable space is emulated in the routines
   798                              <1> ;	device_read and device_write
   799                              <1> 
   800                              <1> ;	Peripheral bus types implemented are
   801                              <1> 
   802                              <1> ;		filestore containing extents of up to 768K octets
   803                              <1> ;		accessible to RTA1 as up to 256K words in each extent.
   804                              <1> ;		The 3-octet words are in canonical order and packed
   805                              <1> 
   806                              <1> ;		network interface buffer store shared with the emulator
   807                              <1> ;		platform and reading out to RTA1 at 16 data bits per word
   808                              <1> ;		with eight high-order zero bits. RTA writes 16 data bits
   809                              <1> ;		to these locations from register low-order bit positions.
   810                              <1> ;		Storage byte order is canonical. These buffers are normal
   811                              <1> ;		and contiguous byte arrays of the emulator platform.
   812                              <1> ;		To RTA1 they are an attached device array of 16-bit words
   813                              <1> 
   814                              <1> ;	Device array types are
   815                              <1> 
   816                              <1> ;		executable space
   817                              <1> ;		24-bit filestore array
   818                              <1> ;		16-bit network interface array
   819                              <1> 
   820                              <1> ;	devices are identified in RTA1 memory relocation pointers and
   821                              <1> ;	tagged with device type. Executable space is device zero
   822                              <1> 
   823                              <1> ;	esi -> core.REGISTER
   824                              <1> 
   825                              <1> _burst_read2:
   826 000004CA 66B90600            <1> 	mov	cx, 6
   827 000004CE A900FFFF00          <1> 	test	eax, 00FFFF00h
   828 000004D3 7405                <1> 	jz	read2_registers
   829 000004D5 E950000000          <1> 	jmp	_bus_read
   830                              <1> 
   831                              <1> read2_registers:				; load registers from registers
   832                              <1> 	%if	__REGFOR
   833                              <1> 
   834                              <1> 	mov	rax, qword ptr [rsi+rax*4]	; swap the halves of r8 if computing in r8
   835                              <1> 	ret					; just mov for double register load
   836                              <1> 						; do this load inline anyway
   837                              <1> 	%else	
   838                              <1> 
   839 000004DA 8B5C8604            <1> 	mov	ebx, dword ptr [rsi+rax*4+4]
   840 000004DE 8B0486              <1> 	mov	eax, dword ptr [rsi+rax*4]
   841 000004E1 C3                  <1> 	ret
   842                              <1> 
   843                              <1> 	%endif
   844                              <1> 	
   845                              <1> ;	rsi -> core.REGISTER
   846                              <1> 
   847                              <1> _burst_read4:					; buffered read
   848 000004E2 66B90700            <1> 	mov	cx, 7				; that will help the caller
   849 000004E6 A900FFFF00          <1> 	test	eax, 00FFFF00h			; ebp+ebx contains a register number
   850 000004EB 7405                <1> 	jz	read4_registers			; may also identify extra
   851 000004ED E938000000          <1> 	jmp	_bus_read
   852                              <1> 						; workspace registers
   853                              <1> read4_registers:				; at register stack tail
   854                              <1> 
   855                              <1> 	%if	__REGFOR			; registeres are modelled
   856                              <1> 						; platform endian in storage
   857                              <1> 	mov	rax, qword ptr [rsi+rax*4+2*4]	; core-ways round individually but reverse order
   858                              <1> 	mov	rdx, qword ptr [rsi+rax*4]	; into correct register order individually platform-ordered 
   859                              <1> 	ret
   860                              <1> 
   861                              <1> 	%else
   862                              <1> 
   863 000004F2 8B4C860C            <1> 	mov	ecx, dword ptr [rsi+rax*4+3*4]
   864 000004F6 894C9D0C            <1> 	mov	dword ptr [rbp+rbx*4+3*4], ecx
   865 000004FA 8B4C8608            <1> 	mov	ecx, dword ptr [rsi+rax*4+2*4]
   866 000004FE 894C9D08            <1> 	mov	dword ptr [rbp+rbx*4+2*4], ecx
   867 00000502 8B4C8604            <1> 	mov	ecx, dword ptr [rsi+rax*4+4]
   868 00000506 894C9D04            <1> 	mov	dword ptr [rbp+rbx*4+4], ecx
   869 0000050A 8B0C86              <1> 	mov	ecx, dword ptr [rsi+rax*4]
   870 0000050D 894C9D00            <1> 	mov	dword ptr [rbp+rbx*4], ecx
   871 00000511 C3                  <1> 	ret
   872                              <1> 
   873                              <1> 	%endif
   874                              <1> 
   875                              <1> ;	esi -> core.REGISTER
   876                              <1> 
   877                              <1> _operand_read:			; call here with designator coded in cx
   878 00000512 80E107              <1> 	and	cl, 7		; and ea in eax
   879 00000515 80F904              <1> 	cmp	cl, 4
   880 00000518 740F                <1> 	je	immediate	; EA is operand
   881 0000051A 80F905              <1> 	cmp	cl, 5
   882 0000051D 740A                <1> 	je	immediate_xi	; EA is operand
   883                              <1> 
   884 0000051F A900FFFF00          <1> 	test	eax, 00FFFF00h
   885 00000524 7504                <1> 	jnz	_bus_read	; ea does not point to registers
   886 00000526 8B0486              <1> 	mov	eax, dword ptr [rsi+rax*4]
   887                              <1> 
   888                              <1> immediate:
   889                              <1> immediate_xi:
   890 00000529 C3                  <1> 	ret 
   891                              <1> 
   892                              <1> _bus_read:				; readout any memory
   893                              <1> 
   894 0000052A E870060000          <1> 	call	base_read_pointer	; returns eax <- storage block
   895                              <1> 					; 	  esi <- word offset
   896                              <1> 					;	  edi <- EA
   897                              <1> 
   898 0000052F A900004000          <1> 	test	eax, 00400000h		; big block?
   899 00000534 7420                <1> 	je	memory_read_4k_block
   900                              <1> 
   901 00000536 80F906              <1> 	cmp	cl, 6			; multiword operation?
   902 00000539 720D                <1> 	jb	_bus_read_256k_block
   903                              <1> 
   904 0000053B 81FEFCFF0300        <1> 	cmp	esi, 03FFFCh		; near the edge?
   905 00000541 7605                <1> 	jna	_bus_read_256k_block	; no
   906                              <1> 
   907 00000543 E8B3230000          <1> 	call	read_straddle_18b?
   908                              <1> 
   909                              <1> _bus_read_256k_block:
   910 00000548 25FFFF3F00          <1> 	and	eax, 003FFFFFh		; 64-bit shift to page won't brush off 00400000 bit
   911 0000054D A83F                <1> 	test	al, 63
   912 0000054F 742A                <1> 	jz	memory_read_page
   913                              <1> 
   914 00000551 E93D040000          <1> 	jmp	device_read
   915                              <1> 
   916                              <1> memory_read_4k_block:
   917 00000556 F7C600F00300        <1> 	test	esi, 0003F000h		; inside 4k block?
   918 0000055C 740A                <1> 	jz	memory_read_thru
   919                              <1> 
   920 0000055E B90E000000          <1> 	mov	ecx, LP_ADDRESS
   921 00000563 E9460C0000          <1> 	jmp	guard_ii_escape		; no
   922                              <1> 
   923                              <1> memory_read_thru:
   924 00000568 80F906              <1> 	cmp	cl, 6
   925 0000056B 720E                <1> 	jb	memory_read_page
   926                              <1> 
   927 0000056D 4881FEFC0F0000      <1> 	cmp	rsi, 0FFCh		; near the edge?
   928 00000574 7605                <1> 	jna	memory_read_page	; no
   929                              <1> 
   930 00000576 E84D230000          <1> 	call	read_straddle_12b?
   931                              <1> 
   932                              <1> memory_read_page:
   933 0000057B 48C1E00C            <1> 	shl	rax, 12			; multiply by page and lose bit 00400000
   934 0000057F 4801C6              <1> 	add	rsi, rax
   935                              <1> ;	mov	ch, byte ptr [edi+PSR]	; field of PSR with byte options
   936 00000582 48BF-               <1> 	mov	rdi, _memory		; byte address
   937 00000584 [0000000000000000]  <1>
   938                              <1> 
   939                              <1> memory_read_on:
   940 0000058C 488D3CB7            <1> 	lea	rdi, [rdi+rsi*4]
   941 00000590 488BB560020000      <1> 	mov	rsi, qword ptr [rbp+CORE_INDEX1]
   942 00000597 480FB6C1            <1> 	movzx	rax, cl
   943 0000059B 488B04C5[A5050000]  <1> 	mov	rax, qword ptr [read_action+rax*8]
   944          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
   945 000005A3 FFE0                <1> 	jmp	rax
   946                              <1> 
   947                              <1> read_action:
   948 000005A5 [E505000000000000]  <1> 	dq	memory_read_w0
   949 000005AD [2606000000000000]  <1> 	dq	memory_t1
   950 000005B5 [3006000000000000]  <1> 	dq	memory_t2	; or h1
   951 000005BD [4306000000000000]  <1> 	dq	memory_t3	; or h2
   952 000005C5 [2905000000000000]  <1> 	dq	immediate	; don't get here
   953 000005CD [2905000000000000]  <1> 	dq	immediate_xi	; don't get here
   954 000005D5 [EC05000000000000]  <1> 	dq	memory_read2
   955 000005DD [FA05000000000000]  <1> 	dq	memory_read4
   956                              <1> 
   957                              <1> memory_read_w0:			; readout system memory 1 word
   958                              <1> 
   959                              <1> 	%if	__MOVBE
   960                              <1> 	movbe	eax, dword ptr [rdi]
   961                              <1> 	%else
   962 000005E5 8B07                <1> 	mov	eax, dword ptr [rdi]
   963 000005E7 B000                <1> 	mov	al, 0
   964 000005E9 0FC8                <1> 	bswap	eax
   965                              <1> 	%endif
   966                              <1> ; immediate:
   967                              <1> ; immediate_xi:
   968 000005EB C3                  <1>  	ret
   969                              <1> 
   970                              <1> memory_read2:			; readout system memory 2 words
   971                              <1> 	%if	__MOVBE
   972                              <1> 
   973                              <1> 	movbe	rax, qword ptr [rdi]
   974                              <1> 	ret
   975                              <1> 
   976                              <1> 	%else
   977                              <1> 
   978 000005EC 8B5F04              <1> 	mov	ebx, dword ptr [rdi+4]
   979 000005EF 8B07                <1> 	mov	eax, dword ptr [rdi]
   980                              <1> 
   981 000005F1 B000                <1> 	mov	al, 0
   982 000005F3 B300                <1> 	mov	bl, 0
   983 000005F5 0FC8                <1> 	bswap	eax
   984 000005F7 0FCB                <1> 	bswap	ebx
   985 000005F9 C3                  <1> 	ret
   986                              <1> 
   987                              <1> 	%endif
   988                              <1> 				; readout system memory 4 words
   989                              <1> memory_read4:			; store by pointer
   990                              <1> 				; this will be useful to the caller
   991                              <1> 
   992                              <1> 	%if	__MOVBE
   993                              <1> 	
   994                              <1> 	movbe	rax, qword ptr [rdi+2*4]
   995                              <1> 	movbe	rdx, qword ptr [rdi]
   996                              <1> 	ret
   997                              <1> 
   998                              <1> 	%else
   999                              <1> 
  1000 000005FA 8B07                <1> 	mov	eax, dword ptr [rdi]
  1001 000005FC B000                <1> 	mov	al, 0
  1002 000005FE 0FC8                <1> 	bswap	eax
  1003 00000600 89449D00            <1> 	mov	dword ptr [rbp+rbx*4], eax
  1004 00000604 8B4704              <1> 	mov	eax, dword ptr [rdi+4]
  1005 00000607 B000                <1> 	mov	al, 0
  1006 00000609 0FC8                <1> 	bswap	eax
  1007 0000060B 89449D04            <1> 	mov	dword ptr [rbp+rbx*4+4], eax
  1008 0000060F 8B4708              <1> 	mov	eax, dword ptr [rdi+2*4]
  1009 00000612 B000                <1> 	mov	al, 0
  1010 00000614 0FC8                <1> 	bswap	eax
  1011 00000616 89449D08            <1> 	mov	dword ptr [rbp+rbx*4+2*4], eax
  1012 0000061A 8B470C              <1> 	mov	eax, dword ptr [rdi+3*4]
  1013 0000061D B000                <1> 	mov	al, 0
  1014 0000061F 0FC8                <1> 	bswap	eax
  1015 00000621 89449D0C            <1> 	mov	dword ptr [rbp+rbx*4+3*4], eax
  1016 00000625 C3                  <1> 	ret
  1017                              <1> 
  1018                              <1> 	%endif
  1019                              <1> 
  1020                              <1> memory_t1:
  1021 00000626 8B07                <1> 	mov	eax, dword ptr [rdi]
  1022 00000628 C1E010              <1> 	shl	eax, 16		; t1 = 3.2.THIS.zero
  1023 0000062B E91E000000          <1> 	jmp	memory_tw
  1024                              <1> 
  1025                              <1> memory_t2:
  1026 00000630 8B07                <1> 	mov	eax, dword ptr [rdi]
  1027 00000632 F686B004000080      <1> 	test	byte ptr [rsi+PSR], HALF_W
  1028 00000639 751A                <1> 	jnz	memory_h1
  1029 0000063B C1E008              <1> 	shl	eax, 8		; t2 = 3.THIS.1.zero
  1030 0000063E E90B000000          <1> 	jmp	memory_tw
  1031                              <1> 
  1032                              <1> memory_t3:
  1033 00000643 8B07                <1> 	mov	eax, dword ptr [rdi]
  1034 00000645 F686B004000080      <1> 	test	byte ptr [rsi+PSR], HALF_W
  1035 0000064C 7511                <1> 	jnz	memory_h2
  1036                              <1> memory_tw:
  1037 0000064E C1F810              <1> 	sar	eax, 16		; t3 = THIS.2.1.zero
  1038 00000651 C1E808              <1> 	shr	eax, 8
  1039 00000654 C3                  <1> 	ret
  1040                              <1> 
  1041                              <1> memory_h1:
  1042 00000655 0FC8                <1> 	bswap	eax		; already loaded but not swapped
  1043 00000657 C1E008              <1> 	shl	eax, 8		; h1 = zero.HERE.2.3
  1044 0000065A E905000000          <1> 	jmp	memory_hw
  1045                              <1> 
  1046                              <1> memory_h2:
  1047 0000065F 0FC8                <1> 	bswap	eax		; already loaded but not swapped
  1048 00000661 C1E014              <1> 	shl	eax, 8+12
  1049                              <1> memory_hw:
  1050 00000664 C1F80C              <1> 	sar	eax, 12
  1051 00000667 C1E808              <1> 	shr	eax, 8
  1052 0000066A C3                  <1> 	ret
  1053                              <1> 
  1054                              <1> ;	esi -> core.REGISTER
  1055                              <1> 				; store system memory
  1056                              <1> _burst_write4:
  1057 0000066B 66B90700            <1> 	mov	cx, 7
  1058 0000066F A900FFFF00          <1> 	test	eax, 00FFFF00h
  1059 00000674 0F858E000000        <1> 	jnz	NEAR bus_write
  1060                              <1> 
  1061                              <1> 	; store emulated registers to emulated registers
  1062                              <1> 
  1063 0000067A F786B0040000000080- <1> 	test	dword ptr [rsi+PSR], 0800000h	; ISR ?
  1064 00000683 00                  <1>
  1065 00000684 750C                <1> 	jnz	write4_registers	; ISRs may write some spare registers
  1066 00000686 3D7C000000          <1> 	cmp	eax, 124
  1067 0000068B 7605                <1> 	jna	write4_registers
  1068 0000068D E9170B0000          <1> 	jmp	guard_ii_authority	; but applications may not write
  1069                              <1> 					; any interrupt registers
  1070                              <1> 
  1071                              <1> write4_registers:
  1072                              <1> ;	mov	edi, eax		; eax can be freed
  1073                              <1> 
  1074                              <1> 	%if	__REGFOR
  1075                              <1> 	mov	rdx, qword ptr [rbp+rbx*4]
  1076                              <1> 	ror	rdx, 32
  1077                              <1> 	mov	qword ptr [rsi+REGISTER+rax*4], rdx
  1078                              <1> 
  1079                              <1> 	mov	rdx, qword ptr [rbp+rbx*4+2*4]
  1080                              <1> 	ror	rdx, 32
  1081                              <1> 	mov	qword ptr [rsi+REGISTERrax*4+2*4], rdx
  1082                              <1> 	ret
  1083                              <1> 
  1084                              <1> 	%else
  1085                              <1> 
  1086 00000692 8B4C9D00            <1> 	mov	ecx, dword ptr [rbp+rbx*4]	; data for store
  1087                              <1> 					; ebp+ebx is a register number
  1088                              <1> 					; which can be extra register locations
  1089                              <1> 					; serving as workspace at the tail of
  1090                              <1> 					; the register stack
  1091                              <1> 
  1092 00000696 890C86              <1> 	mov	dword ptr [rsi+rax*4], ecx
  1093 00000699 8B4C9D04            <1> 	mov	ecx, dword ptr [rbp+rbx*4+4]
  1094 0000069D 894C8604            <1> 	mov	dword ptr [rsi+rax*4+4], ecx
  1095                              <1> 
  1096 000006A1 8B4C9D08            <1> 	mov	ecx, dword ptr [rbp+rbx*4+2*4]
  1097 000006A5 894C8608            <1> 	mov	dword ptr [rsi+rax*4+2*4], ecx
  1098 000006A9 8B4C9D0C            <1> 	mov	ecx, dword ptr [rbp+rbx*4+3*4]
  1099 000006AD 894C860C            <1> 	mov	dword ptr [rsi+rax*4+3*4], ecx
  1100 000006B1 C3                  <1> 	ret
  1101                              <1> 
  1102                              <1> 	%endif
  1103                              <1> 
  1104                              <1> ;	esi -> core.REGISTER
  1105                              <1> 
  1106                              <1> _burst_write2:
  1107 000006B2 66B90600            <1> 	mov	cx, 6
  1108 000006B6 A900FFFF00          <1> 	test	eax, 00FFFF00h
  1109 000006BB 754B                <1> 	jnz	bus_write
  1110                              <1> 
  1111                              <1> 	; store to emulated registers
  1112                              <1> 
  1113 000006BD F786B0040000000080- <1> 	test	dword ptr [rsi+PSR], 0800000h	; ISR ?
  1114 000006C6 00                  <1>
  1115 000006C7 750C                <1> 	jnz	write2_registers	; there are spare registers at the end
  1116 000006C9 3D7E000000          <1> 	cmp	eax, 126		; but applications may not write
  1117 000006CE 7605                <1> 	jna	write2_registers	; any interrupt registers
  1118 000006D0 E9D40A0000          <1> 	jmp	guard_ii_authority
  1119                              <1> 
  1120                              <1> write2_registers:
  1121                              <1> ;	mov	edi, eax			; time to free eax
  1122                              <1> 
  1123                              <1> 	%if	__REGFOR
  1124                              <1> 
  1125                              <1> 	mov	rdx, qword ptr [rbp+rbx*4]
  1126                              <1> 	ror	rdx, 32
  1127                              <1> 	mov	qword ptr [rsi+REGISTER+rax*4], rdx
  1128                              <1> 	ret 
  1129                              <1> 
  1130                              <1> 	%else
  1131                              <1> 
  1132 000006D5 8B4C9D00            <1> 	mov	ecx, dword ptr [rbp+rbx*4]
  1133 000006D9 890C86              <1> 	mov	dword ptr [rsi+rax*4], ecx
  1134 000006DC 8B4C9D04            <1> 	mov	ecx, dword ptr [rbp+rbx*4+4]
  1135 000006E0 894C8604            <1> 	mov	dword ptr [rsi+rax*4++4], ecx
  1136 000006E4 C3                  <1> 	ret
  1137                              <1> 
  1138                              <1> 	%endif
  1139                              <1> 
  1140                              <1> ;	esi -> core.REGISTER
  1141                              <1> 
  1142                              <1> _operand_write:
  1143 000006E5 A900FFFF00          <1> 	test	eax, 00FFFF00h
  1144 000006EA 751C                <1> 	jnz	bus_write
  1145                              <1> 
  1146                              <1> _operand_write_register:
  1147 000006EC A980000000          <1> 	test	eax, 80h		; in the interrupt registers?
  1148 000006F1 7411                <1> 	jz	write1_register
  1149 000006F3 F786B0040000000080- <1> 	test	dword ptr [rsi+PSR], 0800000h
  1150 000006FC 00                  <1>
  1151 000006FD 7505                <1> 	jnz	write1_register
  1152 000006FF E9A50A0000          <1> 	jmp	guard_ii_authority
  1153                              <1> 
  1154                              <1> write1_register:
  1155 00000704 891C86              <1> 	mov	dword ptr [rsi+rax*4], ebx
  1156 00000707 C3                  <1> 	ret
  1157                              <1> 
  1158                              <1> bus_write:				; write any memory
  1159                              <1> 					;	eax <- EA
  1160                              <1> 					;	ebx <- data | [ ebp + ebx * 4] -> 1st data word
  1161                              <1> 					;	cl  <- encoding [ word * 1 / 2 / 4 ] / byte
  1162                              <1> 					;	esi <- core
  1163                              <1> 
  1164 00000708 E8E7040000          <1> 	call	base_write_pointer	; returns eax <- block
  1165                              <1> 					;         edi <- EA
  1166                              <1> 					;	  esi <- word offset
  1167                              <1> 
  1168 0000070D A900004000          <1> 	test	eax, 00400000h		; big block?
  1169 00000712 7423                <1> 	jz	memory_write_4k_block	; no
  1170 00000714 80F906              <1> 	cmp	cl, 6			; multiword operation?
  1171 00000717 720D                <1> 	jb	bus_write_256k_block	; no
  1172                              <1> 
  1173 00000719 81FEFCFF0300        <1> 	cmp	esi, 03FFFCh		; near the edge?
  1174 0000071F 7605                <1> 	jna	bus_write_256k_block	; no
  1175                              <1> 
  1176 00000721 E85A220000          <1> 	call	write_straddle_18b?
  1177                              <1> 
  1178                              <1> bus_write_256k_block:
  1179 00000726 25FFFF3F00          <1> 	and	eax, 003FFFFFh		; 64-bit shift to page size won't rub off 00400000 bit
  1180 0000072B A93F000000          <1> 	test	eax, 63			; a device array?
  1181 00000730 7429                <1> 	jz	memory_write_page	; no. scaling shift will scrub bit 400000
  1182 00000732 E974030000          <1> 	jmp	_device_write		; yes a device array
  1183                              <1> 
  1184                              <1> memory_write_4k_block:
  1185 00000737 F7C600F00300        <1> 	test	esi, 0003F000h		; inside a 4k page?
  1186 0000073D 740A                <1> 	jz	memory_write_thru
  1187 0000073F B90E000000          <1> 	mov	ecx, LP_ADDRESS
  1188 00000744 E9650A0000          <1> 	jmp	guard_ii_escape		; no
  1189                              <1> 
  1190                              <1> memory_write_thru:
  1191 00000749 80F906              <1> 	cmp	cl, 6			; multiword operation?
  1192 0000074C 720D                <1> 	jb	memory_write_page	; no
  1193                              <1> 
  1194 0000074E 81FEFC0F0000        <1> 	cmp	esi, 0FFCh		; near the edge?
  1195 00000754 7605                <1> 	jna	memory_write_page	; no
  1196                              <1> 
  1197 00000756 E8ED210000          <1> 	call	write_straddle_12b?
  1198                              <1> 
  1199                              <1> memory_write_page:
  1200 0000075B 488BBD60020000      <1> 	mov	rdi, qword ptr [rbp+CORE_INDEX1]
  1201 00000762 3B87D0060000        <1> 	cmp	eax, dword ptr [rdi+IO_PORT+124*4] ; edi -> core registers
  1202 00000768 0F883B0A0000        <1> 	js	near guard_ii_authority	; guard the NVRAM whether real or emulated
  1203                              <1> 
  1204 0000076E 48C1E00C            <1> 	shl	rax, 12			; multiply by page and lose bit 00400000
  1205 00000772 4801C6              <1> 	add	rsi, rax		; add offset
  1206                              <1> 
  1207                              <1> ;	mov	ch, byte ptr [edi+PSR]	; field of PSR with byte options
  1208 00000775 48BF-               <1> 	mov	rdi, _memory
  1209 00000777 [0000000000000000]  <1>
  1210                              <1> 
  1211                              <1> memory_write_on:
  1212 0000077F 488D3CB7            <1> 	lea	rdi, [rdi+rsi*4]
  1213 00000783 67488BB560020000    <1> 	mov	rsi, qword ptr [ebp+CORE_INDEX1]
  1214                              <1> 
  1215                              <1> 	%if	1
  1216 0000078B 4D21FF              <1> 	and	r15, r15		; is there any touchpoint?
  1217 0000078E 7414                <1> 	jz	memory_write_on_go
  1218 00000790 4C39FF              <1> 	cmp	rdi, r15		; value of TOUCHPOINT
  1219 00000793 780F                <1> 	js	memory_write_on_go	; below range
  1220 00000795 483B3C25[00000000]  <1> 	cmp	rdi, qword ptr [_touchpoint2]
  1221          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  1222 0000079D 7905                <1> 	jns	memory_write_on_go	; above range
  1223 0000079F E9050A0000          <1> 	jmp	guard_ii_authority
  1224                              <1> 
  1225                              <1> 	%else
  1226                              <1> 
  1227                              <1> 	test	dword ptr [_general_indication], TOUCHPOINT
  1228                              <1> 	jz	memory_write_on_go
  1229                              <1> 
  1230                              <1> 	cmp	edi, dword ptr [_touchpoint]
  1231                              <1> 	js	memory_write_on_go
  1232                              <1> 	cmp	edi, dword ptr [_touchpoint2]
  1233                              <1> 	jns	memory_write_on_go
  1234                              <1> 	jmp	guard_ii_authority
  1235                              <1> 
  1236                              <1> 	%endif
  1237                              <1> 
  1238                              <1> memory_write_on_go:
  1239 000007A4 480FB6C1            <1> 	movzx	rax, cl
  1240 000007A8 488B04C5[B2070000]  <1> 	mov	rax, qword ptr [write_action+rax*8]
  1241          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  1242 000007B0 FFE0                <1> 	jmp	rax
  1243                              <1> 
  1244                              <1> write_action:
  1245 000007B2 [F207000000000000]  <1> 	dq	memory_write
  1246 000007BA [F707000000000000]  <1> 	dq	write_t1
  1247 000007C2 [FB07000000000000]  <1> 	dq	write_t2	; or h1
  1248 000007CA [0808000000000000]  <1> 	dq	write_t3	; or h2
  1249 000007D2 [F607000000000000]  <1> 	dq	just_dont
  1250 000007DA [F607000000000000]  <1> 	dq	just_dont
  1251 000007E2 [4508000000000000]  <1> 	dq	memory_write2
  1252 000007EA [5708000000000000]  <1> 	dq	memory_write4
  1253                              <1> 
  1254                              <1> memory_write:					; store system memory 1 word
  1255                              <1> 
  1256                              <1> 	%if	__MOVBE
  1257                              <1> 
  1258                              <1> 	movbe	dword ptr [rdi], ebx
  1259                              <1> 
  1260                              <1> 	%else
  1261                              <1> 
  1262 000007F2 0FCB                <1> 	bswap	ebx
  1263 000007F4 891F                <1> 	mov	dword ptr [rdi], ebx
  1264                              <1> 
  1265                              <1> 	%endif
  1266                              <1> 
  1267                              <1> just_dont:
  1268 000007F6 C3                  <1> 	ret
  1269                              <1> 
  1270                              <1> write_t1:
  1271 000007F7 885F01              <1> 	mov	byte ptr [rdi+1], bl
  1272 000007FA C3                  <1> 	ret
  1273                              <1> 
  1274                              <1> write_t2:
  1275 000007FB F686B004000080      <1> 	test	byte ptr [rsi+PSR], HALF_W
  1276 00000802 7511                <1> 	jnz	write_h1
  1277 00000804 885F02              <1> 	mov	byte ptr [rdi+2], bl
  1278 00000807 C3                  <1> 	ret
  1279                              <1> 
  1280                              <1> write_t3:
  1281 00000808 F686B004000080      <1> 	test	byte ptr [rsi+PSR], HALF_W
  1282 0000080F 751D                <1> 	jnz	write_h2
  1283 00000811 885F03              <1> 	mov	byte ptr [rdi+3], bl
  1284 00000814 C3                  <1> 	ret
  1285                              <1> 
  1286                              <1> write_h1:
  1287                              <1> 	%if	__MOVBE
  1288                              <1> 	movbe	eax, dword ptr [rdi]
  1289                              <1> 	%else
  1290 00000815 8B07                <1> 	mov	eax, dword ptr [rdi]
  1291 00000817 0FC8                <1> 	bswap	eax
  1292                              <1> 	%endif
  1293                              <1> 
  1294 00000819 81E3FF0F0000        <1> 	and	ebx, 4095
  1295 0000081F C1E30C              <1> 	shl	ebx, 12
  1296 00000822 25FF0F0000          <1> 	and	eax, 4095
  1297 00000827 09D8                <1> 	or	eax, ebx
  1298 00000829 E912000000          <1> 	jmp	write_hw
  1299                              <1> 
  1300                              <1> write_h2:
  1301                              <1> 	%if	__MOVBE
  1302                              <1> 	movbe	eax, dword ptr [rdi]
  1303                              <1> 	%else
  1304 0000082E 8B07                <1> 	mov	eax, dword ptr [rdi]
  1305 00000830 0FC8                <1> 	bswap	eax
  1306                              <1> 	%endif
  1307                              <1> 
  1308 00000832 C1E80C              <1> 	shr	eax, 12
  1309 00000835 C1E00C              <1> 	shl	eax, 12
  1310 00000838 81E3FF0F0000        <1> 	and	ebx, 4095
  1311 0000083E 09D8                <1> 	or	eax, ebx
  1312                              <1> 
  1313                              <1> write_hw:
  1314                              <1> 	%if	__MOVBE
  1315                              <1> 	movbe	dword ptr [rdi], eax
  1316                              <1> 	ret
  1317                              <1> 
  1318                              <1> 	%else
  1319                              <1> 
  1320 00000840 0FC8                <1> 	bswap	eax
  1321 00000842 8907                <1> 	mov	dword ptr [rdi], eax
  1322 00000844 C3                  <1> 	ret
  1323                              <1> 
  1324                              <1> 	%endif
  1325                              <1> 
  1326                              <1> 	%if	__MOVBE
  1327                              <1> 
  1328                              <1> memory_write2:
  1329                              <1> 	movbe	qword ptr [edi], rax
  1330                              <1> 	ret	
  1331                              <1> 
  1332                              <1> memory_write4:
  1333                              <1> 	movbe	qword ptr [edi+2*4], rax
  1334                              <1> 	movbe	qword ptr [edi], rdx
  1335                              <1> 	ret
  1336                              <1> 
  1337                              <1> 	%else
  1338                              <1> 
  1339                              <1> 					; store system memory 2 words
  1340                              <1> memory_write2:				; eax is already free
  1341 00000845 8B449D00            <1> 	mov	eax, dword ptr [rbp+rbx*4]
  1342 00000849 0FC8                <1> 	bswap	eax
  1343 0000084B 8907                <1> 	mov	dword ptr [rdi], eax
  1344                              <1> 
  1345 0000084D 8B449D04            <1> 	mov	eax, dword ptr [rbp+rbx*4+4]
  1346 00000851 0FC8                <1> 	bswap	eax
  1347 00000853 894704              <1> 	mov	dword ptr [rdi+4], eax
  1348 00000856 C3                  <1> 	ret
  1349                              <1> 
  1350                              <1> memory_write4:					; store system memory 4 words
  1351 00000857 8B449D00            <1> 	mov	eax, dword ptr [rbp+rbx*4]	; bx is a register number and may
  1352                              <1> 						; identify extra workspace registers
  1353                              <1> 						; at register stack tail
  1354 0000085B 0FC8                <1> 	bswap	eax
  1355 0000085D 8907                <1> 	mov	dword ptr [rdi], eax
  1356 0000085F 8B449D04            <1> 	mov	eax, dword ptr [rbp+rbx*4+4]
  1357 00000863 0FC8                <1> 	bswap	eax
  1358 00000865 894704              <1> 	mov	dword ptr [rdi+4], eax
  1359 00000868 8B449D08            <1> 	mov	eax, dword ptr [rbp+rbx*4+8]
  1360 0000086C 0FC8                <1> 	bswap	eax
  1361 0000086E 894708              <1> 	mov	dword ptr [rdi+2*4], eax
  1362 00000871 8B449D0C            <1> 	mov	eax, dword ptr [rbp+rbx*4+12]
  1363 00000875 0FC8                <1> 	bswap	eax
  1364 00000877 89470C              <1> 	mov	dword ptr [rdi+3*4], eax
  1365 0000087A C3                  <1> 	ret
  1366                              <1> 
  1367                              <1> ;	modify instructions n inc dec src slc sim popA
  1368                              <1> ;	rewrite here
  1369                              <1> 
  1370                              <1> 	%endif
  1371                              <1> 
  1372                              <1> memoreg_writeback:
  1373                              <1> 	%if	1
  1374 0000087B 4821FF              <1> 	and	rdi, rdi
  1375 0000087E 7509                <1> 	jnz	memory_direct
  1376 00000880 25FFFFFF00          <1> 	and	eax, 00FFFFFFh			; unchanged esi -> core.REGISTER	
  1377 00000885 89049E              <1> 	mov	[rsi+rbx*4+REGISTER], eax	; platform endian
  1378                              <1> 						; register writeback index ebx ->
  1379 00000888 C3                  <1> 	ret
  1380                              <1> 	%else
  1381                              <1> 
  1382                              <1> 
  1383                              <1> 	test	ebx, -256			; save EA is ?
  1384                              <1> 	jnz	memory_direct			; a memory device
  1385                              <1> 	xchg	eax, ebx			; a register
  1386                              <1> 	and	ebx, 00FFFFFFh
  1387                              <1> 	jmp	_operand_write_register		; esi -> core.REGISTER
  1388                              <1> 
  1389                              <1> ;	if not a register rewrite
  1390                              <1> ;	n inc dec src slc sim popA
  1391                              <1> ;	write RTA memory at its saved platform address
  1392                              <1> 	%endif
  1393                              <1> 
  1394                              <1> memory_direct:					; esi <- memory_offset
  1395                              <1> 	%if	__MOVBE
  1396                              <1> 	movbe	dword ptr [rdi+rsi*4], eax
  1397                              <1> 	%else
  1398 00000889 0FC8                <1> 	bswap	eax				; write components edi esi kept from base_read
  1399 0000088B 30C0                <1> 	xor	al, al				
  1400 0000088D 8904B7              <1> 	mov	dword ptr [rdi+rsi*4], eax
  1401                              <1> 	%endif
  1402 00000890 C3                  <1> 	ret
  1403                              <1> 
  1404                              <1> 
  1405                              <1> ;	execute calls memory read
  1406                              <1> ;	ea < 256 is not for execute a register
  1407                              <1> ;	operand is at a readable address in system memory or array
  1408                              <1> 
  1409                              <1> memory_read:					; for execute and modify instructions:
  1410 00000891 E875000000          <1> 	call	memory_point			; read only executable space
  1411                              <1> 	%if	__MOVBE
  1412                              <1> 	movbe	eax, dword ptr [rdi+rsi*4]
  1413                              <1> 	%else
  1414 00000896 8B04B7              <1> 	mov	eax, dword ptr [rdi+rsi*4]	; and similar memory types
  1415 00000899 B000                <1> 	mov	al, 0
  1416 0000089B 0FC8                <1> 	bswap	eax
  1417                              <1> 	%endif
  1418 0000089D C3                  <1> 	ret
  1419                              <1> 
  1420                              <1> ;	modify instructions n inc dec src slc sim popA call here
  1421                              <1> ;	ea < 256 is a register
  1422                              <1> 
  1423                              <1> memoreg:					; read-modify-write registers / system memory
  1424 0000089E A900FFFFFF          <1> 	test	eax, -256			; but nothing marked as a peripheral bus
  1425 000008A3 751B                <1> 	jnz	memory_read_lock
  1426 000008A5 A880                <1> 	test	al, 128				; interrupt register?
  1427 000008A7 740E                <1> 	jz	register_read_for_write		; no, clear to update
  1428 000008A9 F686B204000080      <1> 	test	byte ptr [rsi+PSR+2], 128	; ISR ?
  1429 000008B0 7505                <1> 	jnz	register_read_for_write
  1430 000008B2 E9F2080000          <1> 	jmp	guard_ii_authority
  1431                              <1> 
  1432                              <1> register_read_for_write:			; unchanged esi -> core.REGISTER
  1433 000008B7 89C3                <1>         mov     ebx, eax                        ; copy of ea -> registers to memoreg_writeback
  1434 000008B9 4831FF              <1>         xor     rdi, rdi                        ; tell memoreg->writeback that's how it is, no device
  1435 000008BC 8B0486              <1>         mov     eax, dword ptr [rsi+REGISTER+rax*4]
  1436 000008BF C3                  <1>         ret					; register writeback index ebx ->
  1437                              <1> 
  1438                              <1> 
  1439                              <1> ;	RAM boundary in port 124 defines the upper page limit
  1440                              <1> ;	of a real or emulated NVRAM containing the fixed system image
  1441                              <1> 
  1442                              <1> ;	fixed system image may be kernel + loader in a dozen pages
  1443                              <1> ;	or it may be the entire application
  1444                              <1> 
  1445                              <1> ;	emulated machine applies the update limit
  1446                              <1> ;	whether NVRAM is emulated or real
  1447                              <1> 
  1448                              <1> ;	if not a register
  1449                              <1> ;	n inc dec src slc sim popA read a memory word which is legal to write
  1450                              <1> ;	and keep the platform address to write the modified value
  1451                              <1> ;	modify instructions do not lock memory between read and rewrite
  1452                              <1> 
  1453                              <1> memory_read_lock:
  1454 000008C0 E808000000          <1> 	call	memory_lock
  1455                              <1> 	%if	__MOVBE
  1456                              <1> 	movbe	eax, dword ptr [rdi+rsi*4]
  1457                              <1> 	%else
  1458 000008C5 8B04B7              <1> 	mov	eax, dword ptr [rdi+rsi*4]
  1459 000008C8 B000                <1> 	mov	al, 0
  1460 000008CA 0FC8                <1> 	bswap	eax
  1461                              <1> 	%endif
  1462 000008CC C3                  <1> 	ret
  1463                              <1> 
  1464                              <1> ;	memory_read_lock calls here for modify instructions if ea > registers
  1465                              <1> ;	ts calls here with ea whatever range always -> memory
  1466                              <1> 
  1467                              <1> ;	ea must be a legally writable memory word
  1468                              <1> ;	memory_lock does not lock but identifies a platform write address  
  1469                              <1> ;	ts reads / unconditionally replaces word.t1
  1470                              <1> ;	under platform locking protocol, xchg platform instruction
  1471                              <1> 
  1472                              <1> memory_lock:					; point for update
  1473                              <1> 						; barred below RAM boundary as write is
  1474 000008CD E822030000          <1> 	call	base_write_pointer		; resolve device:block:offset from EA
  1475                              <1> 						; edi <- core.REGISTERS <- esi
  1476                              <1> 						; eax <- memory block index
  1477                              <1> 						; esi <- memory word offset
  1478                              <1> 
  1479 000008D2 488BBD60020000      <1> 	mov	rdi, qword ptr [rbp+CORE_INDEX1]
  1480 000008D9 A900004000          <1> 	test	eax, 00400000h			; update block name is a big bank ?
  1481 000008DE 741E                <1> 	jz	memory_lock_page		; no
  1482                              <1> 
  1483 000008E0 25FFFF3F00          <1> 	and	eax, 003FFFFFh			; 64-bit shift won't rub off 00400000 bit
  1484                              <1> 						; on shift to page size
  1485                              <1> 
  1486 000008E5 A93F000000          <1> 	test	eax, 63				; a device outside executable space ?
  1487 000008EA 755D                <1> 	jnz	_yspace_read			; yes
  1488 000008EC 25FFFF3F00          <1> 	and	eax, 003FFFFFh			; bit 0400000 is gets stripped later anyway
  1489 000008F1 3B87D0060000        <1> 	cmp	eax, dword ptr [rdi+IO_PORT+124*4]	; below RAM boundary?
  1490 000008F7 7341                <1> 	jnb	_xspace_read			; no, go ahead
  1491 000008F9 E9AB080000          <1> 	jmp	guard_ii_authority
  1492                              <1> 
  1493                              <1> memory_lock_page:
  1494 000008FE 3B87D0060000        <1> 	cmp	eax, dword ptr [rdi+IO_PORT+124*4]	; below RAM boundary?
  1495 00000904 7322                <1> 	jnb	_xspace_read4K			; no, go head if offset < 1000 hex
  1496 00000906 E99E080000          <1> 	jmp	guard_ii_authority
  1497                              <1> 
  1498                              <1> 
  1499                              <1> ;	memory_read calls here for execute
  1500                              <1> ;	identify a platform read address of an RTA memory word
  1501                              <1> 
  1502                              <1> memory_point:
  1503 0000090B E88F020000          <1> 	call	base_read_pointer		; edi <- core.REGISTERS <- esi
  1504                              <1> 						; esi <- word offset in memory block
  1505 00000910 A900004000          <1> 	test	eax, 00400000h			; eax <- page index
  1506 00000915 7411                <1> 	jz	_xspace_read4K
  1507                              <1> 
  1508 00000917 25FFFF3F00          <1> 	and	eax, 003FFFFFh			; 64-bit shift won't rub off 00400000 bit
  1509                              <1> 						; on shift to page size
  1510 0000091C A93F000000          <1> 	test	eax, 63
  1511 00000921 7417                <1> 	jz	_xspace_read
  1512 00000923 E921000000          <1> 	jmp	_yspace_read			; ie a device either appropriate or not
  1513                              <1> 
  1514                              <1> _xspace_read4K:
  1515 00000928 F7C600F00300        <1> 	test	esi, 003F000h
  1516 0000092E 740A                <1> 	jz	_xspace_read
  1517 00000930 B90E000000          <1> 	mov	ecx, LP_ADDRESS
  1518 00000935 E974080000          <1> 	jmp	guard_ii_escape
  1519                              <1> 
  1520                              <1> _xspace_read:
  1521 0000093A 48BF-               <1> 	mov	rdi, _memory
  1522 0000093C [0000000000000000]  <1>
  1523 00000944 E93E000000          <1> 	jmp	_memory_deliver			; device array zero
  1524                              <1> 
  1525                              <1> _yspace_read:
  1526 00000949 A900008000          <1> 	test	eax, 00800000h			; a tripsy non-space?
  1527 0000094E 753E                <1> 	jnz	_zspace_read			; not allowed
  1528                              <1> 
  1529 00000950 4889C7              <1> 	mov	rdi, rax
  1530 00000953 4881E73F000000      <1> 	and	rdi, 63
  1531 0000095A 488BBCBEE0060000    <1> 	mov	rdi, qword ptr [rsi+IO_PORT+128*4+rdi*4]
  1532 00000962 48F7C700008000      <1> 	test	rdi, SYSMEM_FLAG
  1533 00000969 7423                <1> 	jz	_zspace_read
  1534 0000096B 48F7C700004000      <1> 	test	rdi, DATA16_FLAG
  1535 00000972 751A                <1> 	jnz	_zspace_read
  1536                              <1> 
  1537 00000974 C1E002              <1> 	shl	eax, 2				; al = 4 * device index
  1538 00000977 480FB6F8            <1> 	movzx	rdi, al
  1539                              <1> 
  1540 0000097B 488BBF[00000000]    <1> 	mov	rdi, qword ptr [_devices+rdi]
  1541          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  1542 00000982 30C0                <1> 	xor	al, al				; necessary to lose the device bits now
  1543 00000984 C1E802              <1> 	shr	eax, 2
  1544                              <1> 
  1545                              <1> _memory_deliver:
  1546 00000987 C1E00C              <1> 	shl	eax, 12		; multiply by page and lose bit 00400000
  1547 0000098A 4801C6              <1> 	add	rsi, rax
  1548                              <1> 
  1549                              <1> 	%if	__SMP
  1550                              <1> 	%else
  1551                              <1> 	mov	eax, dword ptr [edi+esi*4]
  1552                              <1> 	bswap	eax
  1553                              <1> 	%endif
  1554 0000098D C3                  <1> 	ret
  1555                              <1> 
  1556                              <1> _zspace_read:
  1557 0000098E E916080000          <1> 	jmp	guard_ii_authority
  1558                              <1> 
  1559                              <1> 
  1560                              <1> ;	sub-architectural measure on sabr and reload instructions
  1561                              <1> 
  1562                              <1> ;	check the target memory block is in range and the bus characteristic
  1563                              <1> ;	of the memory device when selecting blocks of memory, not when
  1564                              <1> ;	accessing them. Use 8 spare bits in the word containing _base[]
  1565                              <1> ;	for a quick recall of the emulated bus attribute on reference
  1566                              <1> 
  1567                              <1> ;	because this software emulation needs to act differently for
  1568                              <1> 
  1569                              <1> ;		executable space	rta1 24-bit words canonical memory
  1570                              <1> ;					modeled in platform 32-bit words
  1571                              <1> 
  1572                              <1> ;		shared network buffers	16-bit words canonical in memory
  1573                              <1> ;					and zero extend on readout to RTA1
  1574                              <1> 
  1575                              <1> ;		24-bit filestore array	3-octet words stored big-endian
  1576                              <1> ;					in packed array
  1577                              <1> 
  1578                              <1> ;	concept RTA1 device arrays with bus behaviour differences are completely
  1579                              <1> ;	emulated on PC emulations because device arrays are modeled in PC RAM.
  1580                              <1> 
  1581                              <1> ;	Various bus behaviours are emulated transparently to RTA1 target software
  1582                              <1> ;	in anticipation	that different memories for different uses may be attached
  1583                              <1> ;	on product boards, making core-emulated RTA1s much more efficient for not
  1584                              <1> ;	needing this part of emulation
  1585                              <1> 
  1586                              <1> ;	devices
  1587                              <1> 
  1588                              <1> ;	device 0 is always executable space, but there may be more devices
  1589                              <1> ;	with bus characteristics like device 0. The device descriptors are
  1590                              <1> 
  1591                              <1> ;		_________________________________________________________________
  1592                              <1> ;		| 16 bits flags	| 16 bits banks	|       32 bits pointer		|
  1593                              <1> ;		|_______________|____high index_|_______________________________|
  1594                              <1> 
  1595                              <1> 
  1596                              <1> ;	[out]	sabr	[go]	[call]	reload instructions call here
  1597                              <1> ;	go and call can probably check quicker themself
  1598                              <1> ;	out can be trusted because applications don't out memory _base[] ports
  1599                              <1> 
  1600                              <1> ;	a big block in an RTA1 address window is 262144 words.
  1601                              <1> ;	this checking concerns address windows tagged 2..63
  1602                              <1> ;	a device is an array up to 65536 big blocks or banks
  1603                              <1> 
  1604                              <1> ;	you get here with the relocation handle in ebx
  1605                              <1> ;	and the target window tag in eax, because that is the EA of a sabr instruction
  1606                              <1> 
  1607                              <1> device_read:				; readout device arrays
  1608 00000993 A900008000          <1>         test    eax, 0800000h           ; the vilainous bank index?
  1609 00000998 7542                <1>         jnz     device_read_escape
  1610                              <1> 
  1611                              <1> 	%if	1
  1612                              <1> 					; edi -> core.REGISTER
  1613 0000099A 48C1E002            <1> 	shl	rax, 2			; al is device index * 4
  1614 0000099E 50                  <1> 	push	rax			; rest of eax is block index * 4
  1615 0000099F 480FB6C0            <1> 	movzx	rax, al			; extend device number
  1616                              <1> 					; sense device descriptor
  1617                              <1> 
  1618 000009A3 488BBD60020000      <1> 	mov	rdi, qword ptr [rbp+CORE_INDEX1]
  1619 000009AA F68407E2060000C0    <1> 	test	byte ptr [rdi+rax+IO_PORT+128*4+2], 192
  1620                              <1> 
  1621 000009B2 58                  <1> 	pop	rax			; recover storage block index
  1622                              <1> 
  1623 000009B3 7427                <1> 	jz	device_read_escape	; neither type flag set
  1624                              <1> 
  1625 000009B5 9C                  <1> 	pushfq				; sign is set for descriptor bit 23	
  1626                              <1> 					; parity is set if both bits are
  1627                              <1> 
  1628                              <1> ;	mov	ch, byte ptr [rdi+PSR]	; flag field with byte options for memory read
  1629 000009B6 480FB6F8            <1> 	movzx	rdi, al			; device select
  1630                              <1> 
  1631 000009BA 30C0                <1> 	xor	al, al			; add storage block to offset
  1632 000009BC C1E008              <1> 	shl	eax, 8			; brush of bit 00400000 (now bit 01000000)
  1633 000009BF 48C1E002            <1> 	shl	rax, 10-8		; block index * 64 * 4 now times 262144
  1634 000009C3 4801C6              <1> 	add	rsi, rax		; offset += <-
  1635                              <1> 
  1636                              <1> 
  1637 000009C6 488BBC3F[00000000]  <1> 	mov	rdi,  qword ptr [_devices+rdi*2]	; rdi = device id * 4
  1638          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  1639                              <1> 							; pointers in array are * 8 bytes
  1640                              <1> 
  1641                              <1> 					; known that one or two bits is set
  1642 000009CE 58                  <1> 	pop	rax			; flags from test of device	
  1643                              <1> 
  1644 000009CF A804                <1> 	test	al, 4			; parity flag?
  1645 000009D1 7563                <1> 	jnz	device_read_array24	; parity -> 2 bits set -> FSYS24 bus
  1646                              <1> 
  1647 000009D3 A880                <1> 	test	al, 128			; sign -> descriptor bit 23 -> SYSMEM
  1648 000009D5 7414                <1> 	jz	device_read_data16	; otherwise NET16 trunk
  1649 000009D7 E90A000000          <1> 	jmp	device_read_sysmem	; system memory type if yes				
  1650                              <1> 
  1651                              <1> 	%else
  1652                              <1> 
  1653                              <1> 	shl	eax, 2			;  al = device pointer * 4
  1654                              <1> 	movzx	edi, al			; edi = device pointer * 4
  1655                              <1> 	xor	al, al			; eax = memory block * 256
  1656                              <1> 	shl	eax, 10			; eax = memory block * 262144
  1657                              <1> 	add	esi, eax		; offset += base
  1658                              <1> 	mov	eax, edi
  1659                              <1> 	mov	edi, dword ptr [_devices+eax] ; physical array storage
  1660                              <1> 
  1661                              <1> 
  1662                              <1> _device_read_xpanded:
  1663                              <1> 	mov	eax, dword ptr [esi+IO_PORT+128*4]	; ????? eax
  1664                              <1> 
  1665                              <1> 	shr	eax, 22			; following conditions use parity
  1666                              <1> 					; parity only generated from LS octet
  1667                              <1> 					; how dumb can you get?
  1668                              <1> 
  1669                              <1> 	and	al, 3			; what sort of device array?
  1670                              <1> 
  1671                              <1> 	jz	device_read_escape	; that's double-checked option 00
  1672                              <1> 	jpe	device_read_array24	; and option 11 shorten
  1673                              <1> 	test	al, SYSMEM_FLAG>>22
  1674                              <1> 	jz	device_read_data16	; and option 01
  1675                              <1> 	jmp	device_read_sysmem	; and option 10
  1676                              <1> 	%endif
  1677                              <1> 	
  1678                              <1> device_read_escape:
  1679 000009DC B90E000000          <1> 	mov	ecx, LP_ADDRESS
  1680 000009E1 E9C8070000          <1> 	jmp	guard_ii_escape
  1681                              <1> 
  1682                              <1> 
  1683                              <1> device_read_sysmem:			; readout system memory array
  1684 000009E6 E9A1FBFFFF          <1> 	jmp	memory_read_on		; allow all variations partial word / multiword
  1685                              <1> 
  1686                              <1> device_read_data16:			; readout 16-bit array
  1687                              <1> 
  1688 000009EB 80F907              <1> 	cmp	cl, 7
  1689 000009EE 7419                <1> 	jz	device_read_data16_4
  1690 000009F0 80F906              <1> 	cmp	cl, 6
  1691 000009F3 7407                <1> 	jz	device_read_data16_2
  1692                              <1> ;	jmp	device_read_data16_1
  1693                              <1> 
  1694                              <1> device_read_data16_1:			; readout 1 word of 16-bit array
  1695 000009F5 0FB70477            <1> 	movzx	eax, word ptr [rdi+rsi*2]
  1696 000009F9 86E0                <1> 	xchg	ah, al
  1697 000009FB C3                  <1> 	ret
  1698                              <1> 
  1699                              <1> device_read_data16_2:			; readout 2 words of 16-bit array
  1700 000009FC 8B0477              <1> 	mov	eax, dword ptr [rdi+rsi*2]	; 4.3.2.1
  1701 000009FF 0FC8                <1> 	bswap	eax				; 1.2.3.4
  1702 00000A01 480FB7D8            <1> 	movzx	rbx, ax				; 0.0.3.4
  1703 00000A05 C1E810              <1> 	shr	eax, 16				; 0.0.1.2
  1704 00000A08 C3                  <1> 	ret
  1705                              <1> 
  1706                              <1> device_read_data16_4:			; readout 4 words of 16-bit array
  1707 00000A09 488B0477            <1> 	mov	rax, qword ptr [rdi+rsi*2]
  1708 00000A0D 480FC8              <1> 	bswap	rax				; 1.2.3.4
  1709 00000A10 0FB7C8              <1> 	movzx	ecx, ax
  1710 00000A13 894C9D0C            <1> 	mov	dword ptr [rbp+rbx*4+12], ecx
  1711 00000A17 48C1E810            <1> 	shr	rax, 16
  1712 00000A1B 0FB7C8              <1> 	movzx	ecx, ax
  1713 00000A1E 894C9D08            <1> 	mov	dword ptr [rbp+rbx*4+8], ecx
  1714 00000A22 48C1E810            <1> 	shr	rax, 16
  1715 00000A26 0FB7C8              <1> 	movzx	ecx, ax
  1716 00000A29 48C1E810            <1> 	shr	rax, 16
  1717 00000A2D 894C9D04            <1> 	mov	dword ptr [rbp+rbx*4+4], ecx
  1718 00000A31 89449D00            <1> 	mov	dword ptr [rbp+rbx*4], eax
  1719 00000A35 C3                  <1> 	ret
  1720                              <1> 
  1721                              <1> device_read_array24:			; readout from packed 24-bit array
  1722 00000A36 E85A010000          <1> 	call	device_array24_setpointer
  1723                              <1> 
  1724 00000A3B 80F907              <1> 	cmp	cl, 7
  1725 00000A3E 7446                <1> 	jz	device_read_array24_4
  1726 00000A40 80F906              <1> 	cmp	cl, 6
  1727 00000A43 7436                <1> 	jz	device_read_array24_2
  1728                              <1> ;	jmp	device_read_array24_1
  1729                              <1> 
  1730                              <1> device_read_array24_1:			; readout a word of packed 24-bit array
  1731 00000A45 660FB60437          <1> 	movzx	ax, byte ptr [rdi+rsi]
  1732 00000A4A C1E008              <1> 	shl	eax, 8
  1733 00000A4D 8A443701            <1> 	mov	al, byte ptr [rdi+rsi+1]
  1734 00000A51 C1E008              <1> 	shl	eax, 8
  1735 00000A54 8A443702            <1> 	mov	al, byte ptr [rdi+rsi+2]
  1736 00000A58 4881C603000000      <1> 	add	rsi, 3
  1737 00000A5F C3                  <1> 	ret
  1738                              <1> 
  1739                              <1> device_read_array24_1R:
  1740 00000A60 660FB61C37          <1> 	movzx	bx, byte ptr [rdi+rsi]
  1741 00000A65 C1E308              <1> 	shl	ebx, 8
  1742 00000A68 8A5C3701            <1> 	mov	bl, byte ptr [rdi+rsi+1]
  1743 00000A6C C1E308              <1> 	shl	ebx, 8
  1744 00000A6F 8A5C3702            <1> 	mov	bl, byte ptr [rdi+rsi+2]
  1745 00000A73 4881C603000000      <1> 	add	rsi, 3
  1746 00000A7A C3                  <1> 	ret
  1747                              <1> 
  1748                              <1> device_read_array24_2:			; readout 2 words of packed 24-bit array
  1749 00000A7B E8C5FFFFFF          <1> 	call	device_read_array24_1
  1750 00000A80 E8DBFFFFFF          <1> 	call	device_read_array24_1R
  1751 00000A85 C3                  <1> 	ret
  1752                              <1> 
  1753                              <1> device_read_array24_4:			; readout 4 words of packed 24-bit array
  1754 00000A86 E8BAFFFFFF          <1> 	call	device_read_array24_1
  1755 00000A8B 89449D00            <1> 	mov	dword ptr [rbp+rbx*4], eax
  1756 00000A8F E8B1FFFFFF          <1> 	call	device_read_array24_1
  1757 00000A94 89449D04            <1> 	mov	dword ptr [rbp+rbx*4+4], eax
  1758 00000A98 E8A8FFFFFF          <1> 	call	device_read_array24_1
  1759 00000A9D 89449D08            <1> 	mov	dword ptr [rbp+rbx*4+8], eax
  1760 00000AA1 E89FFFFFFF          <1> 	call	device_read_array24_1
  1761 00000AA6 89449D0C            <1> 	mov	dword ptr [rbp+rbx*4+12], eax
  1762 00000AAA C3                  <1> 	ret
  1763                              <1> 
  1764                              <1> _device_write:				; store device arrays
  1765 00000AAB A900008000          <1> 	test	eax, 0800000h		; the vilainous bank index?
  1766 00000AB0 7548                <1> 	jnz	device_write_escape
  1767                              <1> 
  1768                              <1> 	%if	1
  1769                              <1>                                         ; edi -> core.REGISTER
  1770 00000AB2 48C1E002            <1>         shl     rax, 2                  ; al is device index * 4
  1771 00000AB6 50                  <1>         push    rax                     ; rest of eax is block index * 4
  1772 00000AB7 480FB6C0            <1>         movzx   rax, al                 ; extend device number
  1773                              <1>                                         ; sense device descriptor
  1774                              <1> 
  1775 00000ABB 488BBD60020000      <1> 	mov	rdi, qword ptr [rbp+CORE_INDEX1]
  1776 00000AC2 F68407E2060000C0    <1>         test    byte ptr [rdi+rax+IO_PORT+128*4+2], 192
  1777                              <1> 
  1778 00000ACA 58                  <1>         pop     rax                     ; recover storage block index
  1779                              <1> 
  1780 00000ACB 742D                <1>         jz      device_write_escape      ; neither type flag set
  1781                              <1> 
  1782 00000ACD 9C                  <1>         pushfq                          ; sign is set for descriptor bit 23     
  1783                              <1>                                         ; parity is set if both bits are
  1784                              <1> 
  1785 00000ACE 8AAFB0040000        <1>         mov     ch, byte ptr [rdi+PSR]  ; flag field with byte options for memory read
  1786 00000AD4 480FB6F8            <1>         movzx   rdi, al                 ; device select
  1787                              <1> 
  1788 00000AD8 30C0                <1>         xor     al, al                  ; add storage block to offset
  1789 00000ADA C1E008              <1> 	shl	eax, 8			; brush off bit 00400000 (now bit 01000000)
  1790 00000ADD 48C1E002            <1>         shl     rax, 10-8		; block index * 64 * 4 now times 262144
  1791 00000AE1 4801C6              <1>         add     rsi, rax                ; offset += <-
  1792                              <1> 
  1793 00000AE4 488BBC3F[00000000]  <1>         mov     rdi,  qword ptr [_devices+rdi*2]	; rdi = device id * 4
  1794          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  1795                              <1> 							; pointers in array are * 8 octets
  1796                              <1> 
  1797                              <1>                                         ; known that one or two bits is set
  1798 00000AEC 58                  <1>         pop     rax                     ; flags from test of device     
  1799                              <1> 
  1800 00000AED A804                <1>         test    al, 4                   ; parity?
  1801 00000AEF 754F                <1>         jnz     device_write_array24    ; parity -> 2 bits set -> FSYS24 bus
  1802 00000AF1 A880                <1>         test    al, 128                 ; sign -> descriptor bit 23 -> SYSMEM
  1803 00000AF3 7414                <1>         jz      device_write_data16     ; otherwise NET16 trunk
  1804 00000AF5 E90A000000          <1>         jmp     device_write_sysmem     ; system memory type if yes                     
  1805                              <1> 
  1806                              <1> 	%else
  1807                              <1> 
  1808                              <1> 	shl	eax, 2			;  al = device ID * 4
  1809                              <1> 	movzx	rdi, al			; edi = device ID * 4
  1810                              <1> 	xor	al, al			; eax = 256 * block pointer
  1811                              <1> 	shl	eax, 10			; block pointer *= 262144
  1812                              <1> 	add	esi, eax
  1813                              <1> 	mov	eax, edi
  1814                              <1> 	mov	edi, dword ptr [eax+_devices]	; physical buffer device array
  1815                              <1> 	mov	eax, dword ptr [esi+IO_PORT+128*4] ; descriptor port of device
  1816                              <1> 
  1817                              <1> 	shr	eax, 22			; following conditions use parity
  1818                              <1> 					; which is only generated from LS octet
  1819                              <1> 
  1820                              <1> 	and	al, 3			; isolate the device type
  1821                              <1> 	jz	device_write_escape
  1822                              <1> 	jpe	device_write_array24
  1823                              <1> 	test	al, SYSMEM_FLAG>>22
  1824                              <1> 	jz	device_write_data16
  1825                              <1> 	jmp	device_write_sysmem
  1826                              <1> 
  1827                              <1> 	%endif
  1828                              <1> 
  1829                              <1> device_write_escape:
  1830 00000AFA B90E000000          <1> 	mov	ecx, LP_ADDRESS
  1831 00000AFF E9AA060000          <1> 	jmp	guard_ii_escape
  1832                              <1> 
  1833                              <1> 
  1834                              <1> device_write_sysmem:
  1835 00000B04 E976FCFFFF          <1> 	jmp	memory_write_on		; allow all variations partial word / multiword
  1836                              <1> 
  1837                              <1> 
  1838                              <1> device_write_data16:
  1839                              <1> 
  1840 00000B09 80F907              <1> 	cmp	cl, 7
  1841 00000B0C 740C                <1> 	jz	device_write_data16_4
  1842 00000B0E 80F906              <1> 	cmp	cl, 6
  1843 00000B11 741A                <1> 	jz	device_write_data16_2
  1844                              <1> ;	jmp	device_write_data16_1
  1845                              <1> 
  1846                              <1> 	%if	__MOVBE
  1847                              <1> 
  1848                              <1> 	movbe	word ptr [rdi+rsi*2], bx
  1849                              <1> 	ret
  1850                              <1> 
  1851                              <1> device_write_data16_2:
  1852                              <1> 	mov	ax, word ptr [rbp+rbx*4]
  1853                              <1> 	shl	eax, 16
  1854                              <1> 	mov	ax, word ptr [rbp+rbx*4+4]
  1855                              <1> 	movbe	dword ptr [rdi+rsi*2], ax
  1856                              <1> 	
  1857                              <1> 	ret
  1858                              <1> 
  1859                              <1> device_write_data16_4:
  1860                              <1> 	mov	ax, word ptr [rbp+rbx*4]
  1861                              <1> 	shl	rax, 16
  1862                              <1> 	mov	ax, word ptr [rbp+rbx*4+4]
  1863                              <1> 	shl	rax, 16
  1864                              <1> 	mov	ax, word ptr [rbp+rbx*4+4*2]
  1865                              <1> 	shl	rax, 16
  1866                              <1> 	mov	ax, word ptr [rbp+rbx*4+4*3]
  1867                              <1> 	movbe	qword ptr [rdi+rsi*2], rax
  1868                              <1> 	ret
  1869                              <1> 
  1870                              <1> 	%else
  1871                              <1> 
  1872                              <1> device_write_data16_1:			; store 16-bit array
  1873 00000B13 86FB                <1> 	xchg	bh, bl
  1874 00000B15 66891C77            <1> 	mov	word ptr [rdi+rsi*2], bx
  1875 00000B19 C3                  <1> 	ret
  1876                              <1> 
  1877                              <1> 
  1878                              <1> device_write_data16_4:			; store 4 words in 16-bit array
  1879                              <1> 					; low-order half is swapped on bus read
  1880                              <1> 					; and canonical in eax
  1881 00000B1A 668B449D08          <1> 	mov	ax, word ptr [rbp+rbx*4+8]	; get low-order half 3rd register
  1882 00000B1F C1E010              <1> 	shl	eax, 16				; 5.6.0.0
  1883 00000B22 668B449D0C          <1> 	mov	ax, word ptr [rbp+rbx*4+12]	; 5.6.7.8
  1884 00000B27 0FC8                <1> 	bswap	eax				; it's correct so swap for bus write
  1885 00000B29 89447704            <1> 	mov	dword ptr [rdi+rsi*2+4], eax
  1886                              <1> 
  1887                              <1> 
  1888                              <1> device_write_data16_2:			; store 2 words in 16-bit array
  1889                              <1> 					; registers are modeled in storage
  1890                              <1> 					; so each bus read corrects an octet pair
  1891                              <1> 
  1892 00000B2D 668B449D00          <1> 	mov	ax, word ptr [rbp+rbx*4]	; get low-order half 1st register
  1893 00000B32 C1E010              <1> 	shl	eax, 16				; 1.2.0.0
  1894 00000B35 668B449D04          <1> 	mov	ax, word ptr [rbp+rbx*4+4]	; 1.2.3.4
  1895 00000B3A 0FC8                <1> 	bswap	eax				; it's correct, so swap for bus write
  1896 00000B3C 890477              <1> 	mov	dword ptr [rdi+rsi*2], eax
  1897 00000B3F C3                  <1> 	ret
  1898                              <1> 
  1899                              <1> 	%endif
  1900                              <1> 
  1901                              <1> device_write_array24:			; store 24-bit packed array
  1902 00000B40 E850000000          <1> 	call	device_array24_setpointer
  1903                              <1> 
  1904 00000B45 80F907              <1> 	cmp	cl, 7
  1905 00000B48 743A                <1> 	jz	device_write_array24_4
  1906 00000B4A 80F906              <1> 	cmp	cl, 6
  1907 00000B4D 7422                <1> 	jz	device_write_array24_2
  1908 00000B4F E900000000          <1> 	jmp	device_write_array24_1
  1909                              <1> 
  1910                              <1> device_write_array24_1:			; store 1 word in packed 24-bit array
  1911 00000B54 89D8                <1> 	mov	eax, ebx
  1912                              <1> device_write_array24_x:
  1913 00000B56 C1C010              <1> 	rol	eax, 16
  1914 00000B59 880437              <1> 	mov	byte ptr [rdi+rsi], al
  1915 00000B5C C1C008              <1> 	rol	eax, 8
  1916 00000B5F 88443701            <1> 	mov	byte ptr [rdi+rsi+1], al
  1917 00000B63 C1C008              <1> 	rol	eax, 8
  1918 00000B66 88443702            <1> 	mov	byte ptr [rdi+rsi+2], al
  1919 00000B6A 81C603000000        <1> 	add	esi, 3
  1920 00000B70 C3                  <1> 	ret
  1921                              <1> 
  1922                              <1> device_write_array24_2:			; store 2 words in packed 24-bit array
  1923 00000B71 8B449D00            <1> 	mov	eax, [rbp+rbx*4]
  1924 00000B75 E8DCFFFFFF          <1> 	call	device_write_array24_x
  1925 00000B7A 8B449D04            <1> 	mov	eax, [rbp+rbx*4+4]
  1926 00000B7E E8D3FFFFFF          <1> 	call	device_write_array24_x
  1927                              <1> ;	add	ebx, 2
  1928 00000B83 C3                  <1> 	ret
  1929                              <1> 
  1930                              <1> device_write_array24_4:			; store 4 words in packed 24-bit array
  1931 00000B84 E8E8FFFFFF          <1> 	call	device_write_array24_2
  1932 00000B89 81C302000000        <1> 	add	ebx, 2
  1933 00000B8F E8DDFFFFFF          <1> 	call	device_write_array24_2
  1934 00000B94 C3                  <1> 	ret
  1935                              <1> 
  1936                              <1> device_array24_setpointer:
  1937 00000B95 4889F0              <1> 	mov	rax, rsi			; think of a number
  1938 00000B98 48D1E0              <1> 	shl	rax, 1				; double it
  1939 00000B9B 4801C6              <1> 	add	rsi, rax			; add it to the number you first thought of...
  1940 00000B9E C3                  <1> 	ret
  1941                              <1> 
  1942                                  	%include	"base_map.msm"
  1943                              <1> 
  1944                              <1> base_read_pointer:
  1945 00000B9F 4889C7              <1> 	mov	rdi, rax		; keep EA for +words reads
  1946                              <1> 					; straddling storage blocks
  1947 00000BA2 C1C910              <1> 	ror	ecx, 16			; conserve designator / word counts
  1948                              <1> 
  1949 00000BA5 C1C812              <1> 	ror	eax, 18
  1950 00000BA8 A83F                <1> 	test	al, 63
  1951 00000BAA 750F                <1> 	jnz	read_address18
  1952 00000BAC C1C006              <1> 	rol	eax, 6
  1953 00000BAF 660FB6C8            <1> 	movzx	cx, al
  1954 00000BB3 C1E814              <1> 	shr	eax, 32-12
  1955                              <1> 					; advise caller address 6.12
  1956 00000BB6 E907000000          <1> 	jmp	resolve_read_tag	; this path is  most storage reads
  1957                              <1> 	
  1958                              <1> read_address18:
  1959 00000BBB 660FB6C8            <1> 	movzx	cx, al
  1960 00000BBF C1E80E              <1> 	shr	eax, 32-18
  1961                              <1> 
  1962                              <1> resolve_read_tag:
  1963                              <1> 
  1964 00000BC2 80E13F              <1> 	and	cl, 63
  1965 00000BC5 7418                <1> 	jz	read_window_free	; everyone may read B0
  1966 00000BC7 F6C138              <1> 	test	cl, 56
  1967 00000BCA 7513                <1> 	jnz	read_window_free
  1968 00000BCC 80F10F              <1> 	xor	cl, 8+7			; [ 1 2 3 4 5 6 7 ] -> 8 + [ 6 5 4 3 2 1 0]
  1969 00000BCF 660FA38EB0040000    <1> 	bt	word ptr [rsi+PSR], cx	; in memory bytes ffff f00c 0xxx xxxx
  1970 00000BD7 7303                <1> 	jnc	read_application_window	; x86 bus read -> 0xxx xxxx ffff f00c
  1971 00000BD9 80C940              <1> 	or	cl, 64
  1972                              <1> 
  1973                              <1> read_application_window:
  1974 00000BDC 80F10F              <1> 	xor	cl, 8+7			; [ 1 2 3 4 5 6 7 ] <- 8 + [ 6 5 4 3 2 1 0]
  1975                              <1> 
  1976                              <1> read_window_free:
  1977 00000BDF 4889C2              <1> 	mov	rdx,rax
  1978 00000BE2 480FB6C1            <1> 	movzx	rax, cl
  1979 00000BE6 8B8486E0040000      <1> 	mov	eax, dword ptr [rsi+rax*4+IO_PORT]
  1980 00000BED 4889D6              <1> 	mov	rsi, rdx
  1981                              <1> 
  1982 00000BF0 C1C910              <1> 	ror	ecx, 16
  1983 00000BF3 C3                  <1> 	ret
  1984                              <1> 
  1985                              <1> base_write_pointer:
  1986                              <1> 
  1987 00000BF4 4889C7              <1> 	mov	rdi, rax		; keep EA for +words writes
  1988 00000BF7 C1C910              <1> 	ror	ecx, 16			; straddling storage blocks
  1989                              <1> 					; protect designators in ecx
  1990 00000BFA C1C812              <1> 	ror	eax, 18			
  1991                              <1> 
  1992 00000BFD A83F                <1> 	test	al, 63
  1993 00000BFF 750F                <1> 	jnz	write_address18
  1994 00000C01 C1C006              <1> 	rol	eax, 6
  1995 00000C04 660FB6C8            <1> 	movzx	cx, al
  1996 00000C08 C1E814              <1> 	shr	eax, 32-12
  1997 00000C0B E907000000          <1> 	jmp	resolve_write_tag	; this path is
  1998                              <1> 					; most storge writes
  1999                              <1> write_address18:
  2000 00000C10 660FB6C8            <1> 	movzx	cx, al
  2001 00000C14 C1E80E              <1> 	shr	eax, 32-18
  2002                              <1> 	
  2003                              <1> resolve_write_tag:
  2004                              <1> 
  2005 00000C17 80E13F              <1> 	and	cl, 63
  2006 00000C1A 0F8489050000        <1> 	jz	near guard_ii_authority	; no-one may write B0
  2007 00000C20 F6C138              <1> 	test	cl, 56
  2008 00000C23 7538                <1> 	jnz	write_window_free
  2009 00000C25 80F10F              <1> 	xor	cl, 8+7			; [ 1 2 3 4 5 6 7 ] -> 8 + [ 6 5 4 3 2 1 0]
  2010 00000C28 660FA38EB0040000    <1> 	bt	word ptr [rsi+PSR], cx		; in memory bytes ffff f00c 0xxx xxxx
  2011 00000C30 7313                <1> 	jnc	write_application_window	; x86 bus read -> 0xxx xxxx ffff f00c
  2012 00000C32 F786B0040000000080- <1> 	test	dword ptr [rsi+PSR], 00800000h 
  2013 00000C3B 00                  <1>
  2014 00000C3C 0F8467050000        <1> 	jz	near guard_ii_authority
  2015 00000C42 80C940              <1> 	or	cl, 64
  2016                              <1> 
  2017                              <1> write_application_window:
  2018 00000C45 80F10F              <1> 	xor	cl, 8+7			; [ 1 2 3 4 5 6 7 ] <- 8 + [ 6 5 4 3 2 1 0]
  2019                              <1> 
  2020                              <1> write_window_known:
  2021 00000C48 80F902              <1> 	cmp	cl, 2			; application dnw vector page
  2022 00000C4B 7510                <1> 	jnz	write_window_free
  2023 00000C4D F786B0040000000080- <1> 	test	dword ptr [rsi+PSR], 00800000h			; ISR ?
  2024 00000C56 00                  <1>
  2025 00000C57 0F844C050000        <1> 	jz	near guard_ii_authority		; the unbalanced push is harmless
  2026                              <1> 						; stack is reset on faults
  2027                              <1> write_window_free:
  2028 00000C5D 4889C2              <1> 	mov	rdx, rax
  2029 00000C60 480FB6C1            <1> 	movzx	rax, cl
  2030 00000C64 8B8486E0040000      <1> 	mov	eax, dword ptr [rsi+rax*4+IO_PORT]
  2031 00000C6B 4889D6              <1> 	mov	rsi, rdx
  2032                              <1> 
  2033 00000C6E C1C910              <1> 	ror	ecx, 16		; restore designator information
  2034 00000C71 C3                  <1> 	ret
  2035                              <1> 
  2036                                  	%include	"sr.msm"
  2037                              <1> 
  2038                              <1> ;	read staging register
  2039                              <1> ;	read bits from a stream of bits
  2040                              <1> 
  2041 00000C72 8B4E50              <1> _rsr:	mov	ecx, dword ptr [rsi+RDATAC]
  2042 00000C75 88CD                <1> 	mov	ch, cl
  2043 00000C77 88C1                <1> 	mov	cl, al
  2044                              <1> 
  2045 00000C79 31C0                <1> 	xor	eax, eax
  2046 00000C7B F786B0040000400000- <1> 	test	dword ptr [rsi+PSR], B_STREAMZR
  2047 00000C84 00                  <1>
  2048 00000C85 7503                <1> 	jnz	_rsr_zadd
  2049 00000C87 8B4510              <1> 	mov	eax, dword ptr [rbp+A]
  2050                              <1> _rsr_zadd:
  2051 00000C8A 20C9                <1> 	and	cl, cl
  2052 00000C8C 7454                <1> 	jz	_rsr_x
  2053 00000C8E 8B5E54              <1> 	mov	ebx, dword ptr [rsi+RDATA]
  2054                              <1> 
  2055 00000C91 20ED                <1> 	and	ch, ch			; any data loaded yet?
  2056 00000C93 740F                <1> 	jz	_rsr_read		; if not read first no question 
  2057 00000C95 38CD                <1> 	cmp	ch, cl			; otherwise, already enough for request?
  2058 00000C97 7334                <1> 	jnb	_rsr_draw		; if so deliver data
  2059 00000C99 28E9                <1> 	sub	cl, ch			; if not trim the oustanding count
  2060 00000C9B 86CD                <1> 	xchg	cl, ch			
  2061 00000C9D E8F70F0000          <1> 	call	dsl			; and deliver available data
  2062 00000CA2 86E9                <1> 	xchg	ch, cl			; before reading some more
  2063                              <1> _rsr_read:
  2064 00000CA4 E89B000000          <1> 	call	stream_read
  2065 00000CA9 488BB560020000      <1> 	mov	rsi, qword ptr [rbp+CORE_INDEX1]	; after call to operand_read
  2066 00000CB0 C7465018000000      <1> 	mov	dword ptr [rsi+RDATAC], 24
  2067 00000CB7 F786B0040000200000- <1> 	test	dword ptr [rsi+PSR], B_STREAM16R
  2068 00000CC0 00                  <1>
  2069 00000CC1 740A                <1> 	jz	_rsr_draw
  2070 00000CC3 C7465010000000      <1> 	mov	dword ptr [rsi+RDATAC], 16
  2071 00000CCA C1E308              <1> 	shl	ebx, 8
  2072                              <1> _rsr_draw:
  2073 00000CCD 6651                <1> 	push	cx
  2074 00000CCF E8C50F0000          <1> 	call	dsl
  2075 00000CD4 6659                <1> 	pop	cx
  2076 00000CD6 81E1FF000000        <1> 	and	ecx, 255
  2077 00000CDC 294E50              <1> 	sub	dword ptr [rsi+RDATAC], ecx
  2078 00000CDF 895E54              <1> 	mov	dword ptr [rsi+RDATA], ebx
  2079                              <1> _rsr_x:
  2080 00000CE2 894510              <1> 	mov	dword ptr [rbp+A], eax
  2081 00000CE5 C3                  <1> 	ret
  2082                              <1> 
  2083                              <1> 
  2084                              <1> ;	write staging register
  2085                              <1> ;	write bits to a stream of bits
  2086                              <1> 
  2087 00000CE6 8B4E58              <1> _wsr:	mov	ecx, dword ptr [rsi+WDATAC]
  2088 00000CE9 88CD                <1> 	mov	ch, cl					; accumulated count
  2089 00000CEB 88C1                <1> 	mov	cl, al					; new request
  2090                              <1> 
  2091 00000CED 8B465C              <1> 	mov	eax, dword ptr [rsi+WDATA]	; accumulated data
  2092 00000CF0 8B5D10              <1> 	mov	ebx, dword ptr [rbp+A]		; source new data
  2093                              <1> 
  2094 00000CF3 80C5E8              <1> 	add	ch, -24				; space for new data expressed negative
  2095 00000CF6 F786B0040000100000- <1> 	test	dword ptr [rsi+PSR], B_STREAM16W	; 16 bits / word flag
  2096 00000CFF 00                  <1>
  2097 00000D00 7403                <1> 	jz	_wsr24
  2098 00000D02 80C508              <1> 	add	ch, 8
  2099                              <1> 
  2100 00000D05 00CD                <1> _wsr24:	add	ch, cl			; increment towards zero
  2101 00000D07 7404                <1> 	jz	_wsr_write		; accumulated word exactly full
  2102 00000D09 7320                <1> 	jnc	_wsr_add		; not yet full
  2103                              <1> 
  2104 00000D0B 28E9                <1> 	sub	cl, ch			; full + some more
  2105                              <1> 
  2106                              <1> _wsr_write:
  2107 00000D0D E8870F0000          <1> 	call	dsl			; fill output word
  2108 00000D12 88E9                <1> 	mov	cl, ch			; position outstanding count
  2109 00000D14 E843000000          <1> 	call	stream_write
  2110 00000D19 8BB560020000        <1> 	mov	esi, dword ptr [rbp+CORE_INDEX1]	; after call to operand_write
  2111 00000D1F B800000000          <1> 	mov	eax, 0
  2112 00000D24 C7465800000000      <1> 	mov	dword ptr [rsi+REGISTER+WDATAC], 0
  2113                              <1> 
  2114                              <1> _wsr_add:
  2115 00000D2B 6651                <1> 	push	cx
  2116 00000D2D E8670F0000          <1> 	call	dsl			; add to output word
  2117 00000D32 6659                <1> 	pop	cx
  2118 00000D34 81E1FF000000        <1> 	and	ecx, 255		; format ecx for add to accumulated count 
  2119 00000D3A 014E58              <1> 	add	dword ptr [rsi+REGISTER+WDATAC], ecx
  2120 00000D3D 89465C              <1> 	mov	dword ptr [rsi+REGISTER+WDATA], eax
  2121 00000D40 895D10              <1> 	mov	dword ptr [rbp+A], ebx
  2122 00000D43 C3                  <1> 	ret
  2123                              <1> 
  2124                              <1> stream_read:
  2125 00000D44 51                  <1> 	push	rcx
  2126 00000D45 50                  <1> 	push	rax
  2127 00000D46 8B4534              <1> 	mov	eax, dword ptr [rbp+Q]
  2128 00000D49 81453401000000      <1> 	add	dword ptr [rbp+Q], 1
  2129 00000D50 30C9                <1> 	xor	cl, cl
  2130 00000D52 E8BBF7FFFF          <1> 	call	_operand_read
  2131 00000D57 89C3                <1> 	mov	ebx, eax
  2132 00000D59 58                  <1> 	pop	rax
  2133 00000D5A 59                  <1> 	pop	rcx
  2134 00000D5B C3                  <1> 	ret
  2135                              <1> 
  2136                              <1> stream_write:
  2137 00000D5C 51                  <1> 	push	rcx
  2138 00000D5D 53                  <1> 	push	rbx
  2139 00000D5E 89C3                <1> 	mov	ebx, eax
  2140 00000D60 8B4530              <1> 	mov	eax, dword ptr [rbp+P]
  2141 00000D63 81453001000000      <1> 	add	dword ptr [rbp+P], 1
  2142 00000D6A 30C9                <1> 	xor	cl, cl
  2143 00000D6C E874F9FFFF          <1> 	call	_operand_write
  2144 00000D71 5B                  <1> 	pop	rbx
  2145 00000D72 59                  <1> 	pop	rcx
  2146 00000D73 C3                  <1> 	ret
  2147                              <1> 
  2148                                  	%include	"io.msm"
  2149 00000D74 678B9C86E0040000    <1> _inA:	mov	ebx, dword ptr [esi+IO_PORT+eax*4]
  2150 00000D7C 67895D10            <1> 	mov	dword ptr [ebp+A], ebx
  2151 00000D80 C3                  <1> _inA_:	ret
  2152                              <1> 
  2153 00000D81 678B9C86E0040000    <1> _inB:	mov	ebx, dword ptr [esi+IO_PORT+eax*4]
  2154 00000D89 67895D14            <1> 	mov	dword ptr [ebp+B], ebx
  2155 00000D8D C3                  <1> _inB_:	ret
  2156                              <1> 
  2157 00000D8E 678B5D10            <1> _outA:	mov	ebx, dword ptr [ebp+A]
  2158 00000D92 E9D3010000          <1> 	jmp	oport
  2159                              <1> 
  2160 00000D97 678B5D14            <1> _outB:	mov	ebx, dword ptr [ebp+B]
  2161 00000D9B E9CA010000          <1> 	jmp	oport
  2162                              <1> 
  2163                              <1> 
  2164                              <1> ISR_ONLY equ	8
  2165                              <1> MEMTYPE	equ	1
  2166                              <1> MEMZERONLY equ	2
  2167                              <1> EXTERNAL_IO equ	4
  2168                              <1> BROADCAST equ	16
  2169                              <1> 
  2170                              <1> B_1	equ	MEMTYPE
  2171                              <1> B_TCB	equ	MEMTYPE+ISR_ONLY
  2172                              <1> B_KERN	equ	MEMTYPE+ISR_ONLY
  2173                              <1> A_THREP	equ	MEMZERONLY+ISR_ONLY
  2174                              <1> I_PORT	equ	EXTERNAL_IO
  2175                              <1> O_PORT	equ	EXTERNAL_IO
  2176                              <1> O_INDICA equ	EXTERNAL_IO
  2177                              <1> O_CHILL	equ	EXTERNAL_IO
  2178                              <1> I_TZONE	equ	EXTERNAL_IO
  2179                              <1> RAM_THRESH equ	ISR_ONLY+MEMZERONLY
  2180                              <1> XI_ACK	equ	ISR_ONLY+EXTERNAL_IO
  2181                              <1> O_LEDS	equ	EXTERNAL_IO
  2182                              <1> O_INC	equ	ISR_ONLY+EXTERNAL_IO
  2183                              <1> O_MCAST	equ	ISR_ONLY+BROADCAST
  2184                              <1> 
  2185                              <1> 
  2186                              <1> mask_port_outAB:
  2187 00000DA0 000100000000000000- <1> 	db	0, B_1, 0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
  2188 00000DA9 00000000000000      <1>
  2189 00000DB0 000000000000000000- <1> 	db	    0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
  2190 00000DB9 00000000000000      <1>
  2191                              <1> 
  2192 00000DC0 000000000000000000- <1> 	db	    0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
  2193 00000DC9 00000000000000      <1>
  2194 00000DD0 000000000000000000- <1> 	db	    0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
  2195 00000DD9 00000000000000      <1>
  2196                              <1> 
  2197 00000DE0 0009090909090909    <1> 	db	0,  B_TCB,B_KERN,B_KERN,B_KERN,B_KERN,B_KERN,B_KERN
  2198 00000DE8 0A00000C0C000018    <1> 	db	A_THREP, 0, 0, XI_ACK,  O_INC, 0,0, O_MCAST
  2199                              <1> 
  2200 00000DF0 0404040404040404    <1> 	db	I_PORT,I_PORT,I_PORT,I_PORT,I_PORT,I_PORT,I_PORT,I_PORT
  2201 00000DF8 0404040404040404    <1> 	db	O_PORT,O_PORT,O_PORT,O_PORT,O_PORT,O_PORT,O_PORT,O_PORT
  2202                              <1> 
  2203 00000E00 0000000000040404    <1> 	db	0,0,0,0, 0, I_TZONE, O_INDICA, O_CHILL
  2204 00000E08 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  RAM_THRESH, 0,0, O_LEDS
  2205 00000E11 0000000A000004      <1>
  2206                              <1> 
  2207 00000E18 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
  2208 00000E21 00000000000000      <1>
  2209 00000E28 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
  2210 00000E31 00000000000000      <1>
  2211 00000E38 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
  2212 00000E41 00000000000000      <1>
  2213 00000E48 000000000000000000- <1> 	db	0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
  2214 00000E51 00000000000000      <1>
  2215                              <1> 
  2216                              <1> 					; outA|B rules flags per I/O port
  2217                              <1> 
  2218                              <1> _reload:
  2219 00000E58 50                  <1> 	push	rax
  2220 00000E59 8B4510              <1> 	mov	eax, dword ptr [rbp+A]
  2221 00000E5C 81451002000000      <1> 	add	dword ptr [rbp+A], 2
  2222 00000E63 E862F6FFFF          <1> 	call	_burst_read2
  2223 00000E68 5F                  <1> 	pop	rdi
  2224 00000E69 488BB560020000      <1> 	mov	rsi, qword ptr [rbp+CORE_INDEX1]
  2225 00000E70 8984BEE0040000      <1> 	mov	dword ptr [rsi+IO_PORT+rdi*4], eax
  2226 00000E77 899CBEE4040000      <1> 	mov	dword ptr [rsi+IO_PORT+rdi*4+4], ebx
  2227 00000E7E C3                  <1> 	ret
  2228                              <1> 
  2229 00000E7F C3                  <1> _emulator_cool: ret
  2230                              <1> 
  2231                              <1> ;	sabr checks what it places in operand space windows
  2232                              <1> ;	there are no subsequent range checks on reference
  2233                              <1> 
  2234                              <1> 	%if	1
  2235                              <1> 
  2236                              <1> 	%else
  2237                              <1> 
  2238                              <1> _sabr:	test	eax, 0000003Eh			; target window must be 2..63
  2239                              <1> 	jz	_sabr_reserved
  2240                              <1> 	test	eax, 00FFFFC0h
  2241                              <1> 	jnz	_sabr_reserved
  2242                              <1> 						; ea in range 2..63
  2243                              <1> 	mov	ebx, dword ptr [ebp+A]		; read page index
  2244                              <1> 	test	ebx, 00400000h
  2245                              <1> 	jz	_sabr_executable_space		; 4K page 
  2246                              <1> 	test	ebx, 63
  2247                              <1> 	jz	_sabr_executable_space		; 256k page in system memory
  2248                              <1> 						; otherwise a device
  2249                              <1> 
  2250                              <1> 	test	ebx, 00800000h			; a non-access device?
  2251                              <1> 	jz	_sabr_access_device		; nor a trap device
  2252                              <1> 						; a non-access trap device
  2253                              <1> 	test	byte ptr [esi+PSR+2], 128
  2254                              <1> 	jz	_sabr_reserved			; applications may not
  2255                              <1> 	jmp	_sabr_thru			; ISRs may
  2256                              <1> 
  2257                              <1> _sabr_access_device
  2258                              <1> 	mov	cl, bl				; find peripheral array
  2259                              <1> 	and	ecx, 63
  2260                              <1> 	mov	ecx, dword ptr [esi+ecx*4+IO_PORT+128*4]
  2261                              <1> 	test	ecx, 00400000h
  2262                              <1> 	jz	_sabr_array_type?
  2263                              <1> 	test	byte ptr [esi+PSR+2], 128	; this device is filestore or network trunk
  2264                              <1> 	jnz	_sabr_authorised		; only ISRs can base it
  2265                              <1> 
  2266                              <1> _sabr_reserved:
  2267                              <1> 	jmp	guard_ii_authority		
  2268                              <1> 
  2269                              <1> _sabr_authorised:
  2270                              <1> 
  2271                              <1> ;	shl	ecx, 6				; align peripheral array high index
  2272                              <1> ;	jmp	_sabr_array_type		; for comparison
  2273                              <1> 
  2274                              <1> 	mov	edi, ebx
  2275                              <1> 	shr	ebx, 6
  2276                              <1> 	and	ebx, 65535
  2277                              <1> 	and	ecx, 65535
  2278                              <1> 	jmp	_sabr_range?
  2279                              <1> 
  2280                              <1> _sabr_array_type?:
  2281                              <1> 	test	ecx, 00800000h
  2282                              <1> 	jz	_sabr_notype
  2283                              <1> 	jmp	_sabr_array_type
  2284                              <1> 
  2285                              <1> _sabr_executable_space:
  2286                              <1> 	mov	ecx, dword ptr [esi+IO_PORT+128*4]
  2287                              <1> 
  2288                              <1> _sabr_array_type:
  2289                              <1> 	and	ecx, 003FFFFFh			; is that page index in range?
  2290                              <1> 	mov	edi, ebx
  2291                              <1> 	and	ebx, 003FFFFFh
  2292                              <1> 
  2293                              <1> _sabr_range?
  2294                              <1> 	sub	ecx, ebx
  2295                              <1> ;	mov	dword ptr [_ultra], ecx
  2296                              <1> 	jns	_sabr_thru
  2297                              <1> 
  2298                              <1> _sabr_notype:
  2299                              <1> 	mov	edi, 0C00001h			; not there
  2300                              <1> 
  2301                              <1> _sabr_thru:
  2302                              <1> 	mov	dword ptr [esi+IO_PORT+eax*4], edi
  2303                              <1> 	
  2304                              <1> 	mov	ebx, dword ptr [esi+IO_PORT+65*4]
  2305                              <1> 	shl	ebx, 12				; write thru to base table
  2306                              <1> 	add	eax, ebx			; in reload store
  2307                              <1> 	mov	ebx, edi
  2308                              <1> 	bswap	ebx
  2309                              <1> 	mov	edi, _memory
  2310                              <1> 	mov	dword ptr [edi+eax*4+64*4], ebx
  2311                              <1> 	ret
  2312                              <1> 
  2313                              <1> 	%if	0
  2314                              <1> 
  2315                              <1> 	mov	esi, eax		; target window
  2316                              <1> 	mov	eax, dword ptr [ebp+A]	; requested storage block index
  2317                              <1> 	mov	ebx, eax		; cache a copy
  2318                              <1> 
  2319                              <1> 	mov	ecx, dword ptr [esi+IO_PORT+128*4]
  2320                              <1> 					; device zero = executable space
  2321                              <1> 					; load its size parameter
  2322                              <1> 	test	eax, 00400000h		; big and maybe not system memory?
  2323                              <1> 	jz	_sabr_executable_space	; yes executable space
  2324                              <1> 
  2325                              <1> 	test	ebx, 63
  2326                              <1> 	jz	_sabr_executable_space	; yes executable space
  2327                              <1> 					; no some other space
  2328                              <1> 
  2329                              <1> 	and	ebx, 63
  2330                              <1> 	mov	ecx, dword ptr [esi+IO_PORT+128*4+ebx*4]
  2331                              <1> 	test	ecx, DATA16_FLAG
  2332                              <1> 	jnz	 _sabr_device_array
  2333                              <1> 	test	ecx, 00800000h
  2334                              <1> 	jz	_sabr_guard		; range issue. The device is void
  2335                              <1> 
  2336                              <1> 	mov	ebx, eax
  2337                              <1> 	and	ebx, 00BFFFC0h		; blocks of 64 pages if not device zero
  2338                              <1> 	jmp	_sabr_executable_type	; devices usable as system memory
  2339                              <1> 	
  2340                              <1> _sabr_executable_space:			; is the target page @+ application space?
  2341                              <1> 	and	ebx, 00BFFFFFh		; just the page, not any flags
  2342                              <1> 	cmp	ebx, dword ptr [esi+IO_PORT+72*4]
  2343                              <1> 	js	_sabr_guard		; neither ISrs nor applications may base ISR space
  2344                              <1> 
  2345                              <1> _sabr_executable_type:			; has the device this much memory?
  2346                              <1> 	and	ecx, 003FFFFFh		; 4K-word page high index of device
  2347                              <1> 					; has the device this many pages?
  2348                              <1> 	sub	ecx, ebx
  2349                              <1> 
  2350                              <1> 	jns	_sabr_thru		; yes
  2351                              <1> 	jmp	_sabr_guard		; no
  2352                              <1> 
  2353                              <1> _sabr_device_array:
  2354                              <1> 	test	dword ptr [esi+PSR], 00800000h
  2355                              <1> 	jz	near guard_ii_authority	; only be here if you are an ISR
  2356                              <1> 	mov	ebx, eax		; refresh the requested block index
  2357                              <1> 	and	ebx, 003FFFFFh
  2358                              <1> 	shr	ebx, 6			; align it with high index from device port
  2359                              <1> 	and	ecx, 003FFFFFh		; has the device array this many blocks?
  2360                              <1> 
  2361                              <1> 	sub	ecx, ebx
  2362                              <1> 	jns	_sabr_thru		; yes
  2363                              <1> 					; no
  2364                              <1> _sabr_guard:
  2365                              <1> 	mov	eax, 00C00001h		; no-access value
  2366                              <1> 					; will trip on reference in target window
  2367                              <1> _sabr_thru:
  2368                              <1> 	mov	dword ptr [esi+IO_PORT+esi*4], eax	; ????????
  2369                              <1> 					; esi = target window
  2370                              <1> 	mov	ebx, dword ptr [esi+IO_PORT+65*4]	; thread TCB
  2371                              <1> 	shl	ebx, 12+2		; 4K page * 4 platform bytes
  2372                              <1> 	mov	edi, _memory		; so system memory of emulated machine
  2373                              <1> 	add	edi, ebx		; + offset of TCB 
  2374                              <1> 	bswap	eax			; big endian store at TCB + ABT + esi * 4 
  2375                              <1> 	mov	dword ptr [edi+esi*4+64*4], eax
  2376                              <1> 					; -> TCB + ABT + window index
  2377                              <1> _sabrx:	ret
  2378                              <1> 	%endif
  2379                              <1> 	%endif
  2380                                  	%include	"sabr.msm"
  2381                              <1> ;	check and write to I/O port <- storage base index in range [ 2..63 ]
  2382                              <1> ;	write a copy to reload base table in thread control block
  2383                              <1> ;	values out of memory range are replaced with trap device C00001
  2384                              <1> ;	which causes GUARD$ exception if the sindow is accessed
  2385                              <1> 
  2386                              <1> ;	anauthorised actions
  2387                              <1> ;
  2388                              <1> ;		attempt to write window base < 2 or > 63
  2389                              <1> ;		application selecting ISR space
  2390                              <1> ;		application selecting NVRAM
  2391                              <1> ;
  2392                              <1> ;	are not carried out and a GUARD$ exception is raised
  2393                              <1> ;	ISRs write the trap device C00001 to close memory windows
  2394                              <1> 
  2395                              <1> _sabr_guard:
  2396 00000E80 E924030000          <1> 	jmp	guard_ii_authority
  2397                              <1> 
  2398 00000E85 A93E000000          <1> _sabr:	test	eax, 03Eh		; ea not < 2
  2399 00000E8A 74F4                <1> 	jz	_sabr_guard
  2400 00000E8C A9C0FFFF00          <1> 	test	eax, 0FFFFC0h		; ea not > 63
  2401 00000E91 75ED                <1> 	jnz	_sabr_guard
  2402                              <1> 
  2403 00000E93 8B4D10              <1> 	mov	ecx, dword ptr [rbp+A]
  2404                              <1> 
  2405 00000E96 F7C100004000        <1> 	test	ecx, 00400000h
  2406 00000E9C 7478                <1> 	jz	memory_page
  2407 00000E9E F7C13F000000        <1> 	test	ecx, 63
  2408 00000EA4 746A                <1> 	jz	large_memory_page
  2409                              <1> 
  2410 00000EA6 F7C100008000        <1> 	test	ecx, 00800000h
  2411 00000EAC 7411                <1> 	jz	array_attribute
  2412                              <1> 
  2413 00000EAE F786B0040000000080- <1> 	test	dword ptr [rsi+PSR], 0800000h
  2414 00000EB7 00                  <1>
  2415 00000EB8 74C6                <1> 	jz	_sabr_guard
  2416 00000EBA E982000000          <1> 	jmp	unthru			; ISR write illegal device thru
  2417                              <1> 					; closes the address space window
  2418                              <1> 
  2419                              <1> 					; application may not write device
  2420                              <1> 					; but may zero -> sabr  with same effect
  2421                              <1> array_attribute:
  2422                              <1> 
  2423 00000EBF 48C1E102            <1> 	shl	rcx, 2
  2424 00000EC3 480FB6D9            <1> 	movzx	rbx, cl			; cl = device * 4
  2425                              <1> 
  2426 00000EC7 8B9C1EE0060000      <1> 	mov	ebx, dword ptr [rsi+rbx+IO_PORT+128*4]
  2427                              <1> 					; platform address + device descriptor
  2428                              <1> 
  2429                              <1> 
  2430                              <1> 	%if	0
  2431                              <1> 	mov	dword ptr [rsi+eax*8+DATAFRAME], rbx	; rapid recall
  2432                              <1> 	mov	dword ptr [rsi+eax*8+DATAFRAME+4], rdi	; device information
  2433                              <1> 	%endif						; via window tag
  2434                              <1> 
  2435 00000ECE 48C1E908            <1> 	shr	rcx, 6+2		; lose previous shift + device code
  2436 00000ED2 F7C300004000        <1> 	test	ebx, 00400000h
  2437 00000ED8 750D                <1> 	jnz	peripheral_array
  2438 00000EDA F7C300008000        <1> 	test	ebx, 00800000h
  2439 00000EE0 7526                <1> 	jnz	memory_array
  2440                              <1> 
  2441 00000EE2 E999FFFFFF          <1> 	jmp	_sabr_guard		; no device code
  2442                              <1> 
  2443                              <1> peripheral_array:			; device types 00C00000 00400000
  2444 00000EE7 F786B0040000000080- <1> 	test	dword ptr [rsi+PSR], 00800000h
  2445 00000EF0 00                  <1>
  2446 00000EF1 748D                <1> 	jz	_sabr_guard
  2447                              <1> 
  2448 00000EF3 81E1FFFF0000        <1> 	and	ecx, 0000FFFFh		; have # large blocks in low 16 bits
  2449 00000EF9 81E3FFFF0000        <1> 	and	ebx, 0000FFFFh
  2450 00000EFF 29CB                <1> 	sub	ebx, ecx
  2451 00000F01 793B                <1> 	jns	thru
  2452 00000F03 E92C000000          <1> 	jmp	_sabr_safeguard
  2453                              <1> 
  2454                              <1> memory_array:
  2455 00000F08 C1E106              <1> 	shl	ecx, 6			; block * 64
  2456 00000F0B E914000000          <1> 	jmp	memory_array_bound?
  2457                              <1> 
  2458                              <1> large_memory_page:
  2459 00000F10 81E1FFFFBF00        <1> 	and	ecx, 00BFFFFFh		; remove 00400000 bit for lower bound check
  2460                              <1> 
  2461                              <1> memory_page:
  2462 00000F16 8B9EE0060000        <1> 	mov	ebx, dword ptr [rsi+IO_PORT+128*4]	; device zero memory attribute
  2463 00000F1C 3B8E00060000        <1> 	cmp	ecx, dword ptr [rsi+IO_PORT+72*4]	; ISR / application boundary
  2464 00000F22 7210                <1> 	jb	_sabr_safeguard
  2465                              <1> 
  2466                              <1> memory_array_bound?:
  2467 00000F24 81E1FFFFBF00        <1> 	and	ecx, 00BFFFFFh		; bit 00800000 is a bad accident
  2468 00000F2A 81E3FFFF3F00        <1> 	and	ebx, 003FFFFFh		; stop it here
  2469 00000F30 29CB                <1> 	sub	ebx, ecx
  2470 00000F32 790A                <1> 	jns	thru
  2471                              <1> 
  2472                              <1> _sabr_safeguard:
  2473 00000F34 B90100C000          <1> 	mov	ecx, 00C00001h
  2474 00000F39 E903000000          <1> 	jmp	unthru
  2475                              <1> 
  2476 00000F3E 8B4D10              <1> thru:	mov	ecx, dword ptr [rbp+A]		; i.e. correct as supplied
  2477 00000F41 898C86E0040000      <1> unthru:	mov	dword ptr [rsi+rax*4+IO_PORT], ecx
  2478                              <1> 
  2479 00000F48 48BF-               <1> 	mov	rdi, _memory
  2480 00000F4A [0000000000000000]  <1>
  2481 00000F52 678B9EE4050000      <1> 	mov	ebx, dword ptr [esi+IO_PORT+65*4] ; thread control block
  2482                              <1> 
  2483 00000F59 48C1E30C            <1> 	shl	rbx, 12			; multiply to TCB size
  2484 00000F5D 4801C3              <1> 	add	rbx, rax		; ea is target base index
  2485 00000F60 0FC9                <1> 	bswap	ecx			; for this is a big endian memory write
  2486 00000F62 898C9F00010000      <1> 	mov	dword ptr [rdi+rbx*4+64*4], ecx
  2487 00000F69 C3                  <1> 	ret				; save TCB reload copy of loaded pointer
  2488                                  	%include	"oport.msm"
  2489                              <1> 
  2490                              <1> OOO_TRACE	equ	0
  2491                              <1> 
  2492                              <1> 							; static void oport(int ea, int value, smp *xcore)
  2493                              <1> 							; {
  2494                              <1> oport:		; write I / O port			;    int		 rule,
  2495                              <1> 		; RTA instructions outA outB		;			 device;
  2496                              <1> 							; 
  2497                              <1> 		; ports which are memory pointers	;    int		 mask,
  2498                              <1> 		; must have a block that exists		;			 from,
  2499                              <1> 		; ISRs can write trap value C00001 	;                 	 index;
  2500                              <1> 		; = device 400001 | illegal 800000	; 
  2501                              <1> 		; port # = effective address = eax	;    int		 device_index = 0;
  2502                              <1> 		; write value in ebx			; 
  2503                              <1> 		; multicast bits in RTA register k	;    smp		*ascor;
  2504                              <1> 		 					;    unsigned	*register_set = xcore->register_set;
  2505                              <1> 
  2506 00000F6A 3DC0000000          <1> 	cmp	eax, IO_PORTS				; 
  2507 00000F6F 0F839D000000        <1> 	jnb	near no_port				;    if (ea < IO_PORTS)
  2508                              <1> 							;    {
  2509 00000F75 8A88[A00D0000]      <1> 	mov	cl, byte ptr [rax+mask_port_outAB]	;       rule = mask_port_outAB[ea];
  2510          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  2511 00000F7B 20C9                <1> 	and	cl, cl					; 
  2512 00000F7D 0F848F000000        <1> 	jz	near no_rule				;       if (rule)
  2513 00000F83 F6C108              <1> 	test	cl, ISR_ONLY				;       {
  2514 00000F86 7410                <1> 	jz	application_plus_isr_rule		;          if (((rule & ISR_ONLY) == 0) || (psr & 0x00800000))
  2515 00000F88 F786B0040000000080- <1> 	test	dword ptr [rsi+PSR], 0800000h		;          {
  2516 00000F91 00                  <1>
  2517 00000F92 0F847A000000        <1> 	jz	near no_authority			;
  2518                              <1> 							;
  2519                              <1> application_plus_isr_rule:				;
  2520 00000F98 F6C104              <1> 	test	cl, EXTERNAL_IO				;             if (rule & EXTERNAL_IO)
  2521 00000F9B 7427                <1> 	jz	broadcast_rule?				;             {
  2522 00000F9D 899C86E0040000      <1> 	mov	dword ptr [rsi+IO_PORT+rax*4], ebx	;                base[ea] = value;
  2523 00000FA4 3D66000000          <1> 	cmp	eax, 102	; INDICATION$		;                if (ea == 102) indication |= value;
  2524 00000FA9 7506                <1> 	jne	xi_ack?		 			;
  2525 00000FAB 099EA4040000        <1> 	or	dword ptr [rsi+INDICATION], ebx		;
  2526                              <1>  							;
  2527                              <1> xi_ack?:							;
  2528 00000FB1 3D4B000000          <1> 	cmp	eax, 75					;                if (ea == 75)
  2529 00000FB6 750B                <1> 	jne	xi_no_ack				;                {
  2530 00000FB8 F6D3                <1> 	not	bl					;                    base[74] &= (value & 255) ^ 255;
  2531 00000FBA 0FB6DB              <1> 	movzx	ebx, bl					;                    // indication |= (value & 255) << 8;
  2532                              <1> 							;                }
  2533 00000FBD 219E08060000        <1> 	and	dword ptr [rsi+IO_PORT+74*4], ebx	; 
  2534                              <1> xi_no_ack:						; //               if ((ea == 79) && (value & 1)) indication |= ATTENTION;
  2535 00000FC3 C3                  <1> 	ret						;                return;
  2536                              <1> 							;             }
  2537                              <1> 							; 
  2538                              <1> broadcast_rule?:					;             if (rule & BROADCAST)
  2539 00000FC4 F6C110              <1> 	test	cl, BROADCAST				;             {
  2540 00000FC7 744E                <1> 	jz	memory_rule?				;                mask = k;
  2541                              <1> 							;
  2542 00000FC9 899C86E0040000      <1> 	mov	dword ptr [rsi+IO_PORT+rax*4], ebx 	;
  2543 00000FD0 8B8E14060000        <1> 	mov	ecx, dword ptr [rsi+IO_PORT+_CORE_SOCKET] ;
  2544 00000FD6 B801000000          <1> 	mov	eax, 1					;
  2545 00000FDB D3E0                <1> 	shl	eax, cl					;
  2546 00000FDD 89C1                <1> 	mov	ecx, eax	; source identifier bit	;
  2547                              <1> 							;
  2548 00000FDF BB01000000          <1> 	mov	ebx, 1					;
  2549 00000FE4 48BF-               <1> 	mov	rdi, _core				;
  2550 00000FE6 [0000000000000000]  <1>
  2551 00000FEE 8B4504              <1> 	mov	eax, dword ptr [rbp+REGISTER+K]		;
  2552                              <1> 							;
  2553                              <1> multicast_select:					;
  2554 00000FF1 85D8                <1> 	test	eax, ebx				;                from = base[77];
  2555 00000FF3 740F                <1> 	jz	multicast_next				; 
  2556 00000FF5 31D8                <1> 	xor	eax, ebx				;                for (index = 0; index < RTA_SMP; index++)
  2557 00000FF7 098F18060000        <1> 	or	dword ptr [rdi+IO_PORT+_MCAST_PENDING], ecx ;             {
  2558 00000FFD 808FA404000080      <1> 	or	byte ptr [rdi+INDICATION], ATTENTION	;                   if (mask & 1)
  2559                              <1> 							;                   {
  2560                              <1> multicast_next:						;                      ascor = core + index;
  2561 00001004 4881C7E0070000      <1> 	add	rdi, CORE_SIZE				;                      ascor->BASE[78] |= 1 << from;
  2562 0000100B D1E3                <1> 	shl	ebx, 1					;                      ascor->INDICATION |= ATTENTION;
  2563 0000100D 21C0                <1> 	and	eax, eax				;                   }
  2564 0000100F 75E0                <1> 	jnz	multicast_select			; 
  2565 00001011 C3                  <1> 	ret						;                   mask >>= 1;
  2566                              <1> 							;                }
  2567                              <1> no_port:						; 
  2568                              <1> no_rule:						;                /**************************************************
  2569                              <1> no_authority:						; 			keep these on the sending side
  2570                              <1> 							; 			until constructing interrupt frame
  2571 00001012 E992010000          <1> 	jmp	guard_ii_authority			; 			between instructions at target core
  2572                              <1> 							;                         to avoid overwrites from other cores
  2573                              <1> 							;                **************************************************/
  2574                              <1> 							; 
  2575                              <1> 							;                base[ea] = value;	/* latent parameter	*/
  2576                              <1> 							;                return;
  2577                              <1> 							;             }
  2578                              <1> 							; 
  2579                              <1> memory_rule?:	; system memory type only		;             else if (rule & MEMTYPE)
  2580                              <1> 
  2581 00001017 F6C101              <1> 	test	cl, MEMTYPE				;             {
  2582 0000101A 745E                <1> 	jz	page_pointer?				;                if (value & 0x00400000) device_index = value & 63;
  2583 0000101C F7C300004000        <1> 	test	ebx, 0400000h	; bank sized?		; 
  2584 00001022 7463                <1> 	jz	memory_page_pointer			;                if (device_index)
  2585                              <1> 							;                {
  2586 00001024 F7C33F000000        <1> 	test	ebx, 63					;                   if (value & 0x00800000)
  2587 0000102A 741C                <1> 	jz	device_is_pointed			;                   {
  2588 0000102C F7C300008000        <1> 	test	ebx, 0800000h	; the trap device?	;                      if (psr & 0x00800000)
  2589 00001032 7414                <1> 	jz	device_is_pointed			;                      {
  2590 00001034 F786B004000000350C- <1> 	test	dword ptr [rsi+PSR], 00800000	; ISR?	;                         base[ea] = value;
  2591 0000103D 00                  <1>
  2592 0000103E 74D2                <1> 	jz	no_authority				;                         return;
  2593 00001040 899C86E0040000      <1> 	mov	[rsi+IO_PORT+rax*4], ebx		;                      }
  2594 00001047 C3                  <1> 	ret						; 
  2595                              <1> 							;                      GUARD_AUTHORITY
  2596                              <1> device_is_pointed:					;                      return;
  2597 00001048 678B8EE0060000      <1> 	mov	ecx, dword ptr [esi+IO_PORT+128*4]	;                   }
  2598 0000104F F7C100008000        <1> 	test	ecx, 00800000h				;                }
  2599 00001055 74BB                <1> 	jz	no_authority				; 
  2600 00001057 F7C100004000        <1> 	test	ecx, 00400000h				;                device = base[128+device_index];
  2601 0000105D 75B3                <1> 	jnz	no_authority				;            
  2602 0000105F 81E1FFFF3F00        <1> 	and	ecx, 003FFFFFh				;                if ((device & 0x00C00000) == 0x00800000)
  2603 00001065 89DF                <1> 	mov	edi, ebx				;                {
  2604 00001067 81E7FFFF3F00        <1> 	and	edi, 003FFFFFh	; catch any 00800000	;                   if ((value & 0x003FFFC0) > (device & 0x003FFFFF))
  2605 0000106D 39F9                <1> 	cmp	ecx, edi				;                   {
  2606 0000106F 7234                <1> 	jb	outwith		; beyond memory		;                   }
  2607 00001071 67899C86E0040000    <1> 	mov	[esi+IO_PORT+eax*4], ebx		;                   else
  2608 00001079 C3                  <1> 	ret						;                   {
  2609                              <1> 							;                      base[ea] = value;
  2610                              <1> 							;                      return;
  2611                              <1> 							;                   }
  2612                              <1> 							;                }
  2613                              <1> 							;             }
  2614                              <1> 							;             else
  2615                              <1> 							;             {
  2616                              <1> 							;                /*******************************************
  2617                              <1> ;	only a device zero page index will do		; 			page pointer to system memory
  2618                              <1> 							;                *******************************************/
  2619                              <1> page_pointer?:						; 
  2620 0000107A F6C102              <1> 	test	cl, MEMZERONLY				;                if ((value & 0x00400000) == 0)
  2621 0000107D 7493                <1> 	jz	no_rule					;                {
  2622 0000107F F7C30000C000        <1> 	test	ebx, 00C00000h				;                   if (value > (base[128] & 0x003FFFFF))
  2623 00001085 758B                <1> 	jnz	no_authority				;                   {
  2624                              <1> 							;                   }
  2625                              <1> memory_page_pointer:					;                   else
  2626 00001087 8B8EE0060000        <1> 	mov	ecx, dword ptr [rsi+IO_PORT+128*4]	;                   {
  2627 0000108D 81E1FFFF3F00        <1> 	and	ecx, 003FFFFFh				;                      base[ea] = value;
  2628 00001093 81E3FFFFFF00        <1> 	and	ebx, 00FFFFFFh				;                      return;
  2629 00001099 39D9                <1> 	cmp	ecx, ebx				;                   }
  2630 0000109B 7208                <1> 	jb	outwith					;                }
  2631 0000109D 899C86E0040000      <1> 	mov	dword ptr [rsi+IO_PORT+rax*4], ebx	;             }
  2632 000010A4 C3                  <1> 	ret						;          }
  2633                              <1> 							;       }
  2634                              <1> 							;    }
  2635                              <1> outwith:						; 
  2636 000010A5 B90E000000          <1> 	mov	ecx, LP_ADDRESS				;    GUARD_AUTHORITY;
  2637 000010AA E9FF000000          <1> 	jmp	guard_ii_escape				; }							; 
  2638                                  	%include	"ii.msm"
  2639 000010AF 67660986B0040000    <1> _on:	or	word ptr [esi+PSR], ax	; only touch low-order 16 bits
  2640 000010B7 C3                  <1> 	ret
  2641                              <1> 
  2642 000010B8 6635FFFF            <1> _off:	xor	ax, 0000FFFFh
  2643 000010BC 67662186B0040000    <1> 	and	word ptr [esi+PSR], ax	; only touch low-order 16 bits
  2644 000010C4 C3                  <1> 	ret
  2645                              <1> 
  2646                              <1> RELOAD_SMPP	equ	1
  2647                              <1> III_TRACE	equ	1
  2648                              <1> 
  2649                              <1> _xi:
  2650                              <1> 	%if	RELOAD_SMPP
  2651 000010C5 488BB560020000      <1> 	mov	rsi, qword ptr [rbp+CORE_INDEX1]
  2652                              <1> 	%endif
  2653                              <1> 
  2654 000010CC 20E4                <1> 	and	ah, ah				; 8 external interrupts?
  2655 000010CE 741B                <1> 	jz	_xix				; nane
  2656                              <1> 
  2657 000010D0 30C9                <1> 	xor	cl, cl
  2658                              <1> 
  2659                              <1> _xi_next:					; external interrupt pending signals[8]
  2660 000010D2 88A608060000        <1> 	mov	byte ptr [rsi+IO_PORT+74*4], ah	; position for inA|B from port XI_PENDING$	LL.mm.hh.zz
  2661 000010D8 C686A504000000      <1> 	mov	byte ptr [rsi+INDICATION+1], 0	; clear from platform indications fabric	ll.MM.hh.zz
  2662 000010DF 31C9                <1> 	xor	ecx, ecx			; clear latent param
  2663 000010E1 B802000000          <1> 	mov	eax, II_XINT			; select external interrupt
  2664                              <1> 
  2665 000010E6 E9F6000000          <1> 	jmp	_ii_
  2666                              <1> 	
  2667 000010EB A880                <1> _xix:	test	al, ATTENTION			; core2core interrupt
  2668 000010ED 0F8472000000        <1> 	jz	near _xiy
  2669                              <1> 
  2670 000010F3 BB01000000          <1> 	mov	ebx, 1
  2671 000010F8 48BF-               <1> 	mov	rdi, _core
  2672 000010FA [0000000000000000]  <1>
  2673                              <1> 
  2674                              <1> _xi_atn_sources:
  2675                              <1> 
  2676 00001102 F78618060000FFFFFF- <1> 	test	dword ptr [rsi+IO_PORT+_MCAST_PENDING], -1
  2677 0000110B FF                  <1>
  2678 0000110C 7450                <1> 	jz	_xi_atn_sources_all				; i.e. all cleared
  2679 0000110E 859E18060000        <1> 	test	dword ptr [rsi+IO_PORT+_MCAST_PENDING], ebx	; this source cleared?
  2680 00001114 7438                <1> 	jz	_xi_atn_source_next				; i.e. this one cleared
  2681                              <1> 
  2682 00001116 319E18060000        <1> 	xor	dword ptr [rsi+IO_PORT+_MCAST_PENDING], ebx	; clear pending source
  2683                              <1> 
  2684 0000111C 8B8F1C060000        <1> 	mov	ecx, dword ptr [rdi+IO_PORT+_MCAST_TO]		; latent parameter from sending side
  2685 00001122 81E1FFFFFF00        <1> 	and	ecx, 00FFFFFFh					; relay updated dayclock?
  2686 00001128 740A                <1> 	jz	_xi_atn_dayclock				; yes
  2687                              <1> 
  2688 0000112A B805000000          <1> 	mov	eax, II_ATTENTION				; no
  2689 0000112F E9AD000000          <1> 	jmp	_ii_						; _ii_ takes ecx for
  2690                              <1> 								; interrupt latent parameter
  2691                              <1> _xi_atn_dayclock:
  2692 00001134 488B8758020000      <1> 	mov	rax, qword ptr [rdi+REGISTER+DAYCLOCK_U]
  2693 0000113B 48898658020000      <1> 	mov	qword ptr [rsi+REGISTER+DAYCLOCK_U], rax
  2694                              <1> 
  2695 00001142 8B8774060000        <1> 	mov	eax, dword ptr [rdi+IO_PORT+_TZONE]
  2696 00001148 898674060000        <1> 	mov	dword ptr [rsi+IO_PORT+_TZONE], eax
  2697                              <1> 
  2698                              <1> _xi_atn_source_next:
  2699 0000114E D1E3                <1> 	shl	ebx, 1
  2700 00001150 720C                <1> 	jc	_xi_atn_sources_all
  2701 00001152 4881C7E0070000      <1> 	add	rdi, CORE_SIZE
  2702 00001159 E9A4FFFFFF          <1> 	jmp	_xi_atn_sources
  2703                              <1> 
  2704                              <1> _xi_atn_sources_all:
  2705 0000115E 80B6A404000080      <1> 	xor	byte ptr [rsi+INDICATION], ATTENTION
  2706                              <1> 
  2707 00001165 8B86A4040000        <1> _xiy:	mov	eax, dword ptr [rsi+INDICATION]			; case we did _xix in the same sweep
  2708 0000116B F686A404000040      <1> 	test	byte ptr [rsi+INDICATION], INCREMENTER_CARRY	; nanosecond or other counter 
  2709 00001172 7413                <1> 	jz	_xiz						; from minus to carrry on zero
  2710                              <1> 								; to feed millisecond dayclock
  2711 00001174 80B6A404000040      <1> 	xor	byte ptr [rsi+INDICATION], INCREMENTER_CARRY
  2712 0000117B B804000000          <1> 	mov	eax, II_MSECOND
  2713 00001180 31C9                <1> 	xor	ecx, ecx
  2714 00001182 E95A000000          <1> 	jmp	_ii_
  2715                              <1> 
  2716 00001187 C3                  <1> _xiz:	ret
  2717                              <1> 
  2718                              <1> _ii_instruction:
  2719 00001188 89C3                <1> 	mov	ebx, eax
  2720 0000118A C1EB06              <1> 	shr	ebx, 6
  2721 0000118D 672B9E00060000      <1> 	sub	ebx, dword ptr [esi+IO_PORT+72*4]	; application threshold
  2722 00001194 7913                <1> 	jns	guard_ii_authority	; must have executed a character string
  2723                              <1> 					; like 757575
  2724 00001196 A9C0FFFFFF          <1> 	test	eax, -64
  2725 0000119B 7524                <1> 	jnz	_ii			; not in restart page OK
  2726 0000119D F786B004000000350C- <1> 	test	dword ptr [rsi+PSR], 00800000
  2727 000011A6 00                  <1>
  2728 000011A7 7518                <1> 	jnz	_ii			; ISR may interrupt to restart page
  2729                              <1> 
  2730                              <1> 					; service call application to restart page not allowed
  2731                              <1> 					; most likely to be an accident
  2732                              <1> 					; drop thru and be quelled
  2733                              <1> 
  2734                              <1> guard_ii_authority:
  2735 000011A9 B901000000          <1> 	mov	ecx, LP_AUTHORITY
  2736                              <1> guard_ii_escape:
  2737 000011AE B85F000000          <1> 	mov	eax, II_GUARD
  2738                              <1> _ii_escape:
  2739                              <1> 	%if	RELOAD_SMPP
  2740 000011B3 488BB560020000      <1> 	mov	rsi, qword ptr [rbp+CORE_INDEX1]	; read register 152 or 280
  2741                              <1> 	%endif						; depending ebp -> application / ISR registers
  2742                              <1> 
  2743 000011BA 488BA678040000      <1> 	mov	rsp, qword ptr [rsi+REGISTER+286*4]	; read esp at start of _execute
  2744                              <1> 
  2745 000011C1 3D5F000000          <1> _ii:	cmp	eax, II_GUARD
  2746 000011C6 7519                <1> 	jnz	_ii_
  2747 000011C8 F60425[19000000]01  <1> 	test	byte ptr [_uflag+'Z'-'A'], 1	; break to debug console?
  2748          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  2749 000011D0 740F                <1> 	jz	_ii_					; not if not opted
  2750 000011D2 808EA404000002      <1> 	or	byte ptr [rsi+INDICATION], LOCKSTEP
  2751 000011D9 800C25[00000000]02  <1> 	or	byte ptr [_general_indication], LOCKSTEP
  2752          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  2753                              <1> 	
  2754 000011E1 488DAE00020000      <1> _ii_:	lea	rbp, [rsi+128*4] 
  2755                              <1> 
  2756 000011E8 4889AE98040000      <1> 	mov	qword ptr [rsi+REGISTER_SET], rbp
  2757 000011EF C786AC040000800000- <1> 	mov	dword ptr [rsi+ISELECT], 128
  2758 000011F8 00                  <1>
  2759                              <1> 
  2760 000011F9 8B5D3C              <1> 	mov	ebx, dword ptr [rbp+S_P]
  2761 000011FC 81FB00010000        <1> 	cmp	ebx, 256
  2762 00001202 0F87F4010000        <1> 	ja	near guard_stack
  2763 00001208 81C3FCFFFFFF        <1> 	add	ebx, -4
  2764                              <1> 
  2765 0000120E 81FB9A000000        <1> 	cmp	ebx, 128+24+2
  2766 00001214 0F82E2010000        <1> 	jb	near guard_stack
  2767 0000121A 895D3C              <1> 	mov	dword ptr [rbp+S_P], ebx
  2768                              <1> 
  2769 0000121D 4C2BA690040000      <1> 	sub	r12, qword ptr [rsi+B0P]		; platform-relative absolute program counter
  2770 00001224 49C1EC02            <1> 	shr	r12, 2
  2771 00001228 4489649E0C          <1> 	mov	dword ptr [rsi+rbx*4+REGISTER+3*4], r12d	; save PC offset
  2772 0000122D 8B96B4040000        <1> 	mov	edx, dword ptr [rsi+B0_NAME]
  2773 00001233 89549E08            <1> 	mov	dword ptr [rsi+rbx*4+REGISTER+2*4], edx	; save bank ID
  2774 00001237 8B96B0040000        <1> 	mov	edx, dword ptr [rsi+PSR]
  2775 0000123D 89549E04            <1> 	mov	dword ptr [rsi+rbx*4+REGISTER+4], edx	; saved PSR
  2776 00001241 890C9E              <1> 	mov	dword ptr [rsi+rbx*4+REGISTER], ecx	; latent parameter
  2777 00001244 F7C200008000        <1> 	test	edx, 00800000h				; nested interrupt ?
  2778 0000124A 7503                <1> 	jnz	_ii_ii
  2779 0000124C 895D38              <1> 	mov	dword ptr [rbp+FP], ebx			; if not, mark interrupted
  2780                              <1> 							; application stack frame
  2781                              <1> _ii_ii:
  2782 0000124F 81CA00008000        <1> 	or	edx, 00800000h				; ISR active
  2783 00001255 8996B0040000        <1> 	mov	dword ptr [rsi+PSR], edx
  2784                              <1> 
  2785 0000125B 89C2                <1> 	mov	edx, eax				; get to the operand
  2786 0000125D 81E23F000000        <1> 	and	edx, 63					; vector offset
  2787 00001263 C1E806              <1> 	shr	eax, 6					; vector start page index
  2788 00001266 25FF030000          <1> 	and	eax, 000003FFh				; eax -> page containing ISR ; edx  -> vector
  2789 0000126B 31DB                <1> 	xor	ebx, ebx				; single page ISR
  2790 0000126D E9D5060000          <1> 	jmp	_go2_frame
  2791                              <1> 
  2792                              <1> ;	_ir	sign extended ea is in eax
  2793                              <1> 
  2794 00001272 67F786B00400000000- <1> _ir:	test	dword ptr [esi+PSR], 00800000h		; eax = EA = variation on return offset
  2795 0000127B 8000                <1>
  2796 0000127D 0F8426FFFFFF        <1> 	jz	guard_ii_authority			; not good to do Interrupt Return from application space
  2797                              <1> 
  2798                              <1> 							; r12 stays the same until return is finalised
  2799                              <1> 							; in case the operation interrupts itself
  2800 00001283 89C2                <1> 	mov	edx, eax				; +- displacement operand, offset in stack added later
  2801                              <1> 
  2802 00001285 E8AA010000          <1> 	call	stack_read4				; [rbp+rbx*4] -> interrupt stack frame
  2803                              <1> 							; interrupt stack pointer is already updated ebx+4
  2804                              <1> 
  2805 0000128A 8B449E08            <1> 	mov	eax, dword ptr [rsi+rbx*4+2*4]		; interrupted b0_name
  2806                              <1> 
  2807 0000128E 8B4C9E04            <1> 	mov	ecx, dword ptr [rsi+rbx*4+1*4]		; interrupted psr
  2808                              <1> 
  2809 00001292 03549E0C            <1> 	add	edx, dword ptr [rsi+rbx*4+3*4]		; add interrupted iframe offset to EA
  2810 00001296 81E2FFFF3F00        <1> 	and	edx, 03FFFFFh				;
  2811                              <1> 
  2812 0000129C 31DB                <1> 	xor	ebx, ebx				; iframe default page high index  
  2813 0000129E A900008000          <1> 	test	eax, 00800000h				; +page[s] flag on b0_name ?
  2814 000012A3 7418                <1> 	jz	ir_4k_iframe				; 1-page iframe return target
  2815                              <1> 
  2816 000012A5 89C3                <1> 	mov	ebx, eax
  2817 000012A7 C1E30A              <1> 	shl	ebx, 2+8				; drop the flag bit from iframe name
  2818 000012AA 48C1E302            <1> 	shl	rbx, 12-10				; complete the multiplication * page 
  2819                              <1> 
  2820                              <1> 	%if	__MOVBE
  2821                              <1> 	movbe	ebx, dword ptr [rbx*4+64*4+_memory]
  2822                              <1> 	%else
  2823 000012AE 8B1C9D[00010000]    <1> 	mov	ebx, dword ptr [rbx*4+64*4+_memory]	; read the embedded gate table
  2824          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  2825 000012B5 30C0                <1> 	xor	al, al
  2826 000012B7 0FCB                <1> 	bswap	ebx
  2827                              <1> 	%endif
  2828                              <1> 
  2829 000012B9 48C1EB12            <1> 	shr	rbx, 18					; <- iframe page high index
  2830                              <1> 
  2831                              <1> ir_4k_iframe:
  2832 000012BD 898EB0040000        <1> 	mov	dword ptr [rsi+PSR], ecx
  2833 000012C3 F7C100008000        <1> 	test	ecx, 00800000h				; returning ISR -> ISR ?
  2834 000012C9 741D                <1> 	jz	ir_application				; no
  2835                              <1> 
  2836 000012CB 488DAE00020000      <1> 	lea	rbp, [rsi+REGISTER+128*4]		; for nested interrupts
  2837 000012D2 4889AE98040000      <1> 	mov	qword ptr [rsi+REGISTER_SET], rbp	; interrupt register set. presumably already so
  2838 000012D9 C786AC040000800000- <1> 	mov	dword ptr [rsi+ISELECT], 128		; interrupt register set
  2839 000012E2 00                  <1>
  2840 000012E3 E95F060000          <1> 	jmp	_go2_frame				; yes
  2841                              <1> 
  2842                              <1> ir_application:
  2843 000012E8 4889F5              <1> 	mov	rbp, rsi				; application register set
  2844 000012EB 4889AE98040000      <1> 	mov	qword ptr [rsi+REGISTER_SET], rbp
  2845 000012F2 C786AC040000000000- <1> 	mov	dword ptr [rsi+ISELECT], 0
  2846 000012FB 00                  <1>
  2847 000012FC E946060000          <1> 	jmp	_go2_frame				; eax <- reload iframe name
  2848                              <1> 							; ebx <- reload iframe page high index
  2849                              <1> 							; edx <- return word offset
  2850                                  	%include	"stack.msm"
  2851                              <1> ;	stack operations call these to add or subract stack
  2852                              <1> ;	limits are checked here
  2853                              <1> ;	these routines always leave epb -> all registers 0..255
  2854                              <1> ;	because both  interrupt internal stack pointer register 128 + 15
  2855                              <1> ;		and application internal stack pointer register 15
  2856                              <1> 
  2857                              <1> ;	are absolute pointers to the entire register stack
  2858                              <1> 
  2859                              <1> ;	therefore instructions calling here must afterwards
  2860                              <1> 
  2861                              <1> ;		mov	ebp, dword ptr [_register_set]
  2862                              <1> 
  2863                              <1> ;	to get ebp back to application registers 0..127
  2864                              <1> ;			or interrupt registers 128..255
  2865                              <1> 
  2866                              <1> ;	ebp governs which r k x y a b mantissa2 mantissa3 fp sp is implied in the instruction opcode
  2867                              <1> ;	registers addressed as operand are always absolute in the range 0..255
  2868                              <1> 
  2869                              <1> ;	these don't move any data but leave [ebp+ebx*4] pointing to the required stack frame
  2870                              <1> ;	and update the stack pointer
  2871                              <1> 
  2872                              <1> ;	although applications can and must read interrupt registers with load instructions
  2873                              <1> ;	they can't read interrupt registers with runaway pop instructions
  2874                              <1> ;	because the problem is easier to find with an interrupt as soon as 128+ gets popped
  2875                              <1> 
  2876                              <1> 
  2877                              <1> 
  2878                              <1> stack1:
  2879                              <1> 	%if	0
  2880                              <1> 	mov	ebx, dword ptr [ebp+S_P]
  2881                              <1> 	dec	ebx
  2882                              <1> 	mov	dword ptr [ebp+S_P], ebx
  2883                              <1> 	ret
  2884                              <1> 	%endif
  2885                              <1> 
  2886 00001301 8B5D3C              <1> 	mov	ebx, dword ptr [rbp+S_P]	; read whichever internal sp
  2887 00001304 F686B204000080      <1> 	test	byte ptr [rsi+PSR+2], 128	; ISR ?
  2888 0000130B 742C                <1> 	jz	stack1_a			; no ?
  2889 0000130D 81FB00010000        <1> 	cmp	ebx, 256			; in upper range ?
  2890 00001313 0F87E3000000        <1> 	ja	near guard_stack		; no ?
  2891 00001319 FFCB                <1> 	dec	ebx				; decrement
  2892 0000131B 0F88DB000000        <1> 	js	near guard_stack		; < 0 ?
  2893 00001321 81FB9A000000        <1> 	cmp	ebx, 128+24+2			; in clock registers?
  2894 00001327 730C                <1> 	jnb	stack1_j			;
  2895 00001329 81FB80000000        <1> 	cmp	ebx, 128			; in app stack? Allowed for thread switch
  2896 0000132F 0F83C7000000        <1> 	jnb	near guard_stack		; in working registers page
  2897                              <1> stack1_j:
  2898 00001335 895D3C              <1> 	mov	dword ptr [rbp+S_P], ebx	; new frame
  2899 00001338 C3                  <1> 	ret
  2900                              <1> 
  2901                              <1> stack1_a:					; this is application
  2902 00001339 81FB80000000        <1> 	cmp	ebx, 128			; > interrupt register range start
  2903 0000133F 0F87B7000000        <1> 	ja	near guard_stack		; not allowed
  2904 00001345 FFCB                <1> 	dec	ebx				; decrement
  2905 00001347 0F88AF000000        <1> 	js	near guard_stack		; < 0 ?
  2906 0000134D 81FB18000000        <1> 	cmp	ebx, 24				; in control registers ?
  2907 00001353 0F82A3000000        <1> 	jb	near guard_stack		; not allowed
  2908 00001359 895D3C              <1> 	mov	dword ptr [rbp+S_P], ebx	; new frame
  2909 0000135C C3                  <1> 	ret
  2910                              <1> 
  2911                              <1> stack2:
  2912                              <1> 	%if	0
  2913                              <1> 	mov	ebx, dword ptr [ebp+S_P]
  2914                              <1> 	add	ebx, -2
  2915                              <1> 	mov	dword ptr [ebp+S_P], ebx
  2916                              <1> 	ret
  2917                              <1> 	%endif
  2918                              <1> 
  2919 0000135D 8B5D3C              <1> 	mov	ebx, dword ptr [rbp+S_P]
  2920 00001360 F686B204000080      <1> 	test	byte ptr [rsi+PSR+2], 128
  2921 00001367 7430                <1> 	jz	stack2_a
  2922 00001369 81FB00010000        <1> 	cmp	ebx, 256
  2923 0000136F 0F8787000000        <1> 	ja	near guard_stack
  2924 00001375 81C3FEFFFFFF        <1> 	add	ebx, -2
  2925 0000137B 0F887B000000        <1> 	js	near guard_stack
  2926 00001381 81FB98000000        <1> 	cmp	ebx, 128+24
  2927 00001387 730C                <1> 	jnb	stack2_j
  2928 00001389 81FB7E000000        <1> 	cmp	ebx, 128-2
  2929 0000138F 0F8767000000        <1> 	ja	near guard_stack
  2930                              <1> 
  2931                              <1> stack2_j:
  2932 00001395 895D3C              <1> 	mov	dword ptr [rbp+S_P], ebx
  2933 00001398 C3                  <1> 	ret
  2934                              <1> 
  2935                              <1> stack2_a:
  2936 00001399 81FB80000000        <1> 	cmp	ebx, 128			; application push high limit 128,  ISR 256
  2937 0000139F 775B                <1> 	ja	guard_stack
  2938 000013A1 81C3FEFFFFFF        <1> 	add	ebx, -2
  2939 000013A7 7853                <1> 	js	guard_stack
  2940 000013A9 81FB18000000        <1> 	cmp	ebx, 24
  2941 000013AF 724B                <1> 	jb	guard_stack			; stack top limit zero ISR and application
  2942 000013B1 895D3C              <1> 	mov	dword ptr [rbp+S_P], ebx
  2943 000013B4 C3                  <1> 	ret
  2944                              <1> 
  2945                              <1> stack4:
  2946                              <1> 	%if	0
  2947                              <1> 	mov	ebx, dword ptr [ebp+S_P]
  2948                              <1> 	add	ebx, -4
  2949                              <1> 	mov	dword ptr [ebp+S_P], ebx
  2950                              <1> 	ret
  2951                              <1> 	%endif
  2952                              <1> 
  2953 000013B5 8B5D3C              <1> 	mov	ebx, dword ptr [rbp+S_P]
  2954 000013B8 F686B204000080      <1> 	test	byte ptr [rsi+PSR+2], 128	; read psr interrupt bit
  2955 000013BF 7422                <1> 	jz	stack4_a			; stack is registers 24..127
  2956 000013C1 81FB00010000        <1> 	cmp	ebx, 256			; stack is registers  0..255
  2957 000013C7 7733                <1> 	ja	guard_stack
  2958 000013C9 81C3FCFFFFFF        <1> 	add	ebx, -4				; proposed frame
  2959 000013CF 782B                <1> 	js	guard_stack			; not lower than register zero
  2960 000013D1 81FB98000000        <1> 	cmp	ebx, 128+24
  2961 000013D7 7306                <1> 	jnb	stack4_j
  2962 000013D9 81FB7C000000        <1> 	cmp	ebx, 128-4			; in working registers page
  2963                              <1> ;	ja	guard_stack			; caller does that
  2964                              <1> 
  2965                              <1> stack4_j:
  2966 000013DF 895D3C              <1> 	mov	dword ptr [rbp+S_P], ebx
  2967 000013E2 C3                  <1> 	ret					; both sp are absolute pointers
  2968                              <1> 
  2969                              <1> stack4_a:
  2970 000013E3 81FB80000000        <1> 	cmp	ebx, 128			; don't push into a higher register than 127
  2971 000013E9 7711                <1> 	ja	guard_stack
  2972 000013EB 81C3FCFFFFFF        <1> 	add	ebx, -4
  2973 000013F1 7809                <1> 	js	guard_stack
  2974 000013F3 81FB18000000        <1> 	cmp	ebx, 24				; dont push lower than 24
  2975 000013F9 7201                <1> 	jb	guard_stack
  2976                              <1> ;	mov	dword ptr [rbp+S_P], ebx	; caller does that
  2977 000013FB C3                  <1> 	ret					; return new frame
  2978                              <1> 
  2979                              <1> guard_stack:
  2980                              <1> stack_underflow:
  2981 000013FC 8BAE98040000        <1> 	mov	ebp, dword ptr [rsi+REGISTER_SET] ; esi -> core.REGISTER
  2982 00001402 F786B0040000000080- <1> 	test	dword ptr [rsi+PSR], 00800000h	; interrupt mode?
  2983 0000140B 00                  <1>
  2984 0000140C 0F8497FDFFFF        <1> 	jz	guard_ii_authority		; sideline the application
  2985 00001412 C7453C00010000      <1> 	mov	dword ptr [rbp+S_P], 256	; restart the interrupt stack
  2986 00001419 B801000000          <1> 	mov	eax, 1				; so the interrupt can be interrupted
  2987 0000141E F60425[19000000]01  <1> 	test	byte ptr [_uflag+'Z'-'A'], 1
  2988          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  2989 00001426 7407                <1> 	jz	gsago
  2990 00001428 808EA404000002      <1> 	or	byte ptr [rsi+INDICATION], LOCKSTEP
  2991 0000142F E97FFDFFFF          <1> gsago:	jmp	_ii_escape
  2992                              <1> 
  2993                              <1> stack_read4:
  2994 00001434 BB04000000          <1> 	mov	ebx, 4
  2995 00001439 035D3C              <1> 	add	ebx, dword ptr [rbp+S_P]
  2996 0000143C 81FB80000000        <1> 	cmp	ebx, 128			; you can have stack locations up to here
  2997 00001442 7611                <1> 	jna	stack_r4			; whoever you are
  2998 00001444 F686B204000080      <1> 	test	byte ptr [rsi+PSR+2], 128	; any higher you have to be an ISR
  2999 0000144B 74AF                <1> 	jz	stack_underflow
  3000 0000144D 81FB00010000        <1> 	cmp	ebx, 256			; and then not any higher than this
  3001 00001453 77A7                <1> 	ja	stack_underflow
  3002                              <1> 
  3003                              <1> stack_r4:
  3004 00001455 875D3C              <1> 	xchg	ebx, dword ptr [rbp+S_P]	; write new stack top
  3005 00001458 C3                  <1> 	ret					; return old stack top
  3006                              <1> 
  3007                              <1> stack_read2:
  3008 00001459 BB02000000          <1> 	mov	ebx, 2
  3009 0000145E 035D3C              <1> 	add	ebx, dword ptr [rbp+S_P]
  3010 00001461 81FB80000000        <1> 	cmp	ebx, 128			; you can have stack locations up to here
  3011 00001467 7611                <1> 	jna	stack_r2			; whoever you are
  3012 00001469 F686B204000080      <1> 	test	byte ptr [rsi+PSR+2], 128	; any higher you have to be an ISR
  3013 00001470 748A                <1> 	jz	stack_underflow
  3014 00001472 81FB00010000        <1> 	cmp	ebx, 256			; and then not any higher than this
  3015 00001478 7782                <1> 	ja	stack_underflow
  3016                              <1> 
  3017                              <1> stack_r2:
  3018 0000147A 875D3C              <1> 	xchg	ebx, dword ptr [rbp+S_P]	; write new stack top
  3019 0000147D C3                  <1> 	ret					; return old stack top
  3020                              <1> 
  3021                              <1> stack_read1:
  3022 0000147E BB01000000          <1> 	mov	ebx, 1				; calculate
  3023 00001483 035D3C              <1> 	add	ebx, dword ptr [rbp+S_P]	; new stack top
  3024 00001486 81FB80000000        <1> 	cmp	ebx, 128			; you can have stack locations up to here
  3025 0000148C 7619                <1> 	jna	stack_r1			; whoever you are
  3026 0000148E F686B204000080      <1> 	test	byte ptr [rsi+PSR+2], 128	; any higher you have to be an ISR
  3027 00001495 0F8461FFFFFF        <1> 	jz	stack_underflow
  3028 0000149B 81FB00010000        <1> 	cmp	ebx, 256			; and then not any higher than this
  3029 000014A1 0F8755FFFFFF        <1> 	ja	stack_underflow
  3030                              <1> 
  3031                              <1> stack_r1:
  3032 000014A7 875D3C              <1> 	xchg	ebx, dword ptr [rbp+S_P]	; write new stack top
  3033 000014AA C3                  <1> 	ret					; return old stack top
  3034                              <1> 
  3035                                  	%include	"return.msm"
  3036                              <1> _autoexit:
  3037 000014AB B846000000          <1> 	mov	eax, II_EXIT
  3038 000014B0 B90B000000          <1> 	mov	ecx, LP_AUTOEXIT
  3039 000014B5 E9F9FCFFFF          <1> 	jmp	_ii_escape
  3040                              <1> 
  3041 000014BA F786B0040000000080- <1> _lret:	test	dword ptr [rsi+PSR], 00800000h
  3042 000014C3 00                  <1>
  3043 000014C4 7509                <1> 	jnz	_lret_
  3044                              <1> 
  3045 000014C6 817D3C80000000      <1> 	cmp	dword ptr [rbp+S_P], 128
  3046 000014CD 74DC                <1> 	jz	_autoexit
  3047                              <1> 
  3048 000014CF E8AAFFFFFF          <1> _lret_:	call	stack_read1
  3049 000014D4 03049E              <1> 	add	eax, dword ptr [rsi+rbx*4]
  3050 000014D7 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
  3051 000014DC E93B020000          <1> 	jmp	_j
  3052                              <1> 
  3053 000014E1 F786B0040000000080- <1> _fret:	test	dword ptr [rsi+PSR], 00800000h
  3054 000014EA 00                  <1>
  3055 000014EB 7509                <1> 	jnz	_fret_
  3056                              <1> 
  3057 000014ED 817D3C80000000      <1> 	cmp	dword ptr [rbp+S_P], 128
  3058 000014F4 74B5                <1> 	jz	_autoexit
  3059                              <1> 
  3060 000014F6 E85EFFFFFF          <1> _fret_:	call	stack_read2
  3061 000014FB 4C89A680040000      <1> 	mov	qword ptr [rsi+APC],r12
  3062 00001502 4889C2              <1> 	mov	rdx, rax
  3063 00001505 03549E04            <1> 	add	edx, dword ptr [rsi+rbx*4+1*4]	; add EA as displacement to offset on stack
  3064 00001509 8B049E              <1> 	mov	eax, dword ptr [rsi+rbx*4]	; return b0_name
  3065 0000150C 31DB                <1> 	xor	ebx, ebx			; 1-page frame?
  3066 0000150E A900008000          <1> 	test	eax, 00800000h			; multipages frame?
  3067 00001513 7418                <1> 	jz	_fret_1page
  3068                              <1> 
  3069 00001515 89C3                <1> 	mov	ebx, eax
  3070 00001517 C1E30A              <1> 	shl	ebx, 2+8			; drop flag bit from b0_name
  3071 0000151A 48C1E302            <1> 	shl	rbx, 12-10			; complete multiplication * page
  3072                              <1> 
  3073                              <1> 	%if	__MOVBE				; read the embedded gate table
  3074                              <1> 	movbe	ebx, dword ptr [_memory+rbx*4+64*4]
  3075                              <1> 	%else
  3076 0000151E 8B1C9D[00010000]    <1> 	mov	ebx, dword ptr [_memory+rbx*4+64*4]
  3077          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  3078 00001525 30C0                <1> 	xor	al, al
  3079 00001527 0FCB                <1> 	bswap	ebx
  3080                              <1> 	%endif
  3081                              <1> 
  3082 00001529 48C1EB12            <1> 	shr	rbx, 18				; ebx <- iframe page high index
  3083                              <1> 
  3084                              <1> _fret_1page:					; eax <- iframe name
  3085 0000152D E915040000          <1> 	jmp	_go2_frame			; edx <- word offset
  3086                              <1> 
  3087 00001532 B803000000          <1> _fpxpo:	mov	eax, II_FPXPO
  3088 00001537 B90C000000          <1> 	mov	ecx, LP_RANGE
  3089 0000153C E972FCFFFF          <1> 	jmp	_ii_escape
  3090                              <1> 
  3091                                  	%include	"rta.msm"
  3092                              <1> 
  3093 00001541 80F904              <1> _sr:	cmp	cl, I
  3094 00001544 0F842AF8FFFF        <1> 	jz	_inA
  3095 0000154A 80F905              <1> 	cmp	cl, XI
  3096 0000154D 0F845CFBFFFF        <1> 	jz	_on
  3097                              <1> 
  3098 00001553 8B5D00              <1> 	mov	ebx, dword ptr [rbp+R]
  3099 00001556 E98AF1FFFF          <1> 	jmp	_operand_write
  3100                              <1> 
  3101 0000155B 80F904              <1> _sk:	cmp	cl, I
  3102 0000155E 0F841DF8FFFF        <1> 	jz	_inB
  3103 00001564 80F905              <1> 	cmp	cl, XI
  3104 00001567 0F844BFBFFFF        <1> 	jz	_off
  3105                              <1> 
  3106 0000156D 8B5D04              <1> 	mov	ebx, dword ptr [rbp+K]
  3107 00001570 E970F1FFFF          <1> 	jmp	_operand_write
  3108                              <1> 
  3109 00001575 80F904              <1> _sx:	cmp	cl, I
  3110 00001578 0F8410F8FFFF        <1> 	jz	_outA
  3111 0000157E 80F905              <1> 	cmp	cl, XI
  3112 00001581 0F84EBF6FFFF        <1> 	jz	_rsr
  3113                              <1> 
  3114 00001587 8B5D08              <1> 	mov	ebx, dword ptr [rbp+X]
  3115 0000158A E956F1FFFF          <1> 	jmp	_operand_write
  3116                              <1> 
  3117 0000158F 80F904              <1> _sy:	cmp	cl, I
  3118 00001592 0F84FFF7FFFF        <1> 	jz	_outB
  3119 00001598 80F905              <1> 	cmp	cl, XI
  3120 0000159B 0F8445F7FFFF        <1> 	jz	_wsr
  3121                              <1> 
  3122 000015A1 8B5D0C              <1> 	mov	ebx, dword ptr [rbp+Y]
  3123 000015A4 E93CF1FFFF          <1> 	jmp	_operand_write;
  3124                              <1> 
  3125 000015A9 80F904              <1> _sa:	cmp	cl, I
  3126 000015AC 0F84A6F8FFFF        <1> 	jz	_reload
  3127 000015B2 80F905              <1> 	cmp	cl, XI
  3128 000015B5 7452                <1> 	jz	escape
  3129                              <1> 
  3130 000015B7 8B5D10              <1> 	mov	ebx, dword ptr [rbp+A]
  3131 000015BA E926F1FFFF          <1> 	jmp	_operand_write
  3132                              <1> 
  3133 000015BF 80F904              <1> _sb:	cmp	cl, I
  3134 000015C2 0F84B7F8FFFF        <1> 	jz	_emulator_cool
  3135 000015C8 80F905              <1> 	cmp	cl, XI
  3136 000015CB 743C                <1> 	jz	escape
  3137                              <1> 
  3138 000015CD 8B5D14              <1> 	mov	ebx, dword ptr [rbp+B]
  3139 000015D0 E910F1FFFF          <1> 	jmp	_operand_write
  3140                              <1> 
  3141 000015D5 80F904              <1> _z:	cmp	cl, I
  3142 000015D8 0F84A7F8FFFF        <1> 	jz	_sabr
  3143 000015DE 80F905              <1> 	cmp	cl, XI
  3144 000015E1 0F84D3FEFFFF        <1> 	jz	_lret
  3145 000015E7 31DB                <1> 	xor	ebx, ebx
  3146 000015E9 E9F7F0FFFF          <1> 	jmp	_operand_write
  3147                              <1> 
  3148 000015EE 80F904              <1> _pop:	cmp	cl, I
  3149 000015F1 7416                <1> 	jz	escape
  3150 000015F3 80F905              <1> 	cmp	cl, XI
  3151 000015F6 0F84E5FEFFFF        <1> 	jz	_fret
  3152                              <1> 
  3153 000015FC E87DFEFFFF          <1> 	call	stack_read1
  3154 00001601 8B1C9E              <1> 	mov	ebx, dword ptr [rsi+rbx*4]
  3155 00001604 E9DCF0FFFF          <1> 	jmp	_operand_write
  3156                              <1> 
  3157 00001609 C3                  <1> escape	ret
  3158                              <1> 
  3159 0000160A E803EFFFFF          <1> _lr:	call	_operand_read
  3160 0000160F 894500              <1> 	mov	dword ptr [rbp+R], eax
  3161 00001612 C3                  <1> 	ret
  3162                              <1> 
  3163 00001613 E8FAEEFFFF          <1> _lk:	call	_operand_read
  3164 00001618 894504              <1> 	mov	dword ptr [rbp+K], eax
  3165 0000161B C3                  <1> 	ret
  3166 0000161C E8F1EEFFFF          <1> _lx:	call	_operand_read
  3167 00001621 894508              <1> 	mov	dword ptr [rbp+X], eax
  3168 00001624 C3                  <1> 	ret
  3169                              <1> 
  3170 00001625 E8E8EEFFFF          <1> _ly:	call	_operand_read
  3171 0000162A 89450C              <1> 	mov	dword ptr [rbp+Y], eax
  3172 0000162D C3                  <1> 	ret
  3173                              <1> 
  3174 0000162E E8DFEEFFFF          <1> _la:	call	_operand_read
  3175 00001633 894510              <1> 	mov	dword ptr [rbp+A], eax
  3176 00001636 C3                  <1> 	ret
  3177                              <1> 
  3178 00001637 E8D6EEFFFF          <1> _lb:	call	_operand_read
  3179 0000163C 894514              <1> 	mov	dword ptr [rbp+B], eax
  3180 0000163F C3                  <1> 	ret
  3181                              <1> 
  3182 00001640 80F904              <1> _tz:	cmp	cl, I
  3183 00001643 0F84F8140000        <1> 	jz	near _rex
  3184 00001649 80F905              <1> 	cmp	cl, XI
  3185 0000164C B900000000          <1> 	mov	ecx, 0
  3186 00001651 0F8431FBFFFF        <1> 	jz	_ii_instruction
  3187                              <1> 
  3188 00001657 E8B6EEFFFF          <1> 	call	_operand_read
  3189 0000165C A9FFFFFF00          <1> 	test	eax, 00FFFFFFh
  3190 00001661 7507                <1> 	jnz	_tz_
  3191 00001663 4981C404000000      <1> 	add	r12, 4
  3192 0000166A C3                  <1> _tz_:	ret
  3193                              <1> 
  3194 0000166B 80F904              <1> _tp:	cmp	cl, I
  3195 0000166E 7432                <1> 	jz	_jdz
  3196 00001670 80F905              <1> 	cmp	cl, XI
  3197 00001673 0F84F9FBFFFF        <1> 	jz	_ir
  3198                              <1> 
  3199 00001679 E894EEFFFF          <1> 	call	_operand_read
  3200 0000167E A900008000          <1> 	test	eax, 00800000h
  3201 00001683 7507                <1> 	jnz	_tp_
  3202 00001685 4981C404000000      <1> 	add	r12, 4
  3203 0000168C C3                  <1> _tp_:	ret
  3204                              <1> 
  3205 0000168D E880EEFFFF          <1> _push:	call	_operand_read
  3206 00001692 488BB560020000      <1> 	mov	rsi, qword ptr [rbp+CORE_INDEX1]
  3207 00001699 E863FCFFFF          <1> 	call	stack1
  3208 0000169E 89049E              <1> 	mov	dword ptr [rsi+rbx*4], eax
  3209 000016A1 C3                  <1> 	ret
  3210                              <1> 
  3211 000016A2 8B5D14              <1> _jdz:	mov	ebx, dword ptr [rbp+B]
  3212 000016A5 0B5D10              <1> 	or	ebx, dword ptr [rbp+A]
  3213 000016A8 0F846E000000        <1> 	jz	near _j
  3214 000016AE C3                  <1> 	ret
  3215                              <1> 
  3216 000016AF 8B5D00              <1> _jdr:	mov	ebx, dword ptr [rbp+R]		; dec r and jump if it passed from zero to -1
  3217 000016B2 81C3FFFFFF00        <1> 	add	ebx, 00FFFFFFh
  3218 000016B8 C1C308              <1> 	rol	ebx, 8
  3219 000016BB 88D9                <1> 	mov	cl, bl
  3220 000016BD C1EB08              <1> 	shr	ebx, 8				; write back to registers only 00000000 thru 00FFFFFF
  3221 000016C0 895D00              <1> 	mov	dword ptr [rbp+R], ebx
  3222 000016C3 F6C101              <1> 	test	cl, 1
  3223 000016C6 7554                <1> 	jnz	_j
  3224 000016C8 C3                  <1> 	ret
  3225                              <1> 
  3226 000016C9 E833FCFFFF          <1> _lcal:	call	stack1
  3227 000016CE 4C89E2              <1> 	mov	rdx, r12
  3228 000016D1 482B9690040000      <1> 	sub	rdx, qword ptr [rsi+B0P]
  3229 000016D8 48C1EA02            <1> 	shr	rdx, 2
  3230 000016DC 89149E              <1> 	mov	dword ptr [rsi+rbx*4], edx
  3231                              <1> 
  3232                              <1> 	%if	0
  3233                              <1> 	shl	rax, 2
  3234                              <1> 	add	rax, qword ptr [rsi+B0P]
  3235                              <1> 	mov	r12, rax
  3236                              <1> 	ret
  3237                              <1> 	%endif
  3238                              <1> 
  3239 000016DF E938000000          <1> 	jmp	_j				; EA is in eax
  3240                              <1> 
  3241 000016E4 F786B0040000010000- <1> _jnc:	test	dword ptr [rsi+PSR], 1
  3242 000016ED 00                  <1>
  3243 000016EE 742C                <1> 	jz	_j
  3244 000016F0 C3                  <1> 	ret
  3245                              <1> 
  3246 000016F1 F786B0040000010000- <1> _jc:	test	dword ptr [rsi+PSR], 1
  3247 000016FA 00                  <1>
  3248 000016FB 751F                <1> 	jnz	_j
  3249 000016FD C3                  <1> 	ret
  3250                              <1> 
  3251 000016FE F7451001000000      <1> _jao:	test	dword ptr [rbp+A], 1
  3252 00001705 7515                <1> 	jnz	_j
  3253 00001707 C3                  <1> 	ret
  3254                              <1> 
  3255 00001708 F7451000008000      <1> _jpa:	test	dword ptr [rbp+A], 00800000h
  3256 0000170F 740B                <1> 	jz	_j
  3257 00001711 C3                  <1> 	ret
  3258                              <1> 
  3259 00001712 F7451400008000      <1> _jpb:	test	dword ptr [rbp+B], 00800000h
  3260 00001719 7401                <1> 	jz	_j
  3261 0000171B C3                  <1> 	ret
  3262                              <1> 
  3263 0000171C 48C1E002            <1> _j:	shl	rax, 2
  3264 00001720 48038690040000      <1> 	add	rax, qword ptr [rsi+B0P]
  3265                              <1> 
  3266                              <1> ;	cmp	rax, r13			; there is a range check on instr fetch but 
  3267                              <1> ;	ja	_j_check			; if a jump goes wrong the come-from address
  3268                              <1> 						; is more use in the interrupt frame
  3269 00001727 4989C4              <1> 	mov	r12, rax			; than a wild go-to address
  3270 0000172A C3                  <1> 	ret
  3271                              <1> 
  3272                              <1> _j_check:					; apc before is in rdx
  3273                              <1> 						; restore updated apc
  3274 0000172B B90E000000          <1> 	mov	ecx, LP_ADDRESS
  3275 00001730 E979FAFFFF          <1> 	jmp	guard_ii_escape			; for interrupt come-from
  3276                              <1> 
  3277 00001735 E880110000          <1> _jpo:	call	NEAR _get_parity
  3278 0000173A 7BE0                <1> 	jpo	_j
  3279 0000173C C3                  <1> 	ret
  3280                              <1> 
  3281 0000173D 816510FFFFFF00      <1> _jza:	and	dword ptr [rbp+A], 00FFFFFFh
  3282 00001744 74D6                <1> 	jz	_j
  3283 00001746 C3                  <1> 	ret
  3284                              <1> 
  3285 00001747 816514FFFFFF00      <1> _jzb:	and	dword ptr [rbp+B], 00FFFFFFh
  3286 0000174E 74CC                <1> 	jz	_j
  3287 00001750 C3                  <1> 	ret
  3288                              <1> 
  3289 00001751 816510FFFFFF00      <1> _jnza:	and	dword ptr [rbp+A], 00FFFFFFh
  3290 00001758 75C2                <1> 	jnz	_j
  3291 0000175A C3                  <1> 	ret
  3292                              <1> 
  3293 0000175B 816514FFFFFF00      <1> _jnzb:	and	dword ptr [rbp+B], 00FFFFFFh
  3294 00001762 75B8                <1> 	jnz	_j
  3295 00001764 C3                  <1> 	ret
  3296                              <1> 
  3297 00001765 F7451000008000      <1> _jna:	test	dword ptr [rbp+A], 00800000h
  3298 0000176C 75AE                <1> 	jnz	_j
  3299 0000176E C3                  <1> 	ret
  3300                              <1> 
  3301 0000176F F7451400008000      <1> _jnb:	test	dword ptr [rbp+B], 00800000h
  3302 00001776 75A4                <1> 	jnz	_j
  3303 00001778 C3                  <1> 	ret
  3304                              <1> 
  3305 00001779 8B5D08              <1> _jxge:	mov	ebx, dword ptr [rbp+X]
  3306 0000177C 2B5D00              <1> 	sub	ebx, dword ptr [rbp+R]
  3307 0000177F F7C300000001        <1> 	test	ebx, 01000000h		; microcarry?
  3308 00001785 7495                <1> 	jz	_j			; no:  x <  r,    jump
  3309 00001787 C3                  <1> 	ret				; yes: x >= r, no jump
  3310                              <1> 
  3311 00001788 8B5D0C              <1> _jyge:	mov	ebx, dword ptr [rbp+Y]
  3312 0000178B 2B5D00              <1> 	sub	ebx, dword ptr [rbp+R]
  3313 0000178E F7C300000001        <1> 	test	ebx, 01000000h		; microcarry?
  3314 00001794 7486                <1> 	jz	_j			; no:  y <  r,    jump
  3315 00001796 C3                  <1> 	ret				; yes: y >= r, no jump
  3316                              <1> 
  3317 00001797 BB04000000          <1> _qs:	mov	ebx, a
  3318 0000179C E9CAEEFFFF          <1> 	jmp	_burst_write4
  3319                              <1> 
  3320 000017A1 BB04000000          <1> _ql:	mov	ebx, a
  3321 000017A6 E937EDFFFF          <1> 	jmp	_burst_read4
  3322                              <1> 
  3323 000017AB E884FCFFFF          <1> _qpop:	call	stack_read4			; places 4 stack registers in the scope of burst write
  3324 000017B0 55                  <1> 	push	rbp
  3325 000017B1 67488BAD60020000    <1> 	mov	rbp, qword ptr [ebp+CORE_INDEX1] 
  3326 000017B9 E8ADEEFFFF          <1> 	call	_burst_write4
  3327 000017BE 5D                  <1> 	pop	rbp
  3328 000017BF C3                  <1> 	ret					; stack pointers are absolute
  3329                              <1> 
  3330 000017C0 E8F0FBFFFF          <1> _qpush:	call	stack4
  3331 000017C5 55                  <1> 	push	rbp
  3332 000017C6 67488BAD60020000    <1> 	mov	rbp, qword ptr [ebp+CORE_INDEX1]
  3333 000017CE E80FEDFFFF          <1> 	call	_burst_read4
  3334 000017D3 5D                  <1> 	pop	rbp
  3335 000017D4 67895D3C            <1> 	mov	dword ptr [ebp+S_P], ebx	; not done in stack4 in case
  3336 000017D8 C3                  <1> 	ret					; RTA1 sp is in the pushed frame
  3337                              <1> 						; then it would pop wrong
  3338 000017D9 E87BFCFFFF          <1> _dpop:	call	stack_read2
  3339 000017DE 55                  <1> 	push	rbp
  3340 000017DF 67488BAD60020000    <1> 	mov	rbp, qword ptr [ebp+CORE_INDEX1]
  3341 000017E7 E8C6EEFFFF          <1> 	call	_burst_write2
  3342 000017EC 5D                  <1> 	pop	rbp
  3343 000017ED C3                  <1> 	ret
  3344                              <1> 
  3345 000017EE E8D7ECFFFF          <1> _dpush:	call	_burst_read2			; do this before changing RTA1 sp
  3346 000017F3 89DA                <1> 	mov	edx, ebx			; in case that is in pushed pair
  3347 000017F5 488BB560020000      <1> 	mov	rsi, qword ptr [rbp+CORE_INDEX1]
  3348 000017FC E85CFBFFFF          <1> 	call	stack2				
  3349 00001801 89549E04            <1> 	mov	dword ptr [rsi+rbx*4+4], edx	; stack the data
  3350 00001805 89049E              <1> 	mov	dword ptr [rsi+rbx*4], eax
  3351 00001808 C3                  <1> 	ret
  3352                              <1> 
  3353 00001809 E804EDFFFF          <1> _mta:	call	_operand_read
  3354 0000180E 334510              <1> 	xor	eax, dword ptr [rbp+A]
  3355 00001811 234504              <1> 	and	eax, dword ptr [rbp+K]
  3356 00001814 7507                <1> 	jnz	_mta_
  3357 00001816 4981C404000000      <1> 	add	r12, 4		; k AND (a XOR operand) = 0, skip 1 instruction
  3358 0000181D C3                  <1> _mta_:	ret
  3359                              <1> 
  3360 0000181E E8A7ECFFFF          <1> _dte:	call	_burst_read2
  3361 00001823 334510              <1> 	xor	eax, dword ptr [rbp+A]
  3362 00001826 750C                <1> 	jnz	_dte_
  3363 00001828 335D14              <1> 	xor	ebx, dword ptr [rbp+B]
  3364 0000182B 7507                <1> 	jnz	_dte_
  3365 0000182D 4981C404000000      <1> 	add	r12, 4
  3366 00001834 C3                  <1> _dte_:	ret	
  3367                              <1> 
  3368 00001835 8B9EB0040000        <1> _sc:	mov	ebx, dword ptr [rsi+PSR]
  3369 0000183B 81E301000000        <1> 	and	ebx, 1		; store carry 
  3370 00001841 E99FEEFFFF          <1> 	jmp	_operand_write
  3371                              <1> 
  3372 00001846 E8C7ECFFFF          <1> _mlb:	call	_operand_read
  3373 0000184B 8B5D04              <1> 	mov	ebx, dword ptr [rbp+K]
  3374 0000184E 21D8                <1> 	and	eax, ebx
  3375 00001850 81F3FFFFFF00        <1> 	xor	ebx, 00FFFFFFh
  3376 00001856 235D14              <1> 	and	ebx, dword ptr [rbp+B]
  3377 00001859 09C3                <1> 	or	ebx, eax
  3378 0000185B 895D14              <1> 	mov	dword ptr [rbp+B], ebx	; b = (b AND (NOT k)) OR (operand AND k)
  3379 0000185E C3                  <1> 	ret
  3380                              <1> 
  3381 0000185F BB04000000          <1> _ds:	mov	ebx, a
  3382 00001864 E949EEFFFF          <1> 	jmp	_burst_write2
  3383                              <1> 
  3384 00001869 E85CECFFFF          <1> _dl:	call	_burst_read2
  3385 0000186E 895D14              <1> 	mov	dword ptr [rbp+B], ebx
  3386 00001871 894510              <1> 	mov	dword ptr [rbp+A], eax
  3387 00001874 C3                  <1> 	ret
  3388                              <1> 
  3389 00001875 C3                  <1> _spare:	ret
  3390                              <1> 
  3391 00001876 E816F0FFFF          <1> _ex:	call	memory_read
  3392 0000187B 488BB560020000      <1> 	mov	rsi, qword ptr [rbp+CORE_INDEX1]
  3393 00001882 E905E9FFFF          <1> 	jmp	_execute
  3394                              <1> 
  3395 00001887 E841F0FFFF          <1> _ts:	call	memory_lock			; edi + rsi -> memory word
  3396 0000188C 66B80080            <1> 	mov	ax, 08000h
  3397 00001890 668704B7            <1> 	xchg	ax, word ptr [rdi+rsi*4]	; swap -> t1 for 080 under lock
  3398 00001894 6621C0              <1> 	and	ax, ax
  3399 00001897 7807                <1> 	js	_ts___				; no action if already locked
  3400                              <1> 
  3401 00001899 4981C404000000      <1> 	add	r12, 4				; skip if ms bit was clear before
  3402                              <1> 
  3403 000018A0 C3                  <1> _ts___:	ret
  3404                              <1> 
  3405                              <1> 
  3406 000018A1 E8F8EFFFFF          <1> _sim:	call	memoreg				; edi -> device		edi <- NULL
  3407                              <1> 						; rsi -> word	OR	ebx -> register
  3408                              <1> 						; eax <- data
  3409 000018A6 8B8D60020000        <1> 	mov	ecx, dword ptr [rbp+CORE_INDEX1]
  3410 000018AC 66C1E008            <1> 	shl	ax, 8
  3411 000018B0 678A81B2040000      <1> 	mov	al, byte ptr [ecx+PSR+2]
  3412 000018B7 C1C803              <1> 	ror	eax, 3
  3413 000018BA C0C003              <1> 	rol	al, 3
  3414 000018BD 678881B2040000      <1> 	mov	byte ptr [ecx+PSR+2], al
  3415 000018C4 C1E81D              <1> 	shr	eax, 32-3
  3416                              <1> 
  3417 000018C7 E9AFEFFFFF          <1> 	jmp	memoreg_writeback
  3418                              <1> 
  3419 000018CC 4C89E2              <1> _call:	mov	rdx, r12				; copy [ pc -> ] in case the jump interrupts
  3420 000018CF E889FAFFFF          <1> 	call	stack2					; frame
  3421 000018D4 482B9690040000      <1> 	sub	rdx, qword ptr [rsi+B0P]		; pc - page address on platform
  3422 000018DB 48C1EA02            <1> 	shr	rdx, 2					; / 4 = RTA1 word offset
  3423 000018DF 89549E04            <1> 	mov	dword ptr [rsi+rbx*4+1*4], edx		; -> stack frame + 1
  3424 000018E3 8B96B4040000        <1> 	mov	edx, dword ptr [rsi+B0_NAME]		; iframe name
  3425 000018E9 89149E              <1> 	mov	dword ptr [rsi+rbx*4], edx		; -> stack frame + 0
  3426                              <1> 
  3427 000018EC 4C89A680040000      <1> _go:	mov	qword ptr [rsi+APC], r12		; write back actual platform value up2 here
  3428                              <1> 							; of emulated [ program counter -> ]
  3429 000018F3 E81AECFFFF          <1> 	call	_operand_read
  3430                              <1> 
  3431 000018F8 488BB560020000      <1> 	mov	rsi, qword ptr [rbp+CORE_INDEX1]	; regain core pointer
  3432                              <1> 
  3433 000018FF 89C2                <1> 	mov	edx, eax				; lookaside to calculate the vector
  3434 00001901 A900008000          <1> 	test	eax, 00800000h				; gate?			
  3435 00001906 742F                <1> 	jz	_go2_4k_frame				; one page fixed target iframe 
  3436                              <1> 
  3437 00001908 25FFFF7F00          <1> 	and	eax, 007FFFFFh				; read the gate constant / variable
  3438 0000190D E8B8EBFFFF          <1> 	call	_burst_read2				; into eax : ebx
  3439                              <1> 
  3440 00001912 488BB560020000      <1> 	mov	rsi, qword ptr [rbp+CORE_INDEX1]	; retrieve core pointer
  3441                              <1> 
  3442 00001919 89C2                <1> 	mov	edx, eax				; page high index ++ word offset 6.18
  3443 0000191B 89D8                <1> 	mov	eax, ebx				; iframe name
  3444 0000191D C1C20E              <1> 	rol	edx, 6+8				; roll down page high index + 2 flag bits
  3445 00001920 89D3                <1> 	mov	ebx, edx				; instruction frame page high index
  3446 00001922 81E33F000000        <1> 	and	ebx, 63					; remove flag bits 
  3447 00001928 7405                <1> 	jz	_go_gate				; page high index zero -> one page iframe
  3448 0000192A 0D00008000          <1> 	or	eax, 00800000h				; two+ page iframe
  3449                              <1> 
  3450                              <1> _go_gate:
  3451 0000192F C1EA0E              <1> 	shr	edx, 6+8				; net word offset
  3452                              <1> 
  3453 00001932 E910000000          <1> 	jmp	_go2_frame
  3454                              <1> 	
  3455                              <1> _go2_4k_frame:
  3456 00001937 81E23F000000        <1> 	and	edx, 63					; target is in 4k block, 64 vectors
  3457 0000193D C1E806              <1> 	shr	eax, 6					; new b0_name
  3458 00001940 25FFFF0000          <1> 	and	eax, 0000FFFFh				; bit 22 of GO / CALL word reserved
  3459 00001945 31DB                <1> 	xor	ebx, ebx				; frame high page index
  3460                              <1> 
  3461                              <1> _go2_frame:
  3462 00001947 F686B204000080      <1> 	test	byte ptr [rsi+PSR+2], 128		; already in interrupt code?
  3463 0000194E 751C                <1> 	jnz	_go2_base_frame			 	; may branch into interrupt code
  3464                              <1> 							; because already interrupt code
  3465 00001950 89C1                <1> 	mov	ecx, eax				; iframe name
  3466 00001952 81E1FFFF3F00        <1> 	and	ecx, 03FFFFFh				; minus flag bits
  3467 00001958 2B8E00060000        <1> 	sub	ecx, dword ptr [rsi+IO_PORT+72*4]	; applications lower limit
  3468 0000195E 7D0C                <1> 	jnl	_go2_base_frame				; you can
  3469                              <1> 
  3470 00001960 4C8BA680040000      <1> 	mov	r12, qword ptr [rsi+APC]		; you can't
  3471 00001967 E93DF8FFFF          <1> 	jmp	guard_ii_authority
  3472                              <1> 
  3473                              <1> _go2_base_frame:
  3474                              <1> 
  3475 0000196C 8986B4040000        <1> 	mov	dword ptr [rsi+B0_NAME], eax		; iframe name with flags
  3476 00001972 25FFFF3F00          <1> 	and	eax, 003FFFFFh				; start page index without flags
  3477 00001977 01C3                <1> 	add	ebx, eax				; iframe highest page
  3478 00001979 899EE0050000        <1> 	mov	dword ptr [rsi+IO_PORT+64*4], ebx	; port 64 <- iframe highest page
  3479                              <1> 
  3480 0000197F 8B8EE0060000        <1> 	mov	ecx, dword ptr [rsi+IO_PORT+128*4]	; memory page high index
  3481 00001985 81E1FFFF3F00        <1> 	and	ecx, 003FFFFFh				; strip memory type bits
  3482 0000198B 29D9                <1> 	sub	ecx, ebx				; iframe high page may be = not >
  3483 0000198D 7911                <1> 	jns	_go2_frame_in_range			; you can
  3484                              <1> 
  3485 0000198F B90E000000          <1> 	mov	ecx, LP_ADDRESS
  3486 00001994 4C8BA680040000      <1> 	mov	r12, qword ptr [rsi+APC]		; you can't
  3487 0000199B E90EF8FFFF          <1> 	jmp	guard_ii_escape
  3488                              <1> 
  3489                              <1> _go2_frame_in_range:
  3490                              <1> 
  3491 000019A0 48C1E30C            <1> 	shl	rbx, 12					; multiply highest page by page size
  3492 000019A4 4C8D2C9D[FC3F0000]  <1> 	lea	r13, [_memory+rbx*4+4095*4]		; last instruction word in iframe
  3493          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  3494                              <1> 							; higher = wrong
  3495 000019AC 4C89AE88040000      <1> 	mov	qword ptr [rsi+APCZ], r13		; set execution limit pointer
  3496                              <1> 
  3497 000019B3 8986E0040000        <1> 	mov	dword ptr [rsi+IO_PORT], eax		; write B0 <- iframe start page index
  3498 000019B9 48C1E00E            <1> 	shl	rax, 12+2				; 4kword block multiplied by 4 for word
  3499 000019BD 4805[00000000]      <1> 	add	rax, _memory				; add the platform location of executable space
  3500          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  3501 000019C3 898690040000        <1> 	mov	dword ptr [rsi+B0P], eax		; store address in platform of B0 page start
  3502 000019C9 C1E202              <1> 	shl	edx, 2					; add the vector offset * 4 for word
  3503 000019CC 4801C2              <1> 	add	rdx, rax				; absolute apc + _memory
  3504 000019CF 4989D4              <1> 	mov	r12, rdx
  3505 000019D2 C3                  <1> _go_:	ret
  3506                              <1> 
  3507                                  	%include	"alu.msm"
  3508                              <1> 
  3509                              <1> 
  3510 000019D3 E83AEBFFFF          <1> _ax:	call	_operand_read
  3511 000019D8 034508              <1> 	add	eax, dword ptr [rbp+X]
  3512 000019DB 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
  3513 000019E0 894508              <1> 	mov	dword ptr [rbp+X], eax
  3514 000019E3 C3                  <1> 	ret
  3515                              <1> 
  3516 000019E4 E829EBFFFF          <1> _ay:	call	_operand_read
  3517 000019E9 03450C              <1> 	add	eax, dword ptr [rbp+Y]
  3518 000019EC 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
  3519 000019F1 89450C              <1> 	mov	dword ptr [rbp+Y], eax
  3520 000019F4 C3                  <1> 	ret
  3521                              <1> 
  3522 000019F5 E818EBFFFF          <1> _or:	call	_operand_read
  3523 000019FA 094510              <1> 	or	dword ptr [rbp+A], eax
  3524 000019FD C3                  <1> 	ret
  3525                              <1> 
  3526 000019FE E80FEBFFFF          <1> _orB:	call	_operand_read
  3527 00001A03 094514              <1> 	or	dword ptr [rbp+B], eax
  3528 00001A06 C3                  <1> 	ret
  3529                              <1> 
  3530 00001A07 E806EBFFFF          <1> _and:	call	_operand_read
  3531 00001A0C 214510              <1> 	and	dword ptr [rbp+A], eax
  3532 00001A0F C3                  <1> 	ret
  3533                              <1> 
  3534 00001A10 E8FDEAFFFF          <1> _andB:	call	_operand_read
  3535 00001A15 214514              <1> 	and	dword ptr [rbp+B], eax
  3536 00001A18 C3                  <1> 	ret
  3537                              <1> 
  3538 00001A19 E8F4EAFFFF          <1> _xor:	call	_operand_read
  3539 00001A1E 314510              <1> 	xor	dword ptr [rbp+A], eax
  3540 00001A21 C3                  <1> 	ret
  3541                              <1> 
  3542 00001A22 E8EBEAFFFF          <1> _xorB:	call	_operand_read
  3543 00001A27 314514              <1> 	xor	dword ptr [rbp+B], eax
  3544 00001A2A C3                  <1> 	ret
  3545                              <1> 
  3546 00001A2B E8E2EAFFFF          <1> _aa:	call	_operand_read
  3547 00001A30 E90F000000          <1> 	jmp	_aa_
  3548                              <1> 
  3549 00001A35 E8D8EAFFFF          <1> _ana:	call	_operand_read
  3550 00001A3A 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
  3551 00001A3F 0501000000          <1> 	add	eax, 1
  3552                              <1> 
  3553 00001A44 034510              <1> _aa_:	add	eax, dword ptr [rbp+A]
  3554 00001A47 E8E1040000          <1> 	call	_alu_carry
  3555                              <1> 
  3556 00001A4C 894510              <1> 	mov	dword ptr [rbp+A], eax
  3557 00001A4F C3                  <1> 	ret
  3558                              <1> 
  3559 00001A50 E8BDEAFFFF          <1> _ab:	call	_operand_read
  3560 00001A55 E90F000000          <1> 	jmp	_ab_
  3561                              <1> 
  3562 00001A5A E8B3EAFFFF          <1> _anb:	call	_operand_read
  3563 00001A5F 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
  3564 00001A64 0501000000          <1> 	add	eax, 1
  3565                              <1> 
  3566 00001A69 034514              <1> _ab_:	add	eax, dword ptr [rbp+B]
  3567 00001A6C E8BC040000          <1> 	call	_alu_carry
  3568                              <1> 
  3569 00001A71 894514              <1> 	mov	dword ptr [rbp+B], eax
  3570 00001A74 C3                  <1> 	ret
  3571                              <1> 
  3572                              <1> _m:
  3573                              <1> ;	push	rdx			; 80386 platform has it ready made, so
  3574 00001A75 E898EAFFFF          <1> 	call	_operand_read
  3575 00001A7A C1E008              <1> 	shl	eax, 8			; prepare multiplier to be multiplicand 
  3576 00001A7D C1F808              <1> 	sar	eax, 8			; sign it in eax
  3577 00001A80 8B5D14              <1> 	mov	ebx, dword ptr [rbp+B]	; this is register side multiplicand but
  3578                              <1> 					; it makes no difference which is which
  3579 00001A83 C1E308              <1> 	shl	ebx, 8			; so use it as multiplier if that is OK
  3580 00001A86 C1FB08              <1> 	sar	ebx, 8			; sign it first
  3581                              <1> 
  3582 00001A89 F7EB                <1> 	imul	ebx
  3583                              <1> 
  3584 00001A8B C1C008              <1> 	rol	eax, 8			; move 8 bits up from eax to edx
  3585 00001A8E C1E208              <1> 	shl	edx, 8
  3586 00001A91 88C2                <1> 	mov	dl, al
  3587 00001A93 C1E808              <1> 	shr	eax, 8
  3588 00001A96 894514              <1> 	mov	dword ptr [rbp+B], eax	; product bits 23..0
  3589 00001A99 C1E208              <1> 	shl	edx, 8
  3590 00001A9C C1EA08              <1> 	shr	edx, 8
  3591 00001A9F 895510              <1> 	mov	dword ptr [rbp+A], edx	; product high order bits
  3592                              <1> ;	pop	rdx
  3593 00001AA2 C3                  <1> 	ret
  3594                              <1> 
  3595                              <1> _mf:
  3596                              <1> ;	push	rdx		; the multiplier is signed the multiplicand unsigned
  3597 00001AA3 E86AEAFFFF          <1> 	call	_operand_read
  3598 00001AA8 89C1                <1> 	mov	ecx, eax	; just to remember the multiplier sign
  3599 00001AAA A900008000          <1> 	test	eax, 00800000h
  3600 00001AAF 740A                <1> 	jz	_mfplusplus
  3601 00001AB1 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
  3602 00001AB6 0501000000          <1> 	add	eax, 1
  3603                              <1> _mfplusplus:
  3604 00001ABB 8B5D14              <1> 	mov	ebx, dword ptr [rbp+B]	; this is the multiplicand, unsigned
  3605 00001ABE F7E3                <1> 	mul	ebx		; two 24-bit unsigned values should be OK here
  3606 00001AC0 C1C008              <1> 	rol	eax, 8
  3607 00001AC3 C1E208              <1> 	shl	edx, 8
  3608 00001AC6 88C2                <1> 	mov	dl, al
  3609 00001AC8 C1E808              <1> 	shr	eax, 8
  3610 00001ACB C1E208              <1> 	shl	edx, 8
  3611 00001ACE C1EA08              <1> 	shr	edx, 8
  3612 00001AD1 F7C100008000        <1> 	test	ecx, 00800000h	; was the multiplier signed?
  3613 00001AD7 7421                <1> 	jz	_mfstore
  3614 00001AD9 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
  3615 00001ADE 81F2FFFFFF00        <1> 	xor	edx, 00FFFFFFh
  3616 00001AE4 0501000000          <1> 	add	eax, 1
  3617 00001AE9 C1C008              <1> 	rol	eax, 8
  3618 00001AEC 0FB6C8              <1> 	movzx	ecx, al
  3619 00001AEF C1E808              <1> 	shr	eax, 8
  3620 00001AF2 01CA                <1> 	add	edx, ecx
  3621 00001AF4 81E2FFFFFF00        <1> 	and	edx, 00FFFFFFh
  3622                              <1> _mfstore:
  3623 00001AFA 894514              <1> 	mov	dword ptr [rbp+B], eax
  3624 00001AFD 895510              <1> 	mov	dword ptr [rbp+A], edx
  3625                              <1> ;	pop	rdx
  3626 00001B00 C3                  <1> 	ret
  3627                              <1> 
  3628 00001B01 48BF04000000000000- <1> _d:	mov	rdi, a
  3629 00001B0A 00                  <1>
  3630 00001B0B E80A000000          <1> 	call	_divide
  3631 00001B10 895D10              <1> 	mov	dword ptr [rbp+A], ebx
  3632 00001B13 894518              <1> 	mov	dword ptr [rbp+MANTISSA2], eax
  3633 00001B16 894D14              <1> 	mov	dword ptr [rbp+B], ecx
  3634 00001B19 C3                  <1> 	ret
  3635                              <1> 
  3636                              <1> 	%if	1
  3637                              <1> 
  3638                              <1> ;	this divide made from 2 Intel divides should be a better method
  3639                              <1> ;	than the procession of 1-bit shifts and test subtracts
  3640                              <1> ;	which is the %else which it replaces. That also works
  3641                              <1> 
  3642                              <1> ;	this converts to and from positive magnitude
  3643                              <1> ;	because zoning the 2nd divide with a zero 1st remainder
  3644                              <1> ;	can't tell +0 from -0 in platform 2s complement
  3645                              <1> 
  3646                              <1> ;	polarity conversions before and after need no explanation
  3647                              <1> 
  3648                              <1> ;	1st dividend is 48 zero bits and high order 16 data bits
  3649                              <1> ;	of the the 48-bit RTA1 dividend
  3650                              <1> 
  3651                              <1> ;	2nd dividend is 1st remainder and the remaining 32 bits
  3652                              <1> ;	the the RTA1 dividend
  3653                              <1> 
  3654                              <1> ;	input is compressed from 24-bit words and output unpacked
  3655                              <1> ;	to 24-bit words
  3656                              <1> 
  3657                              <1> ;	64-bit dividend in 386 mode is high order bits in edx, low in eax
  3658                              <1> ;	platform faults if quotient carries from eax. Remainder in edx
  3659                              <1> 
  3660                              <1> ;	RTA1 quotient is 48 bits so it takes 2 divides in 32-bit mode
  3661                              <1> 
  3662                              <1> _divide:
  3663                              <1> ;	push	edx
  3664 00001B1A 57                  <1> 	push	rdi
  3665 00001B1B E8F2E9FFFF          <1> 	call	_operand_read	; read divisor
  3666 00001B20 5F                  <1> 	pop	rdi
  3667 00001B21 31C9                <1> 	xor	ecx, ecx	; final sign
  3668 00001B23 A900008000          <1> 	test	eax, 00800000h
  3669 00001B28 7409                <1> 	jz	_dsig?
  3670 00001B2A 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
  3671 00001B2F F7D1                <1> 	not	ecx		; reverse final sign
  3672 00001B31 FFC0                <1> 	inc	eax
  3673 00001B33 25FFFFFF00          <1> _dsig?:	and	eax, 00FFFFFFh	; check zerodiv here mebbes
  3674 00001B38 89C3                <1> 	mov	ebx, eax	; eax will be used twice as divisor LS word
  3675 00001B3A 7474                <1> 	jz	_d_ont		; zero results in eax ebx already
  3676                              <1> 
  3677 00001B3C 8B44BD04            <1> 	mov	eax, dword ptr [rbp+rdi*4+4]
  3678 00001B40 8B54BD00            <1> 	mov	edx, dword ptr [rbp+rdi*4]
  3679 00001B44 C1E008              <1> 	shl	eax, 8		; pack two 24-bit words to 64 bits 
  3680 00001B47 88D0                <1> 	mov	al, dl
  3681 00001B49 C1C808              <1> 	ror	eax, 8
  3682 00001B4C C1E208              <1> 	shl	edx, 8
  3683 00001B4F C1EA10              <1> 	shr	edx, 16
  3684 00001B52 6689D1              <1> 	mov	cx, dx		; save dividend sign
  3685 00001B55 6621D2              <1> 	and	dx, dx		; bit 47 on?
  3686 00001B58 7915                <1> 	jns	_dive_in
  3687                              <1> 
  3688 00001B5A 81F10000FFFF        <1> 	xor	ecx, 0FFFF0000h	; reverse final sign
  3689 00001B60 F7D0                <1> 	not	eax
  3690 00001B62 66F7D2              <1> 	not	dx
  3691 00001B65 0501000000          <1> 	add	eax, 1
  3692 00001B6A 6681D20000          <1> 	adc	dx, 0
  3693                              <1> 
  3694                              <1> _dive_in:
  3695 00001B6F 89C6                <1> 	mov	esi, eax	; reserve 2nd dividend
  3696 00001B71 89D0                <1> 	mov	eax, edx	; position 1st dividend
  3697 00001B73 31D2                <1> 	xor	edx, edx	; with leading zero
  3698 00001B75 F7F3                <1> 	div	ebx
  3699 00001B77 96                  <1> 	xchg	eax, esi	; save 1st quotient
  3700 00001B78 F7F3                <1> 	div	ebx		; generate 2nd quotient
  3701                              <1> 
  3702 00001B7A 6621C9              <1> 	and	cx, cx		; dividend negative?
  3703 00001B7D 7904                <1> 	jns	_d_remainder_plus
  3704 00001B7F F7D2                <1> 	not	edx
  3705 00001B81 FFC2                <1> 	inc	edx
  3706                              <1> 
  3707                              <1> _d_remainder_plus:
  3708 00001B83 81E2FFFFFF00        <1> 	and	edx, 00FFFFFFh
  3709 00001B89 87D1                <1> 	xchg	edx, ecx	; remainder -> ecx / final sign -> edx
  3710                              <1> 
  3711 00001B8B 89C3                <1> 	mov	ebx, eax	; low order quotient
  3712 00001B8D 89F0                <1> 	mov	eax, esi	; high order quotient
  3713                              <1> 
  3714 00001B8F 21D2                <1> 	and	edx, edx	; final sign?
  3715 00001B91 790F                <1> 	jns	_d_quotient_plus
  3716                              <1> 
  3717 00001B93 F7D3                <1> 	not	ebx		; invert + increment quotient
  3718 00001B95 66F7D0              <1> 	not	ax		; RTA1 integer is also 2s complement
  3719 00001B98 81C301000000        <1> 	add	ebx, 1
  3720 00001B9E 66150000            <1> 	adc	ax, 0
  3721                              <1> 
  3722                              <1> _d_quotient_plus:
  3723 00001BA2 0FB7C0              <1> 	movzx	eax, ax		; unpack from 32-bit words to 24-bit words
  3724 00001BA5 C1E008              <1> 	shl	eax, 8		; move 8 bits up
  3725 00001BA8 C1C308              <1> 	rol	ebx, 8
  3726 00001BAB 88D8                <1> 	mov	al, bl
  3727 00001BAD C1EB08              <1> 	shr	ebx, 8		; quotient in eax:ebx
  3728                              <1> 
  3729                              <1> _d_ont:
  3730                              <1> ;	pop	edx		; give back the emulated program counter
  3731 00001BB0 C3                  <1> 	ret
  3732                              <1> 
  3733                              <1> 	%else
  3734                              <1> 
  3735                              <1> _divide:
  3736                              <1> 	xor	ebx, ebx
  3737                              <1> 	push	ebx		;
  3738                              <1> 	push	ebx		; quotient
  3739                              <1> 	push	ebx		; dividend[b]
  3740                              <1> 	push	ebx		; dividend[a]
  3741                              <1> 	push	ebx		; trailing divisor
  3742                              <1> 	push	ebx		; divisor
  3743                              <1> 	push	ebx		; signs2 
  3744                              <1> 	push	ebx		; signs1
  3745                              <1> 	mov	ebx, 24
  3746                              <1> 	push	ebx		; beats
  3747                              <1> 
  3748                              <1> 
  3749                              <1> _D_BEATS	equ	0
  3750                              <1> _D_SIGNS1	equ	1*4
  3751                              <1> _D_SIGNS2	equ	2*4
  3752                              <1> _D_DIVISORU	equ	3*4
  3753                              <1> _D_DIVISORL	equ	4*4
  3754                              <1> _D_DIVIDENDU	equ	5*4
  3755                              <1> _D_DIVIDENDL	equ	6*4
  3756                              <1> _D_QUOTIENTU	equ	7*4
  3757                              <1> _D_QUOTIENTL	equ	8*4
  3758                              <1> 
  3759                              <1> 	push	edi
  3760                              <1> 	call	_operand_read
  3761                              <1> 	pop	edi
  3762                              <1> 
  3763                              <1> 	test	eax, 00800000h
  3764                              <1> 	jnz	_d_nmagnitude1			; must be stored negative
  3765                              <1> 	xor	eax, 00FFFFFFh
  3766                              <1> 	jmp	_d_nmagnitude2
  3767                              <1> _d_nmagnitude1:
  3768                              <1> 	add	eax, -1				; if it's already negative
  3769                              <1> 	mov	dword ptr [rsp+_D_SIGNS2], 0FFFFFFFFh
  3770                              <1> _d_nmagnitude2:
  3771                              <1> 	call	qscale
  3772                              <1> 	cmp	bl, 24
  3773                              <1> 	jz	_d_allsigns
  3774                              <1> 	add	dword ptr [rsp+_D_BEATS], ebx
  3775                              <1> _d_allsigns:
  3776                              <1> 	mov	ebx, 00FFFFFF00h ; make the divisor 48 bits contiguous	
  3777                              <1> 	mov	bl, al
  3778                              <1> 	ror	ebx, 8
  3779                              <1> 	shl	eax, 8
  3780                              <1> 	mov	ax, 65535
  3781                              <1> 	ror	eax, 16
  3782                              <1> 
  3783                              <1> 	mov	dword ptr [rsp+_D_DIVISORL], ebx
  3784                              <1> 	mov	dword ptr [rsp+_D_DIVISORU], eax
  3785                              <1> 
  3786                              <1> 	mov	ecx, 1				; precarry
  3787                              <1> 
  3788                              <1> ;	mov	ebx, dword ptr [rbp+B]	; dividend
  3789                              <1> ;	mov	eax, dword ptr [rbp+A]
  3790                              <1> 
  3791                              <1> 	mov	ebx, dword ptr [rbp+edi*4+4]
  3792                              <1> 	mov	eax, dword ptr [rbp+edi*4] 
  3793                              <1> 
  3794                              <1> 	test	eax, 00800000h
  3795                              <1> 	jz	_d_pmagnitude			; must be stored positive
  3796                              <1> 	mov	dword ptr [rsp+_D_SIGNS1], 00FFFFFFFFh
  3797                              <1> 	xor	ebx, 00FFFFFFh
  3798                              <1> 	xor	eax, 00FFFFFFh
  3799                              <1> 	add	ecx, ebx
  3800                              <1> 	mov	ebx, ecx
  3801                              <1> 	and	ebx, 00FFFFFFh
  3802                              <1> 	shr	ecx, 24
  3803                              <1> 	add	eax, ecx
  3804                              <1> 	and	eax, 00FFFFFFh
  3805                              <1> 
  3806                              <1> _d_pmagnitude:
  3807                              <1> 	shl	ebx, 8
  3808                              <1> 	mov	bl, al
  3809                              <1> 	ror	ebx, 8
  3810                              <1> 	shl	eax, 8
  3811                              <1> 	shr	eax, 16
  3812                              <1> 	mov	dword ptr [rsp+_D_DIVIDENDL], ebx
  3813                              <1> 	mov	dword ptr [rsp+_D_DIVIDENDU], eax
  3814                              <1> 
  3815                              <1> 	mov	ecx, dword ptr [rsp+_D_BEATS]
  3816                              <1> 
  3817                              <1> 	add	ecx, -1
  3818                              <1> _d_beat:			; iterative part as quick as possible
  3819                              <1> 				; could study doing a pair of Intel divides here
  3820                              <1> 	stc
  3821                              <1> 	rcr	dword ptr [rsp+_D_DIVISORU], 1
  3822                              <1> 	rcr	dword ptr [rsp+_D_DIVISORL], 1
  3823                              <1> 
  3824                              <1> 	stc
  3825                              <1> 	adc	ebx, dword ptr [rsp+_D_DIVISORL]
  3826                              <1> 	adc	eax, dword ptr [rsp+_D_DIVISORU]
  3827                              <1> 
  3828                              <1> 	jc	_d_carried
  3829                              <1> 	mov	ebx, dword ptr [rsp+_D_DIVIDENDL]
  3830                              <1> 	mov	eax, dword ptr [rsp+_D_DIVIDENDU]
  3831                              <1> 	jmp	_d_carried_or_not
  3832                              <1> 
  3833                              <1> _d_carried:
  3834                              <1> 	mov	dword ptr [rsp+_D_DIVIDENDL], ebx
  3835                              <1> 	mov	dword ptr [rsp+_D_DIVIDENDU], eax
  3836                              <1> 
  3837                              <1> _d_carried_or_not:
  3838                              <1> 	rcl	dword ptr [rsp+_D_QUOTIENTL], 1
  3839                              <1> 	rcl	dword ptr [rsp+_D_QUOTIENTU], 1
  3840                              <1> 	
  3841                              <1> 	add	ecx, -1
  3842                              <1> 	jc	_d_beat
  3843                              <1> 
  3844                              <1> 	pop	ecx		; BEATS
  3845                              <1> 	pop	ecx		; SIGNS1
  3846                              <1> 	pop	eax		; SIGNS2
  3847                              <1> 	pop	ebx		; DIVISORU
  3848                              <1> 	pop	ebx		; DIVISORL
  3849                              <1> 	pop	ebx		; DIVIDENDU
  3850                              <1> 	pop	ebx		; DIVIDENDL
  3851                              <1> 
  3852                              <1> 	xor	ebx, ecx	; set remainder to sign of dividend
  3853                              <1> 	jns	_d_remplus
  3854                              <1> 	inc	ebx		; set -remainder 2s complement
  3855                              <1> 
  3856                              <1> _d_remplus:
  3857                              <1> 	and	ebx, 00FFFFFFh	; store remainder
  3858                              <1> ;	mov	dword ptr [rbp+B], ebx
  3859                              <1> 
  3860                              <1> 	xor	ecx, eax	; set sign of quotient to difference of signs
  3861                              <1> 	mov	ecx, ebx	; remainder for return
  3862                              <1> 	pop	eax		; QUOTIENTU
  3863                              <1> 	pop	ebx		; QUOTIENTL
  3864                              <1> 
  3865                              <1> 	jns	_d_quotient_plus		; cc set from xor of signy
  3866                              <1> 
  3867                              <1> 	not	eax
  3868                              <1> 	not	ebx
  3869                              <1> 	add	ebx, 1
  3870                              <1> 	adc	eax, 0
  3871                              <1> 
  3872                              <1> _d_quotient_plus:
  3873                              <1> 	shl	eax, 8
  3874                              <1> 	rol	ebx, 8
  3875                              <1> 	mov	al, bl
  3876                              <1> 	shr	ebx, 8
  3877                              <1> 	shl	eax, 8
  3878                              <1> 	shr	eax, 8
  3879                              <1> 
  3880                              <1> ;	mov	dword ptr [rbp+A], ebx
  3881                              <1> ;	mov	dword ptr [rbp+MANTISSA2], eax
  3882                              <1> 	ret
  3883                              <1> 
  3884                              <1> 	%endif
  3885                              <1> 
  3886                              <1> 
  3887 00001BB1 88C1                <1> _sar:	mov	cl, al			; eax shift radix is 31
  3888 00001BB3 8B4510              <1> 	mov	eax, dword ptr [rbp+A]
  3889 00001BB6 F6C1E0              <1> 	test	cl, -32
  3890 00001BB9 7402                <1> 	jz	_sardo
  3891 00001BBB 31C0                <1> 	xor	eax, eax		; shift 32+ clears same as 24+
  3892 00001BBD D3E8                <1> _sardo:	shr	eax, cl
  3893 00001BBF 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
  3894 00001BC4 894510              <1> 	mov	dword ptr [rbp+A], eax
  3895 00001BC7 C3                  <1> 	ret
  3896                              <1> 
  3897 00001BC8 88C1                <1> _sbr:	mov	cl, al
  3898 00001BCA 8B4514              <1> 	mov	eax, dword ptr [rbp+B]
  3899 00001BCD F6C1E0              <1> 	test	cl, -32
  3900 00001BD0 7402                <1> 	jz	_sbrdo
  3901 00001BD2 31C0                <1> 	xor	eax, eax		; shift 32+ clears same as 24+
  3902 00001BD4 D3E8                <1> _sbrdo:	shr	eax, cl
  3903 00001BD6 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
  3904 00001BDB 894514              <1> 	mov	dword ptr [rbp+B], eax
  3905 00001BDE C3                  <1> 	ret
  3906                              <1> 
  3907                              <1> 
  3908 00001BDF 88C1                <1> _dsr:	mov	cl, al
  3909 00001BE1 8B5D14              <1> 	mov	ebx, dword ptr [rbp+B]
  3910 00001BE4 8B4510              <1> 	mov	eax, dword ptr [rbp+A]
  3911 00001BE7 E875000000          <1> 	call	dsr
  3912 00001BEC 895D14              <1> 	mov	dword ptr [rbp+B], ebx
  3913 00001BEF 894510              <1> 	mov	dword ptr [rbp+A], eax
  3914 00001BF2 C3                  <1> 	ret
  3915                              <1> 
  3916 00001BF3 88C1                <1> _sal:	mov	cl, al			; shift radix eax is 31
  3917 00001BF5 8B4510              <1> 	mov	eax, dword ptr [rbp+A]
  3918 00001BF8 F6C1E0              <1> 	test	cl, -32
  3919 00001BFB 7402                <1> 	jz	_saldo
  3920 00001BFD 31C0                <1> 	xor	eax, eax		; shift 32+ clears same as 24+
  3921 00001BFF D3E0                <1> _saldo:	shl	eax, cl
  3922 00001C01 25FFFFFF00          <1> 	and	eax, 00FFFFFFh		; write back to registers only 00000000 thru 00FFFFFF
  3923 00001C06 894510              <1> 	mov	dword ptr [rbp+A], eax
  3924 00001C09 C3                  <1> 	ret
  3925                              <1> 
  3926 00001C0A 88C1                <1> _sbl:	mov	cl, al
  3927 00001C0C 8B4514              <1> 	mov	eax, dword ptr [rbp+B]
  3928 00001C0F F6C1E0              <1> 	test	cl,-32
  3929 00001C12 7402                <1> 	jz	_sbldo
  3930 00001C14 31C0                <1> 	xor	eax, eax		; shift 32+ clears same as 24+
  3931 00001C16 D3E0                <1> _sbldo:	shl	eax, cl
  3932 00001C18 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
  3933 00001C1D 894514              <1> 	mov	dword ptr [rbp+B], eax
  3934 00001C20 C3                  <1> 	ret
  3935                              <1> 
  3936 00001C21 88C1                <1> _dsl	mov	cl, al
  3937 00001C23 8B5D14              <1> 	mov	ebx, dword ptr [rbp+B]
  3938 00001C26 8B4510              <1> 	mov	eax, dword ptr [rbp+A]
  3939 00001C29 E86B000000          <1> 	call	dsl
  3940 00001C2E 895D14              <1> 	mov	dword ptr [rbp+B], ebx
  3941 00001C31 894510              <1> 	mov	dword ptr [rbp+A], eax
  3942 00001C34 C3                  <1> 	ret
  3943                              <1> 
  3944 00001C35 8B5D10              <1> _rar:	mov	ebx, dword ptr [rbp+A]
  3945 00001C38 E8CF000000          <1> 	call	rr
  3946 00001C3D 895D10              <1> 	mov	dword ptr [rbp+A], ebx
  3947 00001C40 C3                  <1> 	ret
  3948                              <1> 
  3949 00001C41 8B5D14              <1> _rbr:	mov	ebx, dword ptr [rbp+B]
  3950 00001C44 E8C3000000          <1> 	call	rr
  3951 00001C49 895D14              <1> 	mov	dword ptr [rbp+B], ebx
  3952 00001C4C C3                  <1> 	ret
  3953                              <1> 
  3954 00001C4D 88C1                <1> _drr:	mov	cl, al
  3955 00001C4F 8B5D14              <1> 	mov	ebx, dword ptr [rbp+B]
  3956 00001C52 8B4510              <1> 	mov	eax, dword ptr [rbp+A]
  3957 00001C55 E800010000          <1> 	call	drr
  3958 00001C5A 895D14              <1> 	mov	dword ptr [rbp+B], ebx
  3959 00001C5D 894510              <1> 	mov	dword ptr [rbp+A], eax
  3960 00001C60 C3                  <1> 	ret
  3961                              <1> 
  3962                              <1> 
  3963 00001C61 C1E008              <1> dsr:	shl	eax, 8
  3964 00001C64 C1E308              <1> 	shl	ebx, 8
  3965 00001C67 80C1E8              <1> dsru:	add	cl, -24
  3966 00001C6A 7309                <1> 	jnc	dsrl
  3967 00001C6C 89C3                <1> 	mov	ebx, eax
  3968 00001C6E 31C0                <1> 	xor	eax, eax
  3969 00001C70 E9F2FFFFFF          <1> 	jmp	dsru
  3970 00001C75 80C110              <1> dsrl:	add	cl, 16
  3971 00001C78 730D                <1> 	jnc	dsr7
  3972 00001C7A C1E808              <1> dsr8:	shr	eax, 8
  3973 00001C7D 88C3                <1> 	mov	bl, al
  3974 00001C7F C1CB08              <1> 	ror	ebx, 8
  3975 00001C82 80C1F8              <1> 	add	cl,-8
  3976 00001C85 72F3                <1> 	jc	dsr8
  3977 00001C87 80E107              <1> dsr7:	and	cl, 7
  3978 00001C8A D3E8                <1> 	shr	eax, cl
  3979 00001C8C 88C3                <1> 	mov	bl, al		; bits from al in high-order positions bl
  3980 00001C8E D2C3                <1> 	rol	bl, cl		; roll them to low-order positions
  3981 00001C90 D3CB                <1> 	ror	ebx, cl
  3982 00001C92 C1EB08              <1> 	shr	ebx, 8
  3983 00001C95 C1E808              <1> 	shr	eax, 8
  3984 00001C98 C3                  <1> 	ret
  3985                              <1> 
  3986 00001C99 C1E008              <1> dsl:	shl	eax, 8
  3987 00001C9C C1E308              <1> 	shl	ebx, 8
  3988 00001C9F 80C1E8              <1> dslu:	add	cl, -24
  3989 00001CA2 7309                <1> 	jnc	dsll
  3990 00001CA4 89D8                <1> 	mov	eax, ebx
  3991 00001CA6 31DB                <1> 	xor	ebx, ebx
  3992 00001CA8 E9F2FFFFFF          <1> 	jmp	dslu
  3993 00001CAD 80C110              <1> dsll:	add	cl, 16
  3994 00001CB0 730F                <1> 	jnc	dsl7
  3995 00001CB2 C1C308              <1> dsl8:	rol	ebx, 8
  3996 00001CB5 88D8                <1> 	mov	al, bl
  3997 00001CB7 30DB                <1> 	xor	bl, bl
  3998 00001CB9 C1E008              <1> 	shl	eax, 8
  3999 00001CBC 80C1F8              <1> 	add	cl, -8
  4000 00001CBF 72F1                <1> 	jc	dsl8
  4001 00001CC1 80E107              <1> dsl7:	and	cl, 7
  4002 00001CC4 D3C3                <1> 	rol	ebx, cl
  4003 00001CC6 88D8                <1> 	mov	al, bl		; bits from bl in low-order positions al
  4004 00001CC8 D2C8                <1> 	ror	al, cl		; roll them to high-order positions
  4005 00001CCA D3E0                <1> 	shl	eax, cl
  4006 00001CCC C1EB08              <1> 	shr	ebx, 8
  4007 00001CCF C1E808              <1> 	shr	eax, 8
  4008 00001CD2 C3                  <1> 	ret
  4009                              <1> 
  4010 00001CD3 C1E008              <1> dsa:	shl	eax, 8
  4011 00001CD6 C1E308              <1> 	shl	ebx, 8
  4012 00001CD9 80C1E8              <1> dsa24:	add	cl, -24
  4013 00001CDC 730A                <1> 	jnc	dsa16
  4014 00001CDE 89C3                <1> 	mov	ebx, eax
  4015 00001CE0 C1F818              <1> 	sar	eax, 24
  4016 00001CE3 E9F1FFFFFF          <1> 	jmp	dsa24
  4017 00001CE8 80C110              <1> dsa16:	add	cl, 16
  4018 00001CEB 730D                <1> 	jnc	dsa7
  4019 00001CED C1F808              <1> dsa8:	sar	eax, 8
  4020 00001CF0 88C3                <1> 	mov	bl, al
  4021 00001CF2 C1CB08              <1> 	ror	ebx, 8
  4022 00001CF5 80C1F8              <1> 	add	cl, -8
  4023 00001CF8 72F3                <1> 	jc	dsa8
  4024 00001CFA 80E107              <1> dsa7:	and	cl, 7
  4025 00001CFD D3F8                <1> 	sar	eax, cl
  4026 00001CFF 88C3                <1> 	mov	bl, al		; bits from al in high-order positions bl
  4027 00001D01 D2C3                <1> 	rol	bl, cl		; roll them to low-order positions
  4028 00001D03 D3CB                <1> 	ror	ebx, cl
  4029 00001D05 C1E808              <1> 	shr	eax, 8
  4030 00001D08 C1EB08              <1> 	shr	ebx, 8
  4031 00001D0B C3                  <1> 	ret	
  4032                              <1> 
  4033                              <1> 
  4034 00001D0C 88C1                <1> rr:	mov	cl, al
  4035 00001D0E C1E308              <1> 	shl	ebx, 8
  4036 00001D11 F6C118              <1> 	test	cl, 24		; bits 16:8 are self-cancelling
  4037 00001D14 7A11                <1> 	jpe	rr7
  4038 00001D16 F6C110              <1> 	test	cl, 16
  4039 00001D19 7407                <1> 	jz	rr8		; 16 is off so 8 is on
  4040 00001D1B C1C308              <1> 	rol	ebx, 8		; 8 left in 24-bit ring = 16 right
  4041 00001D1E 88DF                <1> 	mov	bh, bl		; compress 32-bit ring to 24-bit
  4042 00001D20 EB05                <1> 	jmp	short rr7
  4043 00001D22 88FB                <1> rr8:	mov	bl, bh		; extend 24-bit ring to 32-bit
  4044 00001D24 C1CB08              <1> 	ror	ebx, 8
  4045 00001D27 80E107              <1> rr7:	and	cl, 7		; isolate remaining count bits
  4046 00001D2A 88FB                <1> 	mov	bl, bh		; don't ask, just do it
  4047 00001D2C D3CB                <1> 	ror	ebx, cl
  4048 00001D2E C1EB08              <1> 	shr	ebx, 8
  4049 00001D31 C3                  <1> 	ret
  4050                              <1> 
  4051 00001D32 88C1                <1> rl:	mov	cl, al
  4052 00001D34 C1E308              <1> 	shl	ebx, 8
  4053 00001D37 F6C118              <1> 	test	cl, 24		; bits 16:8 are self-cancelling
  4054 00001D3A 7A11                <1> 	jpe	rl7
  4055 00001D3C F6C110              <1> 	test	cl, 16
  4056 00001D3F 7407                <1> 	jz	rl8		; 16 is off so 8 is on
  4057 00001D41 88FB                <1> 	mov	bl, bh		; extend 24-bit ring to 32-bit
  4058 00001D43 C1CB08              <1> 	ror	ebx, 8		; 8 right in 24-bit ring = 16 left
  4059 00001D46 EB05                <1> 	jmp	short rl7
  4060 00001D48 C1C308              <1> rl8:	rol	ebx, 8
  4061 00001D4B 88DF                <1> 	mov	bh, bl		; compress 32-bit ring to 24-bit	
  4062 00001D4D 80E107              <1> rl7:	and	cl, 7
  4063 00001D50 30DB                <1> 	xor	bl, bl
  4064 00001D52 D3C3                <1> 	rol	ebx, cl
  4065 00001D54 08DF                <1> 	or	bh, bl
  4066 00001D56 C1EB08              <1> 	shr	ebx, 8
  4067 00001D59 C3                  <1> 	ret
  4068                              <1> 
  4069 00001D5A C1E008              <1> drr:	shl	eax, 8
  4070 00001D5D C1E308              <1> 	shl	ebx, 8
  4071                              <1> 
  4072 00001D60 F6C130              <1> 	test	cl, 48		; bits 32:16 are self-cancelling
  4073 00001D63 7B0A                <1> 	jpo	drr24		; rotate 48 = zero or 56 = 8 positions
  4074 00001D65 F6C108              <1> 	test	cl, 8		; parity = pe dans le pays d'Intel
  4075 00001D68 741F                <1> 	jz	drr7
  4076 00001D6A E915000000          <1> 	jmp	drr_cdrr8
  4077                              <1> 
  4078 00001D6F 93                  <1> drr24:	xchg	eax, ebx	; rotate 24 right or left as you wish
  4079 00001D70 F6C118              <1> 	test	cl, 24
  4080 00001D73 7A0D                <1> 	jpe	drr24_32	; pattern is 100xxx or 011xxx
  4081 00001D75 F6C108              <1> 	test	cl, 8		; pattern is 010xxx or 101xxx
  4082 00001D78 7401                <1> 	jz	drrl8		; pattern is 010
  4083 00001D7A 93                  <1> 	xchg	eax, ebx	; swap back, pattern 101 = 40 right = 8 left 
  4084 00001D7B E828000000          <1> drrl8:	call	near drl8	; pattern is 010
  4085 00001D80 EB07                <1> 	jmp	short drr7 	; already rotated 24 right, now 8 left
  4086                              <1> 
  4087                              <1> drr24_32:
  4088 00001D82 7505                <1> 	jnz	drr7		; pattern is 011 = rotate 24. We did
  4089                              <1> drr_cdrr8:
  4090 00001D84 E814000000          <1> 	call	near drr8	; pattern is 100 = rotate 32
  4091 00001D89 80E107              <1> drr7:	and	cl, 7
  4092 00001D8C 7408                <1> 	jz	drrx
  4093 00001D8E 88E3                <1> 	mov	bl, ah		; rotate low bits ebx 31:8 to eax high positions
  4094 00001D90 88F8                <1> 	mov	al, bh		; rotate low bits eax 31:8 to ebx high positions
  4095 00001D92 D3C8                <1> 	ror	eax, cl		; bits from bh in low order positions al
  4096 00001D94 D3CB                <1> 	ror	ebx, cl		; bits from ah in low order positions bl
  4097 00001D96 C1E808              <1> drrx:	shr	eax, 8
  4098 00001D99 C1EB08              <1> 	shr	ebx, 8
  4099 00001D9C C3                  <1> 	ret
  4100                              <1> 
  4101 00001D9D 88E3                <1> drr8:   mov     bl, ah          ; cross 8 bits from one 32-bit ring to another
  4102 00001D9F 88F8                <1>         mov     al, bh		
  4103 00001DA1 C1C808              <1>         ror     eax, 8
  4104 00001DA4 C1CB08              <1>         ror     ebx, 8
  4105 00001DA7 C3                  <1>         ret
  4106                              <1> 
  4107 00001DA8 C1C008              <1> drl8:   rol     eax, 8
  4108 00001DAB C1C308              <1>         rol     ebx, 8
  4109 00001DAE 88DC                <1>         mov     ah, bl          ; cross 8 bits from one 32-bit ring to another
  4110 00001DB0 88C7                <1>         mov     bh, al
  4111 00001DB2 C3                  <1>         ret
  4112                              <1> 
  4113 00001DB3 C1E008              <1> drl:	shl	eax, 8
  4114 00001DB6 C1E308              <1> 	shl	ebx, 8
  4115 00001DB9 F6C130              <1> 	test	cl, 48		; values 32:16 cancel each other
  4116 00001DBC 7B07                <1> 	jpo	drl24
  4117 00001DBE F6C108              <1> 	test	cl, 8
  4118 00001DC1 741C                <1> 	jz	drl7
  4119 00001DC3 EB15                <1> 	jmp	short drl_cdrl8
  4120                              <1> 
  4121 00001DC5 93                  <1> drl24:	xchg	eax, ebx
  4122 00001DC6 F6C118              <1> 	test	cl, 24
  4123 00001DC9 7A0D                <1> 	jpe	drl24_32	; pattern is 011xxx or 100xxx
  4124 00001DCB F6C108              <1> 	test	cl, 8		; pattern is 010xxx or 101xxx
  4125 00001DCE 7401                <1> 	jz	drlr8		; pattern is 010 = 16 left = 8 right
  4126 00001DD0 93                  <1> 	xchg	eax, ebx	; swap back, pattern = 101 = 40 left = 8 right
  4127 00001DD1 E8C7FFFFFF          <1> drlr8:	call	drr8
  4128 00001DD6 EB07                <1> 	jmp	short drl7
  4129                              <1> 
  4130                              <1> drl24_32:
  4131 00001DD8 7505                <1> 	jnz	drl7		; pattern is 011 = rotate24. We did
  4132                              <1> drl_cdrl8:			; pattern = 100xxx or 001xxx, rotate 8 more
  4133 00001DDA E8C9FFFFFF          <1> 	call	drl8
  4134 00001DDF 80E107              <1> drl7:	and	cl, 7		; rotate positions 0..7
  4135 00001DE2 30C0                <1> 	xor	al, al
  4136 00001DE4 30DB                <1> 	xor	bl, bl
  4137 00001DE6 D3C0                <1> 	rol	eax, cl
  4138 00001DE8 D3C3                <1> 	rol	ebx, cl
  4139 00001DEA 08DC                <1> 	or	ah, bl
  4140 00001DEC 08C7                <1> 	or	bh, al
  4141 00001DEE C1E808              <1> 	shr	eax, 8
  4142 00001DF1 C1EB08              <1> 	shr	ebx, 8
  4143 00001DF4 C3                  <1> 	ret
  4144                              <1> 
  4145 00001DF5 8B5D10              <1> _ral:	mov	ebx, dword ptr [rbp+A]
  4146 00001DF8 E835FFFFFF          <1> 	call	rl
  4147 00001DFD 895D10              <1> 	mov	dword ptr [rbp+A], ebx
  4148 00001E00 C3                  <1> 	ret
  4149                              <1> 
  4150 00001E01 8B5D14              <1> _rbl:	mov	ebx, dword ptr [rbp+B]
  4151 00001E04 E829FFFFFF          <1> 	call	rl
  4152 00001E09 895D14              <1> 	mov	dword ptr [rbp+B], ebx
  4153 00001E0C C3                  <1> 	ret	
  4154                              <1> 
  4155 00001E0D 88C1                <1> _drl:	mov	cl, al
  4156 00001E0F 8B4510              <1> 	mov	eax, dword ptr [rbp+A]
  4157 00001E12 8B5D14              <1> 	mov	ebx, dword ptr [rbp+B]
  4158 00001E15 E899FFFFFF          <1> 	call	drl
  4159 00001E1A 895D14              <1> 	mov	dword ptr [rbp+B], ebx
  4160 00001E1D 894510              <1> 	mov	dword ptr [rbp+A], eax
  4161 00001E20 C3                  <1> 	ret
  4162                              <1> 
  4163 00001E21 88C1                <1> _saa:	mov	cl, al
  4164 00001E23 8B4510              <1> 	mov	eax, dword ptr [rbp+A]
  4165 00001E26 C1E008              <1> 	shl	eax, 8
  4166 00001E29 D3F8                <1> 	sar	eax, cl
  4167 00001E2B C1E808              <1> 	shr	eax, 8
  4168 00001E2E 894510              <1> 	mov	dword ptr [rbp+A], eax
  4169 00001E31 C3                  <1> 	ret
  4170                              <1> 
  4171 00001E32 88C1                <1> _sba:	mov	cl, al
  4172 00001E34 8B5D14              <1> 	mov	ebx, dword ptr [rbp+B]
  4173 00001E37 C1E308              <1> 	shl	ebx, 8
  4174 00001E3A D3FB                <1> 	sar	ebx, cl
  4175 00001E3C C1EB08              <1> 	shr	ebx, 8
  4176 00001E3F 895D14              <1> 	mov	dword ptr [rbp+B], ebx
  4177 00001E42 C3                  <1> 	ret
  4178                              <1> 
  4179 00001E43 88C1                <1> _dsa:	mov	cl, al
  4180 00001E45 8B5D14              <1> 	mov	ebx, dword ptr [rbp+B]
  4181 00001E48 8B4510              <1> 	mov	eax, dword ptr [rbp+A]
  4182 00001E4B E883FEFFFF          <1> 	call	dsa
  4183 00001E50 895D14              <1> 	mov	dword ptr [rbp+B], ebx
  4184 00001E53 894510              <1> 	mov	dword ptr [rbp+A], eax
  4185 00001E56 C3                  <1> 	ret
  4186                              <1> 
  4187 00001E57 E842EAFFFF          <1> _n:	call	memoreg
  4188 00001E5C 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
  4189 00001E61 E915EAFFFF          <1> 	jmp	memoreg_writeback
  4190                              <1> 
  4191 00001E66 E833EAFFFF          <1> _inc:	call	memoreg
  4192 00001E6B FFC0                <1> 	inc	eax
  4193 00001E6D E909EAFFFF          <1> 	jmp	memoreg_writeback
  4194                              <1> 
  4195 00001E72 E827EAFFFF          <1> _dec:	call	memoreg
  4196 00001E77 FFC8                <1> 	dec	eax
  4197 00001E79 E9FDE9FFFF          <1> 	jmp	memoreg_writeback
  4198                              <1> 
  4199 00001E7E E81BEAFFFF          <1> _src:	call	memoreg
  4200 00001E83 C1E008              <1> 	shl	eax, 8
  4201 00001E86 8A86B0040000        <1> 	mov	al, byte ptr [rsi+PSR]
  4202 00001E8C D1C8                <1> 	ror	eax, 1
  4203 00001E8E D0C0                <1> 	rol	al, 1
  4204 00001E90 8886B0040000        <1> 	mov	byte ptr [rsi+PSR], al
  4205 00001E96 C1E808              <1> 	shr	eax, 8
  4206 00001E99 E9DDE9FFFF          <1> 	jmp	memoreg_writeback
  4207                              <1> 
  4208 00001E9E E8FBE9FFFF          <1> _slc:	call	memoreg
  4209 00001EA3 C1E008              <1> 	shl	eax, 8
  4210 00001EA6 8A86B0040000        <1> 	mov	al, byte ptr [rsi+PSR]
  4211 00001EAC D0C8                <1> 	ror	al, 1
  4212 00001EAE D1C0                <1> 	rol	eax, 1
  4213 00001EB0 8886B0040000        <1> 	mov	byte ptr [rsi+PSR], al
  4214 00001EB6 C1E808              <1> 	shr	eax, 8
  4215 00001EB9 E9BDE9FFFF          <1> 	jmp	memoreg_writeback
  4216                              <1> 
  4217                              <1> 	%if	0
  4218                              <1> _popA:	call	stack_read1				; ebx <- stack pointer
  4219                              <1> 	mov	ebx, dword ptr [rsi+ebx*4+REGISTER]	; stack word
  4220                              <1> 
  4221                              <1> 	mov	ecx, rsi				; keep core.REGISTER *
  4222                              <1> 	push	ebx
  4223                              <1> 	call	memoreg					; reply is memory edi + rsi ->
  4224                              <1> 							;     or register rsi + ebx ->
  4225                              <1> 	add	eax, dword ptr [rsp]
  4226                              <1> 	add	rsp, 4
  4227                              <1> 
  4228                              <1> 	rol	eax, 8					; carry -> LS bit
  4229                              <1> 	and	al, 1
  4230                              <1> 
  4231                              <1> 	and	byte ptr [ecx+PSR], 254
  4232                              <1> 	or	byte ptr [ecx+PSR], al
  4233                              <1> 	shr	eax, 8					; resulting value without carry
  4234                              <1> 	jmp	memoreg_writeback			; eax -> target
  4235                              <1> 							; [ edi ] + rsi -> memory / register
  4236                              <1> 	%else
  4237                              <1> 
  4238 00001EBE E8DBE9FFFF          <1> _popA:	call	memoreg					; eax <- addend for update
  4239 00001EC3 53                  <1> 	push	rbx					; ebx -> writeback register
  4240 00001EC4 56                  <1> 	push	rsi					; or [ edi esi ] -> writeback memory word
  4241                              <1> 
  4242 00001EC5 488BB560020000      <1> 	mov	rsi, qword ptr [rbp+CORE_INDEX1]	; get back the smp core for PSR and...
  4243                              <1> 							; total register array and...
  4244                              <1> 							; whichever of [ 2 * RTA1 sp ] is in ebx *
  4245                              <1> 							; that is simple position in register list
  4246                              <1> 							; not application / ISR relative as in rbp
  4247                              <1> 							; although each (RTA1 sp) MOSTLY operates
  4248                              <1> 							; its own portions of the register array
  4249                              <1> 							; CORE_INDEX is in both scopes of rbp :-)
  4250                              <1> 
  4251 00001ECC E8ADF5FFFF          <1> 	call	stack_read1				; ebx -> old (RTA1 internal stack) sp
  4252 00001ED1 03049E              <1> 	add	eax, dword ptr [rsi+rbx*4+REGISTER]	; add word from internal stack
  4253                              <1> 
  4254 00001ED4 C1C008              <1> 	rol	eax, 8					; isolate carry out of bit 23
  4255 00001ED7 2401                <1> 	and	al, 1
  4256 00001ED9 8B9EB0040000        <1> 	mov	ebx, dword ptr [rsi+PSR]		; platform memory read then write MIGHT
  4257 00001EDF 80E3FE              <1> 	and	bl, 254					; be better than 2 * read : write cycle
  4258 00001EE2 08C3                <1> 	or	bl, al
  4259 00001EE4 899EB0040000        <1> 	mov	dword ptr [rsi+PSR], ebx		; write PSR back
  4260                              <1> 
  4261 00001EEA C1E808              <1> 	shr	eax, 8					; reposition and clean result
  4262                              <1> 
  4263 00001EED 5E                  <1> 	pop	rsi					; retrieve possible storage offset
  4264 00001EEE 5B                  <1> 	pop	rbx					; retrieve possible register writeback
  4265 00001EEF E987E9FFFF          <1> 	jmp	memoreg_writeback
  4266                              <1> 
  4267                              <1> 	%endif
  4268                              <1> 	
  4269 00001EF4 E8D1E5FFFF          <1> _da:	call	_burst_read2
  4270 00001EF9 E912000000          <1> 	jmp	_da_
  4271                              <1> 
  4272 00001EFE E8C7E5FFFF          <1> _dan:	call	_burst_read2
  4273 00001F03 81F3FFFFFF00        <1> 	xor	ebx, 00FFFFFFh
  4274 00001F09 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
  4275 00001F0E FFC3                <1> 	inc	ebx			; carry from bit 23 
  4276                              <1> 					; remains in bit 24 for now
  4277                              <1> 
  4278 00001F10 035D14              <1> _da_:	add	ebx, [rbp+B]
  4279 00001F13 C1E308              <1> 	shl	ebx, 8
  4280 00001F16 1500000000          <1> 	adc	eax, 0
  4281 00001F1B C1EB08              <1> 	shr	ebx, 8
  4282 00001F1E 895D14              <1> 	mov	[rbp+B], ebx
  4283 00001F21 034510              <1> 	add	eax, [rbp+A]
  4284 00001F24 E804000000          <1> 	call	_alu_carry
  4285 00001F29 894510              <1> 	mov	[rbp+A], eax
  4286 00001F2C C3                  <1> 	ret
  4287                              <1> 
  4288                              <1> _alu_carry:
  4289 00001F2D 488BB560020000      <1> 	mov	rsi, qword ptr [rbp+CORE_INDEX1]
  4290 00001F34 C1C008              <1> 	rol	eax, 8
  4291 00001F37 2401                <1> 	and	al, 1
  4292 00001F39 80A6B0040000FE      <1> 	and	byte ptr [rsi+PSR], 254
  4293 00001F40 0886B0040000        <1> 	or	byte ptr [rsi+PSR], al
  4294 00001F46 C1E808              <1> 	shr	eax, 8
  4295 00001F49 C3                  <1> 	ret
  4296                              <1> 
  4297 00001F4A 040302020101010100- <1> scalex	db	4,3,2,2, 1,1,1,1, 0,0,0,0, 0,0,0,0
  4298 00001F53 00000000000000      <1>
  4299                              <1> 
  4300                              <1> field_scale:			; examine 24-bit integer in 8-position steps
  4301 00001F5A C1C008              <1> 	rol	eax, 8		; until high-order 8 bits are not all signs
  4302 00001F5D 88C4                <1> 	mov	ah, al
  4303 00001F5F 30E8                <1> 	xor	al, ch
  4304 00001F61 7509                <1> 	jnz	not8signs
  4305 00001F63 80C108              <1> 	add	cl, 8
  4306 00001F66 80F918              <1> 	cmp	cl, 24
  4307 00001F69 72EF                <1> 	jb	field_scale
  4308 00001F6B C3                  <1> 	ret			; 24 signs = the RTA1 computer word
  4309                              <1> not8signs:			; al = 0 indicates it
  4310 00001F6C A8F0                <1> 	test	al, 240		; move back some positions but keep counting up
  4311 00001F6E 7506                <1> 	jnz	scale_u
  4312 00001F70 80C104              <1> 	add	cl, 4
  4313 00001F73 C0C004              <1> 	rol	al, 4
  4314                              <1> scale_u:
  4315 00001F76 C0E804              <1> 	shr	al, 4
  4316 00001F79 480FB6F0            <1> 	movzx	rsi, al		; add to count-up 1..7
  4317 00001F7D 028E[4A1F0000]      <1> 	add	cl, [rsi+scalex]
  4318          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  4319 00001F83 51                  <1> 	push	rcx		; roll back 7..1 positions
  4320 00001F84 80E107              <1> 	and	cl, 7
  4321 00001F87 80F107              <1> 	xor	cl, 7
  4322 00001F8A 80C101              <1> 	add	cl, 1
  4323 00001F8D 88E0                <1> 	mov	al, ah
  4324 00001F8F D3C8                <1> 	ror	eax, cl
  4325 00001F91 59                  <1> 	pop	rcx
  4326 00001F92 C3                  <1> 	ret
  4327                              <1> 
  4328 00001F93 C1E008              <1> qscale:	shl	eax, 8		; 1.2.3
  4329 00001F96 C1F808              <1> 	sar	eax, 8		; s.1.2.3
  4330 00001F99 C1C008              <1> 	rol	eax, 8		; 1.2.3.s
  4331 00001F9C 6631C9              <1> 	xor	cx, cx
  4332 00001F9F 88C5                <1> 	mov	ch, al		; keep 8 sign bits
  4333 00001FA1 E8B4FFFFFF          <1> 	call	field_scale
  4334                              <1> 
  4335 00001FA6 0FB6D9              <1> 	movzx	ebx, cl
  4336                              <1> 
  4337 00001FA9 C1E808              <1> 	shr	eax, 8
  4338 00001FAC C3                  <1> 	ret
  4339                              <1> 
  4340 00001FAD E860E5FFFF          <1> _lsc:	call	_operand_read
  4341 00001FB2 E8DCFFFFFF          <1> 	call	qscale
  4342 00001FB7 895D14              <1> 	mov	dword ptr [rbp+B], ebx	; store the scale
  4343 00001FBA 894510              <1> 	mov	dword ptr [rbp+A], eax	; store the rotated value
  4344 00001FBD C3                  <1> 	ret
  4345                              <1> 
  4346 00001FBE E807E5FFFF          <1> _dlsc:	call	_burst_read2
  4347 00001FC3 894510              <1> 	mov	dword ptr [rbp+A], eax		; keep original 1st word
  4348 00001FC6 C1E008              <1> 	shl	eax, 8
  4349 00001FC9 C1F808              <1> 	sar	eax, 8
  4350 00001FCC C1C008              <1> 	rol	eax, 8
  4351 00001FCF 6631C9              <1> 	xor	cx, cx
  4352 00001FD2 88C5                <1> 	mov	ch, al				; keep 8 sign bits
  4353 00001FD4 E881FFFFFF          <1> 	call	field_scale
  4354 00001FD9 20C0                <1> 	and	al, al
  4355 00001FDB 7415                <1> 	jz	_dlsc24				; if the first word is all signs
  4356                              <1> 
  4357 00001FDD 0FB6C1              <1> 	movzx	eax, cl
  4358 00001FE0 894518              <1> 	mov	dword ptr [rbp+MANTISSA2], eax	; store the scale
  4359 00001FE3 8B4510              <1> 	mov	eax, dword ptr [rbp+A]		; retrieve the input high order word
  4360 00001FE6 E8C8FDFFFF          <1> 	call	drl				; scale the two input words per cl
  4361 00001FEB 895D14              <1> 	mov	dword ptr [rbp+B], ebx
  4362 00001FEE 894510              <1> 	mov	dword ptr [rbp+A], eax  	; store the rotated value
  4363 00001FF1 C3                  <1> 	ret
  4364                              <1> 
  4365                              <1> _dlsc24:				; different when high order word is all signs
  4366 00001FF2 C1E808              <1> 	shr	eax, 8			; one result word of signs
  4367 00001FF5 894514              <1> 	mov	dword ptr [rbp+B], eax	; into the low-order result word
  4368 00001FF8 89D8                <1> 	mov	eax, ebx		; scale the low-order input
  4369 00001FFA C1E008              <1> 	shl	eax, 8
  4370 00001FFD 30C9                <1> 	xor	cl, cl			; restart the scale count-up
  4371 00001FFF E856FFFFFF          <1> 	call	field_scale
  4372 00002004 80C118              <1> 	add	cl, 24			; restore the early part of the count-up
  4373                              <1> 
  4374 00002007 0FB6D9              <1> 	movzx	ebx, cl
  4375 0000200A 895D18              <1> 	mov	dword ptr [rbp+MANTISSA2], ebx	; store the scale
  4376                              <1> 
  4377 0000200D C1E808              <1> 	shr	eax, 8
  4378 00002010 894510              <1> 	mov	dword ptr [rbp+A], eax	; store the rotated value
  4379 00002013 C3                  <1> 	ret
  4380                              <1> 
  4381                              <1> 	%if	0
  4382                              <1> 
  4383                              <1> _fpx:	call	_burst_read2		; data read in eax ebx
  4384                              <1> 	mov	rsi, dword ptr [rbp+CORE_INDEX1]
  4385                              <1> 	push	ebx			; ebx is used in RTA1 stack frame
  4386                              <1> 	call	stack4			; construct RTA1 stack frame
  4387                              <1> 
  4388                              <1> 	shl	eax, 4			; move 12 mantissa bits out of eax
  4389                              <1> 	movsx	ecx, ax			; and extend the normalising bit
  4390                              <1> 
  4391                              <1> 	rol	eax, 4+1		; shelter sign in eax bit 0
  4392                              <1> 	shl	ax, 12			; better still in eax bit 12
  4393                              <1> 	sar	eax, 12			; propagate the value at midpoint position
  4394                              <1> 	ror	eax, 1			; have the sign back
  4395                              <1> 	shr	eax, 8			; clear eax 31..24
  4396                              <1> 	xor	eax, 003ffc00h		; reverse the 12 copies of midpoint bit
  4397                              <1> 					; yon's ra complicated bit done
  4398                              <1> 	mov	dword ptr [rbp+ebx*4], eax
  4399                              <1> 
  4400                              <1> 	xor	eax, ecx		; is the normalising bit opposite to signs ?
  4401                              <1> 	test	eax, 00800000h
  4402                              <1> 	jz	_fpx_allsigns		; no so unnormalised = zero
  4403                              <1> 
  4404                              <1> 	pop	eax			; the 2nd operand word, ya remember?
  4405                              <1> 	shl	eax, 4			; get them 2 halves over the centre
  4406                              <1> 
  4407                              <1> 	shr	cx, 4			; zero quartets at high order of 16 bits
  4408                              <1> 	shr	ax, 4
  4409                              <1> 
  4410                              <1> 	xchg	ax, cx			; low-order mantissa bits with unsigns in ecx
  4411                              <1> 					; high-order mantissa bits with middle part in eax
  4412                              <1> 
  4413                              <1> 	shl	eax, 4			; LLLz | HHHz
  4414                              <1> 	shr	ax, 4			; LLLz | zHHH
  4415                              <1> 	rol	eax, 12			; zzHH | HLLL
  4416                              <1> 
  4417                              <1> 	mov	dword ptr [rbp+ebx*4+1*4], eax
  4418                              <1> 	rol	ecx, 12
  4419                              <1> 	xor	ecx, 0FFFh		; 12 normalising bits = 12 inverted signs
  4420                              <1> 	mov	dword ptr [rbp+ebx*4+2*4], ecx
  4421                              <1> 	not	ecx			; convert high order quartet to signs
  4422                              <1> 	sar	ecx, 20			; 24 of them
  4423                              <1> 	shr	ecx, 8
  4424                              <1> 	mov	dword ptr [rbp+ebx*4+3*4], ecx
  4425                              <1> ;	mov	rbp, dword ptr [rsi+REGISTER_SET]
  4426                              <1> 	mov	dword ptr [rbp+S_P], ebx	; update whichever sp that is
  4427                              <1> 	ret
  4428                              <1> 
  4429                              <1> _fpx_allsigns:
  4430                              <1> 	add	rsp, 4			; take saved operand word back from stack
  4431                              <1> 	sar	ecx, 8			; 16 unnormalised normalising bits
  4432                              <1> 	shr	ecx, 8			; = 24 sign bits
  4433                              <1> 
  4434                              <1> 	mov	dword ptr [rbp+ebx*4], ecx
  4435                              <1> 	mov	dword ptr [rbp+ebx*4+1*4], ecx
  4436                              <1> 	mov	dword ptr [rbp+ebx*4+2*4], ecx
  4437                              <1> 	mov	dword ptr [rbp+ebx*4+3*4], ecx
  4438                              <1> 
  4439                              <1> ;	mov	rbp, dword ptr [_register_set]
  4440                              <1> 	mov	dword ptr [rbp+S_P], ebx	; update whichever sp that is
  4441                              <1> 	ret
  4442                              <1> 
  4443                              <1> _fpp:	call	stack_read4
  4444                              <1> 	push	eax				; thats EA
  4445                              <1> 
  4446                              <1> 	mov	eax, dword ptr [rbp+ebx*4]	; s + 23 exponent bits
  4447                              <1> 	rol	eax, 8+2			; save sign and midpoint
  4448                              <1> 	shl	eax, 12				; squeeze out 12 exponent bits
  4449                              <1> 	shr	ax, 12				; bring sign + midpoint back
  4450                              <1> 	ror	eax, 2				; and roll them back in
  4451                              <1> 	shr	eax, 4				; position 12 bits low in 16 bits
  4452                              <1> 	mov	ecx, dword ptr [rbp+ebx*4+1*4]	; take 1st mantissa word from the stack
  4453                              <1> 	ror	ecx, 12				; rotate 12 bits down
  4454                              <1> 	shl	cx, 4				; position 12 bits high in 16 bits
  4455                              <1> 	mov	ax, cx				; merge
  4456                              <1> 	shr	eax, 4				; position 24 bits low in 32 bits
  4457                              <1> 	mov	dword ptr [rbp+ebx*4], eax	; place back in RTA1 stack frame
  4458                              <1> 						; next 12 mantissa bits in ecx 31..20
  4459                              <1> 
  4460                              <1> 	mov	eax, dword ptr [rbp+ebx*4+2*4]	; read 24 more
  4461                              <1> 	shr	eax, 12-4			; position 12 bits at ax 15..4
  4462                              <1> 	shr	ecx, 4				;				
  4463                              <1> 	mov	cx, ax				; juxtapose with mantissa 23..12
  4464                              <1> 	shr	ecx, 4				; wirraff
  4465                              <1> 
  4466                              <1> 	mov	dword ptr [rbp+ebx*4+1*4], ecx	; making 2nd and final output word
  4467                              <1> 
  4468                              <1> 	pop	eax				; recover EA
  4469                              <1> 	jmp	_burst_write2
  4470                              <1> 
  4471                              <1> 	%endif
  4472                                  	%include	"fpu.msm"
  4473                              <1> compress4to8:			; readout floating operand
  4474                              <1> 				; and pack to 32-bit words
  4475                              <1> 				; for 1 bit-distance shifting
  4476                              <1> 				; acquired operand is in 1st half of 
  4477                              <1> 				; 8-register block [rdi]
  4478                              <1> 
  4479 00002014 8B07                <1> 	mov	eax, dword ptr [rdi]	; 1s-complement scale field
  4480 00002016 C1E008              <1> 	shl	eax, 8			; 1st data bit reveals sign
  4481 00002019 C1F808              <1> 	sar	eax, 8			; propagate that sign some
  4482 0000201C 89C3                <1> 	mov	ebx, eax
  4483 0000201E C1F818              <1> 	sar	eax, 24			; propagate signs to 32 bits
  4484 00002021 31C3                <1> 	xor	ebx, eax		; change scale to unsigned magnitude
  4485 00002023 891F                <1> 	mov	dword ptr [rdi], ebx	; position scale magnitude in 1st register
  4486 00002025 89471C              <1> 	mov	dword ptr [rdi+7*4], eax	; 96 trailing signs
  4487 00002028 894718              <1> 	mov	dword ptr [rdi+6*4], eax
  4488 0000202B 894714              <1> 	mov	dword ptr [rdi+5*4], eax
  4489 0000202E 8B5F0C              <1> 	mov	ebx, dword ptr [rdi+3*4]	; read low-order mantissa word
  4490 00002031 88D8                <1> 	mov	al, bl				; low-order octet
  4491 00002033 C1C808              <1> 	ror	eax, 8				; is followed by 24 signs
  4492 00002036 894710              <1> 	mov	dword ptr [rdi+4*4], eax	; ebx also contains mantissa 23..8
  4493                              <1> 						; in positions 23..8
  4494                              <1> 
  4495 00002039 8B4708              <1> 	mov	eax, dword ptr [rdi+2*4]	; eax now contains mantissa 47..24
  4496 0000203C C1E308              <1> 	shl	ebx, 8
  4497 0000203F 6689C3              <1> 	mov	bx, ax				; mantissa 39..24 -> ebx
  4498 00002042 C1C310              <1> 	rol	ebx, 16				; ebx now contains mantissa 40..8
  4499 00002045 895F0C              <1> 	mov	dword ptr [rdi+3*4], ebx
  4500 00002048 8B5F04              <1> 	mov	ebx, dword ptr [rdi+1*4]	; mantissa 71..48
  4501 0000204B C1E308              <1> 	shl	ebx, 8
  4502 0000204E C1E810              <1> 	shr	eax, 16				; mantissa 47..40
  4503 00002051 88C3                <1> 	mov	bl, al
  4504 00002053 895F08              <1> 	mov	dword ptr [rdi+2*4], ebx	; mantissa 71..40
  4505 00002056 8B4714              <1> 	mov	eax, dword ptr [rdi+5*4]	; copy 32 signs
  4506 00002059 894704              <1> 	mov	dword ptr [rdi+1*4], eax	; to 2nd word of register block
  4507 0000205C C3                  <1> 	ret
  4508                              <1> 
  4509                              <1> 
  4510                              <1> ;	___________________________________
  4511                              <1> ;	| magnitude scale|     32 signs   |
  4512                              <1> ;	|________________|________________|
  4513                              <1> ;	| platform word 7| platform word 6|
  4514                              <1> 
  4515                              <1> 
  4516                              <1> ;	<------------ 168-bit mantissa 167..72-------------|
  4517                              <1> ;	<------------  72-bit mantissa ------>
  4518                              <1> ;	_____________|___________|____________|____________________________
  4519                              <1> ;	|      24    | 8 |   16  |   16   | 8 |    24 signs|96 more signs for
  4520                              <1> ;	|____________|___|______ |________|___|____________|rrsidue calculation
  4521                              <1> ;	| platform word 5| platform word 4|   +rounding <--- @  96-bit operation
  4522                              <1> 
  4523                              <1> ;	                 <---------------------------------[ platform words 2..0
  4524                              <1> ;	                 :
  4525                              <1> ;	                 [                                                  ]
  4526                              <1> 
  4527                              <1> ;	                 |--- 168-bit mantissa 71:0   -------->
  4528                              <1> ;	                      rounding @ 192-bit operation --->+
  4529                              <1> ;      	                 _________________________|____________|_____________
  4530                              <1> ;	                 |      24    | 8 |   16  |   16   | 8 |    24 signs|
  4531                              <1> ;	                 |____________|___|_______|________|___|____________|
  4532                              <1> ;	                 | platform word 2| platform word 1| platform word 0|
  4533                              <1> 
  4534                              <1> ;	                 |    rrsidue rounding -->+
  4535                              <1> ;	                 |--- 144-bit mantissa -->	                                    
  4536                              <1> 
  4537                              <1> _deliver_:
  4538 0000205D 488BB560020000      <1> 	mov	rsi, qword ptr [rbp+CORE_INDEX1]
  4539 00002064 F786B0040000080000- <1> 	test	dword ptr [rsi+PSR], FP_R
  4540 0000206D 00                  <1>
  4541 0000206E 0F8484000000        <1> 	jz	near _deliver
  4542 00002074 53                  <1> 	push	rbx		; save result register index
  4543 00002075 8B1F                <1> 	mov	ebx, dword ptr [rdi]		; read scale unsigned magnitude
  4544                              <1> 						; not yet signed
  4545                              <1> 
  4546                              <1> 				; all results except scale have been polarised
  4547                              <1> 				; ebx = positive magnitude of major exponent
  4548                              <1> 				; deliver floating rrsidue
  4549 00002077 81C3B8FFFFFF        <1> 	add	ebx, -72	; calculate exponent of rrsidue
  4550 0000207D B148                <1> 	mov	cl, 72
  4551                              <1> 
  4552 0000207F 8B4710              <1> 	mov	eax, dword ptr [rdi+4*4]	; mantissa */ 64 bits
  4553 00002082 C1E008              <1> 	shl	eax, 8		; separate rrsidual mantissa
  4554 00002085 C1E808              <1> 	shr	eax, 8
  4555 00002088 50                  <1> 	push	rax
  4556 00002089 8B4714              <1> 	mov	eax, dword ptr [rdi+5*4]	; mantissa */ 96 bits
  4557 0000208C 50                  <1> 	push	rax
  4558 0000208D 8B4718              <1> 	mov	eax, dword ptr [rdi+6*4]	; mantissa */ 128 bits
  4559 00002090 668B4704            <1> 	mov	ax, word ptr [rdi+1*4]		; change low-order half trailing word to signs
  4560 00002094 50                  <1> 	push	rax				; before normalising
  4561                              <1> 
  4562                              <1> _normalise_residue:
  4563 00002095 8B442410            <1> 	mov	eax, dword ptr [rsp+2*8]	; residual mantissa high-order word
  4564 00002099 334704              <1> 	xor	eax, dword ptr [rdi+1*4]	; signs
  4565 0000209C 2500008000          <1> 	and	eax, 00800000h			; normalising position
  4566 000020A1 751D                <1> 	jnz	_residue_normalised
  4567 000020A3 8B4704              <1> 	mov	eax, dword ptr [rdi+1*4]	; signs again
  4568 000020A6 D1D0                <1> 	rcl	eax, 1				; place a sign in carry				
  4569 000020A8 D11424              <1> 	rcl	dword ptr [rsp], 1		; rotate 96 bits rrsidual mantissa
  4570 000020AB D1542408            <1> 	rcl	dword ptr [rsp+1*8], 1
  4571 000020AF D1542410            <1> 	rcl	dword ptr [rsp+2*8], 1		; thirdly the high-order word
  4572 000020B3 81C3FFFFFFFF        <1> 	add	ebx, -1
  4573 000020B9 80C1FF              <1> 	add	cl, -1
  4574 000020BC 72D7                <1> 	jc	_normalise_residue
  4575 000020BE 31DB                <1> 	xor	ebx, ebx			; rrsidue all signs zero -> scale
  4576                              <1> _residue_normalised:
  4577 000020C0 F7C3000080FF        <1> 	test	ebx, 0FF800000h
  4578 000020C6 0F8566F4FFFF        <1> 	jnz	_fpxpo				; nonzero mantissa
  4579                              <1> 						; and exponent underflow / overflow
  4580                              <1> 						
  4581                              <1> ;			rrsidual mantissa on the stack now is
  4582                              <1> ;			______________________________________________
  4583                              <1> ;	sp------------->| mantissa bits 15..0 | 16 sign bits discard |
  4584                              <1> ;			|_____________________|______________________|
  4585                              <1> ;			|            mantissa bits 47..16            |
  4586                              <1> ;			|____________________________________________| 
  4587                              <1> ;			| 0000 0000  mantissa bits 71..48            |
  4588                              <1> ;			|____________________________________________|
  4589                              <1> ;			|	     result register indication      |
  4590                              <1> ;			|____________________________________________|
  4591                              <1> 
  4592 000020CC 8B4704              <1> 	mov	eax, dword ptr [rdi+1*4]	; signs
  4593 000020CF 31D8                <1> 	xor	eax, ebx			; sign rrsidue exponent now
  4594 000020D1 C1E008              <1> 	shl	eax, 8				; trim characteristic to RTA1 24-bit word
  4595 000020D4 C1E808              <1> 	shr	eax, 8
  4596 000020D7 894520              <1> 	mov	dword ptr [rbp+8*4], eax	; scale XOR signs -> rrsidue characteristic
  4597                              <1> 
  4598 000020DA 5B                  <1> 	pop	rbx				; low order mantissa part
  4599 000020DB 58                  <1> 	pop	rax				; middle order mantissa part
  4600 000020DC 88C3                <1> 	mov	bl, al				; donate 8 bits
  4601 000020DE C1CB08              <1> 	ror	ebx, 8				; distribute as RTA1 24-bit words
  4602 000020E1 C1EB08              <1> 	shr	ebx, 8				; mantissa 23..0
  4603 000020E4 C1E808              <1> 	shr	eax, 8				; mantissa 47..24
  4604 000020E7 895D2C              <1> 	mov	dword ptr [rbp+11*4], ebx
  4605 000020EA 894528              <1> 	mov	dword ptr [rbp+10*4], eax
  4606 000020ED 58                  <1> 	pop	rax				; high order rrsidual mantissa part
  4607 000020EE 5B                  <1> 	pop	rbx				; saved result register index
  4608 000020EF C1E008              <1> 	shl	eax, 8
  4609 000020F2 C1E808              <1> 	shr	eax, 8				; normalising position is bit 23
  4610 000020F5 894524              <1> 	mov	dword ptr [rbp+9*4], eax	; mantissa 71..48
  4611                              <1> 
  4612                              <1> _deliver:					; deliver floating result
  4613                              <1> 						; ebx = target register index
  4614                              <1> 						; result register index [rbp+]ebx*4
  4615 000020F8 8B07                <1> 	mov	eax, dword ptr [rdi]		; unsigned scale magnitude
  4616 000020FA A9000080FF          <1> 	test	eax, 0FF800000h
  4617 000020FF 0F852DF4FFFF        <1> 	jnz	_fpxpo				; exponent underflow / overflow
  4618 00002105 334704              <1> 	xor	eax, dword ptr [rdi+1*4]	; sign it
  4619 00002108 C1E008              <1> 	shl	eax, 8
  4620 0000210B C1E808              <1> 	shr	eax, 8
  4621                              <1> 
  4622                              <1> _store_float:
  4623 0000210E 89449D00            <1>         mov     dword ptr [rbp+rbx*4], eax      ; store characteristic = scale XOR signs
  4624 00002112 8B4708              <1>         mov     eax, dword ptr [rdi+2*4]	; read bits 71..40 major mantissa
  4625 00002115 0FB6C8              <1>         movzx   ecx, al
  4626 00002118 C1E808              <1>         shr     eax, 8
  4627 0000211B 89449D04            <1>         mov     dword ptr [rbp+rbx*4+4], eax	; store mantissa bits 71..48
  4628 0000211F 8B470C              <1>         mov     eax, dword ptr [rdi+3*4]	; read mantissa bits 39..8
  4629 00002122 C1E110              <1>         shl     ecx, 16				; position mantissa bits 47..40
  4630 00002125 C1C810              <1>         ror     eax, 16
  4631 00002128 6689C1              <1>         mov     cx, ax				; position mantissa bits 39..24
  4632 0000212B 894C9D08            <1>         mov     dword ptr [rbp+rbx*4+8], ecx	; store mantissa bits 47..24
  4633 0000212F 8B4F10              <1>         mov     ecx, dword ptr [rdi+4*4]	; read mantissa bits 7..0 plus 24 trailing bits
  4634 00002132 C1E910              <1>         shr     ecx, 16				; position after mantissa 23..8
  4635 00002135 6689C8              <1>         mov     ax, cx
  4636 00002138 C1E808              <1>         shr     eax, 8				; store mantissa bits 23..0
  4637 0000213B 89449D0C            <1>         mov     dword ptr [rbp+rbx*4+12], eax
  4638 0000213F C3                  <1> 	ret
  4639                              <1> 
  4640                              <1> ;	_output equ	272
  4641                              <1> ;	_inputr equ	264
  4642                              <1> ;	_input2 equ	256
  4643                              <1> 
  4644                              <1> ;	_OUTPUT	equ	__register+_output*4
  4645                              <1> ;	_INPUTR equ	__register+_inputr*4
  4646                              <1> ;	_INPUT2 equ	__register+_input2*4
  4647                              <1> ;	_BIAS	equ	_OUTPUT
  4648                              <1> 
  4649                              <1> zoutput:
  4650 00002140 31C0                <1> 	xor	eax, eax
  4651 00002142 8907                <1> 	mov	dword ptr [rdi], eax
  4652 00002144 894704              <1> 	mov	dword ptr [rdi+1*4], eax
  4653 00002147 894708              <1> 	mov	dword ptr [rdi+2*4], eax
  4654 0000214A 89470C              <1> 	mov	dword ptr [rdi+3*4], eax
  4655 0000214D 894710              <1> 	mov	dword ptr [rdi+4*4], eax
  4656 00002150 894714              <1> 	mov	dword ptr [rdi+5*4], eax
  4657 00002153 894718              <1> 	mov	dword ptr [rdi+6*4], eax
  4658 00002156 89471C              <1> 	mov	dword ptr [rdi+7*4], eax
  4659 00002159 C3                  <1> 	ret
  4660                              <1> 
  4661                              <1> 
  4662                              <1> ;	round before add or divide
  4663                              <1> ;	XOR rounding pattern to guard field
  4664                              <1> 
  4665 0000215A 0FB6DD              <1> round1:	movzx	ebx, ch
  4666 0000215D 8B8560020000        <1> 	mov	eax, dword ptr [rbp+CORE_INDEX1]
  4667 00002163 8B804C020000        <1> 	mov	eax, dword ptr [rax+REGISTER+FP_GUARD]
  4668 00002169 D3E8                <1> 	shr	eax, cl
  4669 0000216B C1E008              <1> 	shl	eax, 8
  4670 0000216E 31449F08            <1> 	xor	dword ptr [rdi+rbx*4+2*4], eax
  4671                              <1> 
  4672 00002172 C3                  <1> 	ret
  4673                              <1> 
  4674 00002173 0FB6DD              <1> round2:	movzx	ebx, ch
  4675 00002176 8B8560020000        <1> 	mov	eax, dword ptr [rbp+CORE_INDEX1]
  4676 0000217C 8B864C020000        <1> 	mov	eax, dword ptr [rsi+REGISTER+FP_GUARD]
  4677 00002182 D3E8                <1> 	shr	eax, cl
  4678 00002184 C1E008              <1> 	shl	eax, 8
  4679 00002187 01449F08            <1> 	add	dword ptr [rdi+rbx*4+2*4], eax
  4680                              <1> round2more:
  4681 0000218B 81549F0400000000    <1> 	adc	dword ptr [rdi+rbx*4+1*4], 0
  4682 00002193 FFCB                <1> 	dec	ebx
  4683 00002195 75F4                <1> 	jnz	round2more
  4684 00002197 C3                  <1> 	ret
  4685                              <1> 
  4686                              <1> __FLAT_STAC	equ	1
  4687                              <1> 
  4688                              <1> end_around_carry:
  4689                              <1> 
  4690                              <1> 	%if	__FLAT_STAC
  4691 00002198 F7D2                <1> 	not	edx				; signs B4
  4692 0000219A 0FB6C3              <1> 	movzx	eax, bl				; carry saved from add
  4693 0000219D 21D2                <1> 	and	edx, edx			; test new polarity
  4694                              <1> 	%else
  4695                              <1> 
  4696                              <1> 	not	dword ptr [rsi+2*4]		; seems to vary or be vaguely documented
  4697                              <1> 	movzx	eax, byte ptr [rsi+1*4]		; what size the call return stack frame is
  4698                              <1> 						; so we push ei and copy rsp to it
  4699                              <1> 						; to see stuff near the stack top
  4700                              <1> 
  4701                              <1> 	test	byte ptr dword ptr [rsi+2*4], 128
  4702                              <1> 	%endif
  4703                              <1> 
  4704 0000219F 790E                <1> 	jns	end_around_carry_plus		; updated signs +
  4705                              <1> 
  4706 000021A1 B8FFFFFFFF          <1> 	mov	eax, -1				; 1 -> -1 in 1s complement
  4707 000021A6 D3E8                <1> 	shr	eax, cl
  4708 000021A8 F7D0                <1> 	not	eax
  4709 000021AA E906000000          <1> 	jmp	eoc1
  4710                              <1> 
  4711                              <1> end_around_carry_plus:
  4712 000021AF 21C0                <1> 	and	eax, eax
  4713 000021B1 7417                <1> 	jz	eox1				; ? don't call this if there is no carry
  4714 000021B3 D3C8                <1> 	ror	eax, cl
  4715                              <1> 
  4716 000021B5 0FB6DD              <1> eoc1:	movzx	ebx, ch
  4717 000021B8 01449F08            <1> 	add	dword ptr [rdi+rbx*4+2*4], eax
  4718                              <1> 
  4719 000021BC 9C                  <1> 	pushfq
  4720 000021BD C1F81F              <1> 	sar	eax, 31				; shift leave carry alone
  4721 000021C0 9D                  <1> 	popfq
  4722                              <1> 
  4723 000021C1 FFC3                <1> 	inc	ebx				; but reference displacements - 2
  4724                              <1> 
  4725 000021C3 11049F              <1> eoc:	adc	dword ptr [rdi+rbx*4], eax	; referencing displacements - 2
  4726 000021C6 FFCB                <1> 	dec	ebx
  4727 000021C8 75F9                <1> 	jnz	eoc
  4728 000021CA C3                  <1> eox1:	ret
  4729                              <1> 
  4730                              <1> restore_trailing_signs:
  4731 000021CB 0FB6DD              <1> 	movzx	ebx, ch
  4732 000021CE 8B4704              <1> 	mov	eax, dword ptr [rdi+1*4]
  4733                              <1> 
  4734 000021D1 89471C              <1> 	mov	dword ptr [rdi+7*4], eax
  4735                              <1> 
  4736 000021D4 21C0                <1> 	and	eax, eax
  4737 000021D6 780B                <1> 	js	restore_trailing_ones
  4738 000021D8 F7D0                <1> 	not	eax
  4739 000021DA D3E8                <1> 	shr	eax, cl
  4740 000021DC F7D0                <1> 	not	eax
  4741 000021DE 21449F08            <1> 	and	dword ptr [rdi+rbx*4+2*4], eax
  4742 000021E2 C3                  <1> 	ret
  4743                              <1> 
  4744                              <1> restore_trailing_ones:
  4745 000021E3 D3E8                <1> 	shr	eax, cl
  4746 000021E5 09449F08            <1> 	or	dword ptr [rdi+rbx*4+2*4], eax
  4747                              <1> 
  4748 000021E9 C3                  <1> 	ret
  4749                              <1> 	
  4750                              <1> bias_addend:					; input mantissa [rsi] is biased into location _BIAS
  4751 000021EA 57                  <1> 	push	rdi
  4752 000021EB 4889F7              <1> 	mov	rdi, rsi
  4753                              <1> 
  4754 000021EE 488BB560020000      <1> 	mov	rsi, qword ptr[rbp+CORE_INDEX1]
  4755 000021F5 488DB640040000      <1> 	lea	rsi, [rsi+_BIAS]
  4756                              <1> 
  4757 000021FC 56                  <1> 	push	rsi
  4758 000021FD E803000000          <1> 	call	biasfp
  4759                              <1> 
  4760 00002202 5E                  <1> 	pop	rsi
  4761 00002203 5F                  <1> 	pop	rdi
  4762 00002204 C3                  <1> 	ret
  4763                              <1> 
  4764 00002205 52                  <1> biasfp:	push	rdx
  4765 00002206 51                  <1> 	push	rcx
  4766                              <1> 
  4767 00002207 BB01000000          <1> 	mov	ebx, 1				; output index
  4768 0000220C 66C1E003            <1> 	shl	ax, 3				; words sign fill
  4769 00002210 C0E803              <1> 	shr	al, 3				; bits sign fill
  4770 00002213 6689C1              <1> 	mov	cx, ax
  4771 00002216 4881C704000000      <1> 	add	rdi, 4				; input pointer
  4772 0000221D 8B07                <1> 	mov	eax, dword ptr [rdi]		; there shall be this word of signs at least
  4773                              <1> 
  4774 0000221F 89049E              <1> bias32:	mov	dword ptr [rsi+rbx*4], eax	; write 1 word of signs
  4775 00002222 FFC3                <1> 	inc	ebx				; consider the next output word
  4776 00002224 FECD                <1> 	dec	ch				; any more words of signs?
  4777 00002226 79F7                <1> 	jns	bias32
  4778                              <1> 
  4779 00002228 20C9                <1> 	and	cl, cl
  4780 0000222A 742F                <1> 	jz	bias_fast			; there is no 32-bit shift
  4781                              <1> 
  4782 0000222C B520                <1> 	mov	ch, 32				; demonstrate the missing advantage
  4783 0000222E 28CD                <1> 	sub	ch, cl				; of instruction architectures
  4784                              <1> 						; with 2-register shifts
  4785                              <1> biasup2:
  4786 00002230 81FB08000000        <1> 	cmp	ebx, 8
  4787 00002236 7442                <1> 	jz	bias_addx
  4788 00002238 4881C704000000      <1> 	add	rdi, 4				; read new mantissa word
  4789 0000223F 8B17                <1> 	mov	edx, dword ptr [rdi]		; it becomes word # new in edx
  4790 00002241 86E9                <1> 	xchg	ch, cl
  4791 00002243 D3E0                <1> 	shl	eax, cl				; shift buffered word left 32 - bit offset
  4792 00002245 86E9                <1> 	xchg	ch, cl
  4793 00002247 D3EA                <1> 	shr	edx, cl				; shift new mantissa word right bit offset
  4794 00002249 09D0                <1> 	or	eax, edx
  4795 0000224B 89049E              <1> 	mov	dword ptr [rsi+rbx*4], eax	; write 1 merged word
  4796 0000224E 8B07                <1> 	mov	eax, dword ptr [rdi]		; read the same mantissa word again
  4797 00002250 81C301000000        <1> 	add	ebx, 1				; it becomes word # previous in eax
  4798 00002256 E9D5FFFFFF          <1> 	jmp	biasup2
  4799                              <1> 
  4800                              <1> bias_fast:
  4801 0000225B 81FB08000000        <1> 	cmp	ebx, 8
  4802 00002261 7417                <1> 	jz	bias_addx
  4803 00002263 4881C704000000      <1> 	add	rdi, 4
  4804 0000226A 8B07                <1> 	mov	eax, dword ptr [rdi]
  4805 0000226C 89049E              <1> 	mov	dword ptr [rsi+rbx*4], eax
  4806 0000226F 81C301000000        <1> 	add	ebx, 1
  4807 00002275 E9E1FFFFFF          <1> 	jmp	bias_fast
  4808                              <1> 
  4809                              <1> bias_addx:
  4810 0000227A 59                  <1> 	pop	rcx
  4811 0000227B 5A                  <1> 	pop	rdx				; restore the program counter
  4812 0000227C C3                  <1> 	ret
  4813                              <1> 
  4814                              <1> frame_mantissa:
  4815                              <1> ;	ror	ecx, 16				; words count is up, beats index down
  4816 0000227D 80C501              <1> 	add	ch, 1				; up the beats index to beats count
  4817 00002280 66C1E905            <1> 	shr	cx, 5				; positions / 32 in ch
  4818 00002284 C0E903              <1> 	shr	cl, 3				; positions /// 32 in cl
  4819 00002287 0FB6DD              <1> 	movzx	ebx, ch				; derive platform words rounded down
  4820 0000228A C3                  <1> 	ret
  4821                              <1> 
  4822                              <1> renormalise:					; rule 1: restore sign fill in
  4823                              <1> 						; low-order containing platform word
  4824                              <1> ; done before end-around-carry, and saved
  4825                              <1> ;;	call	frame_mantissa			; it was mashed by rounding and adding
  4826 0000228B E83BFFFFFF          <1> 	call	restore_trailing_signs
  4827 00002290 C1C910              <1> 	ror	ecx, 16				; the governing parameter is now
  4828                              <1> 						; the containing words count in cx
  4829                              <1> renormalise32:
  4830 00002293 8B4708              <1> 	mov	eax, dword ptr [rdi+2*4]	; sample 32 mantissa bits
  4831 00002296 3B4704              <1> 	cmp	eax, dword ptr [rdi+1*4]	; compare it with 32 signs
  4832 00002299 750C                <1> 	jnz	renormalise8
  4833 0000229B E847000000          <1> 	call	rotate32left			; this also discovers if it's ALL signs = 0
  4834 000022A0 21C0                <1> 	and	eax, eax			; and is the only place that needs examined
  4835 000022A2 75EF                <1> 	jnz	renormalise32
  4836                              <1> 
  4837 000022A4 8907                <1> 	mov	dword ptr [rdi], eax		; mantissa is signed zero, +0 -> scale
  4838                              <1> renormalised:
  4839 000022A6 C3                  <1> 	ret
  4840                              <1> 
  4841                              <1> renormalise8:					; from this point on the value is nonzero
  4842 000022A7 C1C008              <1> 	rol	eax, 8				; are there 8 signs at head of mantissa?
  4843 000022AA 3A4707              <1> 	cmp	al, byte ptr [rdi+1*4+3]	; this is Intel and the 4th byte is high-order
  4844 000022AD 750D                <1> 	jnz	renormalise1			; you have found the 8 bits containing the
  4845                              <1> 						; normalising bit
  4846 000022AF E856000000          <1> 	call	rotate8left			; or else you haven't
  4847 000022B4 8B4708              <1> 	mov     eax, dword ptr [rdi+2*4]	; sample the moved mantissa
  4848 000022B7 E9EBFFFFFF          <1> 	jmp	renormalise8
  4849                              <1> 
  4850                              <1> renormalise1:
  4851                              <1> ;	movzx	ebx, cx	
  4852 000022BC 8B4704              <1> 	mov	eax, dword ptr [rdi+1*4]		
  4853                              <1> ;	mov	dword ptr [rdi+rbx*4+1*4], eax	; in case polarity has changed
  4854 000022BF 334708              <1> 	xor	eax, dword ptr [rdi+2*4]	; normalising bit opposite polarity to sign?
  4855 000022C2 78E2                <1> 	js	renormalised			; arrived
  4856 000022C4 E805000000          <1> 	call	bitwise_scale			; almost arrived
  4857 000022C9 E9EEFFFFFF          <1> 	jmp	renormalise1
  4858                              <1> 
  4859                              <1> 
  4860                              <1> bitwise_scale:
  4861 000022CE D1571C              <1> 	rcl	dword ptr [rdi+7*4], 1	; so it doesn't matter whether 0 or 1
  4862 000022D1 D15718              <1> 	rcl	dword ptr [rdi+6*4], 1	; gets shifted into the 192nd bit
  4863 000022D4 D15714              <1> 	rcl	dword ptr [rdi+5*4], 1
  4864 000022D7 D15710              <1> 	rcl	dword ptr [rdi+4*4], 1	; it's quicker to shift 6 words
  4865 000022DA D1570C              <1> 	rcl	dword ptr [rdi+3*4], 1	; than a counted loop of 4 or 5 or 6 words
  4866 000022DD D15708              <1> 	rcl	dword ptr [rdi+2*4], 1
  4867                              <1> 
  4868 000022E0 8107FFFFFFFF        <1> 	add	dword ptr [rdi], -1	; scale down
  4869 000022E6 C3                  <1> 	ret
  4870                              <1> 
  4871                              <1> rotate32left:				; rotate all containing platform words of mantissa
  4872 000022E7 52                  <1> 	push	rdx			; 32 bit positions left and report if all signs
  4873 000022E8 51                  <1> 	push	rcx
  4874 000022E9 0FB7D9              <1> 	movzx	ebx, cx
  4875 000022EC 31D2                <1> 	xor	edx, edx		; initialise equality = all signs
  4876                              <1> 
  4877                              <1> rotate32next:				; the word initially loaded in eax is all signs
  4878 000022EE FFCB                <1> 	dec	ebx
  4879 000022F0 87449F08            <1> 	xchg	eax, dword ptr [rdi+rbx*4+2*4]
  4880 000022F4 89C1                <1> 	mov	ecx, eax
  4881 000022F6 334F04              <1> 	xor	ecx, dword ptr [rdi+1*4] ; difference between this word and signs
  4882 000022F9 09CA                <1> 	or	edx, ecx		; sum of differences
  4883 000022FB 21DB                <1> 	and	ebx, ebx
  4884 000022FD 75EF                <1> 	jnz	rotate32next
  4885 000022FF 8107E0FFFFFF        <1> 	add	dword ptr [rdi], -32	; scale down
  4886 00002305 89D0                <1> 	mov	eax, edx
  4887 00002307 59                  <1> 	pop	rcx
  4888 00002308 5A                  <1> 	pop	rdx
  4889 00002309 C3                  <1> 	ret
  4890                              <1> 
  4891                              <1> rotate8left:				; rotate all containing platform words of mantissa
  4892 0000230A 51                  <1> 	push	rcx			; 8 bit positions left. 1st word is rotated already
  4893 0000230B 0FB7D9              <1> 	movzx	ebx, cx			; and contains signs in 8 low-order bit positions
  4894                              <1> rotate8next:
  4895 0000230E 8B4C9F08            <1> 	mov	ecx, dword ptr [rdi+rbx*4+2*4]
  4896 00002312 C1C108              <1> 	rol	ecx, 8
  4897 00002315 86C1                <1> 	xchg	al, cl
  4898 00002317 894C9F08            <1> 	mov	dword ptr [rdi+rbx*4+2*4], ecx
  4899 0000231B 81C3FFFFFFFF        <1> 	add	ebx, -1
  4900 00002321 72EB                <1> 	jc	rotate8next
  4901 00002323 8107F8FFFFFF        <1> 	add	dword ptr [rdi], -8	; scale down
  4902 00002329 59                  <1> 	pop	rcx
  4903 0000232A C3                  <1> 	ret
  4904                              <1> 
  4905 0000232B F75708              <1> zover:	not	dword ptr [rdi+2*4]
  4906 0000232E F7570C              <1> 	not	dword ptr [rdi+3*4]
  4907 00002331 F75710              <1> 	not	dword ptr [rdi+4*4]
  4908 00002334 F75714              <1> 	not	dword ptr [rdi+5*4]
  4909 00002337 F75718              <1> 	not	dword ptr [rdi+6*4]
  4910 0000233A F7571C              <1> 	not	dword ptr [rdi+7*4]
  4911 0000233D C3                  <1> 	ret
  4912                              <1> 
  4913                              <1> _add_low:
  4914 0000233E 8B961C040000        <1>         mov     edx, dword ptr [rsi+_INPUT2+7*4]
  4915 00002344 13963C040000        <1>         adc     edx, dword ptr [rsi+_INPUTR+7*4]
  4916 0000234A 8B9E18040000        <1>         mov     ebx, dword ptr [rsi+_INPUT2+6*4]
  4917 00002350 139E38040000        <1>         adc     ebx, dword ptr [rsi+_INPUTR+6*4]
  4918 00002356 8B8614040000        <1>         mov     eax, dword ptr [rsi+_INPUT2+5*4]
  4919 0000235C 138634040000        <1>         adc     eax, dword ptr [rsi+_INPUTR+5*4]
  4920 00002362 C3                  <1>         ret
  4921                              <1> 
  4922                              <1> _add_high:
  4923 00002363 8B9610040000        <1>         mov     edx, dword ptr [rsi+_INPUT2+4*4]
  4924 00002369 139630040000        <1>         adc     edx, dword ptr [rsi+_INPUTR+4*4]
  4925 0000236F 8B9E0C040000        <1>         mov     ebx, dword ptr [rsi+_INPUT2+3*4]
  4926 00002375 139E2C040000        <1>         adc     ebx, dword ptr [rsi+_INPUTR+3*4]
  4927 0000237B 8B8608040000        <1>         mov     eax, dword ptr [rsi+_INPUT2+2*4]
  4928 00002381 138628040000        <1>         adc     eax, dword ptr [rsi+_INPUTR+2*4]
  4929 00002387 C3                  <1>         ret
  4930                              <1> 
  4931 00002388 488DBE00040000      <1> fan:	lea	rdi, [rsi+_INPUT2]
  4932 0000238F E897FFFFFF          <1> 	call	zover				; mantissa
  4933 00002394 F79604040000        <1> 	not	dword ptr [rsi+_INPUT2+1*4]	; 32 signs
  4934                              <1> 
  4935 0000239A 488DBE20040000      <1> fa:	lea	rdi, [rsi+_INPUTR]
  4936 000023A1 67488DB600040000    <1> 	lea	rsi, [esi+_INPUT2]
  4937                              <1> 
  4938 000023A9 8B4604              <1> 	mov	eax, dword ptr [rsi+1*4]	; normalised?
  4939 000023AC 334608              <1> 	xor	eax, dword ptr [rsi+2*4]	; normalising bit must ^ signs
  4940 000023AF 7801                <1> 	js	fa_addend_normalised		; yes
  4941 000023B1 C3                  <1> fa_nop:	ret					; accumulator block unchanged
  4942                              <1> 
  4943                              <1> fa_addend_normalised:
  4944 000023B2 8B4704              <1> 	mov	eax, dword ptr [rdi+1*4]	; register side operand normalised?
  4945 000023B5 334708              <1> 	xor	eax, dword ptr [rdi+2*4]	; normalising bit must ^ signs
  4946 000023B8 7804                <1> 	js	fa_promote_magnitude		; normalised, get on with it
  4947 000023BA 4889F7              <1> 	mov	rdi, rsi			; accumulator block is not normalised
  4948 000023BD C3                  <1> 	ret					; storage addend zero-added
  4949                              <1> 
  4950                              <1> fa_promote_magnitude:
  4951 000023BE 8B07                <1> 	mov	eax, dword ptr [rdi]
  4952 000023C0 2B06                <1> 	sub	eax, dword ptr [rsi]
  4953                              <1> 
  4954 000023C2 7905                <1> 	jns	fa_add				; register-side operand is not lower
  4955                              <1> 
  4956 000023C4 4887F7              <1> 	xchg	rsi, rdi			;
  4957 000023C7 F7D8                <1> 	neg	eax
  4958                              <1> 
  4959                              <1> fa_add:	;	call	frame_mantissa
  4960 000023C9 50                  <1> 	push	rax				; exponent difference
  4961 000023CA E88BFDFFFF          <1> 	call	round1
  4962                              <1> 
  4963 000023CF 58                  <1> 	pop	rax				; exponent difference
  4964 000023D0 21C0                <1> 	and	eax, eax			; is + and either zero or not
  4965 000023D2 740C                <1> 	jz	fa_addfast
  4966                              <1> 
  4967 000023D4 3DBF000000          <1> 	cmp	eax, 191			; do they touch?
  4968 000023D9 77D6                <1> 	ja	fa_nop
  4969                              <1> 
  4970 000023DB E80AFEFFFF          <1> 	call	bias_addend
  4971                              <1> ;	mov	rsi, dword ptr [rbp+CORE_INDEX1] ; done inside bias_addend
  4972                              <1> ;	lea	rsi, [esi+_BIAS]		; shifted added
  4973                              <1> 
  4974                              <1> fa_addfast:
  4975 000023E0 8B4704              <1> 	mov	eax, dword ptr [rdi+1*4]	; before look signs
  4976                              <1> 
  4977                              <1> 	%if	__FLAT_STAC
  4978 000023E3 89C2                <1> 	mov	edx, eax
  4979                              <1> 	%else
  4980                              <1> 	push	rax				; near stack top until fa_normalised
  4981                              <1> 	%endif
  4982                              <1> 
  4983 000023E5 C1C910              <1> 	ror	ecx, 16				; get containing compute words
  4984 000023E8 0FB7D9              <1> 	movzx	ebx, cx				; index / count
  4985 000023EB C1C910              <1> 	ror	ecx, 16
  4986                              <1> 
  4987 000023EE F8                  <1> 	clc
  4988                              <1> 
  4989                              <1> fa_action:
  4990 000023EF 8B049E              <1> 	mov	eax, dword ptr [rsi+rbx*4]
  4991 000023F2 11049F              <1> 	adc	dword ptr [rdi+rbx*4], eax
  4992 000023F5 FFCB                <1> 	dec	ebx				; process word 1
  4993 000023F7 75F6                <1> 	jnz	fa_action			; leave word 0 alone
  4994                              <1> 
  4995 000023F9 0F92C3              <1> 	setc	bl				; boolean instructions following
  4996                              <1> 
  4997                              <1> 	%if	__FLAT_STAC
  4998                              <1> 	%else
  4999                              <1> 	push	rbx				; should not change carry but
  5000                              <1> 	%endif
  5001                              <1> 
  5002 000023FC 488BB560020000      <1> 	mov	rsi, qword ptr [rbp+CORE_INDEX1]
  5003                              <1> 
  5004                              <1> 	
  5005 00002403 8B4704              <1> 	mov	eax, dword ptr [rdi+1*4]	; has sign switched ?
  5006                              <1> 
  5007                              <1> 	%if	__FLAT_STAC
  5008 00002406 31D0                <1> 	xor	eax, edx
  5009                              <1> 	%else
  5010                              <1> 	xor	eax, dword ptr [rsp+1*4]
  5011                              <1> 	%endif
  5012                              <1> 	
  5013 00002408 7917                <1> 	jns	fa_testcarry
  5014                              <1> 
  5015                              <1> ;	not	dword ptr [rsi+7*4]
  5016                              <1> 
  5017 0000240A F686B004000008      <1> 	test	byte ptr [rsi+PSR], FP_R	; flag 8 = store residue
  5018 00002411 7509                <1> 	jnz	switch_long
  5019                              <1> 
  5020 00002413 F7561C              <1> 	not	dword ptr [rsi+7*4]
  5021 00002416 F75718              <1> 	not	dword ptr [rdi+6*4]		; if double size (+ residue)
  5022 00002419 F75714              <1> 	not	dword ptr [rdi+5*4]		; these are written in the add loop
  5023                              <1> switch_long:
  5024                              <1> 
  5025                              <1> ;	not	dword ptr [rdi+7*4]		; thru zero
  5026                              <1> 
  5027                              <1> 	%if	__FLAT_STAC
  5028                              <1> 	%else
  5029                              <1> 	push	rsi				; have a clear expectation
  5030                              <1> 	mov	rsi, rsp			; where the first stack words are
  5031                              <1> 	%endif
  5032                              <1> 
  5033 0000241C E877FDFFFF          <1> 	call	end_around_carry
  5034                              <1> 
  5035                              <1> 	%if	__FLAT_STAC
  5036                              <1> 	%else
  5037                              <1> 	pop	rsi
  5038                              <1> 	%endif
  5039                              <1> 
  5040                              <1> fa_testcarry:
  5041                              <1> 
  5042                              <1> 	%if	__FLAT_STAC
  5043 00002421 89D0                <1> 	mov	eax, edx
  5044                              <1> 	%else
  5045                              <1> 	mov	eax, dword ptr [rsp+1*4]		; [ rsp + 1L ] -> updated signs
  5046                              <1> 	%endif
  5047                              <1> 
  5048 00002423 334704              <1> 	xor	eax, dword ptr [rdi+1*4]		; carry from normalising position?
  5049                              <1> 
  5050 00002426 2401                <1> 	and	al, 1
  5051 00002428 7423                <1> 	jz	fa_normalise
  5052                              <1> 
  5053 0000242A FF07                <1> 	inc	dword ptr [rdi]				; exponent magnitude++
  5054                              <1> 
  5055                              <1> 	%if	 __FLAT_STAC
  5056 0000242C 89D0                <1> 	mov	eax, edx
  5057                              <1> 	%else
  5058                              <1> 	mov	eax, dword ptr [rsp+1*4]	 	; read 32 signs
  5059                              <1> 	%endif
  5060                              <1> 
  5061 0000242E D1C8                <1> 	ror	eax, 1					; move a sign to carry	
  5062                              <1> 
  5063 00002430 D15F04              <1> 	rcr	dword ptr [rdi+1*4], 1			; shift from signs word
  5064 00002433 D15F08              <1> 	rcr	dword ptr [rdi+2*4], 1			; to normalising position
  5065 00002436 D15F0C              <1> 	rcr	dword ptr [rdi+3*4], 1			; keep going
  5066 00002439 D15F10              <1> 	rcr	dword ptr [rdi+4*4], 1
  5067 0000243C D15F14              <1> 	rcr	dword ptr [rdi+5*4], 1
  5068 0000243F D15F18              <1> 	rcr	dword ptr [rdi+6*4], 1
  5069 00002442 D15F1C              <1> 	rcr	dword ptr [rdi+7*4], 1
  5070                              <1> 
  5071 00002445 894704              <1> 	mov	dword ptr [rdi+1*4], eax		; write all signs back to signs word
  5072                              <1> 
  5073 00002448 E905000000          <1> 	jmp	fa_normalised
  5074                              <1> 
  5075                              <1> fa_normalise:
  5076 0000244D E839FEFFFF          <1> 	call	renormalise				; in case the sum is plenty positions
  5077                              <1> 
  5078                              <1> fa_normalised:
  5079                              <1> 	%if	__FLAT_STAC
  5080                              <1> 	%else
  5081                              <1> 	pop	rbx
  5082                              <1> 	pop	rax					; below the fractional point
  5083                              <1> 	%endif
  5084 00002452 C3                  <1> 	ret
  5085                              <1> 	
  5086 00002453 488DBE40040000      <1> fm:	lea	rdi, [rsi+_OUTPUT]			; initialise final accumulation
  5087 0000245A E8E1FCFFFF          <1> 	call	zoutput
  5088                              <1> 
  5089 0000245F 8B9E24040000        <1> 	mov	ebx, dword ptr [rsi+_INPUTR+1*4]	; read register-side signs
  5090 00002465 8B8628040000        <1> 	mov	eax, dword ptr [rsi+_INPUTR+2*4]	; and high-end mantissa
  5091 0000246B 31D8                <1> 	xor	eax, ebx	 			; cache if-normalised in eax
  5092 0000246D 339E04040000        <1> 	xor	ebx, dword ptr [rsi+_INPUT2+1*4]	; multiply signs
  5093 00002473 899E44040000        <1> 	mov	dword ptr [rsi+_OUTPUT+1*4], ebx	; save the output sign
  5094 00002479 21C0                <1> 	and	eax, eax				; test the cached if-normalised
  5095 0000247B 790E                <1> 	jns	fmdont
  5096                              <1> 
  5097 0000247D 8B8604040000        <1> 	mov	eax, dword ptr [rsi+_INPUT2+1*4]	; is the multiplier normalised?
  5098 00002483 338608040000        <1> 	xor	eax, dword ptr [rsi+_INPUT2+2*4]	; sign XOR normalising bit?
  5099 00002489 782F                <1> 	js	fmgo					; yes, proceed
  5100                              <1> 
  5101 0000248B 899E48040000        <1> fmdont:	mov	dword ptr [rsi+_OUTPUT+2*4], ebx
  5102 00002491 899E4C040000        <1> 	mov	dword ptr [rsi+_OUTPUT+3*4], ebx
  5103 00002497 899E50040000        <1> 	mov	dword ptr [rsi+_OUTPUT+4*4], ebx
  5104 0000249D 899E54040000        <1> 	mov	dword ptr [rsi+_OUTPUT+5*4], ebx
  5105 000024A3 899E58040000        <1> 	mov	dword ptr [rsi+_OUTPUT+6*4], ebx
  5106 000024A9 899E5C040000        <1> 	mov	dword ptr [rsi+_OUTPUT+7*4], ebx
  5107 000024AF C78640040000000000- <1> 	mov	dword ptr [rsi+_OUTPUT], 0		; mantissa to go
  5108 000024B8 00                  <1>
  5109                              <1> 
  5110 000024B9 C3                  <1> 	ret					; no, effective zero multiplier
  5111                              <1> 
  5112 000024BA 51                  <1> fmgo:	push	rcx
  5113 000024BB 8B8624040000        <1> 	mov	eax, dword ptr [rsi+_INPUTR+1*4]
  5114 000024C1 B148                <1> 	mov	cl, 72				; beats count exactly 72
  5115 000024C3 21C0                <1> 	and	eax, eax
  5116                              <1> 
  5117 000024C5 790C                <1> 	jns	fmp1
  5118 000024C7 488DBE20040000      <1> 	lea	rdi, [rsi+_INPUTR]
  5119 000024CE E858FEFFFF          <1> 	call	zover
  5120                              <1> 
  5121 000024D3 8B8604040000        <1> fmp1:	mov	eax, dword ptr [rsi+_INPUT2+1*4]
  5122 000024D9 21C0                <1> 	and	eax, eax
  5123 000024DB 790C                <1> 	jns	fmadd
  5124 000024DD 488DBE00040000      <1> 	lea	rdi, [rsi+_INPUT2]
  5125 000024E4 E842FEFFFF          <1> 	call	zover
  5126                              <1> 
  5127 000024E9 F8                  <1> fmadd:	clc
  5128                              <1> 
  5129 000024EA 488DBE20040000      <1> 	lea	rdi, [rsi+_INPUTR]
  5130 000024F1 D15F08              <1> 	rcr	dword ptr [rdi+2*4], 1		; addend shift right
  5131 000024F4 D15F0C              <1> 	rcr	dword ptr [rdi+3*4], 1
  5132 000024F7 D15F10              <1> 	rcr	dword ptr [rdi+4*4], 1
  5133 000024FA D15F14              <1> 	rcr	dword ptr [rdi+5*4], 1
  5134 000024FD D15F18              <1> 	rcr	dword ptr [rdi+6*4], 1
  5135 00002500 D15F1C              <1> 	rcr	dword ptr [rdi+7*4], 1
  5136                              <1> 
  5137 00002503 488DBE00040000      <1> 	lea	rdi, [rsi+_INPUT2]
  5138                              <1> ;	rcl	dword ptr [rdi+7*4], 1		; multiplier shift left
  5139                              <1> ;	rcl	dword ptr [rdi+6*4], 1
  5140                              <1> ;	rcl	dword ptr [rdi+5*4], 1		; multiplier mantissa is only 72 bits
  5141 0000250A D15710              <1> 	rcl	dword ptr [rdi+4*4], 1
  5142 0000250D D1570C              <1> 	rcl	dword ptr [rdi+3*4], 1
  5143 00002510 D15708              <1> 	rcl	dword ptr [rdi+2*4], 1
  5144                              <1> 
  5145 00002513 488DBE40040000      <1> 	lea	rdi, [rsi+_OUTPUT]
  5146 0000251A 7336                <1> 	jnc	fmadx
  5147                              <1> 						; 1 shifted from multiplier
  5148 0000251C 8B863C040000        <1> fmadc:	mov	eax, dword ptr [rsi+_INPUTR+7*4]	
  5149 00002522 01471C              <1> 	add	dword ptr [rdi+7*4], eax	; do not use carry
  5150 00002525 8B8638040000        <1> 	mov	eax, dword ptr [rsi+_INPUTR+6*4]
  5151 0000252B 114718              <1> 	adc	dword ptr [rdi+6*4], eax	; start using carry
  5152 0000252E 8B8634040000        <1> 	mov	eax, dword ptr [rsi+_INPUTR+5*4]
  5153 00002534 114714              <1> 	adc	dword ptr [rdi+5*4], eax
  5154 00002537 8B8630040000        <1> 	mov	eax, dword ptr [rsi+_INPUTR+4*4]
  5155 0000253D 114710              <1> 	adc	dword ptr [rdi+4*4], eax
  5156 00002540 8B862C040000        <1> 	mov	eax, dword ptr [rsi+_INPUTR+3*4]
  5157 00002546 11470C              <1> 	adc	dword ptr [rdi+3*4], eax
  5158 00002549 8B8628040000        <1> 	mov	eax, dword ptr [rsi+_INPUTR+2*4]
  5159 0000254F 114708              <1> 	adc	dword ptr [rdi+2*4], eax
  5160                              <1> 
  5161 00002552 FEC9                <1> fmadx:	dec	cl
  5162 00002554 7593                <1> 	jnz	fmadd
  5163                              <1> 
  5164 00002556 59                  <1> fmadz:	pop	rcx
  5165                              <1> 
  5166 00002557 8B4708              <1> 	mov	eax, dword ptr [rdi+2*4] 	; normalised?
  5167 0000255A D1D0                <1> 	rcl	eax, 1
  5168 0000255C 7221                <1> 	jc	fm_normalised
  5169                              <1> 
  5170 0000255E 818620040000FFFFFF- <1> 	add	dword ptr [rsi+_INPUTR], -1		; take 1 from scale
  5171 00002567 FF                  <1>
  5172 00002568 D1571C              <1> 	rcl	dword ptr [rdi+7*4], 1
  5173 0000256B D15718              <1> 	rcl	dword ptr [rdi+6*4], 1
  5174 0000256E D15714              <1> 	rcl	dword ptr [rdi+5*4], 1
  5175 00002571 D15710              <1> 	rcl	dword ptr [rdi+4*4], 1
  5176 00002574 D1570C              <1> 	rcl	dword ptr [rdi+3*4], 1
  5177 00002577 D15708              <1> 	rcl	dword ptr [rdi+2*4], 1
  5178                              <1> 
  5179 0000257A E92A000000          <1> 	jmp	fm_inrange
  5180                              <1> 
  5181                              <1> fm_normalised:
  5182 0000257F 488DBE40040000      <1> 	lea	rdi, [rsi+_OUTPUT]
  5183 00002586 E8E8FBFFFF          <1> 	call	round2
  5184 0000258B 731C                <1> 	jnc	fm_inrange
  5185                              <1> 
  5186 0000258D D15F08              <1> 	rcr	dword ptr [rdi+2*4], 1
  5187 00002590 D15F0C              <1> 	rcr	dword ptr [rdi+3*4], 1
  5188 00002593 D15F10              <1> 	rcr	dword ptr [rdi+4*4], 1
  5189 00002596 D15F14              <1> 	rcr	dword ptr [rdi+5*4], 1
  5190 00002599 D15F18              <1> 	rcr	dword ptr [rdi+6*4], 1
  5191 0000259C D15F1C              <1> 	rcr	dword ptr [rdi+7*4], 1
  5192 0000259F 818620040000010000- <1> 	add	dword ptr [rsi+_INPUTR], 1
  5193 000025A8 00                  <1>
  5194                              <1> 
  5195                              <1> fm_inrange:
  5196 000025A9 8B8620040000        <1> 	mov	eax, dword ptr [rsi+_INPUTR]
  5197 000025AF 038600040000        <1> 	add	eax, dword ptr [rsi+_INPUT2]
  5198 000025B5 050000C0FF          <1> 	add	eax, -00400000h
  5199 000025BA 8907                <1> 	mov	dword ptr [rdi], eax		; insert unsigned magnitude product scale
  5200 000025BC 8B4704              <1> 	mov	eax, dword ptr [rdi+1*4]
  5201 000025BF 314708              <1> 	xor	dword ptr [rdi+2*4], eax	; the mantissa gets polarised here
  5202 000025C2 31470C              <1> 	xor	dword ptr [rdi+3*4], eax
  5203 000025C5 314710              <1> 	xor	dword ptr [rdi+4*4], eax
  5204 000025C8 314714              <1> 	xor	dword ptr [rdi+5*4], eax
  5205 000025CB 314718              <1> 	xor	dword ptr [rdi+6*4], eax
  5206 000025CE 31471C              <1> 	xor	dword ptr [rdi+7*4], eax
  5207 000025D1 C3                  <1> 	ret
  5208                              <1> 
  5209 000025D2 488DBE40040000      <1> fd:	lea	rdi, [rsi+_OUTPUT]
  5210 000025D9 E862FBFFFF          <1> 	call	zoutput				; result which may stay zero
  5211 000025DE 8B8604040000        <1> 	mov	eax, dword ptr [rsi+_INPUT2+1*4]	; signs
  5212 000025E4 89C3                <1> 	mov	ebx, eax
  5213 000025E6 338608040000        <1> 	xor	eax, dword ptr [rsi+_INPUT2+2*4]	; normalising bit 31
  5214 000025EC 780C                <1> 	js	fdgo
  5215 000025EE F79644040000        <1> 	not	dword ptr [rsi+_OUTPUT+1*4]		; divisor 0 or otherwise unnormalised
  5216 000025F4 E832FDFFFF          <1> 	call	zover				; return -0.0
  5217 000025F9 C3                  <1> fdnop:	ret					; not normalised = zero divisor
  5218                              <1> 
  5219 000025FA 8B8624040000        <1> fdgo:	mov     eax, dword ptr [rsi+_INPUTR+1*4]	; make sure the dividend is present
  5220 00002600 338628040000        <1> 	xor	eax, dword ptr [rsi+_INPUTR+2*4]	; normalising bit must be not sign
  5221 00002606 783B                <1> 	js	fdop				; go after all
  5222                              <1> 						; unnormalised = 0 = unnormalised
  5223 00002608 8B8624040000        <1> 	mov	eax, dword ptr [rsi+_INPUTR+1*4]	; read the signs I tell you
  5224 0000260E C78640040000000000- <1> 	mov	dword ptr [rsi+_OUTPUT], 0		; exponent magnitude of nowhere
  5225 00002617 00                  <1>
  5226 00002618 898644040000        <1> 	mov	dword ptr [rsi+_OUTPUT+1*4], eax	; signs
  5227 0000261E 898648040000        <1> 	mov	dword ptr [rsi+_OUTPUT+2*4], eax	; and as much mantissa as you like
  5228 00002624 89864C040000        <1> 	mov	dword ptr [rsi+_OUTPUT+3*4], eax
  5229 0000262A 898650040000        <1> 	mov	dword ptr [rsi+_OUTPUT+4*4], eax
  5230 00002630 898654040000        <1> 	mov	dword ptr [rsi+_OUTPUT+5*4], eax
  5231 00002636 898658040000        <1> 	mov	dword ptr [rsi+_OUTPUT+6*4], eax
  5232 0000263C 89865C040000        <1> 	mov	dword ptr [rsi+_OUTPUT+7*4], eax
  5233 00002642 C3                  <1> 	ret
  5234                              <1> 
  5235 00002643 21DB                <1> fdop:	and	ebx, ebx				; divisor either is negative magnitude
  5236 00002645 780C                <1> 	js	fd_comp1	
  5237 00002647 488DBE00040000      <1> 	lea	rdi, [rsi+_INPUT2]			; or shall be
  5238 0000264E E8D8FCFFFF          <1> 	call	zover
  5239                              <1> fd_comp1:
  5240 00002653 F78624040000000000- <1> 	test	dword ptr [rsi+_INPUTR+1*4], 080000000h
  5241 0000265C 80                  <1>
  5242 0000265D 740C                <1> 	jz	fd_upright			; dividend must be positive magnitude
  5243 0000265F 488DBE20040000      <1> 	lea	rdi, [rsi+_INPUTR]
  5244 00002666 E8C0FCFFFF          <1> 	call	zover
  5245                              <1> fd_upright:
  5246 0000266B 488DBE20040000      <1> 	lea	rdi, [rsi+_INPUTR]
  5247                              <1> 
  5248 00002672 E8E3FAFFFF          <1> 	call	round1				; this also sets counters
  5249                              <1> 
  5250 00002677 52                  <1> 	push	rdx
  5251 00002678 51                  <1> 	push	rcx
  5252                              <1> 
  5253                              <1> ;	add	cx, 01818h		; a divide needs 24 more beats
  5254                              <1> 					; than a multiply
  5255                              <1> 
  5256 00002679 89C8                <1> 	mov	eax, ecx		; save words count in add range
  5257 0000267B B15F                <1> 	mov	cl, 95
  5258                              <1> 
  5259 0000267D C1E810              <1> 	shr	eax, 16			; isolate words count in add range
  5260 00002680 6605FAFF            <1> 	add	ax, -6			; is it big?
  5261 00002684 0F8396000000        <1> 	jnc	near fd_72
  5262                              <1> 
  5263                              <1> ;	test	ch, 128
  5264                              <1> ;	jz	near fd_72
  5265                              <1> 
  5266 0000268A 4889E7              <1> 	mov	rdi, rsp
  5267                              <1> 
  5268 0000268D B1BF                <1> 	mov	cl, 191			; maybe
  5269                              <1> 
  5270 0000268F F9                  <1> fd_144:	stc				; add negative mantissa
  5271 00002690 E8A9FCFFFF          <1> 	call	_add_low		; to positive dividend
  5272 00002695 52                  <1> 	push	rdx			; save the low half in the stack
  5273 00002696 53                  <1> 	push	rbx
  5274 00002697 50                  <1> 	push	rax
  5275 00002698 E8C6FCFFFF          <1> 	call	_add_high			; add the high half in eax edx ebx
  5276                              <1> 
  5277 0000269D 7327                <1> 	jnc	fd_144level			; no carry = drop the result
  5278                              <1> 
  5279 0000269F 898628040000        <1> 	mov	dword ptr [rsi+_INPUTR+2*4], eax	; carry = update the dividend
  5280 000026A5 899E2C040000        <1> 	mov	dword ptr [rsi+_INPUTR+3*4], ebx
  5281 000026AB 899630040000        <1> 	mov	dword ptr [rsi+_INPUTR+4*4], edx
  5282                              <1> 
  5283 000026B1 58                  <1> 	pop	rax
  5284 000026B2 898634040000        <1> 	mov	dword ptr [rsi+_INPUTR+5*4], eax
  5285 000026B8 58                  <1> 	pop	rax
  5286 000026B9 898638040000        <1> 	mov	dword ptr [rsi+_INPUTR+6*4], eax
  5287 000026BF 58                  <1> 	pop	rax
  5288 000026C0 89863C040000        <1> 	mov	dword ptr [rsi+_INPUTR+7*4], eax
  5289                              <1> fd_144level:
  5290 000026C6 4889FC              <1> 	mov	rsp, rdi	; clear stack whether popped or not
  5291 000026C9 D1965C040000        <1> 	rcl	dword ptr [rsi+_OUTPUT+7*4], 1	; shift value of carry into quotient
  5292 000026CF D19658040000        <1> 	rcl	dword ptr [rsi+_OUTPUT+6*4], 1
  5293 000026D5 D19654040000        <1> 	rcl	dword ptr [rsi+_OUTPUT+5*4], 1
  5294 000026DB D19650040000        <1> 	rcl	dword ptr [rsi+_OUTPUT+4*4], 1
  5295 000026E1 D1964C040000        <1> 	rcl	dword ptr [rsi+_OUTPUT+3*4], 1
  5296 000026E7 D19648040000        <1> 	rcl	dword ptr [rsi+_OUTPUT+2*4], 1
  5297                              <1> 
  5298 000026ED F9                  <1> 	stc
  5299 000026EE D19E08040000        <1> 	rcr	dword ptr [rsi+_INPUT2+2*4], 1	; shift negative addend
  5300 000026F4 D19E0C040000        <1> 	rcr	dword ptr [rsi+_INPUT2+3*4], 1	; 1 position starboard
  5301 000026FA D19E10040000        <1> 	rcr	dword ptr [rsi+_INPUT2+4*4], 1
  5302 00002700 D19E14040000        <1> 	rcr	dword ptr [rsi+_INPUT2+5*4], 1
  5303 00002706 D19E18040000        <1> 	rcr	dword ptr [rsi+_INPUT2+6*4], 1
  5304 0000270C D19E1C040000        <1> 	rcr	dword ptr [rsi+_INPUT2+7*4], 1
  5305                              <1> 
  5306 00002712 80C1FF              <1> 	add	cl, -1
  5307 00002715 0F8274FFFFFF        <1> 	jc	fd_144
  5308 0000271B E944000000          <1> 	jmp	fd_restore	
  5309                              <1> 
  5310 00002720 F9                  <1> fd_72:	stc					; add negative mantissa
  5311 00002721 E83DFCFFFF          <1> 	call	_add_high			; to positive dividend
  5312 00002726 7312                <1> 	jnc	fd_72level			; no carry = drop the result
  5313                              <1> 
  5314 00002728 898628040000        <1> 	mov	dword ptr [rsi+_INPUTR+2*4], eax	; carry = update the dividend
  5315 0000272E 899E2C040000        <1> 	mov	dword ptr [rsi+_INPUTR+3*4], ebx
  5316 00002734 899630040000        <1> 	mov	dword ptr [rsi+_INPUTR+4*4], edx
  5317                              <1> fd_72level:
  5318 0000273A D19650040000        <1> 	rcl	dword ptr [rsi+_OUTPUT+4*4], 1	; shift value of carry into quotient
  5319 00002740 D1964C040000        <1> 	rcl	dword ptr [rsi+_OUTPUT+3*4], 1
  5320 00002746 D19648040000        <1> 	rcl	dword ptr [rsi+_OUTPUT+2*4], 1
  5321                              <1> 
  5322 0000274C F9                  <1> 	stc
  5323 0000274D D19E08040000        <1> 	rcr	dword ptr [rsi+_INPUT2+2*4], 1	; shift negative addend
  5324 00002753 D19E0C040000        <1> 	rcr	dword ptr [rsi+_INPUT2+3*4], 1	; 1 position starboard
  5325 00002759 D19E10040000        <1> 	rcr	dword ptr [rsi+_INPUT2+4*4], 1	;
  5326                              <1> 
  5327 0000275F 80C1FF              <1> 	add	cl, -1
  5328 00002762 72BC                <1> 	jc	fd_72
  5329                              <1> 
  5330 00002764 59                  <1> fd_restore:	pop	rcx
  5331 00002765 5A                  <1> 		pop	rdx				; hand the program counter back
  5332                              <1> 
  5333                              <1> 
  5334                              <1> ;		mov	rsi, dword ptr [rbp+CORE_INDEX1] ; fd kept esi -> core state
  5335                              <1> 
  5336 00002766 8B8620040000        <1> 		mov	eax, dword ptr [rsi+_INPUTR]	; + magnitude dividend exponent
  5337 0000276C 2B8600040000        <1> 		sub	eax, dword ptr [rsi+_INPUT2]	; + magnitude divisor exponent
  5338 00002772 0501004000          <1> 		add	eax, 00400001h			; midpoint + 1
  5339 00002777 898640040000        <1> 		mov	dword ptr [rsi+_OUTPUT], eax	; magnitude of quotient scale
  5340                              <1> 							; -> front of delivery string
  5341 0000277D 488DBE40040000      <1> 		lea	rdi, [rsi+_OUTPUT]
  5342                              <1> 
  5343 00002784 E802FBFFFF          <1> 		call	renormalise
  5344                              <1> 
  5345 00002789 488DBE40040000      <1> 		lea	rdi, [rsi+_OUTPUT]			; tell rewrite where it is
  5346 00002790 8B8624040000        <1> 		mov	eax, dword ptr [rsi+_INPUTR+1*4]	; determine sign of quotient
  5347 00002796 338604040000        <1> 		xor	eax, dword ptr [rsi+_INPUT2+1*4]
  5348 0000279C 894704              <1> 		mov	[rdi+1*4], eax			; output 32 signs
  5349                              <1> 							; _deliver_ polarises the quotient scale
  5350 0000279F 314708              <1> 		xor	dword ptr [rdi+2*4], eax	; switch quotient mantissa
  5351 000027A2 31470C              <1> 		xor	dword ptr [rdi+3*4], eax
  5352 000027A5 314710              <1> 		xor	dword ptr [rdi+4*4], eax
  5353 000027A8 314714              <1> 		xor	dword ptr [rdi+5*4], eax	; switch the long mantissa
  5354 000027AB 314718              <1> 		xor	dword ptr [rdi+6*4], eax
  5355 000027AE 31471C              <1> 		xor	dword ptr [rdi+7*4], eax
  5356                              <1> 
  5357 000027B1 C3                  <1> fd_z:		ret
  5358                              <1> 
  5359                              <1> 	;	these instructions take the left-side + target as
  5360                              <1> 	;	[register_set]->a:b:mantissa2:mantissa3
  5361                              <1> 	;	and the right side as [ea]
  5362                              <1> 
  5363                              <1> 	;	after acquisition and before delivery they call modules
  5364                              <1> ;	fa fan fm fd
  5365                              <1> ;	which may be used in extended instruction sets
  5366                              <1> ;	using source and target registers in the internal stack
  5367                              <1> ;	with maximum mantissa size 168 bits
  5368                              <1> 
  5369                              <1> 
  5370                              <1> ;	rsi -> core state but must also be used dynamically a lot
  5371                              <1> ;	rbp -> always points at either one of two locations
  5372                              <1> 
  5373                              <1> ;		RTA1 application registers [ 0..127 ] modeled in 128 integers
  5374                              <1> ;		RTA1 interrupt registers [ 128..255 ] modeled in 128 integers
  5375                              <1> ;
  5376                              <1> ;	there is always a copy of rsi for retrieval at [ rbp + 152 integers ] ->
  5377                              <1> 
  5378                              <1> ;	_________________________.------ rsi and rbp in application mode
  5379                              <1> ;	|  RTA1 register 0	|					|
  5380                              <1> ;	|_______________________|					|
  5381                              <1> ;									|
  5382                              <1> ;	________________________.------- rbp in ISR mode		|
  5383                              <1> ;	|  RTA1 register 128	|			|		|
  5384                              <1> ;	|_______________________|			|		|
  5385                              <1> ;							|		|
  5386                              <1> ;							|		|
  5387                              <1> ;							|		|
  5388                              <1> ;	_________________________.______________________________________|
  5389                              <1> ;	| RTA register 152 = rsi| offset rbp + 152 integers 
  5390                              <1> ;	|_______________________|			|
  5391                              <1> ;							|
  5392                              <1> ;	.________________________.______________________|
  5393                              <1> ;	| RTA register 280 = rsi| offset rbp + 152 integers
  5394                              <1> ;	|_______________________|
  5395                              <1> 
  5396 000027B2 BB04000000          <1> _fa:	mov 	ebx, a
  5397 000027B7 53                  <1> _far:	push	rbx
  5398 000027B8 E86F000000          <1> 	call	fp_operands
  5399 000027BD E8A0000000          <1> 	call	fp_registers_a
  5400 000027C2 E8D3FBFFFF          <1> 	call	fa
  5401 000027C7 5B                  <1> 	pop	rbx
  5402 000027C8 E990F8FFFF          <1> 	jmp	_deliver_
  5403                              <1> 
  5404 000027CD BB04000000          <1> _fan:	mov	ebx, a
  5405 000027D2 53                  <1> _fanr:	push	rbx
  5406 000027D3 E854000000          <1> 	call	fp_operands
  5407 000027D8 E885000000          <1> 	call	fp_registers_a
  5408 000027DD E8A6FBFFFF          <1> 	call	fan
  5409 000027E2 5B                  <1> 	pop	rbx
  5410 000027E3 E975F8FFFF          <1> 	jmp	_deliver_
  5411                              <1> 
  5412 000027E8 BB04000000          <1> _fm:	mov	ebx, a
  5413 000027ED 53                  <1> _fmr:	push	rbx
  5414 000027EE E839000000          <1> 	call	fp_operands
  5415 000027F3 E888000000          <1> 	call	fp_registers_m
  5416 000027F8 E856FCFFFF          <1> 	call	fm
  5417 000027FD 5B                  <1> 	pop	rbx
  5418 000027FE 488DBE40040000      <1> 	lea	rdi, [rsi+_OUTPUT]
  5419 00002805 E953F8FFFF          <1> 	jmp	 _deliver_
  5420                              <1> 
  5421 0000280A BB04000000          <1> _fd:	mov	ebx, a				; default target register
  5422 0000280F 53                  <1> _fdr:	push	rbx
  5423 00002810 E817000000          <1> 	call	fp_operands
  5424 00002815 E866000000          <1> 	call	fp_registers_m
  5425 0000281A E8B3FDFFFF          <1> 	call	fd
  5426 0000281F 5B                  <1> 	pop	rbx
  5427 00002820 488DBE40040000      <1> 	lea	rdi, [rsi+_OUTPUT]
  5428 00002827 E931F8FFFF          <1> 	jmp	_deliver_
  5429                              <1> 
  5430                              <1> fp_operands:
  5431 0000282C 488DBE20040000      <1> 	lea	rdi, [rsi+_INPUTR]
  5432 00002833 50                  <1> 	push	rax				; save effective address
  5433 00002834 E865000000          <1> 	call	_load_quad
  5434 00002839 E8D6F7FFFF          <1> 	call	compress4to8
  5435 0000283E 58                  <1> 	pop	rax				; restore effective address
  5436                              <1> 
  5437 0000283F 55                  <1> 	push	rbp				; ebp must momentarily
  5438 00002840 4889F5              <1> 	mov	rbp, rsi			; -> start of all register list
  5439 00002843 BB00010000          <1> 	mov	ebx, _input2			; into starboard buffer
  5440 00002848 E895DCFFFF          <1> 	call	_burst_read4			; memory or registers @ ea
  5441 0000284D 5D                  <1> 	pop	rbp				; App / Int register context
  5442                              <1> 
  5443 0000284E 488BB560020000      <1> 	mov	rsi, qword ptr [rbp+CORE_INDEX1]
  5444 00002855 488DBE00040000      <1> 	lea	rdi, [rsi+_INPUT2]		; but still in rbp
  5445 0000285C E8B3F7FFFF          <1> 	call	compress4to8
  5446 00002861 C3                  <1> 	ret
  5447                              <1> 
  5448                              <1> fp_registers_a:
  5449 00002862 488BB560020000      <1> 	mov	rsi, qword ptr [rbp+CORE_INDEX1]
  5450 00002869 B908020400          <1> 	mov	ecx, 00040208h
  5451 0000286E F786B0040000080000- <1> 	test	dword ptr [rsi+PSR], FP_R
  5452 00002877 00                  <1>
  5453 00002878 7405                <1> 	jz	fp_registers_x
  5454 0000287A B910040600          <1> 	mov	ecx, 00060410h
  5455                              <1> fp_registers_x:
  5456 0000287F C3                  <1> 	ret
  5457                              <1> 
  5458                              <1> fp_registers_m:
  5459 00002880 488BB560020000      <1> 	mov	rsi, qword ptr [rbp+CORE_INDEX1]
  5460 00002887 B908020400          <1> 	mov	ecx, 00040208h
  5461 0000288C F786B0040000080000- <1> 	test	dword ptr [rsi+PSR], FP_R
  5462 00002895 00                  <1>
  5463 00002896 7405                <1> 	jz	fp_registers_z
  5464 00002898 B910040600          <1> 	mov	ecx, 00060410h
  5465                              <1> fp_registers_z:
  5466 0000289D C3                  <1> 	ret
  5467                              <1> 
  5468                              <1> _load_quad:
  5469 0000289E 8B449D0C            <1> 	mov	eax, dword ptr[rbp+rbx*4+3*4]
  5470 000028A2 89470C              <1> 	mov	dword ptr [rdi+3*4], eax
  5471 000028A5 8B449D08            <1> 	mov	eax, dword ptr  [rbp+rbx*4+2*4]
  5472 000028A9 894708              <1> 	mov	dword ptr [rdi+2*4], eax
  5473 000028AC 8B449D04            <1> 	mov	eax, dword ptr [rbp+rbx*4+1*4]
  5474 000028B0 894704              <1> 	mov	dword ptr [rdi+1*4], eax
  5475 000028B3 8B449D00            <1> 	mov	eax, dword ptr [rbp+rbx*4]
  5476 000028B7 8907                <1> 	mov	dword ptr [rdi], eax
  5477 000028B9 C3                  <1> 	ret
  5478                              <1> 
  5479                              <1> 
  5480                              <1> 	%if	0
  5481                              <1> ultrate:
  5482                              <1> 	mov	eax, dword ptr [rdi]
  5483                              <1> 	mov	dword ptr [_ultra], eax
  5484                              <1>  
  5485                              <1> 	mov     eax, dword ptr [rdi+1*4]
  5486                              <1> 	mov     dword ptr [_ultra1], eax
  5487                              <1> 
  5488                              <1>         mov     eax, dword ptr [rdi+2*4]
  5489                              <1>         mov     dword ptr [_ultra2], eax
  5490                              <1> 
  5491                              <1>         mov     eax, dword ptr [rdi+3*4]
  5492                              <1>         mov     dword ptr [_ultra3], eax
  5493                              <1> 
  5494                              <1>         mov     eax, dword ptr [rdi+4*4]
  5495                              <1>         mov     dword ptr [_ultra4], eax
  5496                              <1> 
  5497                              <1>         mov     eax, dword ptr [rdi+5*4]
  5498                              <1>         mov     dword ptr [_ultra5], eax
  5499                              <1> 
  5500                              <1>         mov     eax, dword ptr [rdi+6*4]
  5501                              <1>         mov     dword ptr [_ultra6], eax
  5502                              <1> 
  5503                              <1>         mov     eax, dword ptr [rdi+7*4]
  5504                              <1>         mov     dword ptr [_ultra7], eax
  5505                              <1> 
  5506                              <1> 	ret
  5507                              <1> 
  5508                              <1> zultrate:
  5509                              <1> 	push	rdi
  5510                              <1> 	mov	rdi, __ZERO
  5511                              <1> 	call	ultrate
  5512                              <1> 	pop	rdi
  5513                              <1> 	ret
  5514                              <1> 
  5515                              <1> __ZERO	dd	0, 0, 0, 0, 0, 0, 0, 0
  5516                              <1> 	%endif
  5517                                  	%include	"parity.msm"
  5518                              <1> _get_parity:
  5519 000028BA 8B5D10              <1>         mov     ebx, dword ptr [rbp+A]
  5520 000028BD 235D04              <1>         and     ebx, dword ptr [rbp+K]
  5521                              <1> _fold_parity:
  5522 000028C0 30DF                <1>         xor     bh, bl
  5523 000028C2 C1EB08              <1>         shr     ebx, 8
  5524 000028C5 30FB                <1>         xor     bl, bh
  5525 000028C7 C3                  <1>         ret
  5526                              <1> 
  5527                                  	%include	"margin.msm"
  5528                              <1> read_straddle_12b?:
  5529                              <1> 
  5530 000028C8 F6C101              <1> 	test	cl, 1				; 4 words? You are here because
  5531 000028CB 753D                <1> 	jnz	split_read4w			; offset is within last 3 of page
  5532                              <1> 						; 2 words then
  5533 000028CD 81FEFF0F0000        <1> 	cmp	esi, 0FFFh			; starting @ last word of page?
  5534 000028D3 7234                <1> 	jb	readout				; not so, go ahead with burst read
  5535                              <1> 
  5536                              <1> split_read2w:
  5537 000028D5 488BB560020000      <1> 	mov	rsi, qword ptr [rbp+CORE_INDEX1]
  5538 000028DC 48893C24            <1> 	mov	qword ptr [rsp], rdi		; delete 1st return address + save EA
  5539 000028E0 4889F8              <1> 	mov	rax, rdi			; recover EA
  5540 000028E3 30C9                <1> 	xor	cl, cl				; request 1 word
  5541 000028E5 E840DCFFFF          <1> 	call	_bus_read			;
  5542 000028EA 48870424            <1> 	xchg	rax, qword ptr [rsp]		; save 1st word read + load updated EA
  5543 000028EE FFC0                <1> 	inc	eax				; advance EA onto next page
  5544 000028F0 30C9                <1> 	xor	cl, cl				; request 1 word
  5545 000028F2 E833DCFFFF          <1> 	call	_bus_read			; read new page or block
  5546 000028F7 89C3                <1> 	mov	ebx, eax
  5547 000028F9 58                  <1> 	pop	rax				; recover 1st read word
  5548 000028FA C3                  <1> 	ret					; return to caller of operand_read
  5549                              <1> 
  5550                              <1> read_straddle_18b?:
  5551 000028FB F6C101              <1> 	test	cl, 1				; 4 words? You are here because 
  5552 000028FE 750A                <1> 	jnz	split_read4w			; offset is within last 3 of of bank
  5553                              <1> 						; 2 words then
  5554 00002900 4881FEFFFF0300      <1> 	cmp	rsi, 0003FFFFh			; starting @ last word of bank?
  5555 00002907 73CC                <1> 	jnb	split_read2w			; otherwise fall thru to burst read
  5556                              <1> 
  5557                              <1> readout:
  5558 00002909 C3                  <1> 	ret					; burst read in order
  5559                              <1> 
  5560                              <1> split_read4w:					; write EA over stack top return address
  5561 0000290A 488BB560020000      <1> 	mov	rsi, qword ptr [rbp+CORE_INDEX1]
  5562 00002911 48893C24            <1> 	mov	qword ptr [rsp], rdi		; one or other of these 2-word reads
  5563 00002915 89F8                <1> 	mov	eax, edi			; splits down to 1-word reads
  5564 00002917 E807000000          <1> 	call	read2				; when offset is [3F]FFD
  5565 0000291C E802000000          <1> 	call	read2				;             or [3F]FFF
  5566 00002921 58                  <1> 	pop	rax				;   but not when [3F]FFE
  5567 00002922 C3                  <1> 	ret					; return to caller of caller
  5568                              <1> 	
  5569 00002923 50                  <1> read2:	push	rax				; EA
  5570 00002924 53                  <1> 	push	rbx				; destination index on stack top
  5571 00002925 B106                <1> 	mov	cl, 6				; ask bus for 2 words
  5572 00002927 E8FEDBFFFF          <1> 	call	_bus_read			; replaces eax and ebx
  5573 0000292C 48871C24            <1> 	xchg	rbx, qword ptr [rsp]		; get destination index up again
  5574 00002930 89449D00            <1> 	mov	dword ptr [rbp+rbx*4], eax	; write 1st result word
  5575 00002934 58                  <1> 	pop	rax				; recover 2nd result word
  5576 00002935 89449D04            <1> 	mov	dword ptr [rbp+rbx*4+1*4], eax	; write 2nd result word
  5577 00002939 58                  <1> 	pop	rax				; EA
  5578 0000293A 480502000000        <1> 	add	rax, 2
  5579 00002940 4881C302000000      <1> 	add	rbx, 2
  5580 00002947 C3                  <1> 	ret	
  5581                              <1> 
  5582                                  	%include	"margin_w.msm"
  5583                              <1> write_straddle_12b?:				; multiword write request
  5584                              <1> write_straddle12b?:				; in last 3 words of block
  5585 00002948 F6C101              <1> 	test	cl, 1				; 4-word write request?
  5586 0000294B 7541                <1> 	jnz	split_write4w			;
  5587 0000294D 81FEFF0F0000        <1> 	cmp	esi, 0FFFH			; 2 words then. In last word?
  5588 00002953 7238                <1> 	jb	writeout			; no
  5589                              <1> 						; yes
  5590                              <1> split_write2w:
  5591 00002955 488BB560020000      <1> 	mov	rsi, qword ptr [rbp+CORE_INDEX1]
  5592 0000295C 48891C24            <1> 	mov	qword ptr [rsp], rbx		; not returning to there
  5593 00002960 57                  <1> 	push	rdi				; esp -> saved eax [ea], saved ebx
  5594 00002961 4889F8              <1> 	mov	rax, rdi			; place ea in eax
  5595 00002964 30C9                <1> 	xor	cl, cl				; request 1-word write
  5596 00002966 8B5C9D00            <1> 	mov	ebx, dword ptr [rbp+rbx*4]	; data from register array
  5597 0000296A E899DDFFFF          <1> 	call	bus_write
  5598 0000296F 58                  <1> 	pop	rax				; retrieve ea from stack
  5599 00002970 5B                  <1> 	pop	rbx				; retrieve register index
  5600 00002971 48FFC0              <1> 	inc	rax				; advance ea to next block
  5601 00002974 8B5C9D04            <1> 	mov	ebx, dword ptr [rbp+rbx*4+4]	; data from register array
  5602 00002978 30C9                <1> 	xor	cl, cl				; request 1-word write
  5603 0000297A E889DDFFFF          <1> 	call	bus_write
  5604 0000297F C3                  <1> 	ret					; return caller of caller
  5605                              <1> 
  5606                              <1> write_straddle_18b?:				; multiword write request
  5607                              <1> write_straddle18b?:				; in last 3 words of block
  5608 00002980 F6C101              <1> 	test	cl, 1				; 4 words?
  5609 00002983 7509                <1> 	jnz	split_write4w
  5610 00002985 81FEFFFF0300        <1> 	cmp	esi, 0003FFFFh			; 2 words then. In last word?
  5611 0000298B 73C8                <1> 	jnb	split_write2w			; yes
  5612                              <1> 						; no
  5613                              <1> writeout:
  5614 0000298D C3                  <1> 	ret					; return to burst write
  5615                              <1> 
  5616                              <1> split_write4w:
  5617 0000298E 488BB560020000      <1> 	mov	rsi, qword ptr [rbp+CORE_INDEX1]
  5618 00002995 48893C24            <1> 	mov	qword ptr [rsp], rdi		; return address at stack top not used
  5619 00002999 4889F8              <1> 	mov	rax, rdi			; copy ea
  5620 0000299C E807000000          <1> 	call	write2				; request 2 writes word pairs
  5621 000029A1 E802000000          <1> 	call	write2				; if 1 of them straddles it splits again
  5622 000029A6 58                  <1> 	pop	rax				; this is ea
  5623 000029A7 C3                  <1> 	ret					; return to caller of caller
  5624                              <1> 
  5625                              <1> 
  5626 000029A8 B106                <1> write2:	mov	cl, 6				; request 2-word bus write
  5627 000029AA 50                  <1> 	push	rax				; save ea
  5628 000029AB 53                  <1> 	push	rbx				; save register array index
  5629 000029AC E857DDFFFF          <1> 	call	bus_write			; send write pair request
  5630 000029B1 5B                  <1> 	pop	rbx				; retrieve register index
  5631 000029B2 58                  <1> 	pop	rax				; and ea
  5632 000029B3 4881C302000000      <1> 	add	rbx, 2				; update register index
  5633 000029BA 480502000000        <1> 	add	rax, 2				; and ea
  5634 000029C0 C3                  <1> 	ret
  5635                                  	%include	"rex.msm"
  5636                              <1> 
  5637                              <1> _rextable_1
  5638 000029C1 000000000000000000- <1> 	dd	0, 0, 0, 0,		r_sa, r_sb, r_z, 0
  5639 000029CA 00000000000000-     <1>
  5640 000029D1 [3D2D0000]-         <1>
  5641          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  5642 000029D5 [312D0000]-         <1>
  5643          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  5644 000029D9 [562D0000]00000000  <1>
  5645          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  5646 000029E1 000000000000000000- <1> 	dd	0, 0, 0, 0,		r_la, r_lb, r_tz, r_tp
  5647 000029EA 00000000000000-     <1>
  5648 000029F1 [742D0000]-         <1>
  5649          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  5650 000029F5 [682D0000]-         <1>
  5651          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  5652 000029F9 [FA2C0000]-         <1>
  5653          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  5654 000029FD [152D0000]          <1>
  5655          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  5656 00002A01 0000000000000000-   <1> 	dd	0, 0, r_or, r_orB,	r_and, r_andB, r_xor, r_xorB
  5657 00002A09 [952D0000]-         <1>
  5658          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  5659 00002A0D [892D0000]-         <1>
  5660          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  5661 00002A11 [BA2D0000]-         <1>
  5662          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  5663 00002A15 [AE2D0000]-         <1>
  5664          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  5665 00002A19 [DF2D0000]-         <1>
  5666          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  5667 00002A1D [D32D0000]          <1>
  5668          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  5669 00002A21 [042E0000]-         <1> 	dd	r_aa, r_ab, r_ana, r_anb, r_m, r_mf, r_d, 0
  5670          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  5671 00002A25 [F82D0000]-         <1>
  5672          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  5673 00002A29 [252E0000]-         <1>
  5674          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  5675 00002A2D [192E0000]-         <1>
  5676          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  5677 00002A31 [622E0000]-         <1>
  5678          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  5679 00002A35 [412E0000]-         <1>
  5680          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  5681 00002A39 [0E2F0000]00000000  <1>
  5682          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  5683                              <1> 
  5684                              <1> _rextable_6
  5685 00002A41 [572F0000]-         <1> 	dd	r_sar, r_sbr, r_dsr, 0, r_sal, r_sbl, r_dsl, 0
  5686          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  5687 00002A45 [4B2F0000]-         <1>
  5688          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  5689 00002A49 [722F0000]00000000- <1>
  5690          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  5691 00002A51 [A12F0000]-         <1>
  5692          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  5693 00002A55 [952F0000]-         <1>
  5694          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  5695 00002A59 [BC2F0000]00000000  <1>
  5696          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  5697 00002A61 [EB2F0000]-         <1> 	dd	r_rar, r_rbr, r_drr, 0, r_ral, r_rbl, r_drl, 0
  5698          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  5699 00002A65 [DF2F0000]-         <1>
  5700          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  5701 00002A69 [04300000]00000000- <1>
  5702          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  5703 00002A71 [33300000]-         <1>
  5704          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  5705 00002A75 [27300000]-         <1>
  5706          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  5707 00002A79 [4C300000]00000000  <1>
  5708          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  5709 00002A81 [7B300000]-         <1> 	dd	r_saa, r_sba, r_dsa, 0, 0, 0, 0, 0
  5710          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  5711 00002A85 [6F300000]-         <1>
  5712          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  5713 00002A89 [97300000]00000000- <1>
  5714          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  5715 00002A91 000000000000000000- <1>
  5716 00002A9A 00000000000000      <1>
  5717 00002AA1 000000000000000000- <1> 	dd	0, 0, 0, 0, 		0, 0, 0, 0
  5718 00002AAA 000000000000000000- <1>
  5719 00002AB3 000000000000000000- <1>
  5720 00002ABC 0000000000          <1>
  5721                              <1> 
  5722                              <1> _rextable_7
  5723 00002AC1 000000000000000000- <1> 	dd	0, 0, 0, 0,		0, 0, 0, 0
  5724 00002ACA 000000000000000000- <1>
  5725 00002AD3 000000000000000000- <1>
  5726 00002ADC 0000000000          <1>
  5727 00002AE1 [BA300000]-         <1> 	dd	r_qs, r_ql, r_dte, 0,	r_fa, r_fan, r_fm, r_fd
  5728          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  5729 00002AE5 [C9300000]-         <1>
  5730          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  5731 00002AE9 [D8300000]00000000- <1>
  5732          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  5733 00002AF1 [BE2C0000]-         <1>
  5734          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  5735 00002AF5 [CD2C0000]-         <1>
  5736          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  5737 00002AF9 [DC2C0000]-         <1>
  5738          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  5739 00002AFD [EB2C0000]          <1>
  5740          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  5741 00002B01 000000000000000000- <1> 	dd	0, 0, 0, 0, 		0, r_mta, 0, 0
  5742 00002B0A 000000000000000000- <1>
  5743 00002B13 0000[F1300000]0000- <1>
  5744          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  5745 00002B1B 000000000000        <1>
  5746 00002B21 [13310000]-         <1> 	dd	r_ds, r_dl, r_da, r_dan, 0, 0, 0, 0
  5747          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  5748 00002B25 [22310000]-         <1>
  5749          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  5750 00002B29 [59310000]-         <1>
  5751          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  5752 00002B2D [3B310000]00000000- <1>
  5753          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  5754 00002B35 000000000000000000- <1>
  5755 00002B3E 000000              <1>
  5756                              <1> 
  5757                              <1> 
  5758 00002B41 F686B204000080      <1> _rex:	test	byte ptr [rsi+PSR+2], 128
  5759 00002B48 0F88ED000000        <1> 	js	near _rex_z				; ISRs can't do this
  5760                              <1> 
  5761 00002B4E E83EDDFFFF          <1> 	call	memory_read				; ea -> instruction for repeat	
  5762                              <1> 
  5763 00002B53 488BB560020000      <1> 	mov	rsi, qword ptr [rbp+CORE_INDEX1]	; retrieve smp core ->
  5764 00002B5A 898668040000        <1> 	mov	dword ptr [rsi+REGISTER+282*4], eax	; save instruction word
  5765 00002B60 E8C5D5FFFF          <1> 	call	__ea					; get initial ea of repeated  instruction
  5766 00002B65 0FB6DD              <1> 	movzx	ebx, ch					; spin-off is opcode index in ch
  5767                              <1> 							; and operand type in cl
  5768 00002B68 80F906              <1> 	cmp	cl, 6
  5769 00002B6B 721A                <1> 	jb	_rex_itable1
  5770 00002B6D 770C                <1> 	ja	_rex_itable7
  5771                              <1> 							; instruction list 6
  5772 00002B6F 8B1C9D[412A0000]    <1> 	mov	ebx, dword ptr [_rextable_6+rbx*4]	; shifts and jumps
  5773          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  5774 00002B76 E913000000          <1> 	jmp	_rex_evaluate
  5775                              <1> 
  5776                              <1> _rex_itable7:						; instruction list 7
  5777 00002B7B 8B1C9D[C12A0000]    <1> 	mov	ebx, dword ptr [_rextable_7+rbx*4]	; large arithmetic
  5778          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  5779 00002B82 E907000000          <1> 	jmp	_rex_evaluate
  5780                              <1> 
  5781                              <1> _rex_itable1:						; instruction list 1
  5782 00002B87 8B1C9D[C1290000]    <1> 	mov	ebx, dword ptr [_rextable_1+rbx*4]	; single integer arithmetic
  5783          ******************  <1>  error: Mach-O 64-bit format does not support 32-bit absolute addresses
  5784                              <1> 
  5785                              <1> _rex_evaluate:
  5786 00002B8E 21DB                <1> 	and	ebx, ebx				; instruction for repeat execute?
  5787 00002B90 0F84A5000000        <1> 	jz	near _rex_z				; no
  5788 00002B96 899E74040000        <1> 	mov	dword ptr [rsi+REGISTER+285*4], ebx	; yes: save execution logic pointer
  5789                              <1> 
  5790                              <1> 							; if repeat instruction is indexed:
  5791                              <1> 							; quick lookup tag for index increment
  5792 00002B9C C78670040000000000- <1> 	mov	dword ptr [rsi+REGISTER+284*4], 0		; default no index register referenced
  5793 00002BA5 00                  <1>
  5794 00002BA6 8B9E68040000        <1> 	mov	ebx, dword ptr [rsi+REGISTER+282*4]	; identify any index register tag
  5795 00002BAC 6621DB              <1> 	and	bx, bx					; in the instruction word
  5796 00002BAF 791D                <1> 	jns	_rex_ready				; by testing bit 15
  5797 00002BB1 66C1EB0C            <1> 	shr	bx, 12
  5798                              <1> 							; must be > indirection tags *B0+ *B1+
  5799 00002BB5 80FB0A              <1> 	cmp	bl, 10					; pointers in storage not incremented
  5800 00002BB8 7214                <1> 	jb	_rex_ready				; index registers may increment
  5801 00002BBA 80FB0E              <1> 	cmp	bl, 14
  5802 00002BBD 7303                <1> 	jnb	_rex_indexed				; [   fp sp ]  registers   [ 14 15 ]
  5803 00002BBF 80E307              <1> 	and	bl, 7					; [ x y a b ]  registers [ 2 3 4 5 ]
  5804                              <1> 
  5805                              <1> _rex_indexed:
  5806 00002BC2 81E30F000000        <1> 	and	ebx, 15					; make 32-bit index value
  5807 00002BC8 899E70040000        <1> 	mov	dword ptr [rsi+REGISTER+284*4], ebx	; write quick lookup
  5808                              <1> 
  5809                              <1> _rex_ready:
  5810 00002BCE 8B5E34              <1> 	mov	ebx, dword ptr [rsi+REGISTER+Q]		; default target register [ q ] ->	
  5811 00002BD1 8B9674040000        <1> 	mov	edx, dword ptr [rsi+REGISTER+285*4]	; execute logic ->
  5812 00002BD7 FFD2                <1> 	call	rdx
  5813                              <1> 
  5814 00002BD9 8B8670040000        <1> 	mov	eax, dword ptr [rsi+REGISTER+284*4]	; index register tag?
  5815 00002BDF 6621C0              <1> 	and	ax, ax
  5816 00002BE2 7417                <1> 	jz	_rex_count				; no
  5817                              <1> 
  5818 00002BE4 8B4E5C              <1> 	mov	ecx, dword ptr [rsi+REGISTER+WDATA]
  5819 00002BE7 81E1FFFFFF00        <1> 	and	ecx, 00FFFFFFh				; index register increment configured?
  5820 00002BED 740C                <1> 	jz	_rex_count				; no
  5821                              <1> 
  5822 00002BEF 030C86              <1> 	add	ecx, dword ptr [rsi+REGISTER+rax*4]	; calculate index + increment
  5823 00002BF2 81E1FFFFFF00        <1> 	and	ecx, 00FFFFFFh				; 
  5824 00002BF8 890C86              <1> 	mov	dword ptr [rsi+REGISTER+rax*4], ecx	; write back to tagged index register
  5825                              <1> 
  5826                              <1> _rex_count:
  5827 00002BFB 8B4650              <1> 	mov	eax, dword ptr [rsi+REGISTER+RDATAC]
  5828 00002BFE FFC8                <1> 	dec	eax
  5829 00002C00 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
  5830                              <1> 
  5831 00002C05 894650              <1> 	mov	dword ptr [rsi+REGISTER+RDATAC], eax
  5832 00002C08 A900008000          <1> 	test	eax, 00800000h
  5833 00002C0D 752C                <1> 	jnz	_rex_z					; reached -1 end
  5834                              <1> 
  5835 00002C0F 66F786A4040000C0FF  <1> 	test	word ptr [rsi+INDICATION], EXTERNAL_INDICATIONS
  5836 00002C18 740B                <1> 	jz	_rex_along
  5837                              <1> 
  5838 00002C1A 81C2FCFFFFFF        <1> 	add	edx, -4					; restart after
  5839 00002C20 E916000000          <1> 	jmp	_rex_z					; yielding to interrupt
  5840                              <1> 
  5841                              <1> _rex_along:
  5842 00002C25 8B8668040000        <1> 	mov	eax, [rsi+REGISTER+282*4]			; instruction encoding
  5843 00002C2B E8FAD4FFFF          <1> 	call	__ea
  5844 00002C30 8B9E74040000        <1> 	mov	ebx, [rsi+REGISTER+285*4]			; command pointer
  5845 00002C36 E993FFFFFF          <1> 	jmp	_rex_ready
  5846 00002C3B C3                  <1> _rex_z:	ret
  5847                              <1> 
  5848                              <1> _rex_prime_final_count:
  5849 00002C3C F7455000008000      <1> 	test	dword ptr [rbp+RDATAC], 00800000h
  5850 00002C43 7422                <1> 	jz	_rex_primed
  5851 00002C45 8B5D58              <1> 	mov	ebx, dword ptr [rbp+WDATAC]
  5852 00002C48 895D50              <1> 	mov	dword ptr [rbp+RDATAC], ebx
  5853 00002C4B C3                  <1> 	ret
  5854                              <1> 
  5855                              <1> _rex_prime:
  5856 00002C4C F7455000008000      <1> 	test	dword ptr [rbp+RDATAC], 00800000h
  5857 00002C53 7412                <1> 	jz	_rex_primed
  5858 00002C55 8B5D58              <1> 	mov	ebx, dword ptr [rbp+WDATAC]
  5859 00002C58 895D50              <1> 	mov	dword ptr [rbp+RDATAC], ebx
  5860 00002C5B 8B5D3C              <1> 	mov	ebx, dword ptr [rbp+S_P]
  5861 00002C5E 81E3FFFFFF00        <1> 	and	ebx, 00FFFFFFh
  5862 00002C64 895D34              <1> 	mov	dword ptr [rbp+Q], ebx
  5863                              <1> _rex_primed:
  5864 00002C67 C3                  <1> 	ret
  5865                              <1> 
  5866                              <1> _rex_accumulate:
  5867 00002C68 488BB560020000      <1> 	mov	rsi, qword ptr [rbp+CORE_INDEX1]
  5868 00002C6F 8B5E54              <1> 	mov	ebx, dword ptr [rsi+RDATA]
  5869 00002C72 035D34              <1> 	add	ebx, dword ptr [rbp+Q]
  5870 00002C75 81E3FFFFFF00        <1> 	and	ebx, 00FFFFFFh
  5871 00002C7B 895D34              <1> 	mov	dword ptr [rbp+Q], ebx
  5872 00002C7E C3                  <1> 	ret
  5873                              <1> 
  5874                              <1> _rex_chex_127:
  5875 00002C7F E8C8FFFFFF          <1> 	call	_rex_prime
  5876 00002C84 81FB7F000000        <1> 	cmp	ebx, 127
  5877 00002C8A 7624                <1> 	jna	_rex_chex_low
  5878 00002C8C E928000000          <1> 	jmp	_rex_chexit
  5879                              <1> 
  5880                              <1> _rex_chex_126:
  5881 00002C91 E8B6FFFFFF          <1> 	call	_rex_prime
  5882 00002C96 81FB7E000000        <1> 	cmp	ebx, 126
  5883 00002C9C 7612                <1> 	jna	_rex_chex_low
  5884 00002C9E E916000000          <1> 	jmp	_rex_chexit
  5885                              <1> 
  5886                              <1> _rex_chex_124:
  5887 00002CA3 E8A4FFFFFF          <1> 	call	_rex_prime
  5888 00002CA8 81FB7C000000        <1> 	cmp	ebx, 124
  5889 00002CAE 7709                <1> 	ja	_rex_chexit
  5890                              <1> _rex_chex_low:
  5891 00002CB0 81FB18000000        <1> 	cmp	ebx, 24
  5892 00002CB6 7201                <1> 	jb	_rex_chexit
  5893 00002CB8 C3                  <1> 	ret
  5894                              <1> 
  5895                              <1> _rex_chexit:
  5896 00002CB9 E9EBE4FFFF          <1> 	jmp	guard_ii_authority
  5897                              <1> 
  5898                              <1> ;	eax = EA
  5899                              <1> ;	q -> target register selected
  5900                              <1> 
  5901 00002CBE E8E0FFFFFF          <1> r_fa:	call	_rex_chex_124
  5902 00002CC3 E8EFFAFFFF          <1> 	call	_far
  5903 00002CC8 E99BFFFFFF          <1> 	jmp	_rex_accumulate
  5904                              <1> 
  5905 00002CCD E8D1FFFFFF          <1> r_fan:	call	_rex_chex_124
  5906 00002CD2 E8FBFAFFFF          <1> 	call	_fanr
  5907 00002CD7 E98CFFFFFF          <1> 	jmp	_rex_accumulate
  5908                              <1> 
  5909 00002CDC E8C2FFFFFF          <1> r_fm:	call	_rex_chex_124
  5910 00002CE1 E807FBFFFF          <1> 	call	_fmr
  5911 00002CE6 E97DFFFFFF          <1> 	jmp	_rex_accumulate
  5912                              <1> 
  5913 00002CEB E8B3FFFFFF          <1> r_fd:	call	_rex_chex_124
  5914 00002CF0 E81AFBFFFF          <1> 	call	_fdr
  5915 00002CF5 E96EFFFFFF          <1> 	jmp	_rex_accumulate
  5916                              <1> 
  5917 00002CFA E83DFFFFFF          <1> r_tz:	call	_rex_prime_final_count
  5918 00002CFF 80F904              <1> 	cmp	cl, 4			; may not be [ i xi ]
  5919 00002D02 732C                <1> 	jnb	r_noskip		; but pointers are updated on no_op
  5920 00002D04 E809D8FFFF          <1> 	call	_operand_read
  5921 00002D09 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
  5922 00002D0E 7520                <1> 	jnz	r_noskip
  5923                              <1> 
  5924 00002D10 E9F0030000          <1> 	jmp	r_skipout		; stop search repeat
  5925                              <1> 
  5926 00002D15 E822FFFFFF          <1> r_tp:	call	_rex_prime_final_count
  5927 00002D1A 80F904              <1> 	cmp	cl, 4			; may not be [ i xi ]
  5928 00002D1D 7311                <1> 	jnb	r_noskip		; but pointers are updated on no_op
  5929 00002D1F E8EED7FFFF          <1> 	call	_operand_read
  5930 00002D24 A900008000          <1> 	test	eax, 00800000h
  5931 00002D29 7505                <1> 	jnz	r_noskip
  5932                              <1> 
  5933 00002D2B E9D5030000          <1> 	jmp	r_skipout		; stop search repeat
  5934                              <1> 
  5935 00002D30 C3                  <1> r_noskip:	ret
  5936                              <1> 
  5937 00002D31 E85BFFFFFF          <1> r_sb:	call	_rex_chex_126
  5938 00002D36 FFC3                <1> 	inc	ebx			; starboard lane
  5939 00002D38 E905000000          <1> 	jmp	r_s
  5940 00002D3D E83DFFFFFF          <1> r_sa:	call	_rex_chex_127
  5941 00002D42 80F904              <1> r_s:	cmp	cl, 4			; may not be [ i xi ]
  5942 00002D45 7309                <1> 	jnb	r_no_op_s		; but pointers are updated 
  5943 00002D47 8B5C9D00            <1> 	mov	ebx, dword ptr [rbp+rbx*4]
  5944 00002D4B E895D9FFFF          <1> 	call	_operand_write
  5945                              <1> r_no_op_s:
  5946 00002D50 E913FFFFFF          <1> 	jmp	_rex_accumulate
  5947 00002D55 C3                  <1> 	ret
  5948                              <1> 
  5949 00002D56 E8E1FEFFFF          <1> r_z:	call	_rex_prime_final_count
  5950 00002D5B 80F904              <1> 	cmp	cl, 4			; may not be [ i xi ]
  5951 00002D5E 7307                <1> 	jnb	r_no_op_z		; but pointers are updated
  5952 00002D60 31DB                <1> 	xor	ebx, ebx
  5953 00002D62 E97ED9FFFF          <1> 	jmp	_operand_write
  5954                              <1> r_no_op_z:
  5955 00002D67 C3                  <1> 	ret
  5956                              <1> 
  5957 00002D68 E824FFFFFF          <1> r_lb:	call	_rex_chex_126
  5958 00002D6D FFC3                <1> 	inc	ebx			; starboard lane
  5959 00002D6F E905000000          <1> 	jmp	r_l
  5960 00002D74 E806FFFFFF          <1> r_la:	call	_rex_chex_127
  5961 00002D79 53                  <1> r_l:	push	rbx
  5962 00002D7A E893D7FFFF          <1> 	call	_operand_read
  5963 00002D7F 5B                  <1> 	pop	rbx
  5964 00002D80 89449D00            <1> 	mov	dword ptr [rbp+rbx*4], eax
  5965 00002D84 E9DFFEFFFF          <1> 	jmp	_rex_accumulate
  5966                              <1> 
  5967 00002D89 E803FFFFFF          <1> r_orB:	call	_rex_chex_126
  5968 00002D8E FFC3                <1> 	inc	ebx			; starboard lane
  5969 00002D90 E905000000          <1> 	jmp	r_OR
  5970 00002D95 E8E5FEFFFF          <1> r_or:	call	_rex_chex_127
  5971 00002D9A 53                  <1> r_OR:	push	rbx
  5972 00002D9B E872D7FFFF          <1> 	call	_operand_read
  5973 00002DA0 5B                  <1> 	pop	rbx
  5974 00002DA1 0B449D00            <1> 	or	eax, dword ptr [rbp+rbx*4]
  5975 00002DA5 89449D00            <1> 	mov	dword ptr [rbp+rbx*4], eax
  5976 00002DA9 E9BAFEFFFF          <1> 	jmp	_rex_accumulate
  5977                              <1> 
  5978 00002DAE E8DEFEFFFF          <1> r_andB:	call	_rex_chex_126
  5979 00002DB3 FFC3                <1> 	inc	ebx		; starboard lane
  5980 00002DB5 E905000000          <1> 	jmp	r_AND
  5981 00002DBA E8C0FEFFFF          <1> r_and:	call	_rex_chex_127
  5982 00002DBF 53                  <1> r_AND:	push	rbx
  5983 00002DC0 E84DD7FFFF          <1> 	call	_operand_read
  5984 00002DC5 5B                  <1> 	pop	rbx
  5985 00002DC6 23449D00            <1> 	and	eax, dword ptr [rbp+rbx*4]
  5986 00002DCA 89449D00            <1> 	mov	dword ptr [rbp+rbx*4], eax
  5987 00002DCE E995FEFFFF          <1> 	jmp	_rex_accumulate
  5988                              <1> 
  5989 00002DD3 E8B9FEFFFF          <1> r_xorB:	call	_rex_chex_126
  5990 00002DD8 FFC3                <1> 	inc	ebx		; starboard lane
  5991 00002DDA E905000000          <1> 	jmp	r_XOR
  5992 00002DDF E89BFEFFFF          <1> r_xor:	call	_rex_chex_127
  5993 00002DE4 53                  <1> r_XOR:	push	rbx
  5994 00002DE5 E828D7FFFF          <1> 	call	_operand_read
  5995 00002DEA 5B                  <1> 	pop	rbx
  5996 00002DEB 33449D00            <1> 	xor	eax, dword ptr [rbp+rbx*4]
  5997 00002DEF 89449D00            <1> 	mov	dword ptr [rbp+rbx*4], eax
  5998 00002DF3 E970FEFFFF          <1> 	jmp	_rex_accumulate
  5999                              <1> 
  6000 00002DF8 E894FEFFFF          <1> r_ab:	call	_rex_chex_126
  6001 00002DFD FFC3                <1> 	inc	ebx		; starboard lane
  6002 00002DFF E905000000          <1> 	jmp	r_a
  6003 00002E04 E876FEFFFF          <1> r_aa:	call	_rex_chex_127
  6004 00002E09 53                  <1> r_a:	push	rbx
  6005 00002E0A E803D7FFFF          <1> 	call	_operand_read
  6006 00002E0F 5F                  <1> 	pop	rdi
  6007 00002E10 0344BD00            <1> 	add	eax, dword ptr [rbp+rdi*4]
  6008 00002E14 E963030000          <1> 	jmp	r_store_carry
  6009                              <1> 
  6010 00002E19 E873FEFFFF          <1> r_anb:	call	_rex_chex_126
  6011 00002E1E FFC3                <1> 	inc	ebx		; starboard lane
  6012 00002E20 E905000000          <1> 	jmp	r_an
  6013 00002E25 E855FEFFFF          <1> r_ana:	call	_rex_chex_127
  6014 00002E2A 53                  <1> r_an:	push	rbx
  6015 00002E2B E8E2D6FFFF          <1> 	call	_operand_read
  6016 00002E30 5F                  <1> 	pop	rdi
  6017 00002E31 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
  6018 00002E36 FFC0                <1> 	inc	eax
  6019 00002E38 0344BD00            <1> 	add	eax, dword ptr [rbp+rdi*4]
  6020 00002E3C E93B030000          <1> 	jmp	r_store_carry
  6021                              <1> 
  6022 00002E41 E839FEFFFF          <1> r_mf:	call    _rex_chex_127
  6023 00002E46 52                  <1> 	push	rdx
  6024 00002E47 53                  <1> 	push	rbx
  6025 00002E48 E8C5D6FFFF          <1> 	call	_operand_read
  6026 00002E4D 5F                  <1> 	pop	rdi
  6027 00002E4E 0FAF44BD00          <1> 	imul	eax, dword ptr [rbp+rdi*4]
  6028 00002E53 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
  6029 00002E58 8944BD00            <1> 	mov	dword ptr [rbp+rdi*4], eax
  6030 00002E5C 5A                  <1> 	pop	rdx
  6031 00002E5D E906FEFFFF          <1> 	jmp	_rex_accumulate
  6032                              <1> 
  6033                              <1> ; use the platform unsigned multiply
  6034                              <1> ; work in positive magnitude
  6035                              <1> ; adjust the final sign after offset-adding products
  6036                              <1> 
  6037 00002E62 E82AFEFFFF          <1> r_m:	call	_rex_chex_126
  6038 00002E67 52                  <1> 	push	rdx
  6039 00002E68 53                  <1> 	push	rbx			; register stack cursor
  6040 00002E69 E8A4D6FFFF          <1> 	call	_operand_read
  6041 00002E6E 5F                  <1> 	pop	rdi			; recover register stack cursor
  6042                              <1> 
  6043 00002E6F 31C9                <1> 	xor	ecx, ecx		; final sign
  6044 00002E71 A900008000          <1> 	test	eax, 00800000h		;
  6045 00002E76 740E                <1> 	jz	r_msigu?		; negative multiplier?
  6046 00002E78 F7D1                <1> 	not	ecx			; final sign reverse
  6047 00002E7A 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
  6048 00002E7F FFC0                <1> 	inc	eax			; 2s complement
  6049 00002E81 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
  6050                              <1> 
  6051                              <1> r_msigu?:
  6052 00002E86 89C3                <1> 	mov	ebx, eax		; multiplier 2b used twice
  6053 00002E88 8B44BD00            <1> 	mov	eax, dword ptr [rbp+rdi*4]
  6054 00002E8C A900008000          <1> 	test	eax, 00800000h		; multiply high order part 1st
  6055 00002E91 7429                <1> 	jz	r_mgoferit_yall
  6056                              <1> 
  6057 00002E93 F7D1                <1> 	not	ecx			; final sign reverse
  6058 00002E95 8B54BD04            <1> 	mov	edx, dword ptr [rbp+rdi*4+4]
  6059 00002E99 81F2FFFFFF00        <1> 	xor	edx, 00FFFFFFh
  6060 00002E9F FFC2                <1> 	inc	edx			; 2s complement
  6061 00002EA1 C1C208              <1> 	rol	edx, 8
  6062 00002EA4 480FB6F2            <1> 	movzx	rsi, dl
  6063 00002EA8 C1EA08              <1> 	shr	edx, 8
  6064 00002EAB 8954BD04            <1> 	mov	dword ptr [rbp+rdi*4+4], edx
  6065 00002EAF 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh		; ms register long multiplicand
  6066 00002EB4 4801F0              <1> 	add	rax, rsi
  6067 00002EB7 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
  6068                              <1> 
  6069                              <1> r_mgoferit_yall:
  6070 00002EBC F7E3                <1> 	mul	ebx			; multiply high order part
  6071 00002EBE 8944BD00            <1> 	mov	dword ptr [rbp+rdi*4], eax	; save lower half of product
  6072 00002EC2 8B44BD04            <1> 	mov	eax, dword ptr [rbp+rdi*4+4]	; multiply low order part
  6073 00002EC6 F7E3                <1> 	mul	ebx
  6074 00002EC8 C1E208              <1> 	shl	edx, 8			; 8 bits of eax must shift up to edx
  6075 00002ECB C1C008              <1> 	rol	eax, 8
  6076 00002ECE 88C2                <1> 	mov	dl, al
  6077 00002ED0 C1E808              <1> 	shr	eax, 8			; leaving 8 zeros in eax high end
  6078 00002ED3 0354BD00            <1> 	add	edx, dword ptr [rbp+rdi*4]	; add2 lower half of 1st product
  6079 00002ED7 21C9                <1> 	and	ecx, ecx		; final sign?
  6080 00002ED9 791A                <1> 	jns	r_m_writeback
  6081                              <1> 
  6082 00002EDB 81F2FFFFFF00        <1> 	xor	edx, 00FFFFFFh
  6083 00002EE1 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
  6084 00002EE6 FFC0                <1> 	inc	eax			; 2s complement
  6085 00002EE8 C1C008              <1> 	rol	eax, 8			; carried out single bit?
  6086 00002EEB 480FB6F0            <1> 	movzx	rsi, al			; must add to edx
  6087 00002EEF C1E808              <1> 	shr	eax, 8
  6088 00002EF2 4801F2              <1> 	add	rdx, rsi
  6089                              <1> 
  6090                              <1> r_m_writeback:
  6091 00002EF5 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
  6092 00002EFA 81E2FFFFFF00        <1> 	and	edx, 00FFFFFFh
  6093 00002F00 8944BD04            <1> 	mov	dword ptr [rbp+rdi*4+4], eax	
  6094 00002F04 8954BD00            <1> 	mov	dword ptr [rbp+rdi*4], edx
  6095 00002F08 5A                  <1> 	pop	rdx
  6096 00002F09 E95AFDFFFF          <1> 	jmp	_rex_accumulate
  6097                              <1> 
  6098 00002F0E E87EFDFFFF          <1> r_d:	call	_rex_chex_126
  6099 00002F13 89DF                <1> 	mov	edi, ebx		; register cursor
  6100 00002F15 E800ECFFFF          <1> 	call	_divide
  6101 00002F1A 895CBD04            <1> 	mov	dword ptr [rbp+rdi*4+4], ebx
  6102 00002F1E 8944BD00            <1> 	mov	dword ptr [rbp+rdi*4], eax
  6103 00002F22 488BB560020000      <1> 	mov	rsi, qword ptr [rbp+CORE_INDEX1]
  6104 00002F29 F686B004000008      <1> 	test	byte ptr [rsi+PSR], FP_R
  6105 00002F30 0F8432FDFFFF        <1> 	jz	_rex_accumulate
  6106 00002F36 81FF7D000000        <1> 	cmp	edi, 125
  6107 00002F3C 0F8726FDFFFF        <1> 	ja	_rex_accumulate
  6108 00002F42 894CBD08            <1> 	mov	dword ptr [rbp+rdi*4+8], ecx
  6109 00002F46 E91DFDFFFF          <1> r_dnor:	jmp	_rex_accumulate
  6110                              <1> 
  6111 00002F4B E841FDFFFF          <1> r_sbr:	call	_rex_chex_126
  6112 00002F50 FFC3                <1> 	inc	ebx		; starboard lane
  6113 00002F52 E905000000          <1> 	jmp	r_lsr
  6114 00002F57 E823FDFFFF          <1> r_sar:	call	_rex_chex_127
  6115 00002F5C 88C1                <1> r_lsr	mov	cl, al
  6116 00002F5E 8B449D00            <1> 	mov	eax, dword ptr [rbp+rbx*4]
  6117 00002F62 D3E8                <1> 	shr	eax, cl
  6118 00002F64 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
  6119 00002F69 89449D00            <1> 	mov	dword ptr [rbp+rbx*4], eax
  6120 00002F6D E9F6FCFFFF          <1> 	jmp	_rex_accumulate
  6121                              <1> 
  6122 00002F72 E81AFDFFFF          <1> r_dsr:	call	_rex_chex_126
  6123 00002F77 88C1                <1> 	mov	cl, al
  6124 00002F79 89DF                <1> 	mov	edi, ebx
  6125 00002F7B 8B44BD00            <1> 	mov	eax, dword ptr [rbp+rdi*4]
  6126 00002F7F 8B5CBD04            <1> 	mov	ebx, dword ptr [rbp+rdi*4+4]
  6127 00002F83 E8D9ECFFFF          <1> 	call	dsr
  6128 00002F88 8944BD00            <1> 	mov	dword ptr [rbp+rdi*4], eax
  6129 00002F8C 895CBD04            <1> 	mov	dword ptr [rbp+rdi*4+4], ebx
  6130 00002F90 E9D3FCFFFF          <1> 	jmp	_rex_accumulate
  6131                              <1> 
  6132 00002F95 E8F7FCFFFF          <1> r_sbl:	call	_rex_chex_126
  6133 00002F9A FFC3                <1> 	inc	ebx		; starboard lane
  6134 00002F9C E905000000          <1> 	jmp	r_lsl
  6135 00002FA1 E8D9FCFFFF          <1> r_sal:	call	_rex_chex_127
  6136 00002FA6 88C1                <1> r_lsl:	mov	cl, al
  6137 00002FA8 8B449D00            <1> 	mov	eax, dword ptr [rbp+rbx*4]
  6138 00002FAC D3E0                <1> 	shl	eax, cl
  6139 00002FAE 25FFFFFF00          <1> 	and	eax, 00FFFFFFh
  6140 00002FB3 89449D00            <1> 	mov	dword ptr [rbp+rbx*4], eax
  6141 00002FB7 E9ACFCFFFF          <1> 	jmp	_rex_accumulate
  6142                              <1> 
  6143 00002FBC E8D0FCFFFF          <1> r_dsl:	call	_rex_chex_126
  6144 00002FC1 88C1                <1> 	mov	cl, al
  6145 00002FC3 89DF                <1> 	mov	edi, ebx
  6146 00002FC5 8B44BD00            <1> 	mov	eax, dword ptr [rbp+rdi*4]
  6147 00002FC9 8B5CBD04            <1> 	mov	ebx, dword ptr [rbp+rdi*4+4]
  6148 00002FCD E8C7ECFFFF          <1> 	call	dsl
  6149 00002FD2 8944BD00            <1> 	mov	dword ptr [rbp+rdi*4], eax
  6150 00002FD6 895CBD04            <1> 	mov	dword ptr [rbp+rdi*4+4], ebx
  6151 00002FDA E989FCFFFF          <1> 	jmp	_rex_accumulate
  6152                              <1> 
  6153 00002FDF E8ADFCFFFF          <1> r_rbr:	call	_rex_chex_126
  6154 00002FE4 FFC3                <1> 	inc	ebx		; starboard lane
  6155 00002FE6 E905000000          <1> 	jmp	r_rr
  6156 00002FEB E88FFCFFFF          <1> r_rar:	call	_rex_chex_127
  6157 00002FF0 89DF                <1> r_rr:	mov	edi, ebx
  6158 00002FF2 8B5CBD00            <1> 	mov	ebx, dword ptr [rbp+rdi*4]
  6159 00002FF6 E811EDFFFF          <1> 	call	rr
  6160 00002FFB 895CBD00            <1> 	mov	dword ptr [rbp+rdi*4], ebx
  6161 00002FFF E964FCFFFF          <1> 	jmp	_rex_accumulate
  6162                              <1> 
  6163 00003004 E888FCFFFF          <1> r_drr:	call	_rex_chex_126
  6164 00003009 88C1                <1> 	mov	cl, al
  6165 0000300B 89DF                <1> 	mov	edi, ebx
  6166 0000300D 8B44BD00            <1> 	mov	eax, dword ptr [rbp+rdi*4]
  6167 00003011 8B5CBD04            <1> 	mov	ebx, dword ptr [rbp+rdi*4+4]
  6168 00003015 E840EDFFFF          <1> 	call	drr
  6169 0000301A 8944BD00            <1> 	mov	dword ptr [rbp+rdi*4], eax
  6170 0000301E 895CBD04            <1> 	mov	dword ptr [rbp+rdi*4+4], ebx
  6171 00003022 E941FCFFFF          <1> 	jmp	_rex_accumulate
  6172                              <1> 
  6173 00003027 E865FCFFFF          <1> r_rbl:	call	_rex_chex_126
  6174 0000302C FFC3                <1> 	inc	ebx		; starboard lane
  6175 0000302E E905000000          <1> 	jmp	r_rl
  6176 00003033 E847FCFFFF          <1> r_ral:	call	_rex_chex_127
  6177 00003038 89DF                <1> r_rl:	mov	edi, ebx
  6178 0000303A 8B5CBD00            <1> 	mov	ebx, dword ptr [rbp+rdi*4]
  6179 0000303E E8EFECFFFF          <1> 	call	rl
  6180 00003043 895CBD00            <1> 	mov	dword ptr [rbp+rdi*4], ebx
  6181 00003047 E91CFCFFFF          <1> 	jmp	_rex_accumulate
  6182                              <1> 
  6183 0000304C E840FCFFFF          <1> r_drl:	call	_rex_chex_126
  6184 00003051 88C1                <1> 	mov	cl, al
  6185 00003053 89DF                <1> 	mov	edi, ebx
  6186 00003055 8B44BD00            <1> 	mov	eax, dword ptr [rbp+rdi*4]
  6187 00003059 8B5CBD04            <1> 	mov	ebx, dword ptr [rbp+rdi*4+4]
  6188 0000305D E851EDFFFF          <1> 	call	drl
  6189 00003062 8944BD00            <1> 	mov	dword ptr [rbp+rdi*4], eax
  6190 00003066 895CBD04            <1> 	mov	dword ptr [rbp+rdi*4+4], ebx
  6191 0000306A E9F9FBFFFF          <1> 	jmp	_rex_accumulate
  6192                              <1> 
  6193 0000306F E81DFCFFFF          <1> r_sba:	call	_rex_chex_126
  6194 00003074 FFC3                <1> 	inc	ebx		; starboard lane
  6195 00003076 E905000000          <1> 	jmp	r_asr
  6196 0000307B E8FFFBFFFF          <1> r_saa:	call	_rex_chex_127
  6197 00003080 88C1                <1> r_asr:	mov	cl, al
  6198 00003082 8B449D00            <1> 	mov	eax, dword ptr [rbp+rbx*4]
  6199 00003086 C1E008              <1> 	shl	eax, 8
  6200 00003089 D3F8                <1> 	sar	eax, cl
  6201 0000308B C1E808              <1> 	shr	eax, 8
  6202 0000308E 89449D00            <1> 	mov	dword ptr [rbp+rbx*4], eax
  6203 00003092 E9D1FBFFFF          <1> 	jmp	_rex_accumulate
  6204                              <1> 
  6205 00003097 E8F5FBFFFF          <1> r_dsa:	call	_rex_chex_126
  6206 0000309C 88C1                <1> 	mov	cl, al
  6207 0000309E 89DF                <1> 	mov	edi, ebx
  6208 000030A0 8B44BD00            <1> 	mov	eax, dword ptr [rbp+rdi*4]
  6209 000030A4 8B5CBD04            <1> 	mov	ebx, dword ptr [rbp+rdi*4+4]
  6210 000030A8 E826ECFFFF          <1> 	call	dsa
  6211 000030AD 8944BD00            <1> 	mov	dword ptr [rbp+rdi*4], eax
  6212 000030B1 895CBD04            <1> 	mov	dword ptr [rbp+rdi*4+4], ebx
  6213 000030B5 E9AEFBFFFF          <1> 	jmp	_rex_accumulate
  6214                              <1> 
  6215 000030BA E8E4FBFFFF          <1> r_qs:	call	_rex_chex_124
  6216 000030BF E8A7D5FFFF          <1> 	call	_burst_write4	; eax -> ea / ebx -> register cursor
  6217 000030C4 E99FFBFFFF          <1> 	jmp	_rex_accumulate
  6218                              <1> 
  6219 000030C9 E8D5FBFFFF          <1> r_ql:	call	_rex_chex_124
  6220 000030CE E80FD4FFFF          <1> 	call	_burst_read4	; eax -> ea / ebx -> register cursor
  6221 000030D3 E990FBFFFF          <1> 	jmp	_rex_accumulate
  6222                              <1> 
  6223 000030D8 E85FFBFFFF          <1> r_dte:	call	_rex_prime_final_count
  6224 000030DD E8E8D3FFFF          <1> 	call	_burst_read2
  6225 000030E2 334510              <1> 	xor	eax, dword ptr [rbp+A]
  6226 000030E5 752B                <1> 	jnz	r_mtax
  6227 000030E7 335D14              <1> 	xor	ebx, dword ptr [rbp+B]
  6228 000030EA 7526                <1> 	jnz	r_mtax
  6229 000030EC E914000000          <1> 	jmp	r_skipout		; stop search repeat
  6230                              <1> 
  6231 000030F1 E846FBFFFF          <1> r_mta:	call	_rex_prime_final_count
  6232 000030F6 B100                <1> 	mov	cl, 0		; operand size 1 word
  6233 000030F8 E815D4FFFF          <1> 	call	_operand_read
  6234 000030FD 334510              <1> 	xor	eax, dword ptr [rbp+A]
  6235 00003100 234504              <1> 	and	eax, dword ptr [rbp+K]
  6236 00003103 750D                <1> 	jnz	r_mtax
  6237                              <1> 
  6238                              <1> r_skipout:				; stop search repeat
  6239 00003105 81C204000000        <1> 	add	edx, 4
  6240 0000310B 488BA568040000      <1> 	mov	rsp, qword ptr [rbp+282*4]
  6241 00003112 C3                  <1> r_mtax:	ret
  6242                              <1> 
  6243 00003113 E879FBFFFF          <1> r_ds:	call	_rex_chex_126
  6244 00003118 E895D5FFFF          <1> 	call	_burst_write2	; eax -> ea / ebx -> register cursor
  6245 0000311D E946FBFFFF          <1> 	jmp	_rex_accumulate
  6246                              <1> 
  6247 00003122 E86AFBFFFF          <1> r_dl:	call	 _rex_chex_126
  6248 00003127 53                  <1> 	push	rbx
  6249 00003128 E89DD3FFFF          <1> 	call	_burst_read2
  6250 0000312D 5F                  <1> 	pop	rdi
  6251 0000312E 895CBD04            <1> 	mov	dword ptr [rbp+rdi*4+4], ebx
  6252 00003132 8944BD00            <1> 	mov	dword ptr [rbp+rdi*4], eax
  6253 00003136 E92DFBFFFF          <1> 	jmp	_rex_accumulate
  6254                              <1> 
  6255 0000313B E851FBFFFF          <1> r_dan:	call	 _rex_chex_126
  6256 00003140 53                  <1> 	push	rbx
  6257 00003141 E884D3FFFF          <1> 	call	_burst_read2
  6258 00003146 5F                  <1> 	pop	rdi
  6259 00003147 81F3FFFFFF00        <1> 	xor	ebx, 00FFFFFFh
  6260 0000314D 35FFFFFF00          <1> 	xor	eax, 00FFFFFFh
  6261 00003152 FFC3                <1> 	inc	ebx
  6262 00003154 E90C000000          <1> 	jmp	r_danad
  6263                              <1> 
  6264 00003159 E833FBFFFF          <1> r_da:	call	 _rex_chex_126
  6265 0000315E 53                  <1> 	push	rbx
  6266 0000315F E866D3FFFF          <1> 	call	_burst_read2
  6267 00003164 5F                  <1> 	pop	rdi
  6268                              <1> 
  6269                              <1> r_danad:
  6270 00003165 035CBD04            <1> 	add	ebx, dword ptr [rbp+rdi*4+4]
  6271 00003169 C1E308              <1> 	shl	ebx, 8
  6272 0000316C 1500000000          <1> 	adc	eax, 0
  6273 00003171 C1EB08              <1> 	shr	ebx, 8
  6274 00003174 895CBD04            <1> 	mov	dword ptr [rbp+rdi*4+4], ebx
  6275 00003178 0344BD00            <1> 	add	eax, dword ptr [rbp+rdi*4]
  6276                              <1> 
  6277                              <1> r_store_carry:
  6278 0000317C E8ACEDFFFF          <1> 	call	_alu_carry
  6279 00003181 8944BD00            <1> 	mov	dword ptr [rbp+rdi*4], eax
  6280 00003185 E9DEFAFFFF          <1> 	jmp	_rex_accumulate
  6281                              <1> 
  6282                                  					; data follows here
  6283                                  					; if it is in this assembly
  6284                                  	%if	RTA_MBANKS
  6285                                  
  6286                                  	section		.data
  6287                                  	%include	"rta_data.msm"
  6288                                  
  6289                                  	section		.bss
  6290                                  _memory	resd	MEMORY
  6291                                  
  6292                                  	%endif
  6293                                  
  6294                                  	end
  6295                                  
